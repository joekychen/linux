<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jfs › jfs_imap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>jfs_imap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   Copyright (C) International Business Machines Corp., 2000-2004</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software;  you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY;  without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> *   the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program;  if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	jfs_imap.c: inode allocation map manager</span>
<span class="cm"> *</span>
<span class="cm"> * Serialization:</span>
<span class="cm"> *   Each AG has a simple lock which is used to control the serialization of</span>
<span class="cm"> *	the AG level lists.  This lock should be taken first whenever an AG</span>
<span class="cm"> *	level list will be modified or accessed.</span>
<span class="cm"> *</span>
<span class="cm"> *   Each IAG is locked by obtaining the buffer for the IAG page.</span>
<span class="cm"> *</span>
<span class="cm"> *   There is also a inode lock for the inode map inode.  A read lock needs to</span>
<span class="cm"> *	be taken whenever an IAG is read from the map or the global level</span>
<span class="cm"> *	information is read.  A write lock needs to be taken whenever the global</span>
<span class="cm"> *	level information is modified or an atomic operation needs to be used.</span>
<span class="cm"> *</span>
<span class="cm"> *	If more than one IAG is read at one time, the read lock may not</span>
<span class="cm"> *	be given up until all of the IAG&#39;s are read.  Otherwise, a deadlock</span>
<span class="cm"> *	may occur when trying to obtain the read lock while another thread</span>
<span class="cm"> *	holding the read lock is waiting on the IAG already being held.</span>
<span class="cm"> *</span>
<span class="cm"> *   The control page of the inode map is read into memory by diMount().</span>
<span class="cm"> *	Thereafter it should only be modified in memory and then it will be</span>
<span class="cm"> *	written out when the filesystem is unmounted by diUnmount().</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/quotaops.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;jfs_incore.h&quot;</span>
<span class="cp">#include &quot;jfs_inode.h&quot;</span>
<span class="cp">#include &quot;jfs_filsys.h&quot;</span>
<span class="cp">#include &quot;jfs_dinode.h&quot;</span>
<span class="cp">#include &quot;jfs_dmap.h&quot;</span>
<span class="cp">#include &quot;jfs_imap.h&quot;</span>
<span class="cp">#include &quot;jfs_metapage.h&quot;</span>
<span class="cp">#include &quot;jfs_superblock.h&quot;</span>
<span class="cp">#include &quot;jfs_debug.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * imap locks</span>
<span class="cm"> */</span>
<span class="cm">/* iag free list lock */</span>
<span class="cp">#define IAGFREE_LOCK_INIT(imap)		mutex_init(&amp;imap-&gt;im_freelock)</span>
<span class="cp">#define IAGFREE_LOCK(imap)		mutex_lock(&amp;imap-&gt;im_freelock)</span>
<span class="cp">#define IAGFREE_UNLOCK(imap)		mutex_unlock(&amp;imap-&gt;im_freelock)</span>

<span class="cm">/* per ag iag list locks */</span>
<span class="cp">#define AG_LOCK_INIT(imap,index)	mutex_init(&amp;(imap-&gt;im_aglock[index]))</span>
<span class="cp">#define AG_LOCK(imap,agno)		mutex_lock(&amp;imap-&gt;im_aglock[agno])</span>
<span class="cp">#define AG_UNLOCK(imap,agno)		mutex_unlock(&amp;imap-&gt;im_aglock[agno])</span>

<span class="cm">/*</span>
<span class="cm"> * forward references</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">diAllocAG</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">diAllocAny</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">diAllocBit</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">diAllocExt</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">diAllocIno</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">diFindFree</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">diNewExt</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">diNewIAG</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">metapage</span> <span class="o">**</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">duplicateIXtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="n">s64</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span> <span class="n">imap</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">metapage</span> <span class="o">**</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">copy_from_dinode</span><span class="p">(</span><span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">copy_to_dinode</span><span class="p">(</span><span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	diMount()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	initialize the incore inode map control structures for</span>
<span class="cm"> *		a fileset or aggregate init time.</span>
<span class="cm"> *</span>
<span class="cm"> *		the inode map&#39;s control structure (dinomap) is</span>
<span class="cm"> *		brought in from disk and placed in virtual memory.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ipimap	- pointer to inode map inode for the aggregate or fileset.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOMEM	- insufficient free virtual memory.</span>
<span class="cm"> *	-EIO	- i/o error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">diMount</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="n">imap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dinomap_disk</span> <span class="o">*</span><span class="n">dinom_le</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate/initialize the in-memory inode map control structure</span>
<span class="cm">	 */</span>
	<span class="cm">/* allocate the in-memory inode map control structure. */</span>
	<span class="n">imap</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">imap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;diMount: kmalloc returned NULL!&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* read the on-disk inode map control structure. */</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span>
			   <span class="n">IMAPBLKNO</span> <span class="o">&lt;&lt;</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">,</span>
			   <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">imap</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* copy the on-disk version to the in-memory version. */</span>
	<span class="n">dinom_le</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dinomap_disk</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_freeiag</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_freeiag</span><span class="p">);</span>
	<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nextiag</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_nextiag</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_numinos</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_numinos</span><span class="p">));</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_numfree</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_numfree</span><span class="p">));</span>
	<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nbperiext</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_nbperiext</span><span class="p">);</span>
	<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_l2nbperiext</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_l2nbperiext</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">MAXAG</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">inofree</span> <span class="o">=</span>
		    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">inofree</span><span class="p">);</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">extfree</span> <span class="o">=</span>
		    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">extfree</span><span class="p">);</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">numinos</span> <span class="o">=</span>
		    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">numinos</span><span class="p">);</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">numfree</span> <span class="o">=</span>
		    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">numfree</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* release the buffer. */</span>
	<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * allocate/initialize inode allocation map locks</span>
<span class="cm">	 */</span>
	<span class="cm">/* allocate and init iag free list lock */</span>
	<span class="n">IAGFREE_LOCK_INIT</span><span class="p">(</span><span class="n">imap</span><span class="p">);</span>

	<span class="cm">/* allocate and init ag list locks */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">MAXAG</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AG_LOCK_INIT</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* bind the inode map inode and inode map control structure</span>
<span class="cm">	 * to each other.</span>
<span class="cm">	 */</span>
	<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span> <span class="o">=</span> <span class="n">ipimap</span><span class="p">;</span>
	<span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_imap</span> <span class="o">=</span> <span class="n">imap</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	diUnmount()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	write to disk the incore inode map control structures for</span>
<span class="cm"> *		a fileset or aggregate at unmount time.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ipimap	- pointer to inode map inode for the aggregate or fileset.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOMEM	- insufficient free virtual memory.</span>
<span class="cm"> *	-EIO	- i/o error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">diUnmount</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mounterror</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="n">imap</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * update the on-disk inode map control structure</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mounterror</span> <span class="o">||</span> <span class="n">isReadOnly</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)))</span>
		<span class="n">diSync</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Invalidate the page cache buffers</span>
<span class="cm">	 */</span>
	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * free in-memory control structure</span>
<span class="cm">	 */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">imap</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	diSync()</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">diSync</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dinomap_disk</span> <span class="o">*</span><span class="n">dinom_le</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="n">imp</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * write imap global conrol page</span>
<span class="cm">	 */</span>
	<span class="cm">/* read the on-disk inode map control structure */</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">get_metapage</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span>
			  <span class="n">IMAPBLKNO</span> <span class="o">&lt;&lt;</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">,</span>
			  <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;diSync: get_metapage failed!&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* copy the in-memory version to the on-disk version */</span>
	<span class="n">dinom_le</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dinomap_disk</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_freeiag</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">imp</span><span class="o">-&gt;</span><span class="n">im_freeiag</span><span class="p">);</span>
	<span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_nextiag</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">imp</span><span class="o">-&gt;</span><span class="n">im_nextiag</span><span class="p">);</span>
	<span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_numinos</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imp</span><span class="o">-&gt;</span><span class="n">im_numinos</span><span class="p">));</span>
	<span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_numfree</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imp</span><span class="o">-&gt;</span><span class="n">im_numfree</span><span class="p">));</span>
	<span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_nbperiext</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">imp</span><span class="o">-&gt;</span><span class="n">im_nbperiext</span><span class="p">);</span>
	<span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_l2nbperiext</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">imp</span><span class="o">-&gt;</span><span class="n">im_l2nbperiext</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">MAXAG</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">inofree</span> <span class="o">=</span>
		    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">imp</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">inofree</span><span class="p">);</span>
		<span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">extfree</span> <span class="o">=</span>
		    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">imp</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">extfree</span><span class="p">);</span>
		<span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">numinos</span> <span class="o">=</span>
		    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">imp</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">numinos</span><span class="p">);</span>
		<span class="n">dinom_le</span><span class="o">-&gt;</span><span class="n">in_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">numfree</span> <span class="o">=</span>
		    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">imp</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">numfree</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* write out the control structure */</span>
	<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * write out dirty pages of imap</span>
<span class="cm">	 */</span>
	<span class="n">filemap_write_and_wait</span><span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>

	<span class="n">diWriteSpecial</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	diRead()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	initialize an incore inode from disk.</span>
<span class="cm"> *</span>
<span class="cm"> *		on entry, the specifed incore inode should itself</span>
<span class="cm"> *		specify the disk inode number corresponding to the</span>
<span class="cm"> *		incore inode (i.e. i_number should be initialized).</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine handles incore inode initialization for</span>
<span class="cm"> *		both &quot;special&quot; and &quot;regular&quot; inodes.  special inodes</span>
<span class="cm"> *		are those required early in the mount process and</span>
<span class="cm"> *		require special handling since much of the file system</span>
<span class="cm"> *		is not yet initialized.  these &quot;special&quot; inodes are</span>
<span class="cm"> *		identified by a NULL inode map inode pointer and are</span>
<span class="cm"> *		actually initialized by a call to diReadSpecial().</span>
<span class="cm"> *</span>
<span class="cm"> *		for regular inodes, the iag describing the disk inode</span>
<span class="cm"> *		is read from disk to determine the inode extent address</span>
<span class="cm"> *		for the disk inode.  with the inode extent address in</span>
<span class="cm"> *		hand, the page of the extent that contains the disk</span>
<span class="cm"> *		inode is read and the disk inode is copied to the</span>
<span class="cm"> *		incore inode.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ip	-  pointer to incore inode to be initialized from disk.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-EIO	- i/o error.</span>
<span class="cm"> *	-ENOMEM	- insufficient memory</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">diRead</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">iagno</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">extno</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="n">iagp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">agstart</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="n">imap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inodes_left</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pageno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rel_inode</span><span class="p">;</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;diRead: ino = %ld&quot;</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="n">ipimap</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">ipimap</span><span class="p">;</span>
	<span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipimap</span> <span class="o">=</span> <span class="n">ipimap</span><span class="p">;</span>

	<span class="cm">/* determine the iag number for this inode (number) */</span>
	<span class="n">iagno</span> <span class="o">=</span> <span class="n">INOTOIAG</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="cm">/* read the iag */</span>
	<span class="n">imap</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">;</span>
	<span class="n">IREAD_LOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">RDWRLOCK_IMAP</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;diRead: diIAGRead returned %d&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">iagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* determine inode extent that holds the disk inode */</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INOSPERIAG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">extno</span> <span class="o">=</span> <span class="n">ino</span> <span class="o">&gt;&gt;</span> <span class="n">L2INOSPEREXT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">lengthPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span><span class="p">])</span> <span class="o">!=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nbperiext</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get disk block number of the page within the inode extent</span>
<span class="cm">	 * that holds the disk inode.</span>
<span class="cm">	 */</span>
	<span class="n">blkno</span> <span class="o">=</span> <span class="n">INOPBLK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span><span class="p">],</span> <span class="n">ino</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">);</span>

	<span class="cm">/* get the ag for the iag */</span>
	<span class="n">agstart</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">agstart</span><span class="p">);</span>

	<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="n">rel_inode</span> <span class="o">=</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INOSPERPAGE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">pageno</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&gt;&gt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">block_offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * OS/2 didn&#39;t always align inode extents on page boundaries</span>
<span class="cm">		 */</span>
		<span class="n">inodes_left</span> <span class="o">=</span>
		     <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span> <span class="o">-</span> <span class="n">block_offset</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2niperblk</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rel_inode</span> <span class="o">&lt;</span> <span class="n">inodes_left</span><span class="p">)</span>
			<span class="n">rel_inode</span> <span class="o">+=</span> <span class="n">block_offset</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2niperblk</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">pageno</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">rel_inode</span> <span class="o">-=</span> <span class="n">inodes_left</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* read the page of disk inode */</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">pageno</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;diRead: read_metapage failed&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* locate the disk inode requested */</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">dp</span> <span class="o">+=</span> <span class="n">rel_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">!=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_number</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;diRead: i_ino != di_number&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_nlink</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/* copy the disk inode to the in-memory inode */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">copy_from_dinode</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

	<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/* set the ag for the inode */</span>
	<span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">agstart</span> <span class="o">=</span> <span class="n">agstart</span><span class="p">;</span>
	<span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">active_ag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	diReadSpecial()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	initialize a &#39;special&#39; inode from disk.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routines handles aggregate level inodes.  The</span>
<span class="cm"> *		inode cache cannot differentiate between the</span>
<span class="cm"> *		aggregate inodes and the filesystem inodes, so we</span>
<span class="cm"> *		handle these here.  We don&#39;t actually use the aggregate</span>
<span class="cm"> *		inode map, since these inodes are at a fixed location</span>
<span class="cm"> *		and in some cases the aggregate inode map isn&#39;t initialized</span>
<span class="cm"> *		yet.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	sb - filesystem superblock</span>
<span class="cm"> *	inum - aggregate inode number</span>
<span class="cm"> *	secondary - 1 if secondary aggregate inode table</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	new inode	- success</span>
<span class="cm"> *	NULL		- i/o error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">diReadSpecial</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">uint</span> <span class="n">address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>

	<span class="n">ip</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;diReadSpecial: new_inode returned NULL!&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ip</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">secondary</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">address</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">ait2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">;</span>
		<span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipimap</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">ipaimap2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">address</span> <span class="o">=</span> <span class="n">AITBL_OFF</span> <span class="o">&gt;&gt;</span> <span class="n">L2PSIZE</span><span class="p">;</span>
		<span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipimap</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">ipaimap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">inum</span> <span class="o">&lt;</span> <span class="n">INOSPEREXT</span><span class="p">);</span>

	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">inum</span><span class="p">;</span>

	<span class="n">address</span> <span class="o">+=</span> <span class="n">inum</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* 8 inodes per 4K page */</span>

	<span class="cm">/* read the page of fixed disk inode (AIT) in raw mode */</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">address</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_nlink</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* Don&#39;t want iput() deleting it */</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* get the pointer to the disk inode of interest */</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">dp</span> <span class="o">+=</span> <span class="n">inum</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>		<span class="cm">/* 8 inodes per 4K page */</span>

	<span class="cm">/* copy on-disk inode to in-memory inode */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">copy_from_dinode</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* handle bad return by returning NULL for ip */</span>
		<span class="n">set_nlink</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* Don&#39;t want iput() deleting it */</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
		<span class="cm">/* release the page */</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">jfs_metapage_aops</span><span class="p">;</span>
	<span class="n">mapping_set_gfp_mask</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>

	<span class="cm">/* Allocations to metadata inodes should not affect quotas */</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_NOQUOTA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">inum</span> <span class="o">==</span> <span class="n">FILESYSTEM_I</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipimap</span> <span class="o">==</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">ipaimap</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">gengen</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_gengen</span><span class="p">);</span>
		<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">inostamp</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_inostamp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* release the page */</span>
	<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * __mark_inode_dirty expects inodes to be hashed.  Since we don&#39;t</span>
<span class="cm">	 * want special inodes in the fileset inode space, we make them</span>
<span class="cm">	 * appear hashed, but do not put on any lists.  hlist_del()</span>
<span class="cm">	 * will work fine and require no locking.</span>
<span class="cm">	 */</span>
	<span class="n">hlist_add_fake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_hash</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	diWriteSpecial()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	Write the special inode to disk</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ip - special inode</span>
<span class="cm"> *	secondary - 1 if secondary aggregate inode table</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES: none</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">diWriteSpecial</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">uint</span> <span class="n">address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">inum</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">secondary</span><span class="p">)</span>
		<span class="n">address</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">ait2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">address</span> <span class="o">=</span> <span class="n">AITBL_OFF</span> <span class="o">&gt;&gt;</span> <span class="n">L2PSIZE</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">inum</span> <span class="o">&lt;</span> <span class="n">INOSPEREXT</span><span class="p">);</span>

	<span class="n">address</span> <span class="o">+=</span> <span class="n">inum</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* 8 inodes per 4K page */</span>

	<span class="cm">/* read the page of fixed disk inode (AIT) in raw mode */</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">address</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;diWriteSpecial: failed to read aggregate inode &quot;</span>
			<span class="s">&quot;extent!&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get the pointer to the disk inode of interest */</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">dp</span> <span class="o">+=</span> <span class="n">inum</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>		<span class="cm">/* 8 inodes per 4K page */</span>

	<span class="cm">/* copy on-disk inode to in-memory inode */</span>
	<span class="n">copy_to_dinode</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_xtroot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_xtroot</span><span class="p">,</span> <span class="mi">288</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">==</span> <span class="n">FILESYSTEM_I</span><span class="p">)</span>
		<span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_gengen</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">gengen</span><span class="p">);</span>

	<span class="cm">/* write the page */</span>
	<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	diFreeSpecial()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	Free allocated space for special inode</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">diFreeSpecial</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;diFreeSpecial called with NULL ip!&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">filemap_write_and_wait</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * NAME:	diWrite()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	write the on-disk inode portion of the in-memory inode</span>
<span class="cm"> *		to its corresponding on-disk inode.</span>
<span class="cm"> *</span>
<span class="cm"> *		on entry, the specifed incore inode should itself</span>
<span class="cm"> *		specify the disk inode number corresponding to the</span>
<span class="cm"> *		incore inode (i.e. i_number should be initialized).</span>
<span class="cm"> *</span>
<span class="cm"> *		the inode contains the inode extent address for the disk</span>
<span class="cm"> *		inode.  with the inode extent address in hand, the</span>
<span class="cm"> *		page of the extent that contains the disk inode is</span>
<span class="cm"> *		read and the disk inode portion of the incore inode</span>
<span class="cm"> *		is copied to the disk inode.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	tid -  transacation id</span>
<span class="cm"> *	ip  -  pointer to incore inode to be written to the inode extent.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-EIO	- i/o error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">diWrite</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="o">*</span><span class="n">jfs_ip</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inodes_left</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pageno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rel_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dioffset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">lid_t</span> <span class="n">lid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">ditlck</span><span class="p">,</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="n">dilinelock</span><span class="p">,</span> <span class="o">*</span><span class="n">ilinelock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lv</span> <span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">ipimap</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">ipimap</span><span class="p">;</span>

	<span class="n">ino</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INOSPERIAG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">ixpxd</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">lengthPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">ixpxd</span><span class="p">))</span> <span class="o">!=</span>
	     <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="o">-&gt;</span><span class="n">im_nbperiext</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;diWrite: ixpxd invalid&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * read the page of disk inode containing the specified inode:</span>
<span class="cm">	 */</span>
	<span class="cm">/* compute the block address of the page */</span>
	<span class="n">blkno</span> <span class="o">=</span> <span class="n">INOPBLK</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">ixpxd</span><span class="p">),</span> <span class="n">ino</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">);</span>

	<span class="n">rel_inode</span> <span class="o">=</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INOSPERPAGE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">pageno</span> <span class="o">=</span> <span class="n">blkno</span> <span class="o">&gt;&gt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">block_offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * OS/2 didn&#39;t always align inode extents on page boundaries</span>
<span class="cm">		 */</span>
		<span class="n">inodes_left</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span> <span class="o">-</span> <span class="n">block_offset</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2niperblk</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rel_inode</span> <span class="o">&lt;</span> <span class="n">inodes_left</span><span class="p">)</span>
			<span class="n">rel_inode</span> <span class="o">+=</span> <span class="n">block_offset</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2niperblk</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">pageno</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">rel_inode</span> <span class="o">-=</span> <span class="n">inodes_left</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* read the page of disk inode */</span>
      <span class="nl">retry:</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">pageno</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* get the pointer to the disk inode */</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">dp</span> <span class="o">+=</span> <span class="n">rel_inode</span><span class="p">;</span>

	<span class="n">dioffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INOSPERPAGE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">L2DISIZE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * acquire transaction lock on the on-disk inode;</span>
<span class="cm">	 * N.B. tlock is acquired on ipimap not ip;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ditlck</span> <span class="o">=</span>
	     <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ipimap</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">tlckINODE</span> <span class="o">|</span> <span class="n">tlckENTRY</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="n">dilinelock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ditlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * copy btree root from in-memory inode to on-disk inode</span>
<span class="cm">	 *</span>
<span class="cm">	 * (tlock is taken from inline B+-tree root in in-memory</span>
<span class="cm">	 * inode when the B+-tree root is updated, which is pointed</span>
<span class="cm">	 * by jfs_ip-&gt;blid as well as being on tx tlock list)</span>
<span class="cm">	 *</span>
<span class="cm">	 * further processing of btree root is based on the copy</span>
<span class="cm">	 * in in-memory inode, where txLog() will log from, and,</span>
<span class="cm">	 * for xtree root, txUpdateMap() will update map and reset</span>
<span class="cm">	 * XAD_NEW bit;</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lid</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">xtlid</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is the special xtree inside the directory for storing</span>
<span class="cm">		 * the directory table</span>
<span class="cm">		 */</span>
		<span class="n">xtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">xp</span><span class="p">;</span>
		<span class="n">xad_t</span> <span class="o">*</span><span class="n">xad</span><span class="p">;</span>

		<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">xtlid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckXTREE</span><span class="p">);</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">|=</span> <span class="n">tlckBTROOT</span><span class="p">;</span>
		<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
		<span class="n">ilinelock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * copy xtree root from inode to dinode:</span>
<span class="cm">		 */</span>
		<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_xtroot</span><span class="p">;</span>
		<span class="n">xp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xtpage_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_dirtable</span><span class="p">;</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="n">ilinelock</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">ilinelock</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">lv</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xp</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">],</span>
			       <span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&lt;&lt;</span> <span class="n">L2XTSLOTSIZE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* reset on-disk (metadata page) xtree XAD_NEW bit */</span>
		<span class="n">xad</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xp</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">XTENTRYSTART</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">XTENTRYSTART</span><span class="p">;</span>
		     <span class="n">n</span> <span class="o">&lt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">xp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">);</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">xad</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xad</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XAD_NEW</span> <span class="o">|</span> <span class="n">XAD_EXTENDED</span><span class="p">))</span>
				<span class="n">xad</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">XAD_NEW</span> <span class="o">|</span> <span class="n">XAD_EXTENDED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">lid</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">blid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">inlineData</span><span class="p">;</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">blid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tlck</span> <span class="o">=</span> <span class="n">lid_to_tlock</span><span class="p">(</span><span class="n">lid</span><span class="p">);</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">|=</span> <span class="n">tlckBTROOT</span><span class="p">;</span>
	<span class="n">tlck</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
	<span class="n">ilinelock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linelock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	regular file: 16 byte (XAD slot) granularity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckXTREE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">xp</span><span class="p">;</span>
		<span class="n">xad_t</span> <span class="o">*</span><span class="n">xad</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * copy xtree root from inode to dinode:</span>
<span class="cm">		 */</span>
		<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_xtroot</span><span class="p">;</span>
		<span class="n">xp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_xtroot</span><span class="p">;</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="n">ilinelock</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">ilinelock</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">lv</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xp</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">],</span>
			       <span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&lt;&lt;</span> <span class="n">L2XTSLOTSIZE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* reset on-disk (metadata page) xtree XAD_NEW bit */</span>
		<span class="n">xad</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xp</span><span class="o">-&gt;</span><span class="n">xad</span><span class="p">[</span><span class="n">XTENTRYSTART</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">XTENTRYSTART</span><span class="p">;</span>
		     <span class="n">n</span> <span class="o">&lt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">xp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nextindex</span><span class="p">);</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">xad</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xad</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XAD_NEW</span> <span class="o">|</span> <span class="n">XAD_EXTENDED</span><span class="p">))</span>
				<span class="n">xad</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">XAD_NEW</span> <span class="o">|</span> <span class="n">XAD_EXTENDED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	directory: 32 byte (directory entry slot) granularity</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">tlckDTREE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dtpage_t</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">xp</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * copy dtree root from inode to dinode:</span>
<span class="cm">		 */</span>
		<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_dtroot</span><span class="p">;</span>
		<span class="n">xp</span> <span class="o">=</span> <span class="p">(</span><span class="n">dtpage_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_dtroot</span><span class="p">;</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="n">ilinelock</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">ilinelock</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">lv</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xp</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">[</span><span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">],</span>
			       <span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&lt;&lt;</span> <span class="n">L2DTSLOTSIZE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">jfs_err</span><span class="p">(</span><span class="s">&quot;diWrite: UFO tlock&quot;</span><span class="p">);</span>
	<span class="p">}</span>

      <span class="nl">inlineData:</span>
	<span class="cm">/*</span>
<span class="cm">	 * copy inline symlink from in-memory inode to on-disk inode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&lt;</span> <span class="n">IDATASIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dilinelock</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dilinelock</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">dioffset</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">128</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2INODESLOTSIZE</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_fastsymlink</span><span class="p">,</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_inline</span><span class="p">,</span> <span class="n">IDATASIZE</span><span class="p">);</span>
		<span class="n">dilinelock</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * copy inline data from in-memory inode to on-disk inode:</span>
<span class="cm">	 * 128 byte slot granularity</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_cflag</span><span class="p">(</span><span class="n">COMMIT_Inlineea</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dilinelock</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dilinelock</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">dioffset</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">128</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">L2INODESLOTSIZE</span><span class="p">;</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_inlineea</span><span class="p">,</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_inline_ea</span><span class="p">,</span> <span class="n">INODESLOTSIZE</span><span class="p">);</span>
		<span class="n">dilinelock</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

		<span class="n">clear_cflag</span><span class="p">(</span><span class="n">COMMIT_Inlineea</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	lock/copy inode base: 128 byte slot granularity</span>
<span class="cm">	 */</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">dilinelock</span><span class="o">-&gt;</span><span class="n">lv</span><span class="p">[</span><span class="n">dilinelock</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">dioffset</span> <span class="o">&gt;&gt;</span> <span class="n">L2INODESLOTSIZE</span><span class="p">;</span>
	<span class="n">copy_to_dinode</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_cflag</span><span class="p">(</span><span class="n">COMMIT_Dirtable</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_dirtable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_dirtable</span><span class="p">,</span> <span class="mi">96</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dilinelock</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* release the buffer holding the updated on-disk inode.</span>
<span class="cm">	 * the buffer will be later written by commit processing.</span>
<span class="cm">	 */</span>
	<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	diFree(ip)</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	free a specified inode from the inode working map</span>
<span class="cm"> *		for a fileset or aggregate.</span>
<span class="cm"> *</span>
<span class="cm"> *		if the inode to be freed represents the first (only)</span>
<span class="cm"> *		free inode within the iag, the iag will be placed on</span>
<span class="cm"> *		the ag free inode list.</span>
<span class="cm"> *</span>
<span class="cm"> *		freeing the inode will cause the inode extent to be</span>
<span class="cm"> *		freed if the inode is the only allocated inode within</span>
<span class="cm"> *		the extent.  in this case all the disk resource backing</span>
<span class="cm"> *		up the inode extent will be freed. in addition, the iag</span>
<span class="cm"> *		will be placed on the ag extent free list if the extent</span>
<span class="cm"> *		is the first free extent in the iag.  if freeing the</span>
<span class="cm"> *		extent also means that no free inodes will exist for</span>
<span class="cm"> *		the iag, the iag will also be removed from the ag free</span>
<span class="cm"> *		inode list.</span>
<span class="cm"> *</span>
<span class="cm"> *		the iag describing the inode will be freed if the extent</span>
<span class="cm"> *		is to be freed and it is the only backed extent within</span>
<span class="cm"> *		the iag.  in this case, the iag will be removed from the</span>
<span class="cm"> *		ag free extent list and ag free inode list and placed on</span>
<span class="cm"> *		the inode map&#39;s free iag list.</span>
<span class="cm"> *</span>
<span class="cm"> *		a careful update approach is used to provide consistency</span>
<span class="cm"> *		in the face of updates to multiple buffers.  under this</span>
<span class="cm"> *		approach, all required buffers are obtained before making</span>
<span class="cm"> *		any updates and are held until all updates are complete.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ip	- inode to be freed.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-EIO	- i/o error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">diFree</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">inum</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="n">iagp</span><span class="p">,</span> <span class="o">*</span><span class="n">aiagp</span><span class="p">,</span> <span class="o">*</span><span class="n">biagp</span><span class="p">,</span> <span class="o">*</span><span class="n">ciagp</span><span class="p">,</span> <span class="o">*</span><span class="n">diagp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="o">*</span><span class="n">amp</span><span class="p">,</span> <span class="o">*</span><span class="n">bmp</span><span class="p">,</span> <span class="o">*</span><span class="n">cmp</span><span class="p">,</span> <span class="o">*</span><span class="n">dmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iagno</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">extno</span><span class="p">,</span> <span class="n">bitno</span><span class="p">,</span> <span class="n">sword</span><span class="p">,</span> <span class="n">agno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">back</span><span class="p">,</span> <span class="n">fwd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bitmap</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipimap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="n">imap</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">;</span>
	<span class="n">pxd_t</span> <span class="n">freepxd</span><span class="p">;</span>
	<span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">iplist</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tlock</span> <span class="o">*</span><span class="n">tlck</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="n">pxdlock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is just to suppress compiler warnings.  The same logic that</span>
<span class="cm">	 * references these variables is used to initialize them.</span>
<span class="cm">	 */</span>
	<span class="n">aiagp</span> <span class="o">=</span> <span class="n">biagp</span> <span class="o">=</span> <span class="n">ciagp</span> <span class="o">=</span> <span class="n">diagp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* get the iag number containing the inode.</span>
<span class="cm">	 */</span>
	<span class="n">iagno</span> <span class="o">=</span> <span class="n">INOTOIAG</span><span class="p">(</span><span class="n">inum</span><span class="p">);</span>

	<span class="cm">/* make sure that the iag is contained within</span>
<span class="cm">	 * the map.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagno</span> <span class="o">&gt;=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nextiag</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;imap: &quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
			       <span class="n">imap</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;diFree: inum = %d, iagno = %d, nextiag = %d&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="n">inum</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nextiag</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get the allocation group for this ino.</span>
<span class="cm">	 */</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">BLKTOAG</span><span class="p">(</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">agstart</span><span class="p">,</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">));</span>

	<span class="cm">/* Lock the AG specific inode map information</span>
<span class="cm">	 */</span>
	<span class="n">AG_LOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>

	<span class="cm">/* Obtain read lock in imap inode.  Don&#39;t release it until we have</span>
<span class="cm">	 * read all of the IAG&#39;s that we are going to.</span>
<span class="cm">	 */</span>
	<span class="n">IREAD_LOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">RDWRLOCK_IMAP</span><span class="p">);</span>

	<span class="cm">/* read the iag.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>
		<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">iagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* get the inode number and extent number of the inode within</span>
<span class="cm">	 * the iag and the inode number within the extent.</span>
<span class="cm">	 */</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">inum</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INOSPERIAG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">extno</span> <span class="o">=</span> <span class="n">ino</span> <span class="o">&gt;&gt;</span> <span class="n">L2INOSPEREXT</span><span class="p">;</span>
	<span class="n">bitno</span> <span class="o">=</span> <span class="n">ino</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INOSPEREXT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">HIGHORDER</span> <span class="o">&gt;&gt;</span> <span class="n">bitno</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">extno</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;diFree: wmap shows inode already free&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>
		<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;diFree: invalid inoext&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* compute the bitmap for the extent reflecting the freed inode.</span>
<span class="cm">	 */</span>
	<span class="n">bitmap</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">extno</span><span class="p">])</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numfree</span> <span class="o">&gt;</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numinos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>
		<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;diFree: numfree &gt; numinos&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	inode extent still has some inodes or below low water mark:</span>
<span class="cm">	 *	keep the inode extent;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bitmap</span> <span class="o">||</span>
	    <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numfree</span> <span class="o">&lt;</span> <span class="mi">96</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numfree</span> <span class="o">&lt;</span> <span class="mi">288</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(((</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numfree</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span>
	       <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numinos</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">25</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* if the iag currently has no free inodes (i.e.,</span>
<span class="cm">		 * the inode being freed is the first free inode of iag),</span>
<span class="cm">		 * insert the iag at head of the inode free list for the ag.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* check if there are any iags on the ag inode</span>
<span class="cm">			 * free list.  if so, read the first one so that</span>
<span class="cm">			 * we can link the current iag onto the list at</span>
<span class="cm">			 * the head.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">fwd</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">inofree</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* read the iag that currently is the head</span>
<span class="cm">				 * of the list.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">fwd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>
					<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
					<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
					<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">aiagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">amp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

				<span class="cm">/* make current head point back to the iag.</span>
<span class="cm">				 */</span>
				<span class="n">aiagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">iagno</span><span class="p">);</span>

				<span class="n">write_metapage</span><span class="p">(</span><span class="n">amp</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* iag points forward to current head and iag</span>
<span class="cm">			 * becomes the new head of the list.</span>
<span class="cm">			 */</span>
			<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span> <span class="o">=</span>
			    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">inofree</span><span class="p">);</span>
			<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">inofree</span> <span class="o">=</span> <span class="n">iagno</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>

		<span class="cm">/* update the free inode summary map for the extent if</span>
<span class="cm">		 * freeing the inode means the extent will now have free</span>
<span class="cm">		 * inodes (i.e., the inode being freed is the first free</span>
<span class="cm">		 * inode of extent),</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">extno</span><span class="p">]</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ONES</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sword</span> <span class="o">=</span> <span class="n">extno</span> <span class="o">&gt;&gt;</span> <span class="n">L2EXTSPERSUM</span><span class="p">;</span>
			<span class="n">bitno</span> <span class="o">=</span> <span class="n">extno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EXTSPERSUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inosmap</span><span class="p">[</span><span class="n">sword</span><span class="p">]</span> <span class="o">&amp;=</span>
			    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">HIGHORDER</span> <span class="o">&gt;&gt;</span> <span class="n">bitno</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/* update the bitmap.</span>
<span class="cm">		 */</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">extno</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">bitmap</span><span class="p">);</span>

		<span class="cm">/* update the free inode counts at the iag, ag and</span>
<span class="cm">		 * map level.</span>
<span class="cm">		 */</span>
		<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numfree</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_numfree</span><span class="p">);</span>

		<span class="cm">/* release the AG inode map lock</span>
<span class="cm">		 */</span>
		<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>

		<span class="cm">/* write the iag */</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="cm">/*</span>
<span class="cm">	 *	inode extent has become free and above low water mark:</span>
<span class="cm">	 *	free the inode extent;</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 *	prepare to update iag list(s) (careful update step 1)</span>
<span class="cm">	 */</span>
	<span class="n">amp</span> <span class="o">=</span> <span class="n">bmp</span> <span class="o">=</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">dmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">fwd</span> <span class="o">=</span> <span class="n">back</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* check if the iag currently has no free extents.  if so,</span>
<span class="cm">	 * it will be placed on the head of the ag extent free list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check if the ag extent free list has any iags.</span>
<span class="cm">		 * if so, read the iag at the head of the list now.</span>
<span class="cm">		 * this (head) iag will be updated later to reflect</span>
<span class="cm">		 * the addition of the current iag at the head of</span>
<span class="cm">		 * the list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fwd</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">extfree</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">fwd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
			<span class="n">aiagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">amp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* iag has free extents. check if the addition of a free</span>
<span class="cm">		 * extent will cause all extents to be free within this</span>
<span class="cm">		 * iag.  if so, the iag will be removed from the ag extent</span>
<span class="cm">		 * free list and placed on the inode map&#39;s free iag list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXTSPERIAG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* in preparation for removing the iag from the</span>
<span class="cm">			 * ag extent free list, read the iags preceding</span>
<span class="cm">			 * and following the iag on the ag extent free</span>
<span class="cm">			 * list.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">fwd</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">fwd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">)))</span>
					<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
				<span class="n">aiagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">amp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">back</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">back</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bmp</span><span class="p">)))</span>
					<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
				<span class="n">biagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* remove the iag from the ag inode free list if freeing</span>
<span class="cm">	 * this extent cause the iag to have no free inodes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">INOSPEREXT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">inofreeback</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">inofreefwd</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span><span class="p">);</span>

		<span class="cm">/* in preparation for removing the iag from the</span>
<span class="cm">		 * ag inode free list, read the iags preceding</span>
<span class="cm">		 * and following the iag on the ag inode free</span>
<span class="cm">		 * list.  before reading these iags, we must make</span>
<span class="cm">		 * sure that we already don&#39;t have them in hand</span>
<span class="cm">		 * from up above, since re-reading an iag (buffer)</span>
<span class="cm">		 * we are currently holding would cause a deadlock.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inofreefwd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">inofreefwd</span> <span class="o">==</span> <span class="n">fwd</span><span class="p">)</span>
				<span class="n">ciagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">amp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inofreefwd</span> <span class="o">==</span> <span class="n">back</span><span class="p">)</span>
				<span class="n">ciagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span>
				     <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">inofreefwd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmp</span><span class="p">)))</span>
					<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
				<span class="n">ciagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">ciagp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inofreeback</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inofreeback</span> <span class="o">==</span> <span class="n">fwd</span><span class="p">)</span>
				<span class="n">diagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">amp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inofreeback</span> <span class="o">==</span> <span class="n">back</span><span class="p">)</span>
				<span class="n">diagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span>
				     <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">inofreeback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmp</span><span class="p">)))</span>
					<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
				<span class="n">diagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">dmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">diagp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * invalidate any page of the inode extent freed from buffer cache;</span>
<span class="cm">	 */</span>
	<span class="n">freepxd</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span><span class="p">];</span>
	<span class="n">invalidate_pxd_metapages</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">freepxd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	update iag list(s) (careful update step 2)</span>
<span class="cm">	 */</span>
	<span class="cm">/* add the iag to the ag extent free list if this is the</span>
<span class="cm">	 * first free extent for the iag.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fwd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">aiagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">iagno</span><span class="p">);</span>

		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span> <span class="o">=</span>
		    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">extfree</span><span class="p">);</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">extfree</span> <span class="o">=</span> <span class="n">iagno</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* remove the iag from the ag extent list if all extents</span>
<span class="cm">		 * are now free and place it on the inode map iag free list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXTSPERIAG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fwd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">aiagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">back</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">biagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">extfree</span> <span class="o">=</span>
				    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span><span class="p">);</span>

			<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

			<span class="n">IAGFREE_LOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">);</span>
			<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">iagfree</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_freeiag</span><span class="p">);</span>
			<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_freeiag</span> <span class="o">=</span> <span class="n">iagno</span><span class="p">;</span>
			<span class="n">IAGFREE_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* remove the iag from the ag inode free list if freeing</span>
<span class="cm">	 * this extent causes the iag to have no free inodes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">INOSPEREXT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ciagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">diagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">inofree</span> <span class="o">=</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span><span class="p">);</span>

		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* update the inode extent address and working map</span>
<span class="cm">	 * to reflect the free extent.</span>
<span class="cm">	 * the permanent map should have been updated already</span>
<span class="cm">	 * for the inode being freed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">extno</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;diFree: the pmap does not show inode free&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">extno</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">PXDlength</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">PXDaddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* update the free extent and free inode summary maps</span>
<span class="cm">	 * to reflect the freed extent.</span>
<span class="cm">	 * the inode summary map is marked to indicate no inodes</span>
<span class="cm">	 * available for the freed extent.</span>
<span class="cm">	 */</span>
	<span class="n">sword</span> <span class="o">=</span> <span class="n">extno</span> <span class="o">&gt;&gt;</span> <span class="n">L2EXTSPERSUM</span><span class="p">;</span>
	<span class="n">bitno</span> <span class="o">=</span> <span class="n">extno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EXTSPERSUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">HIGHORDER</span> <span class="o">&gt;&gt;</span> <span class="n">bitno</span><span class="p">;</span>
	<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inosmap</span><span class="p">[</span><span class="n">sword</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
	<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extsmap</span><span class="p">[</span><span class="n">sword</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">);</span>

	<span class="cm">/* update the number of free inodes and number of free extents</span>
<span class="cm">	 * for the iag.</span>
<span class="cm">	 */</span>
	<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">INOSPEREXT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* update the number of free inodes and backed inodes</span>
<span class="cm">	 * at the ag and inode map level.</span>
<span class="cm">	 */</span>
	<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numfree</span> <span class="o">-=</span> <span class="p">(</span><span class="n">INOSPEREXT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numinos</span> <span class="o">-=</span> <span class="n">INOSPEREXT</span><span class="p">;</span>
	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">INOSPEREXT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_numfree</span><span class="p">);</span>
	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">INOSPEREXT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_numinos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">amp</span><span class="p">)</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">amp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="p">)</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span><span class="p">)</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">cmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dmp</span><span class="p">)</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">dmp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * start transaction to update block allocation map</span>
<span class="cm">	 * for the inode extent freed;</span>
<span class="cm">	 *</span>
<span class="cm">	 * N.B. AG_LOCK is released and iag will be released below, and</span>
<span class="cm">	 * other thread may allocate inode from/reusing the ixad freed</span>
<span class="cm">	 * BUT with new/different backing inode extent from the extent</span>
<span class="cm">	 * to be freed by the transaction;</span>
<span class="cm">	 */</span>
	<span class="n">tid</span> <span class="o">=</span> <span class="n">txBegin</span><span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">COMMIT_FORCE</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">commit_mutex</span><span class="p">);</span>

	<span class="cm">/* acquire tlock of the iag page of the freed ixad</span>
<span class="cm">	 * to force the page NOHOMEOK (even though no data is</span>
<span class="cm">	 * logged from the iag page) until NOREDOPAGE|FREEXTENT log</span>
<span class="cm">	 * for the free of the extent is committed;</span>
<span class="cm">	 * write FREEXTENT|NOREDOPAGE log record</span>
<span class="cm">	 * N.B. linelock is overlaid as freed extent descriptor;</span>
<span class="cm">	 */</span>
	<span class="n">tlck</span> <span class="o">=</span> <span class="n">txLock</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ipimap</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">tlckINODE</span> <span class="o">|</span> <span class="n">tlckFREE</span><span class="p">);</span>
	<span class="n">pxdlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pxd_lock</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tlck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">mlckFREEPXD</span><span class="p">;</span>
	<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">pxd</span> <span class="o">=</span> <span class="n">freepxd</span><span class="p">;</span>
	<span class="n">pxdlock</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="n">iplist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipimap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * logredo needs the IAG number and IAG extent index in order</span>
<span class="cm">	 * to ensure that the IMap is consistent.  The least disruptive</span>
<span class="cm">	 * way to pass these values through  to the transaction manager</span>
<span class="cm">	 * is in the iplist array.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It&#39;s not pretty, but it works.</span>
<span class="cm">	 */</span>
	<span class="n">iplist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">iagno</span><span class="p">;</span>
	<span class="n">iplist</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">extno</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">txCommit</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iplist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">COMMIT_FORCE</span><span class="p">);</span>

	<span class="n">txEnd</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">commit_mutex</span><span class="p">);</span>

	<span class="cm">/* unlock the AG inode map information */</span>
	<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

      <span class="nl">error_out:</span>
	<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">amp</span><span class="p">)</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">amp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="p">)</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span><span class="p">)</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">cmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dmp</span><span class="p">)</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">dmp</span><span class="p">);</span>

	<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>

	<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There are several places in the diAlloc* routines where we initialize</span>
<span class="cm"> * the inode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">diInitInode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iagno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ino</span><span class="p">,</span> <span class="kt">int</span> <span class="n">extno</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span> <span class="n">iagp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="o">*</span><span class="n">jfs_ip</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="p">(</span><span class="n">iagno</span> <span class="o">&lt;&lt;</span> <span class="n">L2INOSPERIAG</span><span class="p">)</span> <span class="o">+</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">ixpxd</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span><span class="p">];</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">agstart</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">agstart</span><span class="p">);</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">active_ag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	diAlloc(pip,dir,ip)</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	allocate a disk inode from the inode working map</span>
<span class="cm"> *		for a fileset or aggregate.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	pip	- pointer to incore inode for the parent inode.</span>
<span class="cm"> *	dir	- &#39;true&#39; if the new disk inode is for a directory.</span>
<span class="cm"> *	ip	- pointer to a new inode</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success.</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources.</span>
<span class="cm"> *	-EIO	- i/o error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">diAlloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">pip</span><span class="p">,</span> <span class="n">bool</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="n">addext</span><span class="p">,</span> <span class="n">extno</span><span class="p">,</span> <span class="n">bitno</span><span class="p">,</span> <span class="n">sword</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nwords</span><span class="p">,</span> <span class="n">rem</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">agno</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">inosmap</span><span class="p">,</span> <span class="n">extsmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">inum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="n">iagp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="n">imap</span><span class="p">;</span>

	<span class="cm">/* get the pointers to the inode map inode and the</span>
<span class="cm">	 * corresponding imap control structure.</span>
<span class="cm">	 */</span>
	<span class="n">ipimap</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipimap</span><span class="p">;</span>
	<span class="n">imap</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">;</span>
	<span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipimap</span> <span class="o">=</span> <span class="n">ipimap</span><span class="p">;</span>
	<span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fileset</span> <span class="o">=</span> <span class="n">FILESYSTEM_I</span><span class="p">;</span>

	<span class="cm">/* for a directory, the allocation policy is to start</span>
<span class="cm">	 * at the ag level using the preferred ag.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">agno</span> <span class="o">=</span> <span class="n">dbNextAG</span><span class="p">(</span><span class="n">JFS_SBI</span><span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipbmap</span><span class="p">);</span>
		<span class="n">AG_LOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">tryag</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* for files, the policy starts off by trying to allocate from</span>
<span class="cm">	 * the same iag containing the parent disk inode:</span>
<span class="cm">	 * try to allocate the new disk inode close to the parent disk</span>
<span class="cm">	 * inode, using parent disk inode number + 1 as the allocation</span>
<span class="cm">	 * hint.  (we use a left-to-right policy to attempt to avoid</span>
<span class="cm">	 * moving backward on the disk.)  compute the hint within the</span>
<span class="cm">	 * file system and the iag.</span>
<span class="cm">	 */</span>

	<span class="cm">/* get the ag number of this iag */</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">BLKTOAG</span><span class="p">(</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">pip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">agstart</span><span class="p">,</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">JFS_SBI</span><span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="o">-&gt;</span><span class="n">db_active</span><span class="p">[</span><span class="n">agno</span><span class="p">]))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * There is an open file actively growing.  We want to</span>
<span class="cm">		 * allocate new inodes from a different ag to avoid</span>
<span class="cm">		 * fragmentation problems.</span>
<span class="cm">		 */</span>
		<span class="n">agno</span> <span class="o">=</span> <span class="n">dbNextAG</span><span class="p">(</span><span class="n">JFS_SBI</span><span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipbmap</span><span class="p">);</span>
		<span class="n">AG_LOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">tryag</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inum</span> <span class="o">=</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">inum</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INOSPERIAG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* back off the hint if it is outside of the iag */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">inum</span> <span class="o">=</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>

	<span class="cm">/* lock the AG inode map information */</span>
	<span class="n">AG_LOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>

	<span class="cm">/* Get read lock on imap inode */</span>
	<span class="n">IREAD_LOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">RDWRLOCK_IMAP</span><span class="p">);</span>

	<span class="cm">/* get the iag number and read the iag */</span>
	<span class="n">iagno</span> <span class="o">=</span> <span class="n">INOTOIAG</span><span class="p">(</span><span class="n">inum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>
		<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">iagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* determine if new inode extent is allowed to be added to the iag.</span>
<span class="cm">	 * new inode extent can be added to the iag if the ag</span>
<span class="cm">	 * has less than 32 free disk inodes and the iag has free extents.</span>
<span class="cm">	 */</span>
	<span class="n">addext</span> <span class="o">=</span> <span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numfree</span> <span class="o">&lt;</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	try to allocate from the IAG</span>
<span class="cm">	 */</span>
	<span class="cm">/* check if the inode may be allocated from the iag</span>
<span class="cm">	 * (i.e. the inode has free inodes or new extent can be added).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span> <span class="o">||</span> <span class="n">addext</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* determine the extent number of the hint.</span>
<span class="cm">		 */</span>
		<span class="n">extno</span> <span class="o">=</span> <span class="n">ino</span> <span class="o">&gt;&gt;</span> <span class="n">L2INOSPEREXT</span><span class="p">;</span>

		<span class="cm">/* check if the extent containing the hint has backed</span>
<span class="cm">		 * inodes.  if so, try to allocate within this extent.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">bitno</span> <span class="o">=</span> <span class="n">ino</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INOSPEREXT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">bitno</span> <span class="o">=</span>
			     <span class="n">diFindFree</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">extno</span><span class="p">]),</span>
					<span class="n">bitno</span><span class="p">))</span>
			    <span class="o">&lt;</span> <span class="n">INOSPEREXT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ino</span> <span class="o">=</span> <span class="p">(</span><span class="n">extno</span> <span class="o">&lt;&lt;</span> <span class="n">L2INOSPEREXT</span><span class="p">)</span> <span class="o">+</span> <span class="n">bitno</span><span class="p">;</span>

				<span class="cm">/* a free inode (bit) was found within this</span>
<span class="cm">				 * extent, so allocate it.</span>
<span class="cm">				 */</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">diAllocBit</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">iagp</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
				<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">assert</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* set the results of the allocation</span>
<span class="cm">					 * and write the iag.</span>
<span class="cm">					 */</span>
					<span class="n">diInitInode</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">extno</span><span class="p">,</span>
						    <span class="n">iagp</span><span class="p">);</span>
					<span class="n">mark_metapage_dirty</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

				<span class="cm">/* free the AG lock and return.</span>
<span class="cm">				 */</span>
				<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addext</span><span class="p">)</span>
				<span class="n">extno</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">extno</span> <span class="o">==</span>
				     <span class="n">EXTSPERIAG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">extno</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * no free inodes within the extent containing the hint.</span>
<span class="cm">		 *</span>
<span class="cm">		 * try to allocate from the backed extents following</span>
<span class="cm">		 * hint or, if appropriate (i.e. addext is true), allocate</span>
<span class="cm">		 * an extent of free inodes at or following the extent</span>
<span class="cm">		 * containing the hint.</span>
<span class="cm">		 *</span>
<span class="cm">		 * the free inode and free extent summary maps are used</span>
<span class="cm">		 * here, so determine the starting summary map position</span>
<span class="cm">		 * and the number of words we&#39;ll have to examine.  again,</span>
<span class="cm">		 * the approach is to allocate following the hint, so we</span>
<span class="cm">		 * might have to initially ignore prior bits of the summary</span>
<span class="cm">		 * map that represent extents prior to the extent containing</span>
<span class="cm">		 * the hint and later revisit these bits.</span>
<span class="cm">		 */</span>
		<span class="n">bitno</span> <span class="o">=</span> <span class="n">extno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EXTSPERSUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">nwords</span> <span class="o">=</span> <span class="p">(</span><span class="n">bitno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">SMAPSZ</span> <span class="o">:</span> <span class="n">SMAPSZ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sword</span> <span class="o">=</span> <span class="n">extno</span> <span class="o">&gt;&gt;</span> <span class="n">L2EXTSPERSUM</span><span class="p">;</span>

		<span class="cm">/* mask any prior bits for the starting words of the</span>
<span class="cm">		 * summary map.</span>
<span class="cm">		 */</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">ONES</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">EXTSPERSUM</span> <span class="o">-</span> <span class="n">bitno</span><span class="p">);</span>
		<span class="n">inosmap</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inosmap</span><span class="p">[</span><span class="n">sword</span><span class="p">])</span> <span class="o">|</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">extsmap</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extsmap</span><span class="p">[</span><span class="n">sword</span><span class="p">])</span> <span class="o">|</span> <span class="n">mask</span><span class="p">;</span>

		<span class="cm">/* scan the free inode and free extent summary maps for</span>
<span class="cm">		 * free resources.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nwords</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* check if this word of the free inode summary</span>
<span class="cm">			 * map describes an extent with free inodes.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">inosmap</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* an extent with free inodes has been</span>
<span class="cm">				 * found. determine the extent number</span>
<span class="cm">				 * and the inode number within the extent.</span>
<span class="cm">				 */</span>
				<span class="n">rem</span> <span class="o">=</span> <span class="n">diFindFree</span><span class="p">(</span><span class="n">inosmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">extno</span> <span class="o">=</span> <span class="p">(</span><span class="n">sword</span> <span class="o">&lt;&lt;</span> <span class="n">L2EXTSPERSUM</span><span class="p">)</span> <span class="o">+</span> <span class="n">rem</span><span class="p">;</span>
				<span class="n">rem</span> <span class="o">=</span> <span class="n">diFindFree</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">extno</span><span class="p">]),</span>
						 <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&gt;=</span> <span class="n">INOSPEREXT</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>
					<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
					<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
					<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
						  <span class="s">&quot;diAlloc: can&#39;t find free bit &quot;</span>
						  <span class="s">&quot;in wmap&quot;</span><span class="p">);</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* determine the inode number within the</span>
<span class="cm">				 * iag and allocate the inode from the</span>
<span class="cm">				 * map.</span>
<span class="cm">				 */</span>
				<span class="n">ino</span> <span class="o">=</span> <span class="p">(</span><span class="n">extno</span> <span class="o">&lt;&lt;</span> <span class="n">L2INOSPEREXT</span><span class="p">)</span> <span class="o">+</span> <span class="n">rem</span><span class="p">;</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">diAllocBit</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">iagp</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
				<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
					<span class="n">assert</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* set the results of the allocation</span>
<span class="cm">					 * and write the iag.</span>
<span class="cm">					 */</span>
					<span class="n">diInitInode</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">extno</span><span class="p">,</span>
						    <span class="n">iagp</span><span class="p">);</span>
					<span class="n">mark_metapage_dirty</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

				<span class="cm">/* free the AG lock and return.</span>
<span class="cm">				 */</span>
				<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>

			<span class="p">}</span>

			<span class="cm">/* check if we may allocate an extent of free</span>
<span class="cm">			 * inodes and whether this word of the free</span>
<span class="cm">			 * extents summary map describes a free extent.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addext</span> <span class="o">&amp;&amp;</span> <span class="o">~</span><span class="n">extsmap</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* a free extent has been found.  determine</span>
<span class="cm">				 * the extent number.</span>
<span class="cm">				 */</span>
				<span class="n">rem</span> <span class="o">=</span> <span class="n">diFindFree</span><span class="p">(</span><span class="n">extsmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">extno</span> <span class="o">=</span> <span class="p">(</span><span class="n">sword</span> <span class="o">&lt;&lt;</span> <span class="n">L2EXTSPERSUM</span><span class="p">)</span> <span class="o">+</span> <span class="n">rem</span><span class="p">;</span>

				<span class="cm">/* allocate an extent of free inodes.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diNewExt</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">iagp</span><span class="p">,</span> <span class="n">extno</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* if there is no disk space for a</span>
<span class="cm">					 * new extent, try to allocate the</span>
<span class="cm">					 * disk inode from somewhere else.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>

					<span class="n">assert</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* set the results of the allocation</span>
<span class="cm">					 * and write the iag.</span>
<span class="cm">					 */</span>
					<span class="n">diInitInode</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span>
						    <span class="n">extno</span> <span class="o">&lt;&lt;</span> <span class="n">L2INOSPEREXT</span><span class="p">,</span>
						    <span class="n">extno</span><span class="p">,</span> <span class="n">iagp</span><span class="p">);</span>
					<span class="n">mark_metapage_dirty</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
				<span class="cm">/* free the imap inode &amp; the AG lock &amp; return.</span>
<span class="cm">				 */</span>
				<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>
				<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* move on to the next set of summary map words.</span>
<span class="cm">			 */</span>
			<span class="n">sword</span> <span class="o">=</span> <span class="p">(</span><span class="n">sword</span> <span class="o">==</span> <span class="n">SMAPSZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">sword</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">inosmap</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inosmap</span><span class="p">[</span><span class="n">sword</span><span class="p">]);</span>
			<span class="n">extsmap</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extsmap</span><span class="p">[</span><span class="n">sword</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* unlock imap inode */</span>
	<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>

	<span class="cm">/* nothing doing in this iag, so release it. */</span>
	<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

      <span class="nl">tryag:</span>
	<span class="cm">/*</span>
<span class="cm">	 * try to allocate anywhere within the same AG as the parent inode.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">diAllocAG</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

	<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * try to allocate in any AG.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">diAllocAny</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">ip</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	diAllocAG(imap,agno,dir,ip)</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	allocate a disk inode from the allocation group.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine first determines if a new extent of free</span>
<span class="cm"> *		inodes should be added for the allocation group, with</span>
<span class="cm"> *		the current request satisfied from this extent. if this</span>
<span class="cm"> *		is the case, an attempt will be made to do just that.  if</span>
<span class="cm"> *		this attempt fails or it has been determined that a new</span>
<span class="cm"> *		extent should not be added, an attempt is made to satisfy</span>
<span class="cm"> *		the request by allocating an existing (backed) free inode</span>
<span class="cm"> *		from the allocation group.</span>
<span class="cm"> *</span>
<span class="cm"> * PRE CONDITION: Already have the AG lock for this AG.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	imap	- pointer to inode map control structure.</span>
<span class="cm"> *	agno	- allocation group to allocate from.</span>
<span class="cm"> *	dir	- &#39;true&#39; if the new disk inode is for a directory.</span>
<span class="cm"> *	ip	- pointer to the new inode to be filled in on successful return</span>
<span class="cm"> *		  with the disk inode number allocated, its extent address</span>
<span class="cm"> *		  and the start of the ag.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success.</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources.</span>
<span class="cm"> *	-EIO	- i/o error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">diAllocAG</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span> <span class="n">imap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">agno</span><span class="p">,</span> <span class="n">bool</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">addext</span><span class="p">,</span> <span class="n">numfree</span><span class="p">,</span> <span class="n">numinos</span><span class="p">;</span>

	<span class="cm">/* get the number of free and the number of backed disk</span>
<span class="cm">	 * inodes currently within the ag.</span>
<span class="cm">	 */</span>
	<span class="n">numfree</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numfree</span><span class="p">;</span>
	<span class="n">numinos</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numinos</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">numfree</span> <span class="o">&gt;</span> <span class="n">numinos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;diAllocAG: numfree &gt; numinos&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* determine if we should allocate a new extent of free inodes</span>
<span class="cm">	 * within the ag: for directory inodes, add a new extent</span>
<span class="cm">	 * if there are a small number of free inodes or number of free</span>
<span class="cm">	 * inodes is a small percentage of the number of backed inodes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="p">)</span>
		<span class="n">addext</span> <span class="o">=</span> <span class="p">(</span><span class="n">numfree</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="o">||</span>
			  <span class="p">(</span><span class="n">numfree</span> <span class="o">&lt;</span> <span class="mi">256</span>
			   <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">numfree</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="n">numinos</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">addext</span> <span class="o">=</span> <span class="p">(</span><span class="n">numfree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * try to allocate a new extent of free inodes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addext</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if free space is not available for this new extent, try</span>
<span class="cm">		 * below to allocate a free and existing (already backed)</span>
<span class="cm">		 * inode from the ag.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diAllocExt</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * try to allocate an existing free inode from the ag.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">diAllocIno</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">ip</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	diAllocAny(imap,agno,dir,iap)</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	allocate a disk inode from any other allocation group.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine is called when an allocation attempt within</span>
<span class="cm"> *		the primary allocation group has failed. if attempts to</span>
<span class="cm"> *		allocate an inode from any allocation group other than the</span>
<span class="cm"> *		specified primary group.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	imap	- pointer to inode map control structure.</span>
<span class="cm"> *	agno	- primary allocation group (to avoid).</span>
<span class="cm"> *	dir	- &#39;true&#39; if the new disk inode is for a directory.</span>
<span class="cm"> *	ip	- pointer to a new inode to be filled in on successful return</span>
<span class="cm"> *		  with the disk inode number allocated, its extent address</span>
<span class="cm"> *		  and the start of the ag.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success.</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources.</span>
<span class="cm"> *	-EIO	- i/o error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">diAllocAny</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span> <span class="n">imap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">agno</span><span class="p">,</span> <span class="n">bool</span> <span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ag</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxag</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="o">-&gt;</span><span class="n">db_maxag</span><span class="p">;</span>


	<span class="cm">/* try to allocate from the ags following agno up to</span>
<span class="cm">	 * the maximum ag number.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ag</span> <span class="o">=</span> <span class="n">agno</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ag</span> <span class="o">&lt;=</span> <span class="n">maxag</span><span class="p">;</span> <span class="n">ag</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AG_LOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">ag</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">diAllocAG</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

		<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">ag</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* try to allocate from the ags in front of agno.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ag</span> <span class="o">&lt;</span> <span class="n">agno</span><span class="p">;</span> <span class="n">ag</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">AG_LOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">ag</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">diAllocAG</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

		<span class="n">AG_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">ag</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* no free disk inodes.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	diAllocIno(imap,agno,ip)</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	allocate a disk inode from the allocation group&#39;s free</span>
<span class="cm"> *		inode list, returning an error if this free list is</span>
<span class="cm"> *		empty (i.e. no iags on the list).</span>
<span class="cm"> *</span>
<span class="cm"> *		allocation occurs from the first iag on the list using</span>
<span class="cm"> *		the iag&#39;s free inode summary map to find the leftmost</span>
<span class="cm"> *		free inode in the iag.</span>
<span class="cm"> *</span>
<span class="cm"> * PRE CONDITION: Already have AG lock for this AG.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	imap	- pointer to inode map control structure.</span>
<span class="cm"> *	agno	- allocation group.</span>
<span class="cm"> *	ip	- pointer to new inode to be filled in on successful return</span>
<span class="cm"> *		  with the disk inode number allocated, its extent address</span>
<span class="cm"> *		  and the start of the ag.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success.</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources.</span>
<span class="cm"> *	-EIO	- i/o error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">diAllocIno</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span> <span class="n">imap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">agno</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iagno</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rem</span><span class="p">,</span> <span class="n">extno</span><span class="p">,</span> <span class="n">sword</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="n">iagp</span><span class="p">;</span>

	<span class="cm">/* check if there are iags on the ag&#39;s free inode list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iagno</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">inofree</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="cm">/* obtain read lock on imap inode */</span>
	<span class="n">IREAD_LOCK</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">,</span> <span class="n">RDWRLOCK_IMAP</span><span class="p">);</span>

	<span class="cm">/* read the iag at the head of the list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">iagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* better be free inodes in this iag if it is on the</span>
<span class="cm">	 * list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">);</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;diAllocIno: nfreeinos = 0, but iag on freelist&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* scan the free inode summary map to find an extent</span>
<span class="cm">	 * with free inodes.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sword</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;</span> <span class="n">sword</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sword</span> <span class="o">&gt;=</span> <span class="n">SMAPSZ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">);</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;diAllocIno: free inode not found in summary map&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inosmap</span><span class="p">[</span><span class="n">sword</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* found a extent with free inodes. determine</span>
<span class="cm">	 * the extent number.</span>
<span class="cm">	 */</span>
	<span class="n">rem</span> <span class="o">=</span> <span class="n">diFindFree</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inosmap</span><span class="p">[</span><span class="n">sword</span><span class="p">]),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&gt;=</span> <span class="n">EXTSPERSUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">);</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;diAllocIno: no free extent found&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">extno</span> <span class="o">=</span> <span class="p">(</span><span class="n">sword</span> <span class="o">&lt;&lt;</span> <span class="n">L2EXTSPERSUM</span><span class="p">)</span> <span class="o">+</span> <span class="n">rem</span><span class="p">;</span>

	<span class="cm">/* find the first free inode in the extent.</span>
<span class="cm">	 */</span>
	<span class="n">rem</span> <span class="o">=</span> <span class="n">diFindFree</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">extno</span><span class="p">]),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&gt;=</span> <span class="n">INOSPEREXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">);</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;diAllocIno: free inode not found&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* compute the inode number within the iag.</span>
<span class="cm">	 */</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="p">(</span><span class="n">extno</span> <span class="o">&lt;&lt;</span> <span class="n">L2INOSPEREXT</span><span class="p">)</span> <span class="o">+</span> <span class="n">rem</span><span class="p">;</span>

	<span class="cm">/* allocate the inode.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">diAllocBit</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">iagp</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* set the results of the allocation and write the iag.</span>
<span class="cm">	 */</span>
	<span class="n">diInitInode</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">extno</span><span class="p">,</span> <span class="n">iagp</span><span class="p">);</span>
	<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	diAllocExt(imap,agno,ip)</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	add a new extent of free inodes to an iag, allocating</span>
<span class="cm"> *		an inode from this extent to satisfy the current allocation</span>
<span class="cm"> *		request.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine first tries to find an existing iag with free</span>
<span class="cm"> *		extents through the ag free extent list.  if list is not</span>
<span class="cm"> *		empty, the head of the list will be selected as the home</span>
<span class="cm"> *		of the new extent of free inodes.  otherwise (the list is</span>
<span class="cm"> *		empty), a new iag will be allocated for the ag to contain</span>
<span class="cm"> *		the extent.</span>
<span class="cm"> *</span>
<span class="cm"> *		once an iag has been selected, the free extent summary map</span>
<span class="cm"> *		is used to locate a free extent within the iag and diNewExt()</span>
<span class="cm"> *		is called to initialize the extent, with initialization</span>
<span class="cm"> *		including the allocation of the first inode of the extent</span>
<span class="cm"> *		for the purpose of satisfying this request.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	imap	- pointer to inode map control structure.</span>
<span class="cm"> *	agno	- allocation group number.</span>
<span class="cm"> *	ip	- pointer to new inode to be filled in on successful return</span>
<span class="cm"> *		  with the disk inode number allocated, its extent address</span>
<span class="cm"> *		  and the start of the ag.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success.</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources.</span>
<span class="cm"> *	-EIO	- i/o error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">diAllocExt</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span> <span class="n">imap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">agno</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rem</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="n">sword</span><span class="p">,</span> <span class="n">extno</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="n">iagp</span><span class="p">;</span>

	<span class="cm">/* check if the ag has any iags with free extents.  if not,</span>
<span class="cm">	 * allocate a new iag for the ag.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iagno</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">extfree</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If successful, diNewIAG will obtain the read lock on the</span>
<span class="cm">		 * imap inode.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diNewIAG</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iagno</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">iagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="cm">/* set the ag number if this a brand new iag</span>
<span class="cm">		 */</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">agstart</span> <span class="o">=</span>
		    <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">AGTOBLK</span><span class="p">(</span><span class="n">agno</span><span class="p">,</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* read the iag.</span>
<span class="cm">		 */</span>
		<span class="n">IREAD_LOCK</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">,</span> <span class="n">RDWRLOCK_IMAP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">);</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;diAllocExt: error reading iag&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* using the free extent summary map, find a free extent.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sword</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;</span> <span class="n">sword</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sword</span> <span class="o">&gt;=</span> <span class="n">SMAPSZ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">);</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;diAllocExt: free ext summary map not found&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extsmap</span><span class="p">[</span><span class="n">sword</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* determine the extent number of the free extent.</span>
<span class="cm">	 */</span>
	<span class="n">rem</span> <span class="o">=</span> <span class="n">diFindFree</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extsmap</span><span class="p">[</span><span class="n">sword</span><span class="p">]),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&gt;=</span> <span class="n">EXTSPERSUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">);</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;diAllocExt: free extent not found&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">extno</span> <span class="o">=</span> <span class="p">(</span><span class="n">sword</span> <span class="o">&lt;&lt;</span> <span class="n">L2EXTSPERSUM</span><span class="p">)</span> <span class="o">+</span> <span class="n">rem</span><span class="p">;</span>

	<span class="cm">/* initialize the new extent.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">diNewExt</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">iagp</span><span class="p">,</span> <span class="n">extno</span><span class="p">);</span>
	<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* something bad happened.  if a new iag was allocated,</span>
<span class="cm">		 * place it back on the inode map&#39;s iag free list, and</span>
<span class="cm">		 * clear the ag number information.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXTSPERIAG</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">IAGFREE_LOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">);</span>
			<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">iagfree</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_freeiag</span><span class="p">);</span>
			<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_freeiag</span> <span class="o">=</span> <span class="n">iagno</span><span class="p">;</span>
			<span class="n">IAGFREE_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* set the results of the allocation and write the iag.</span>
<span class="cm">	 */</span>
	<span class="n">diInitInode</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="n">extno</span> <span class="o">&lt;&lt;</span> <span class="n">L2INOSPEREXT</span><span class="p">,</span> <span class="n">extno</span><span class="p">,</span> <span class="n">iagp</span><span class="p">);</span>

	<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	diAllocBit(imap,iagp,ino)</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	allocate a backed inode from an iag.</span>
<span class="cm"> *</span>
<span class="cm"> *		this routine performs the mechanics of allocating a</span>
<span class="cm"> *		specified inode from a backed extent.</span>
<span class="cm"> *</span>
<span class="cm"> *		if the inode to be allocated represents the last free</span>
<span class="cm"> *		inode within the iag, the iag will be removed from the</span>
<span class="cm"> *		ag free inode list.</span>
<span class="cm"> *</span>
<span class="cm"> *		a careful update approach is used to provide consistency</span>
<span class="cm"> *		in the face of updates to multiple buffers.  under this</span>
<span class="cm"> *		approach, all required buffers are obtained before making</span>
<span class="cm"> *		any updates and are held all are updates are complete.</span>
<span class="cm"> *</span>
<span class="cm"> * PRE CONDITION: Already have buffer lock on iagp.  Already have AG lock on</span>
<span class="cm"> *	this AG.  Must have read lock on imap inode.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	imap	- pointer to inode map control structure.</span>
<span class="cm"> *	iagp	- pointer to iag.</span>
<span class="cm"> *	ino	- inode number to be allocated within the iag.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success.</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources.</span>
<span class="cm"> *	-EIO	- i/o error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">diAllocBit</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span> <span class="n">imap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span> <span class="n">iagp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">extno</span><span class="p">,</span> <span class="n">bitno</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">sword</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">amp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">bmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="n">aiagp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">biagp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* check if this is the last free inode within the iag.</span>
<span class="cm">	 * if so, it will have to be removed from the ag free</span>
<span class="cm">	 * inode list, so get the iags preceding and following</span>
<span class="cm">	 * it on the list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span>
			     <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span><span class="p">),</span>
				       <span class="o">&amp;</span><span class="n">amp</span><span class="p">)))</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
			<span class="n">aiagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">amp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span>
			     <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span>
				       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span><span class="p">),</span>
				       <span class="o">&amp;</span><span class="n">bmp</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">amp</span><span class="p">)</span>
					<span class="n">release_metapage</span><span class="p">(</span><span class="n">amp</span><span class="p">);</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">biagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* get the ag number, extent number, inode number within</span>
<span class="cm">	 * the extent.</span>
<span class="cm">	 */</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">BLKTOAG</span><span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">agstart</span><span class="p">),</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">));</span>
	<span class="n">extno</span> <span class="o">=</span> <span class="n">ino</span> <span class="o">&gt;&gt;</span> <span class="n">L2INOSPEREXT</span><span class="p">;</span>
	<span class="n">bitno</span> <span class="o">=</span> <span class="n">ino</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INOSPEREXT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* compute the mask for setting the map.</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">HIGHORDER</span> <span class="o">&gt;&gt;</span> <span class="n">bitno</span><span class="p">;</span>

	<span class="cm">/* the inode should be free and backed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">extno</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">extno</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">amp</span><span class="p">)</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">amp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="p">)</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>

		<span class="n">jfs_error</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;diAllocBit: iag inconsistent&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* mark the inode as allocated in the working map.</span>
<span class="cm">	 */</span>
	<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">extno</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

	<span class="cm">/* check if all inodes within the extent are now</span>
<span class="cm">	 * allocated.  if so, update the free inode summary</span>
<span class="cm">	 * map to reflect this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">extno</span><span class="p">]</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ONES</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sword</span> <span class="o">=</span> <span class="n">extno</span> <span class="o">&gt;&gt;</span> <span class="n">L2EXTSPERSUM</span><span class="p">;</span>
		<span class="n">bitno</span> <span class="o">=</span> <span class="n">extno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EXTSPERSUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inosmap</span><span class="p">[</span><span class="n">sword</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">HIGHORDER</span> <span class="o">&gt;&gt;</span> <span class="n">bitno</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* if this was the last free inode in the iag, remove the</span>
<span class="cm">	 * iag from the ag free inode list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">amp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">aiagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span><span class="p">;</span>
			<span class="n">write_metapage</span><span class="p">(</span><span class="n">amp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">biagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span><span class="p">;</span>
			<span class="n">write_metapage</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">inofree</span> <span class="o">=</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* update the free inode count at the iag, ag, inode</span>
<span class="cm">	 * map levels.</span>
<span class="cm">	 */</span>
	<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numfree</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_numfree</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	diNewExt(imap,iagp,extno)</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	initialize a new extent of inodes for an iag, allocating</span>
<span class="cm"> *		the first inode of the extent for use for the current</span>
<span class="cm"> *		allocation request.</span>
<span class="cm"> *</span>
<span class="cm"> *		disk resources are allocated for the new extent of inodes</span>
<span class="cm"> *		and the inodes themselves are initialized to reflect their</span>
<span class="cm"> *		existence within the extent (i.e. their inode numbers and</span>
<span class="cm"> *		inode extent addresses are set) and their initial state</span>
<span class="cm"> *		(mode and link count are set to zero).</span>
<span class="cm"> *</span>
<span class="cm"> *		if the iag is new, it is not yet on an ag extent free list</span>
<span class="cm"> *		but will now be placed on this list.</span>
<span class="cm"> *</span>
<span class="cm"> *		if the allocation of the new extent causes the iag to</span>
<span class="cm"> *		have no free extent, the iag will be removed from the</span>
<span class="cm"> *		ag extent free list.</span>
<span class="cm"> *</span>
<span class="cm"> *		if the iag has no free backed inodes, it will be placed</span>
<span class="cm"> *		on the ag free inode list, since the addition of the new</span>
<span class="cm"> *		extent will now cause it to have free inodes.</span>
<span class="cm"> *</span>
<span class="cm"> *		a careful update approach is used to provide consistency</span>
<span class="cm"> *		(i.e. list consistency) in the face of updates to multiple</span>
<span class="cm"> *		buffers.  under this approach, all required buffers are</span>
<span class="cm"> *		obtained before making any updates and are held until all</span>
<span class="cm"> *		updates are complete.</span>
<span class="cm"> *</span>
<span class="cm"> * PRE CONDITION: Already have buffer lock on iagp.  Already have AG lock on</span>
<span class="cm"> *	this AG.  Must have read lock on imap inode.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	imap	- pointer to inode map control structure.</span>
<span class="cm"> *	iagp	- pointer to iag.</span>
<span class="cm"> *	extno	- extent number.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success.</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources.</span>
<span class="cm"> *	-EIO	- i/o error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">diNewExt</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span> <span class="n">imap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span> <span class="n">iagp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">extno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">agno</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="n">fwd</span><span class="p">,</span> <span class="n">back</span><span class="p">,</span> <span class="n">freei</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sword</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="n">aiagp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">biagp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">ciagp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">amp</span><span class="p">,</span> <span class="o">*</span><span class="n">bmp</span><span class="p">,</span> <span class="o">*</span><span class="n">cmp</span><span class="p">,</span> <span class="o">*</span><span class="n">dmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">hint</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>

	<span class="cm">/* better have free extents.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;diNewExt: no free extents&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get the inode map inode.</span>
<span class="cm">	 */</span>
	<span class="n">ipimap</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">;</span>
	<span class="n">sbi</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="n">amp</span> <span class="o">=</span> <span class="n">bmp</span> <span class="o">=</span> <span class="n">cmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* get the ag and iag numbers for this iag.</span>
<span class="cm">	 */</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">BLKTOAG</span><span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">agstart</span><span class="p">),</span> <span class="n">sbi</span><span class="p">);</span>
	<span class="n">iagno</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">iagnum</span><span class="p">);</span>

	<span class="cm">/* check if this is the last free extent within the</span>
<span class="cm">	 * iag.  if so, the iag must be removed from the ag</span>
<span class="cm">	 * free extent list, so get the iags preceding and</span>
<span class="cm">	 * following the iag on this list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fwd</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">fwd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">)))</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
			<span class="n">aiagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">amp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">back</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">back</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bmp</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
			<span class="n">biagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">bmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* the iag has free extents.  if all extents are free</span>
<span class="cm">		 * (as is the case for a newly allocated iag), the iag</span>
<span class="cm">		 * must be added to the ag free extent list, so get</span>
<span class="cm">		 * the iag at the head of the list in preparation for</span>
<span class="cm">		 * adding this iag to this list.</span>
<span class="cm">		 */</span>
		<span class="n">fwd</span> <span class="o">=</span> <span class="n">back</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXTSPERIAG</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">fwd</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">extfree</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">fwd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">)))</span>
					<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
				<span class="n">aiagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">amp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* check if the iag has no free inodes.  if so, the iag</span>
<span class="cm">	 * will have to be added to the ag free inode list, so get</span>
<span class="cm">	 * the iag at the head of the list in preparation for</span>
<span class="cm">	 * adding this iag to this list.  in doing this, we must</span>
<span class="cm">	 * check if we already have the iag at the head of</span>
<span class="cm">	 * the list in hand.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">freei</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">inofree</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">freei</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">freei</span> <span class="o">==</span> <span class="n">fwd</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ciagp</span> <span class="o">=</span> <span class="n">aiagp</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">freei</span> <span class="o">==</span> <span class="n">back</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ciagp</span> <span class="o">=</span> <span class="n">biagp</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">freei</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmp</span><span class="p">)))</span>
					<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
				<span class="n">ciagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ciagp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">jfs_error</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
					  <span class="s">&quot;diNewExt: ciagp == NULL&quot;</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* allocate disk space for the inode extent.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">extno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">hint</span> <span class="o">=</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span> <span class="n">agno</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="o">-&gt;</span><span class="n">db_agl2size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hint</span> <span class="o">=</span> <span class="n">addressPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
		    <span class="n">lengthPXD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAlloc</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nbperiext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkno</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>

	<span class="cm">/* compute the inode number of the first inode within the</span>
<span class="cm">	 * extent.</span>
<span class="cm">	 */</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="p">(</span><span class="n">iagno</span> <span class="o">&lt;&lt;</span> <span class="n">L2INOSPERIAG</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">extno</span> <span class="o">&lt;&lt;</span> <span class="n">L2INOSPEREXT</span><span class="p">);</span>

	<span class="cm">/* initialize the inodes within the newly allocated extent a</span>
<span class="cm">	 * page at a time.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nbperiext</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get a buffer for this page of disk inodes.</span>
<span class="cm">		 */</span>
		<span class="n">dmp</span> <span class="o">=</span> <span class="n">get_metapage</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">blkno</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span><span class="p">)</span> <span class="n">dmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="cm">/* initialize the inode number, mode, link count and</span>
<span class="cm">		 * inode extent address.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">INOSPERPAGE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">dp</span><span class="o">++</span><span class="p">,</span> <span class="n">ino</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_inostamp</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">inostamp</span><span class="p">);</span>
			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_number</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_fileset</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">FILESYSTEM_I</span><span class="p">);</span>
			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_nlink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">PXDaddress</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_ixpxd</span><span class="p">),</span> <span class="n">blkno</span><span class="p">);</span>
			<span class="n">PXDlength</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">di_ixpxd</span><span class="p">),</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nbperiext</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">dmp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* if this is the last free extent within the iag, remove the</span>
<span class="cm">	 * iag from the ag free extent list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fwd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">aiagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">back</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">biagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">extfree</span> <span class="o">=</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span><span class="p">);</span>

		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* if the iag has all free extents (newly allocated iag),</span>
<span class="cm">		 * add the iag to the ag free extent list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXTSPERIAG</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fwd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">aiagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">iagno</span><span class="p">);</span>

			<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">fwd</span><span class="p">);</span>
			<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">extfree</span> <span class="o">=</span> <span class="n">iagno</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* if the iag has no free inodes, add the iag to the</span>
<span class="cm">	 * ag free inode list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">freei</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ciagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">iagno</span><span class="p">);</span>

		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span> <span class="o">=</span>
		    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">inofree</span><span class="p">);</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">inofree</span> <span class="o">=</span> <span class="n">iagno</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize the extent descriptor of the extent. */</span>
	<span class="n">PXDlength</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span><span class="p">],</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nbperiext</span><span class="p">);</span>
	<span class="n">PXDaddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inoext</span><span class="p">[</span><span class="n">extno</span><span class="p">],</span> <span class="n">blkno</span><span class="p">);</span>

	<span class="cm">/* initialize the working and persistent map of the extent.</span>
<span class="cm">	 * the working map will be initialized such that</span>
<span class="cm">	 * it indicates the first inode of the extent is allocated.</span>
<span class="cm">	 */</span>
	<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">extno</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">HIGHORDER</span><span class="p">);</span>
	<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">extno</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* update the free inode and free extent summary maps</span>
<span class="cm">	 * for the extent to indicate the extent has free inodes</span>
<span class="cm">	 * and no longer represents a free extent.</span>
<span class="cm">	 */</span>
	<span class="n">sword</span> <span class="o">=</span> <span class="n">extno</span> <span class="o">&gt;&gt;</span> <span class="n">L2EXTSPERSUM</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">HIGHORDER</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">extno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EXTSPERSUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extsmap</span><span class="p">[</span><span class="n">sword</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
	<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inosmap</span><span class="p">[</span><span class="n">sword</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">);</span>

	<span class="cm">/* update the free inode and free extent counts for the</span>
<span class="cm">	 * iag.</span>
<span class="cm">	 */</span>
	<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span><span class="p">,</span> <span class="p">(</span><span class="n">INOSPEREXT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">le32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* update the free and backed inode counts for the ag.</span>
<span class="cm">	 */</span>
	<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numfree</span> <span class="o">+=</span> <span class="p">(</span><span class="n">INOSPEREXT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">agno</span><span class="p">].</span><span class="n">numinos</span> <span class="o">+=</span> <span class="n">INOSPEREXT</span><span class="p">;</span>

	<span class="cm">/* update the free and backed inode counts for the inode map.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_add</span><span class="p">(</span><span class="n">INOSPEREXT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_numfree</span><span class="p">);</span>
	<span class="n">atomic_add</span><span class="p">(</span><span class="n">INOSPEREXT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_numinos</span><span class="p">);</span>

	<span class="cm">/* write the iags.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">amp</span><span class="p">)</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">amp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="p">)</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span><span class="p">)</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">cmp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

      <span class="nl">error_out:</span>

	<span class="cm">/* release the iags.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">amp</span><span class="p">)</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">amp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmp</span><span class="p">)</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span><span class="p">)</span>
		<span class="n">release_metapage</span><span class="p">(</span><span class="n">cmp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NAME:	diNewIAG(imap,iagnop,agno)</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	allocate a new iag for an allocation group.</span>
<span class="cm"> *</span>
<span class="cm"> *		first tries to allocate the iag from the inode map</span>
<span class="cm"> *		iagfree list:</span>
<span class="cm"> *		if the list has free iags, the head of the list is removed</span>
<span class="cm"> *		and returned to satisfy the request.</span>
<span class="cm"> *		if the inode map&#39;s iag free list is empty, the inode map</span>
<span class="cm"> *		is extended to hold a new iag. this new iag is initialized</span>
<span class="cm"> *		and returned to satisfy the request.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	imap	- pointer to inode map control structure.</span>
<span class="cm"> *	iagnop	- pointer to an iag number set with the number of the</span>
<span class="cm"> *		  newly allocated iag upon successful return.</span>
<span class="cm"> *	agno	- allocation group number.</span>
<span class="cm"> *	bpp	- Buffer pointer to be filled in with new IAG&#39;s buffer</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success.</span>
<span class="cm"> *	-ENOSPC	- insufficient disk resources.</span>
<span class="cm"> *	-EIO	- i/o error.</span>
<span class="cm"> *</span>
<span class="cm"> * serialization:</span>
<span class="cm"> *	AG lock held on entry/exit;</span>
<span class="cm"> *	write lock on the map is held inside;</span>
<span class="cm"> *	read lock on the map is held on successful completion;</span>
<span class="cm"> *</span>
<span class="cm"> * note: new iag transaction:</span>
<span class="cm"> * . synchronously write iag;</span>
<span class="cm"> * . write log of xtree and inode of imap;</span>
<span class="cm"> * . commit;</span>
<span class="cm"> * . synchronous write of xtree (right to left, bottom to top);</span>
<span class="cm"> * . at start of logredo(): init in-memory imap with one additional iag page;</span>
<span class="cm"> * . at end of logredo(): re-read imap inode to determine</span>
<span class="cm"> *   new imap size;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">diNewIAG</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span> <span class="n">imap</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">iagnop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">agno</span><span class="p">,</span> <span class="k">struct</span> <span class="n">metapage</span> <span class="o">**</span> <span class="n">mpp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iagno</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="n">iagp</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">xaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">iplist</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* pick up pointers to the inode map and mount inodes */</span>
	<span class="n">ipimap</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">;</span>
	<span class="n">sb</span> <span class="o">=</span> <span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">sbi</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="cm">/* acquire the free iag lock */</span>
	<span class="n">IAGFREE_LOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">);</span>

	<span class="cm">/* if there are any iags on the inode map free iag list,</span>
<span class="cm">	 * allocate the iag from the head of the list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_freeiag</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* pick up the iag number at the head of the list */</span>
		<span class="n">iagno</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_freeiag</span><span class="p">;</span>

		<span class="cm">/* determine the logical block number of the iag */</span>
		<span class="n">blkno</span> <span class="o">=</span> <span class="n">IAGTOLBLK</span><span class="p">(</span><span class="n">iagno</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* no free iags. the inode map will have to be extented</span>
<span class="cm">		 * to include a new iag.</span>
<span class="cm">		 */</span>

		<span class="cm">/* acquire inode map lock */</span>
		<span class="n">IWRITE_LOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">RDWRLOCK_IMAP</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">L2PSIZE</span> <span class="o">!=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nextiag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IWRITE_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>
			<span class="n">IAGFREE_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">);</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;diNewIAG: ipimap-&gt;i_size is wrong&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>


		<span class="cm">/* get the next available iag number */</span>
		<span class="n">iagno</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nextiag</span><span class="p">;</span>

		<span class="cm">/* make sure that we have not exceeded the maximum inode</span>
<span class="cm">		 * number limit.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iagno</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">MAXIAGS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* release the inode map lock */</span>
			<span class="n">IWRITE_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>

			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * synchronously append new iag page.</span>
<span class="cm">		 */</span>
		<span class="cm">/* determine the logical address of iag page to append */</span>
		<span class="n">blkno</span> <span class="o">=</span> <span class="n">IAGTOLBLK</span><span class="p">(</span><span class="n">iagno</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">);</span>

		<span class="cm">/* Allocate extent for new iag page */</span>
		<span class="n">xlen</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">nbperpage</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">dbAlloc</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xaddr</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* release the inode map lock */</span>
			<span class="n">IWRITE_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>

			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * start transaction of update of the inode map</span>
<span class="cm">		 * addressing structure pointing to the new iag page;</span>
<span class="cm">		 */</span>
		<span class="n">tid</span> <span class="o">=</span> <span class="n">txBegin</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">COMMIT_FORCE</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">commit_mutex</span><span class="p">);</span>

		<span class="cm">/* update the inode map addressing structure to point to it */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span>
		     <span class="n">xtInsert</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ipimap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">xlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">txEnd</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">commit_mutex</span><span class="p">);</span>
			<span class="cm">/* Free the blocks allocated for the iag since it was</span>
<span class="cm">			 * not successfully added to the inode map</span>
<span class="cm">			 */</span>
			<span class="n">dbFree</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">xlen</span><span class="p">);</span>

			<span class="cm">/* release the inode map lock */</span>
			<span class="n">IWRITE_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>

			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* update the inode map&#39;s inode to reflect the extension */</span>
		<span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">PSIZE</span><span class="p">;</span>
		<span class="n">inode_add_bytes</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">);</span>

		<span class="cm">/* assign a buffer for the page */</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="n">get_metapage</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is very unlikely since we just created the</span>
<span class="cm">			 * extent, but let&#39;s try to handle it correctly</span>
<span class="cm">			 */</span>
			<span class="n">xtTruncate</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ipimap</span><span class="p">,</span> <span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-</span> <span class="n">PSIZE</span><span class="p">,</span>
				   <span class="n">COMMIT_PWMAP</span><span class="p">);</span>

			<span class="n">txAbort</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">txEnd</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">commit_mutex</span><span class="p">);</span>

			<span class="cm">/* release the inode map lock */</span>
			<span class="n">IWRITE_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>

			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

		<span class="cm">/* init the iag */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">iagp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iag</span><span class="p">));</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">iagnum</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">iagno</span><span class="p">);</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">iagfree</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXTSPERIAG</span><span class="p">);</span>

		<span class="cm">/* initialize the free inode summary map (free extent</span>
<span class="cm">		 * summary map initialization handled by bzero).</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SMAPSZ</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inosmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ONES</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Write and sync the metapage</span>
<span class="cm">		 */</span>
		<span class="n">flush_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * txCommit(COMMIT_FORCE) will synchronously write address</span>
<span class="cm">		 * index pages and inode after commit in careful update order</span>
<span class="cm">		 * of address index pages (right to left, bottom up);</span>
<span class="cm">		 */</span>
		<span class="n">iplist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipimap</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">txCommit</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iplist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">COMMIT_FORCE</span><span class="p">);</span>

		<span class="n">txEnd</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">commit_mutex</span><span class="p">);</span>

		<span class="n">duplicateIXtree</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">xlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xaddr</span><span class="p">);</span>

		<span class="cm">/* update the next available iag number */</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nextiag</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Add the iag to the iag free list so we don&#39;t lose the iag</span>
<span class="cm">		 * if a failure happens now.</span>
<span class="cm">		 */</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_freeiag</span> <span class="o">=</span> <span class="n">iagno</span><span class="p">;</span>

		<span class="cm">/* Until we have logredo working, we want the imap inode &amp;</span>
<span class="cm">		 * control page to be up to date.</span>
<span class="cm">		 */</span>
		<span class="n">diSync</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>

		<span class="cm">/* release the inode map lock */</span>
		<span class="n">IWRITE_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* obtain read lock on map */</span>
	<span class="n">IREAD_LOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">RDWRLOCK_IMAP</span><span class="p">);</span>

	<span class="cm">/* read the iag */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">iagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* remove the iag from the iag free list */</span>
	<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_freeiag</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">iagfree</span><span class="p">);</span>
	<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">iagfree</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* set the return iag number and buffer pointer */</span>
	<span class="o">*</span><span class="n">iagnop</span> <span class="o">=</span> <span class="n">iagno</span><span class="p">;</span>
	<span class="o">*</span><span class="n">mpp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>

      <span class="nl">out:</span>
	<span class="cm">/* release the iag free lock */</span>
	<span class="n">IAGFREE_UNLOCK</span><span class="p">(</span><span class="n">imap</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	diIAGRead()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	get the buffer for the specified iag within a fileset</span>
<span class="cm"> *		or aggregate inode map.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	imap	- pointer to inode map control structure.</span>
<span class="cm"> *	iagno	- iag number.</span>
<span class="cm"> *	bpp	- point to buffer pointer to be filled in on successful</span>
<span class="cm"> *		  exit.</span>
<span class="cm"> *</span>
<span class="cm"> * SERIALIZATION:</span>
<span class="cm"> *	must have read lock on imap inode</span>
<span class="cm"> *	(When called by diExtendFS, the filesystem is quiesced, therefore</span>
<span class="cm"> *	 the read lock is unnecessary.)</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success.</span>
<span class="cm"> *	-EIO	- i/o error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">diIAGRead</span><span class="p">(</span><span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span> <span class="n">imap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iagno</span><span class="p">,</span> <span class="k">struct</span> <span class="n">metapage</span> <span class="o">**</span> <span class="n">mpp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_ipimap</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">blkno</span><span class="p">;</span>

	<span class="cm">/* compute the logical block number of the iag. */</span>
	<span class="n">blkno</span> <span class="o">=</span> <span class="n">IAGTOLBLK</span><span class="p">(</span><span class="n">iagno</span><span class="p">,</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l2nbperpage</span><span class="p">);</span>

	<span class="cm">/* read the iag. */</span>
	<span class="o">*</span><span class="n">mpp</span> <span class="o">=</span> <span class="n">read_metapage</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">mpp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	diFindFree()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	find the first free bit in a word starting at</span>
<span class="cm"> *		the specified bit position.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	word	- word to be examined.</span>
<span class="cm"> *	start	- starting bit position.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	bit position of first free bit in the word or 32 if</span>
<span class="cm"> *	no free bits were found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">diFindFree</span><span class="p">(</span><span class="n">u32</span> <span class="n">word</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bitno</span><span class="p">;</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="cm">/* scan the word for the first free bit. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">word</span> <span class="o">&lt;&lt;=</span> <span class="n">start</span><span class="p">,</span> <span class="n">bitno</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">bitno</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span>
	     <span class="n">bitno</span><span class="o">++</span><span class="p">,</span> <span class="n">word</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">word</span> <span class="o">&amp;</span> <span class="n">HIGHORDER</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bitno</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	diUpdatePMap()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION: Update the persistent map in an IAG for the allocation or</span>
<span class="cm"> *	freeing of the specified inode.</span>
<span class="cm"> *</span>
<span class="cm"> * PRE CONDITIONS: Working map has already been updated for allocate.</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:</span>
<span class="cm"> *	ipimap	- Incore inode map inode</span>
<span class="cm"> *	inum	- Number of inode to mark in permanent map</span>
<span class="cm"> *	is_free	- If &#39;true&#39; indicates inode should be marked freed, otherwise</span>
<span class="cm"> *		  indicates inode should be marked allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *		0 for success</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">diUpdatePMap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span><span class="p">,</span>
	     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inum</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_free</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span> <span class="n">tblk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="n">iagp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iagno</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">extno</span><span class="p">,</span> <span class="n">bitno</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="n">imap</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">log</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lsn</span><span class="p">,</span> <span class="n">difft</span><span class="p">,</span> <span class="n">diffp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">imap</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">;</span>
	<span class="cm">/* get the iag number containing the inode */</span>
	<span class="n">iagno</span> <span class="o">=</span> <span class="n">INOTOIAG</span><span class="p">(</span><span class="n">inum</span><span class="p">);</span>
	<span class="cm">/* make sure that the iag is contained within the map */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iagno</span> <span class="o">&gt;=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nextiag</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;diUpdatePMap: the iag is outside the map&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* read the iag */</span>
	<span class="n">IREAD_LOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">,</span> <span class="n">RDWRLOCK_IMAP</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">iagno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">IREAD_UNLOCK</span><span class="p">(</span><span class="n">ipimap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="n">metapage_wait_for_io</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">iagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="cm">/* get the inode number and extent number of the inode within</span>
<span class="cm">	 * the iag and the inode number within the extent.</span>
<span class="cm">	 */</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">inum</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INOSPERIAG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">extno</span> <span class="o">=</span> <span class="n">ino</span> <span class="o">&gt;&gt;</span> <span class="n">L2INOSPEREXT</span><span class="p">;</span>
	<span class="n">bitno</span> <span class="o">=</span> <span class="n">ino</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INOSPEREXT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">HIGHORDER</span> <span class="o">&gt;&gt;</span> <span class="n">bitno</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * mark the inode free in persistent map:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_free</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The inode should have been allocated both in working</span>
<span class="cm">		 * map and in persistent map;</span>
<span class="cm">		 * the inode will be freed from working map at the release</span>
<span class="cm">		 * of last reference release;</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">extno</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;diUpdatePMap: inode %ld not marked as &quot;</span>
				  <span class="s">&quot;allocated in wmap!&quot;</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">extno</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;diUpdatePMap: inode %ld not marked as &quot;</span>
				  <span class="s">&quot;allocated in pmap!&quot;</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* update the bitmap for the extent of the freed inode */</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">extno</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * mark the inode allocated in persistent map:</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* The inode should be already allocated in the working map</span>
<span class="cm">		 * and should be free in persistent map;</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">wmap</span><span class="p">[</span><span class="n">extno</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;diUpdatePMap: the inode is not allocated in &quot;</span>
				  <span class="s">&quot;the working map&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">extno</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;diUpdatePMap: the inode is not free in the &quot;</span>
				  <span class="s">&quot;persistent map&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* update the bitmap for the extent of the allocated inode */</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">pmap</span><span class="p">[</span><span class="n">extno</span><span class="p">]</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * update iag lsn</span>
<span class="cm">	 */</span>
	<span class="n">lsn</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">lsn</span><span class="p">;</span>
	<span class="n">log</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">;</span>
	<span class="n">LOGSYNC_LOCK</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">lsn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* inherit older/smaller lsn */</span>
		<span class="n">logdiff</span><span class="p">(</span><span class="n">difft</span><span class="p">,</span> <span class="n">lsn</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>
		<span class="n">logdiff</span><span class="p">(</span><span class="n">diffp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">lsn</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">difft</span> <span class="o">&lt;</span> <span class="n">diffp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">lsn</span> <span class="o">=</span> <span class="n">lsn</span><span class="p">;</span>
			<span class="cm">/* move mp after tblock in logsync list */</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">synclist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">synclist</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* inherit younger/larger clsn */</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">clsn</span><span class="p">);</span>
		<span class="n">logdiff</span><span class="p">(</span><span class="n">difft</span><span class="p">,</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">clsn</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>
		<span class="n">logdiff</span><span class="p">(</span><span class="n">diffp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">clsn</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">difft</span> <span class="o">&gt;</span> <span class="n">diffp</span><span class="p">)</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">clsn</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">clsn</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">log</span> <span class="o">=</span> <span class="n">log</span><span class="p">;</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">lsn</span> <span class="o">=</span> <span class="n">lsn</span><span class="p">;</span>
		<span class="cm">/* insert mp after tblock in logsync list */</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">synclist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tblk</span><span class="o">-&gt;</span><span class="n">synclist</span><span class="p">);</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">clsn</span> <span class="o">=</span> <span class="n">tblk</span><span class="o">-&gt;</span><span class="n">clsn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">LOGSYNC_UNLOCK</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">write_metapage</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	diExtendFS()</span>
<span class="cm"> *</span>
<span class="cm"> * function: update imap for extendfs();</span>
<span class="cm"> *</span>
<span class="cm"> * note: AG size has been increased s.t. each k old contiguous AGs are</span>
<span class="cm"> * coalesced into a new AG;</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">diExtendFS</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipimap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ipbmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rcx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inomap</span> <span class="o">*</span><span class="n">imap</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ipimap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="n">iagp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">hiagp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bmap</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ipbmap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">metapage</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="o">*</span><span class="n">hbp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numinos</span><span class="p">,</span> <span class="n">xnuminos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xnumfree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">agstart</span><span class="p">;</span>

	<span class="n">jfs_info</span><span class="p">(</span><span class="s">&quot;diExtendFS: nextiag:%d numinos:%d numfree:%d&quot;</span><span class="p">,</span>
		   <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nextiag</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_numinos</span><span class="p">),</span>
		   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_numfree</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 *	reconstruct imap</span>
<span class="cm">	 *</span>
<span class="cm">	 * coalesce contiguous k (newAGSize/oldAGSize) AGs;</span>
<span class="cm">	 * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;</span>
<span class="cm">	 * note: new AG size = old AG size * (2**x).</span>
<span class="cm">	 */</span>

	<span class="cm">/* init per AG control information im_agctl[] */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAXAG</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">inofree</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">extfree</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">numinos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* number of backed inodes */</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">numfree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* number of free backed inodes */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	process each iag page of the map.</span>
<span class="cm">	 *</span>
<span class="cm">	 * rebuild AG Free Inode List, AG Free Inode Extent List;</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_nextiag</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">rcx</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">iagnum</span><span class="p">)</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">jfs_error</span><span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				  <span class="s">&quot;diExtendFs: unexpected value of iagnum&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* leave free iag in the free iag list */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXTSPERIAG</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">release_metapage</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">agstart</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">agstart</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">agstart</span> <span class="o">&gt;&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span><span class="p">;</span>
		<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">agstart</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">db_agl2size</span><span class="p">);</span>

		<span class="cm">/* compute backed inodes */</span>
		<span class="n">numinos</span> <span class="o">=</span> <span class="p">(</span><span class="n">EXTSPERIAG</span> <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span><span class="p">))</span>
		    <span class="o">&lt;&lt;</span> <span class="n">L2INOSPEREXT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">numinos</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* merge AG backed inodes */</span>
			<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">numinos</span> <span class="o">+=</span> <span class="n">numinos</span><span class="p">;</span>
			<span class="n">xnuminos</span> <span class="o">+=</span> <span class="n">numinos</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* if any backed free inodes, insert at AG free inode list */</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">head</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">inofree</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hbp</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">rcx</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">nextiag</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">hiagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">hbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
				<span class="n">hiagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">iagnum</span><span class="p">;</span>
				<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreefwd</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
				<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">inofreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">write_metapage</span><span class="p">(</span><span class="n">hbp</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">inofree</span> <span class="o">=</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">iagnum</span><span class="p">);</span>

			<span class="cm">/* merge AG backed free inodes */</span>
			<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">numfree</span> <span class="o">+=</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span><span class="p">);</span>
			<span class="n">xnumfree</span> <span class="o">+=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeinos</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* if any free extents, insert at AG free extent list */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">nfreeexts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">head</span> <span class="o">=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">extfree</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">diIAGRead</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hbp</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">rcx</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">nextiag</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">hiagp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iag</span> <span class="o">*</span><span class="p">)</span> <span class="n">hbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
				<span class="n">hiagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span> <span class="o">=</span> <span class="n">iagp</span><span class="o">-&gt;</span><span class="n">iagnum</span><span class="p">;</span>
				<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreefwd</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
				<span class="n">iagp</span><span class="o">-&gt;</span><span class="n">extfreeback</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">write_metapage</span><span class="p">(</span><span class="n">hbp</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_agctl</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">extfree</span> <span class="o">=</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">iagp</span><span class="o">-&gt;</span><span class="n">iagnum</span><span class="p">);</span>
		<span class="p">}</span>

	      <span class="nl">nextiag:</span>
		<span class="n">write_metapage</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xnuminos</span> <span class="o">!=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_numinos</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">xnumfree</span> <span class="o">!=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_numfree</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jfs_error</span><span class="p">(</span><span class="n">ipimap</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
			  <span class="s">&quot;diExtendFs: numinos or numfree incorrect&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rcx</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	duplicateIXtree()</span>
<span class="cm"> *</span>
<span class="cm"> * serialization: IWRITE_LOCK held on entry/exit</span>
<span class="cm"> *</span>
<span class="cm"> * note: shadow page with regular inode (rel.2);</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">duplicateIXtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">s64</span> <span class="n">blkno</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">xlen</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span><span class="n">xaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_superblock</span> <span class="o">*</span><span class="n">j_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>

	<span class="cm">/* if AIT2 ipmap2 is bad, do not try to update it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mntflag</span> <span class="o">&amp;</span> <span class="n">JFS_BAD_SAIT</span><span class="p">)</span>	<span class="cm">/* s_flag */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ip</span> <span class="o">=</span> <span class="n">diReadSpecial</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">FILESYSTEM_I</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mntflag</span> <span class="o">|=</span> <span class="n">JFS_BAD_SAIT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readSuper</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">j_sb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jfs_superblock</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
		<span class="n">j_sb</span><span class="o">-&gt;</span><span class="n">s_flag</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">JFS_BAD_SAIT</span><span class="p">);</span>

		<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* start transaction */</span>
	<span class="n">tid</span> <span class="o">=</span> <span class="n">txBegin</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">COMMIT_FORCE</span><span class="p">);</span>
	<span class="cm">/* update the inode map addressing structure to point to it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xtInsert</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">xlen</span><span class="p">,</span> <span class="n">xaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">JFS_SBI</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mntflag</span> <span class="o">|=</span> <span class="n">JFS_BAD_SAIT</span><span class="p">;</span>
		<span class="n">txAbort</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="cm">/* update the inode map&#39;s inode to reflect the extension */</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">PSIZE</span><span class="p">;</span>
	<span class="n">inode_add_bytes</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">);</span>
	<span class="n">txCommit</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">,</span> <span class="n">COMMIT_FORCE</span><span class="p">);</span>
      <span class="nl">cleanup:</span>
	<span class="n">txEnd</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
	<span class="n">diFreeSpecial</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	copy_from_dinode()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	Copies inode info from disk inode to in-memory inode</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN VALUES:</span>
<span class="cm"> *	0	- success</span>
<span class="cm"> *	-ENOMEM	- insufficient memory</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_from_dinode</span><span class="p">(</span><span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span> <span class="n">dip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="o">*</span><span class="n">jfs_ip</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">fileset</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_fileset</span><span class="p">);</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">mode2</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_mode</span><span class="p">);</span>
	<span class="n">jfs_set_inode_flags</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_mode</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">umask</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mo">0777</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mo">0777</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">umask</span><span class="p">);</span>
		<span class="cm">/* For directories, add x permission if r is allowed by umask */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="mo">0400</span><span class="p">)</span>
				<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">|=</span> <span class="mo">0100</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="mo">0040</span><span class="p">)</span>
				<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">|=</span> <span class="mo">0010</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="mo">0004</span><span class="p">)</span>
				<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">|=</span> <span class="mo">0001</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">set_nlink</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_nlink</span><span class="p">));</span>

	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">saved_uid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_uid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">saved_uid</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">saved_gid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_gid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">saved_gid</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_size</span><span class="p">);</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_atime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">LBLK2PBLK</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_nblocks</span><span class="p">));</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_gen</span><span class="p">);</span>

	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">ixpxd</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_ixpxd</span><span class="p">;</span>	<span class="cm">/* in-memory pxd&#39;s are little-endian */</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">acl</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_acl</span><span class="p">;</span>	<span class="cm">/* as are dxd&#39;s */</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">ea</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_ea</span><span class="p">;</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_next_index</span><span class="p">);</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">otime</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_otime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">acltype</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_acltype</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_rdev</span><span class="p">);</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_rdev</span> <span class="o">=</span> <span class="n">new_decode_dev</span><span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_dirtable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_dirtable</span><span class="p">,</span> <span class="mi">384</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_xtroot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_xtroot</span><span class="p">,</span> <span class="mi">288</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">i_inline_ea</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_inlineea</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>

	<span class="cm">/* Zero the in-memory-only stuff */</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">cflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">btindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">btorder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">bxflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">blid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atlhead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">atltail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">xtlid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NAME:	copy_to_dinode()</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:	Copies inode info from in-memory inode to disk inode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">copy_to_dinode</span><span class="p">(</span><span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span> <span class="n">dip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_inode_info</span> <span class="o">*</span><span class="n">jfs_ip</span> <span class="o">=</span> <span class="n">JFS_IP</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">jfs_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">JFS_SBI</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_fileset</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">fileset</span><span class="p">);</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_inostamp</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">inostamp</span><span class="p">);</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_number</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_gen</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">);</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_size</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_nblocks</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">PBLK2LBLK</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">));</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_nlink</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_uid</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_uid</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">saved_uid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_gid</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_gid</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">saved_gid</span><span class="p">);</span>
	<span class="n">jfs_get_inode_flags</span><span class="p">(</span><span class="n">jfs_ip</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * mode2 is only needed for storing the higher order bits.</span>
<span class="cm">	 * Trust i_mode for the lower order ones</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">umask</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_mode</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">mode2</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">|</span>
					   <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="k">else</span> <span class="cm">/* Leave the original permissions alone */</span>
		<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_mode</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">mode2</span><span class="p">);</span>

	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_atime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_ixpxd</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">ixpxd</span><span class="p">;</span>	<span class="cm">/* in-memory pxd&#39;s are little-endian */</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_acl</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">acl</span><span class="p">;</span>	<span class="cm">/* as are dxd&#39;s */</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_ea</span> <span class="o">=</span> <span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">ea</span><span class="p">;</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_next_index</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">next_index</span><span class="p">);</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_otime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">otime</span><span class="p">);</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_otime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_acltype</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">acltype</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_rdev</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">jfs_ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
