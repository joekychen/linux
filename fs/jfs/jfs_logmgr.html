<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jfs › jfs_logmgr.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>jfs_logmgr.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   Copyright (C) International Business Machines Corp., 2000-2004</span>
<span class="cm"> *   Portions Copyright (C) Christoph Hellwig, 2001-2002</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software;  you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY;  without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> *   the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program;  if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>
<span class="cp">#ifndef	_H_JFS_LOGMGR</span>
<span class="cp">#define _H_JFS_LOGMGR</span>

<span class="cp">#include &quot;jfs_filsys.h&quot;</span>
<span class="cp">#include &quot;jfs_lock.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> *	log manager configuration parameters</span>
<span class="cm"> */</span>

<span class="cm">/* log page size */</span>
<span class="cp">#define	LOGPSIZE	4096</span>
<span class="cp">#define	L2LOGPSIZE	12</span>

<span class="cp">#define LOGPAGES	16	</span><span class="cm">/* Log pages per mounted file system */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *	log logical volume</span>
<span class="cm"> *</span>
<span class="cm"> * a log is used to make the commit operation on journalled</span>
<span class="cm"> * files within the same logical volume group atomic.</span>
<span class="cm"> * a log is implemented with a logical volume.</span>
<span class="cm"> * there is one log per logical volume group.</span>
<span class="cm"> *</span>
<span class="cm"> * block 0 of the log logical volume is not used (ipl etc).</span>
<span class="cm"> * block 1 contains a log &quot;superblock&quot; and is used by logFormat(),</span>
<span class="cm"> * lmLogInit(), lmLogShutdown(), and logRedo() to record status</span>
<span class="cm"> * of the log but is not otherwise used during normal processing.</span>
<span class="cm"> * blocks 2 - (N-1) are used to contain log records.</span>
<span class="cm"> *</span>
<span class="cm"> * when a volume group is varied-on-line, logRedo() must have</span>
<span class="cm"> * been executed before the file systems (logical volumes) in</span>
<span class="cm"> * the volume group can be mounted.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> *	log superblock (block 1 of logical volume)</span>
<span class="cm"> */</span>
<span class="cp">#define	LOGSUPER_B	1</span>
<span class="cp">#define	LOGSTART_B	2</span>

<span class="cp">#define	LOGMAGIC	0x87654321</span>
<span class="cp">#define	LOGVERSION	1</span>

<span class="cp">#define MAX_ACTIVE	128	</span><span class="cm">/* Max active file systems sharing log */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">logsuper</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">magic</span><span class="p">;</span>		<span class="cm">/* 4: log lv identifier */</span>
	<span class="n">__le32</span> <span class="n">version</span><span class="p">;</span>		<span class="cm">/* 4: version number */</span>
	<span class="n">__le32</span> <span class="n">serial</span><span class="p">;</span>		<span class="cm">/* 4: log open/mount counter */</span>
	<span class="n">__le32</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* 4: size in number of LOGPSIZE blocks */</span>
	<span class="n">__le32</span> <span class="n">bsize</span><span class="p">;</span>		<span class="cm">/* 4: logical block size in byte */</span>
	<span class="n">__le32</span> <span class="n">l2bsize</span><span class="p">;</span>		<span class="cm">/* 4: log2 of bsize */</span>

	<span class="n">__le32</span> <span class="n">flag</span><span class="p">;</span>		<span class="cm">/* 4: option */</span>
	<span class="n">__le32</span> <span class="n">state</span><span class="p">;</span>		<span class="cm">/* 4: state - see below */</span>

	<span class="n">__le32</span> <span class="n">end</span><span class="p">;</span>		<span class="cm">/* 4: addr of last log record set by logredo */</span>
	<span class="kt">char</span> <span class="n">uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>		<span class="cm">/* 16: 128-bit journal uuid */</span>
	<span class="kt">char</span> <span class="n">label</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>		<span class="cm">/* 16: journal label */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">active</span><span class="p">[</span><span class="n">MAX_ACTIVE</span><span class="p">];</span>	<span class="cm">/* 2048: active file systems list */</span>
<span class="p">};</span>

<span class="cp">#define NULL_UUID &quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;</span>

<span class="cm">/* log flag: commit option (see jfs_filsys.h) */</span>

<span class="cm">/* log state */</span>
<span class="cp">#define	LOGMOUNT	0	</span><span class="cm">/* log mounted by lmLogInit() */</span><span class="cp"></span>
<span class="cp">#define LOGREDONE	1	</span><span class="cm">/* log shutdown by lmLogShutdown().</span>
<span class="cm">				 * log redo completed by logredo().</span>
<span class="cm">				 */</span><span class="cp"></span>
<span class="cp">#define LOGWRAP		2	</span><span class="cm">/* log wrapped */</span><span class="cp"></span>
<span class="cp">#define LOGREADERR	3	</span><span class="cm">/* log read error detected in logredo() */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> *	log logical page</span>
<span class="cm"> *</span>
<span class="cm"> * (this comment should be rewritten !)</span>
<span class="cm"> * the header and trailer structures (h,t) will normally have</span>
<span class="cm"> * the same page and eor value.</span>
<span class="cm"> * An exception to this occurs when a complete page write is not</span>
<span class="cm"> * accomplished on a power failure. Since the hardware may &quot;split write&quot;</span>
<span class="cm"> * sectors in the page, any out of order sequence may occur during powerfail</span>
<span class="cm"> * and needs to be recognized during log replay.  The xor value is</span>
<span class="cm"> * an &quot;exclusive or&quot; of all log words in the page up to eor.  This</span>
<span class="cm"> * 32 bit eor is stored with the top 16 bits in the header and the</span>
<span class="cm"> * bottom 16 bits in the trailer.  logredo can easily recognize pages</span>
<span class="cm"> * that were not completed by reconstructing this eor and checking</span>
<span class="cm"> * the log page.</span>
<span class="cm"> *</span>
<span class="cm"> * Previous versions of the operating system did not allow split</span>
<span class="cm"> * writes and detected partially written records in logredo by</span>
<span class="cm"> * ordering the updates to the header, trailer, and the move of data</span>
<span class="cm"> * into the logdata area.  The order: (1) data is moved (2) header</span>
<span class="cm"> * is updated (3) trailer is updated.  In logredo, when the header</span>
<span class="cm"> * differed from the trailer, the header and trailer were reconciled</span>
<span class="cm"> * as follows: if h.page != t.page they were set to the smaller of</span>
<span class="cm"> * the two and h.eor and t.eor set to 8 (i.e. empty page). if (only)</span>
<span class="cm"> * h.eor != t.eor they were set to the smaller of their two values.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logpage</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>		<span class="cm">/* header */</span>
		<span class="n">__le32</span> <span class="n">page</span><span class="p">;</span>	<span class="cm">/* 4: log sequence page number */</span>
		<span class="n">__le16</span> <span class="n">rsrvd</span><span class="p">;</span>	<span class="cm">/* 2: */</span>
		<span class="n">__le16</span> <span class="n">eor</span><span class="p">;</span>	<span class="cm">/* 2: end-of-log offset of lasrt record write */</span>
	<span class="p">}</span> <span class="n">h</span><span class="p">;</span>

	<span class="n">__le32</span> <span class="n">data</span><span class="p">[</span><span class="n">LOGPSIZE</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">4</span><span class="p">];</span>	<span class="cm">/* log record area */</span>

	<span class="k">struct</span> <span class="p">{</span>		<span class="cm">/* trailer */</span>
		<span class="n">__le32</span> <span class="n">page</span><span class="p">;</span>	<span class="cm">/* 4: normally the same as h.page */</span>
		<span class="n">__le16</span> <span class="n">rsrvd</span><span class="p">;</span>	<span class="cm">/* 2: */</span>
		<span class="n">__le16</span> <span class="n">eor</span><span class="p">;</span>	<span class="cm">/* 2: normally the same as h.eor */</span>
	<span class="p">}</span> <span class="n">t</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define LOGPHDRSIZE	8	</span><span class="cm">/* log page header size */</span><span class="cp"></span>
<span class="cp">#define LOGPTLRSIZE	8	</span><span class="cm">/* log page trailer size */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> *	log record</span>
<span class="cm"> *</span>
<span class="cm"> * (this comment should be rewritten !)</span>
<span class="cm"> * jfs uses only &quot;after&quot; log records (only a single writer is allowed</span>
<span class="cm"> * in a page, pages are written to temporary paging space if</span>
<span class="cm"> * if they must be written to disk before commit, and i/o is</span>
<span class="cm"> * scheduled for modified pages to their home location after</span>
<span class="cm"> * the log records containing the after values and the commit</span>
<span class="cm"> * record is written to the log on disk, undo discards the copy</span>
<span class="cm"> * in main-memory.)</span>
<span class="cm"> *</span>
<span class="cm"> * a log record consists of a data area of variable length followed by</span>
<span class="cm"> * a descriptor of fixed size LOGRDSIZE bytes.</span>
<span class="cm"> * the data area is rounded up to an integral number of 4-bytes and</span>
<span class="cm"> * must be no longer than LOGPSIZE.</span>
<span class="cm"> * the descriptor is of size of multiple of 4-bytes and aligned on a</span>
<span class="cm"> * 4-byte boundary.</span>
<span class="cm"> * records are packed one after the other in the data area of log pages.</span>
<span class="cm"> * (sometimes a DUMMY record is inserted so that at least one record ends</span>
<span class="cm"> * on every page or the longest record is placed on at most two pages).</span>
<span class="cm"> * the field eor in page header/trailer points to the byte following</span>
<span class="cm"> * the last record on a page.</span>
<span class="cm"> */</span>

<span class="cm">/* log record types */</span>
<span class="cp">#define LOG_COMMIT		0x8000</span>
<span class="cp">#define LOG_SYNCPT		0x4000</span>
<span class="cp">#define LOG_MOUNT		0x2000</span>
<span class="cp">#define LOG_REDOPAGE		0x0800</span>
<span class="cp">#define LOG_NOREDOPAGE		0x0080</span>
<span class="cp">#define LOG_NOREDOINOEXT	0x0040</span>
<span class="cp">#define LOG_UPDATEMAP		0x0008</span>
<span class="cp">#define LOG_NOREDOFILE		0x0001</span>

<span class="cm">/* REDOPAGE/NOREDOPAGE log record data type */</span>
<span class="cp">#define	LOG_INODE		0x0001</span>
<span class="cp">#define	LOG_XTREE		0x0002</span>
<span class="cp">#define	LOG_DTREE		0x0004</span>
<span class="cp">#define	LOG_BTROOT		0x0010</span>
<span class="cp">#define	LOG_EA			0x0020</span>
<span class="cp">#define	LOG_ACL			0x0040</span>
<span class="cp">#define	LOG_DATA		0x0080</span>
<span class="cp">#define	LOG_NEW			0x0100</span>
<span class="cp">#define	LOG_EXTEND		0x0200</span>
<span class="cp">#define LOG_RELOCATE		0x0400</span>
<span class="cp">#define LOG_DIR_XTREE		0x0800	</span><span class="cm">/* Xtree is in directory inode */</span><span class="cp"></span>

<span class="cm">/* UPDATEMAP log record descriptor type */</span>
<span class="cp">#define	LOG_ALLOCXADLIST	0x0080</span>
<span class="cp">#define	LOG_ALLOCPXDLIST	0x0040</span>
<span class="cp">#define	LOG_ALLOCXAD		0x0020</span>
<span class="cp">#define	LOG_ALLOCPXD		0x0010</span>
<span class="cp">#define	LOG_FREEXADLIST		0x0008</span>
<span class="cp">#define	LOG_FREEPXDLIST		0x0004</span>
<span class="cp">#define	LOG_FREEXAD		0x0002</span>
<span class="cp">#define	LOG_FREEPXD		0x0001</span>


<span class="k">struct</span> <span class="n">lrd</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * type independent area</span>
<span class="cm">	 */</span>
	<span class="n">__le32</span> <span class="n">logtid</span><span class="p">;</span>		<span class="cm">/* 4: log transaction identifier */</span>
	<span class="n">__le32</span> <span class="n">backchain</span><span class="p">;</span>	<span class="cm">/* 4: ptr to prev record of same transaction */</span>
	<span class="n">__le16</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* 2: record type */</span>
	<span class="n">__le16</span> <span class="n">length</span><span class="p">;</span>		<span class="cm">/* 2: length of data in record (in byte) */</span>
	<span class="n">__le32</span> <span class="n">aggregate</span><span class="p">;</span>	<span class="cm">/* 4: file system lv/aggregate */</span>
	<span class="cm">/* (16) */</span>

	<span class="cm">/*</span>
<span class="cm">	 * type dependent area (20)</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 *	COMMIT: commit</span>
<span class="cm">		 *</span>
<span class="cm">		 * transaction commit: no type-dependent information;</span>
<span class="cm">		 */</span>

		<span class="cm">/*</span>
<span class="cm">		 *	REDOPAGE: after-image</span>
<span class="cm">		 *</span>
<span class="cm">		 * apply after-image;</span>
<span class="cm">		 *</span>
<span class="cm">		 * N.B. REDOPAGE, NOREDOPAGE, and UPDATEMAP must be same format;</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span> <span class="n">fileset</span><span class="p">;</span>	<span class="cm">/* 4: fileset number */</span>
			<span class="n">__le32</span> <span class="n">inode</span><span class="p">;</span>	<span class="cm">/* 4: inode number */</span>
			<span class="n">__le16</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* 2: REDOPAGE record type */</span>
			<span class="n">__le16</span> <span class="n">l2linesize</span><span class="p">;</span>	<span class="cm">/* 2: log2 of line size */</span>
			<span class="n">pxd_t</span> <span class="n">pxd</span><span class="p">;</span>	<span class="cm">/* 8: on-disk page pxd */</span>
		<span class="p">}</span> <span class="n">redopage</span><span class="p">;</span>	<span class="cm">/* (20) */</span>

		<span class="cm">/*</span>
<span class="cm">		 *	NOREDOPAGE: the page is freed</span>
<span class="cm">		 *</span>
<span class="cm">		 * do not apply after-image records which precede this record</span>
<span class="cm">		 * in the log with the same page block number to this page.</span>
<span class="cm">		 *</span>
<span class="cm">		 * N.B. REDOPAGE, NOREDOPAGE, and UPDATEMAP must be same format;</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span> <span class="n">fileset</span><span class="p">;</span>	<span class="cm">/* 4: fileset number */</span>
			<span class="n">__le32</span> <span class="n">inode</span><span class="p">;</span>	<span class="cm">/* 4: inode number */</span>
			<span class="n">__le16</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* 2: NOREDOPAGE record type */</span>
			<span class="n">__le16</span> <span class="n">rsrvd</span><span class="p">;</span>	<span class="cm">/* 2: reserved */</span>
			<span class="n">pxd_t</span> <span class="n">pxd</span><span class="p">;</span>	<span class="cm">/* 8: on-disk page pxd */</span>
		<span class="p">}</span> <span class="n">noredopage</span><span class="p">;</span>	<span class="cm">/* (20) */</span>

		<span class="cm">/*</span>
<span class="cm">		 *	UPDATEMAP: update block allocation map</span>
<span class="cm">		 *</span>
<span class="cm">		 * either in-line PXD,</span>
<span class="cm">		 * or     out-of-line  XADLIST;</span>
<span class="cm">		 *</span>
<span class="cm">		 * N.B. REDOPAGE, NOREDOPAGE, and UPDATEMAP must be same format;</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span> <span class="n">fileset</span><span class="p">;</span>	<span class="cm">/* 4: fileset number */</span>
			<span class="n">__le32</span> <span class="n">inode</span><span class="p">;</span>	<span class="cm">/* 4: inode number */</span>
			<span class="n">__le16</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* 2: UPDATEMAP record type */</span>
			<span class="n">__le16</span> <span class="n">nxd</span><span class="p">;</span>	<span class="cm">/* 2: number of extents */</span>
			<span class="n">pxd_t</span> <span class="n">pxd</span><span class="p">;</span>	<span class="cm">/* 8: pxd */</span>
		<span class="p">}</span> <span class="n">updatemap</span><span class="p">;</span>	<span class="cm">/* (20) */</span>

		<span class="cm">/*</span>
<span class="cm">		 *	NOREDOINOEXT: the inode extent is freed</span>
<span class="cm">		 *</span>
<span class="cm">		 * do not apply after-image records which precede this</span>
<span class="cm">		 * record in the log with the any of the 4 page block</span>
<span class="cm">		 * numbers in this inode extent.</span>
<span class="cm">		 *</span>
<span class="cm">		 * NOTE: The fileset and pxd fields MUST remain in</span>
<span class="cm">		 *       the same fields in the REDOPAGE record format.</span>
<span class="cm">		 *</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span> <span class="n">fileset</span><span class="p">;</span>	<span class="cm">/* 4: fileset number */</span>
			<span class="n">__le32</span> <span class="n">iagnum</span><span class="p">;</span>	<span class="cm">/* 4: IAG number     */</span>
			<span class="n">__le32</span> <span class="n">inoext_idx</span><span class="p">;</span>	<span class="cm">/* 4: inode extent index */</span>
			<span class="n">pxd_t</span> <span class="n">pxd</span><span class="p">;</span>	<span class="cm">/* 8: on-disk page pxd */</span>
		<span class="p">}</span> <span class="n">noredoinoext</span><span class="p">;</span>	<span class="cm">/* (20) */</span>

		<span class="cm">/*</span>
<span class="cm">		 *	SYNCPT: log sync point</span>
<span class="cm">		 *</span>
<span class="cm">		 * replay log up to syncpt address specified;</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span> <span class="n">sync</span><span class="p">;</span>	<span class="cm">/* 4: syncpt address (0 = here) */</span>
		<span class="p">}</span> <span class="n">syncpt</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	MOUNT: file system mount</span>
<span class="cm">		 *</span>
<span class="cm">		 * file system mount: no type-dependent information;</span>
<span class="cm">		 */</span>

		<span class="cm">/*</span>
<span class="cm">		 *	? FREEXTENT: free specified extent(s)</span>
<span class="cm">		 *</span>
<span class="cm">		 * free specified extent(s) from block allocation map</span>
<span class="cm">		 * N.B.: nextents should be length of data/sizeof(xad_t)</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* 4: FREEXTENT record type */</span>
			<span class="n">__le32</span> <span class="n">nextent</span><span class="p">;</span>	<span class="cm">/* 4: number of extents */</span>

			<span class="cm">/* data: PXD or XAD list */</span>
		<span class="p">}</span> <span class="n">freextent</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	? NOREDOFILE: this file is freed</span>
<span class="cm">		 *</span>
<span class="cm">		 * do not apply records which precede this record in the log</span>
<span class="cm">		 * with the same inode number.</span>
<span class="cm">		 *</span>
<span class="cm">		 * NOREDOFILE must be the first to be written at commit</span>
<span class="cm">		 * (last to be read in logredo()) - it prevents</span>
<span class="cm">		 * replay of preceding updates of all preceding generations</span>
<span class="cm">		 * of the inumber esp. the on-disk inode itself.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span> <span class="n">fileset</span><span class="p">;</span>	<span class="cm">/* 4: fileset number */</span>
			<span class="n">__le32</span> <span class="n">inode</span><span class="p">;</span>	<span class="cm">/* 4: inode number */</span>
		<span class="p">}</span> <span class="n">noredofile</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	? NEWPAGE:</span>
<span class="cm">		 *</span>
<span class="cm">		 * metadata type dependent</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span> <span class="n">fileset</span><span class="p">;</span>	<span class="cm">/* 4: fileset number */</span>
			<span class="n">__le32</span> <span class="n">inode</span><span class="p">;</span>	<span class="cm">/* 4: inode number */</span>
			<span class="n">__le32</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* 4: NEWPAGE record type */</span>
			<span class="n">pxd_t</span> <span class="n">pxd</span><span class="p">;</span>	<span class="cm">/* 8: on-disk page pxd */</span>
		<span class="p">}</span> <span class="n">newpage</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	? DUMMY: filler</span>
<span class="cm">		 *</span>
<span class="cm">		 * no type-dependent information</span>
<span class="cm">		 */</span>
	<span class="p">}</span> <span class="n">log</span><span class="p">;</span>
<span class="p">};</span>					<span class="cm">/* (36) */</span>

<span class="cp">#define	LOGRDSIZE	(sizeof(struct lrd))</span>

<span class="cm">/*</span>
<span class="cm"> *	line vector descriptor</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lvd</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> *	log logical volume</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">jfs_log</span> <span class="p">{</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">sb_list</span><span class="p">;</span><span class="cm">/*  This is used to sync metadata</span>
<span class="cm">				 *    before writing syncpt.</span>
<span class="cm">				 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">journal_list</span><span class="p">;</span> <span class="cm">/* Global list */</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span> <span class="cm">/* 4: log lv pointer */</span>
	<span class="kt">int</span> <span class="n">serial</span><span class="p">;</span>		<span class="cm">/* 4: log mount serial number */</span>

	<span class="n">s64</span> <span class="n">base</span><span class="p">;</span>		<span class="cm">/* @8: log extent address (inline log ) */</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* 4: log size in log page (in page) */</span>
	<span class="kt">int</span> <span class="n">l2bsize</span><span class="p">;</span>		<span class="cm">/* 4: log2 of bsize */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">;</span>	<span class="cm">/* 4: flag */</span>

	<span class="k">struct</span> <span class="n">lbuf</span> <span class="o">*</span><span class="n">lbuf_free</span><span class="p">;</span>	<span class="cm">/* 4: free lbufs */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">free_wait</span><span class="p">;</span>	<span class="cm">/* 4: */</span>

	<span class="cm">/* log write */</span>
	<span class="kt">int</span> <span class="n">logtid</span><span class="p">;</span>		<span class="cm">/* 4: log tid */</span>
	<span class="kt">int</span> <span class="n">page</span><span class="p">;</span>		<span class="cm">/* 4: page number of eol page */</span>
	<span class="kt">int</span> <span class="n">eor</span><span class="p">;</span>		<span class="cm">/* 4: eor of last record in eol page */</span>
	<span class="k">struct</span> <span class="n">lbuf</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>	<span class="cm">/* 4: current log page buffer */</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">loglock</span><span class="p">;</span>	<span class="cm">/* 4: log write serialization lock */</span>

	<span class="cm">/* syncpt */</span>
	<span class="kt">int</span> <span class="n">nextsync</span><span class="p">;</span>		<span class="cm">/* 4: bytes to write before next syncpt */</span>
	<span class="kt">int</span> <span class="n">active</span><span class="p">;</span>		<span class="cm">/* 4: */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">syncwait</span><span class="p">;</span>	<span class="cm">/* 4: */</span>

	<span class="cm">/* commit */</span>
	<span class="n">uint</span> <span class="n">cflag</span><span class="p">;</span>		<span class="cm">/* 4: */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cqueue</span><span class="p">;</span> <span class="cm">/* FIFO commit queue */</span>
	<span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span><span class="n">flush_tblk</span><span class="p">;</span> <span class="cm">/* tblk we&#39;re waiting on for flush */</span>
	<span class="kt">int</span> <span class="n">gcrtc</span><span class="p">;</span>		<span class="cm">/* 4: GC_READY transaction count */</span>
	<span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span><span class="n">gclrt</span><span class="p">;</span>	<span class="cm">/* 4: latest GC_READY transaction */</span>
	<span class="n">spinlock_t</span> <span class="n">gclock</span><span class="p">;</span>	<span class="cm">/* 4: group commit lock */</span>
	<span class="kt">int</span> <span class="n">logsize</span><span class="p">;</span>		<span class="cm">/* 4: log data area size in byte */</span>
	<span class="kt">int</span> <span class="n">lsn</span><span class="p">;</span>		<span class="cm">/* 4: end-of-log */</span>
	<span class="kt">int</span> <span class="n">clsn</span><span class="p">;</span>		<span class="cm">/* 4: clsn */</span>
	<span class="kt">int</span> <span class="n">syncpt</span><span class="p">;</span>		<span class="cm">/* 4: addr of last syncpt record */</span>
	<span class="kt">int</span> <span class="n">sync</span><span class="p">;</span>		<span class="cm">/* 4: addr from last logsync() */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">synclist</span><span class="p">;</span>	<span class="cm">/* 8: logsynclist anchor */</span>
	<span class="n">spinlock_t</span> <span class="n">synclock</span><span class="p">;</span>	<span class="cm">/* 4: synclist lock */</span>
	<span class="k">struct</span> <span class="n">lbuf</span> <span class="o">*</span><span class="n">wqueue</span><span class="p">;</span>	<span class="cm">/* 4: log pageout queue */</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>		<span class="cm">/* 4: count */</span>
	<span class="kt">char</span> <span class="n">uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>		<span class="cm">/* 16: 128-bit uuid of log device */</span>

	<span class="kt">int</span> <span class="n">no_integrity</span><span class="p">;</span>	<span class="cm">/* 3: flag to disable journaling to disk */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Log flag</span>
<span class="cm"> */</span>
<span class="cp">#define log_INLINELOG	1</span>
<span class="cp">#define log_SYNCBARRIER	2</span>
<span class="cp">#define log_QUIESCE	3</span>
<span class="cp">#define log_FLUSH	4</span>

<span class="cm">/*</span>
<span class="cm"> * group commit flag</span>
<span class="cm"> */</span>
<span class="cm">/* jfs_log */</span>
<span class="cp">#define logGC_PAGEOUT	0x00000001</span>

<span class="cm">/* tblock/lbuf */</span>
<span class="cp">#define tblkGC_QUEUE		0x0001</span>
<span class="cp">#define tblkGC_READY		0x0002</span>
<span class="cp">#define tblkGC_COMMIT		0x0004</span>
<span class="cp">#define tblkGC_COMMITTED	0x0008</span>
<span class="cp">#define tblkGC_EOP		0x0010</span>
<span class="cp">#define tblkGC_FREE		0x0020</span>
<span class="cp">#define tblkGC_LEADER		0x0040</span>
<span class="cp">#define tblkGC_ERROR		0x0080</span>
<span class="cp">#define tblkGC_LAZY		0x0100	</span><span class="c1">// D230860</span>
<span class="cp">#define tblkGC_UNLOCKED		0x0200	</span><span class="c1">// D230860</span>

<span class="cm">/*</span>
<span class="cm"> *		log cache buffer header</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lbuf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">l_log</span><span class="p">;</span>	<span class="cm">/* 4: log associated with buffer */</span>

	<span class="cm">/*</span>
<span class="cm">	 * data buffer base area</span>
<span class="cm">	 */</span>
	<span class="n">uint</span> <span class="n">l_flag</span><span class="p">;</span>		<span class="cm">/* 4: pageout control flags */</span>

	<span class="k">struct</span> <span class="n">lbuf</span> <span class="o">*</span><span class="n">l_wqnext</span><span class="p">;</span>	<span class="cm">/* 4: write queue link */</span>
	<span class="k">struct</span> <span class="n">lbuf</span> <span class="o">*</span><span class="n">l_freelist</span><span class="p">;</span>	<span class="cm">/* 4: freelistlink */</span>

	<span class="kt">int</span> <span class="n">l_pn</span><span class="p">;</span>		<span class="cm">/* 4: log page number */</span>
	<span class="kt">int</span> <span class="n">l_eor</span><span class="p">;</span>		<span class="cm">/* 4: log record eor */</span>
	<span class="kt">int</span> <span class="n">l_ceor</span><span class="p">;</span>		<span class="cm">/* 4: committed log record eor */</span>

	<span class="n">s64</span> <span class="n">l_blkno</span><span class="p">;</span>		<span class="cm">/* 8: log page block number */</span>
	<span class="n">caddr_t</span> <span class="n">l_ldata</span><span class="p">;</span>	<span class="cm">/* 4: data page */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">l_page</span><span class="p">;</span>	<span class="cm">/* The page itself */</span>
	<span class="n">uint</span> <span class="n">l_offset</span><span class="p">;</span>		<span class="cm">/* Offset of l_ldata within the page */</span>

	<span class="n">wait_queue_head_t</span> <span class="n">l_ioevent</span><span class="p">;</span>	<span class="cm">/* 4: i/o done event */</span>
<span class="p">};</span>

<span class="cm">/* Reuse l_freelist for redrive list */</span>
<span class="cp">#define l_redrive_next l_freelist</span>

<span class="cm">/*</span>
<span class="cm"> *	logsynclist block</span>
<span class="cm"> *</span>
<span class="cm"> * common logsyncblk prefix for jbuf_t and tblock</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logsyncblk</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">xflag</span><span class="p">;</span>		<span class="cm">/* flags */</span>
	<span class="n">u16</span> <span class="n">flag</span><span class="p">;</span>		<span class="cm">/* only meaninful in tblock */</span>
	<span class="n">lid_t</span> <span class="n">lid</span><span class="p">;</span>		<span class="cm">/* lock id */</span>
	<span class="n">s32</span> <span class="n">lsn</span><span class="p">;</span>		<span class="cm">/* log sequence number */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">synclist</span><span class="p">;</span>	<span class="cm">/* log sync list link */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	logsynclist serialization (per log)</span>
<span class="cm"> */</span>

<span class="cp">#define LOGSYNC_LOCK_INIT(log) spin_lock_init(&amp;(log)-&gt;synclock)</span>
<span class="cp">#define LOGSYNC_LOCK(log, flags) spin_lock_irqsave(&amp;(log)-&gt;synclock, flags)</span>
<span class="cp">#define LOGSYNC_UNLOCK(log, flags) \</span>
<span class="cp">	spin_unlock_irqrestore(&amp;(log)-&gt;synclock, flags)</span>

<span class="cm">/* compute the difference in bytes of lsn from sync point */</span>
<span class="cp">#define logdiff(diff, lsn, log)\</span>
<span class="cp">{\</span>
<span class="cp">	diff = (lsn) - (log)-&gt;syncpt;\</span>
<span class="cp">	if (diff &lt; 0)\</span>
<span class="cp">		diff += (log)-&gt;logsize;\</span>
<span class="cp">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">lmLogOpen</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">lmLogClose</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">lmLogShutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">lmLogInit</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">lmLogFormat</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">s64</span> <span class="n">logAddress</span><span class="p">,</span> <span class="kt">int</span> <span class="n">logSize</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">lmGroupCommit</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tblock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">jfsIOWait</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">jfs_flush_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span> <span class="n">log</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">jfs_syncpt</span><span class="p">(</span><span class="k">struct</span> <span class="n">jfs_log</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hard_sync</span><span class="p">);</span>

<span class="cp">#endif				</span><span class="cm">/* _H_JFS_LOGMGR */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
