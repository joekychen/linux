<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › hfs › hfs_fs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>hfs_fs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/hfs/hfs_fs.h</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995-1997  Paul H. Hargrove</span>
<span class="cm"> * (C) 2003 Ardis Technologies &lt;roman@ardistech.com&gt;</span>
<span class="cm"> * This file may be distributed under the terms of the GNU General Public License.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_HFS_FS_H</span>
<span class="cp">#define _LINUX_HFS_FS_H</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &quot;hfs.h&quot;</span>

<span class="cp">#define DBG_BNODE_REFS	0x00000001</span>
<span class="cp">#define DBG_BNODE_MOD	0x00000002</span>
<span class="cp">#define DBG_CAT_MOD	0x00000004</span>
<span class="cp">#define DBG_INODE	0x00000008</span>
<span class="cp">#define DBG_SUPER	0x00000010</span>
<span class="cp">#define DBG_EXTENT	0x00000020</span>
<span class="cp">#define DBG_BITMAP	0x00000040</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><h1>define DBG<em>MASK    (DBG</em>EXTENT|DBG<em>INODE|DBG</em>BNODE<em>MOD|DBG</em>CAT<em>MOD|DBG</em>BITMAP)</h1>

<h1>define DBG<em>MASK    (DBG</em>BNODE<em>MOD|DBG</em>CAT<em>MOD|DBG</em>INODE)</h1>

<h1>define DBG<em>MASK    (DBG</em>CAT<em>MOD|DBG</em>BNODE<em>REFS|DBG</em>INODE|DBG_EXTENT)</h1></td><td class="code"><div class="highlight"><pre><span class="cp">#define DBG_MASK	(0)</span>

<span class="cp">#define dprint(flg, fmt, args...) \</span>
<span class="cp">	if (flg &amp; DBG_MASK) printk(fmt , ## args)</span>

<span class="cm">/*</span>
<span class="cm"> * struct hfs_inode_info</span>
<span class="cm"> *</span>
<span class="cm"> * The HFS-specific part of a Linux (struct inode)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hfs_inode_info</span> <span class="p">{</span>
	<span class="n">atomic_t</span> <span class="n">opencnt</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* to deal with localtime ugliness */</span>
	<span class="kt">int</span> <span class="n">tz_secondswest</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hfs_cat_key</span> <span class="n">cat_key</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">open_dir_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">rsrc_inode</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">extents_lock</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">alloc_blocks</span><span class="p">,</span> <span class="n">clump_blocks</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">fs_blocks</span><span class="p">;</span>
	<span class="cm">/* Allocation extents from catlog record or volume header */</span>
	<span class="n">hfs_extent_rec</span> <span class="n">first_extents</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">first_blocks</span><span class="p">;</span>
	<span class="n">hfs_extent_rec</span> <span class="n">cached_extents</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cached_start</span><span class="p">,</span> <span class="n">cached_blocks</span><span class="p">;</span>

	<span class="n">loff_t</span> <span class="n">phys_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define HFS_FLG_RSRC		0x0001</span>
<span class="cp">#define HFS_FLG_EXT_DIRTY	0x0002</span>
<span class="cp">#define HFS_FLG_EXT_NEW		0x0004</span>

<span class="cp">#define HFS_IS_RSRC(inode)	(HFS_I(inode)-&gt;flags &amp; HFS_FLG_RSRC)</span>

<span class="cm">/*</span>
<span class="cm"> * struct hfs_sb_info</span>
<span class="cm"> *</span>
<span class="cm"> * The HFS-specific part of a Linux (struct super_block)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hfs_sb_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">mdb_bh</span><span class="p">;</span>		<span class="cm">/* The hfs_buffer</span>
<span class="cm">						   holding the real</span>
<span class="cm">						   superblock (aka VIB</span>
<span class="cm">						   or MDB) */</span>
	<span class="k">struct</span> <span class="n">hfs_mdb</span> <span class="o">*</span><span class="n">mdb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">alt_mdb_bh</span><span class="p">;</span>		<span class="cm">/* The hfs_buffer holding</span>
<span class="cm">						   the alternate superblock */</span>
	<span class="k">struct</span> <span class="n">hfs_mdb</span> <span class="o">*</span><span class="n">alt_mdb</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">;</span>				<span class="cm">/* The page holding the</span>
<span class="cm">						   allocation bitmap */</span>
	<span class="k">struct</span> <span class="n">hfs_btree</span> <span class="o">*</span><span class="n">ext_tree</span><span class="p">;</span>			<span class="cm">/* Information about</span>
<span class="cm">						   the extents b-tree */</span>
	<span class="k">struct</span> <span class="n">hfs_btree</span> <span class="o">*</span><span class="n">cat_tree</span><span class="p">;</span>			<span class="cm">/* Information about</span>
<span class="cm">						   the catalog b-tree */</span>
	<span class="n">u32</span> <span class="n">file_count</span><span class="p">;</span>				<span class="cm">/* The number of</span>
<span class="cm">						   regular files in</span>
<span class="cm">						   the filesystem */</span>
	<span class="n">u32</span> <span class="n">folder_count</span><span class="p">;</span>			<span class="cm">/* The number of</span>
<span class="cm">						   directories in the</span>
<span class="cm">						   filesystem */</span>
	<span class="n">u32</span> <span class="n">next_id</span><span class="p">;</span>				<span class="cm">/* The next available</span>
<span class="cm">						   file id number */</span>
	<span class="n">u32</span> <span class="n">clumpablks</span><span class="p">;</span>				<span class="cm">/* The number of allocation</span>
<span class="cm">						   blocks to try to add when</span>
<span class="cm">						   extending a file */</span>
	<span class="n">u32</span> <span class="n">fs_start</span><span class="p">;</span>				<span class="cm">/* The first 512-byte</span>
<span class="cm">						   block represented</span>
<span class="cm">						   in the bitmap */</span>
	<span class="n">u32</span> <span class="n">part_start</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">root_files</span><span class="p">;</span>				<span class="cm">/* The number of</span>
<span class="cm">						   regular</span>
<span class="cm">						   (non-directory)</span>
<span class="cm">						   files in the root</span>
<span class="cm">						   directory */</span>
	<span class="n">u16</span> <span class="n">root_dirs</span><span class="p">;</span>				<span class="cm">/* The number of</span>
<span class="cm">						   directories in the</span>
<span class="cm">						   root directory */</span>
	<span class="n">u16</span> <span class="n">fs_ablocks</span><span class="p">;</span>				<span class="cm">/* The number of</span>
<span class="cm">						   allocation blocks</span>
<span class="cm">						   in the filesystem */</span>
	<span class="n">u16</span> <span class="n">free_ablocks</span><span class="p">;</span>			<span class="cm">/* the number of unused</span>
<span class="cm">						   allocation blocks</span>
<span class="cm">						   in the filesystem */</span>
	<span class="n">u32</span> <span class="n">alloc_blksz</span><span class="p">;</span>			<span class="cm">/* The size of an</span>
<span class="cm">						   &quot;allocation block&quot; */</span>
	<span class="kt">int</span> <span class="n">s_quiet</span><span class="p">;</span>				<span class="cm">/* Silent failure when</span>
<span class="cm">						   changing owner or mode? */</span>
	<span class="n">__be32</span> <span class="n">s_type</span><span class="p">;</span>				<span class="cm">/* Type for new files */</span>
	<span class="n">__be32</span> <span class="n">s_creator</span><span class="p">;</span>			<span class="cm">/* Creator for new files */</span>
	<span class="n">umode_t</span> <span class="n">s_file_umask</span><span class="p">;</span>			<span class="cm">/* The umask applied to the</span>
<span class="cm">						   permissions on all files */</span>
	<span class="n">umode_t</span> <span class="n">s_dir_umask</span><span class="p">;</span>			<span class="cm">/* The umask applied to the</span>
<span class="cm">						   permissions on all dirs */</span>
	<span class="n">uid_t</span> <span class="n">s_uid</span><span class="p">;</span>				<span class="cm">/* The uid of all files */</span>
	<span class="n">gid_t</span> <span class="n">s_gid</span><span class="p">;</span>				<span class="cm">/* The gid of all files */</span>

	<span class="kt">int</span> <span class="n">session</span><span class="p">,</span> <span class="n">part</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">nls_table</span> <span class="o">*</span><span class="n">nls_io</span><span class="p">,</span> <span class="o">*</span><span class="n">nls_disk</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">bitmap_lock</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">blockoffset</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">fs_div</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define HFS_FLG_BITMAP_DIRTY	0</span>
<span class="cp">#define HFS_FLG_MDB_DIRTY	1</span>
<span class="cp">#define HFS_FLG_ALT_MDB_DIRTY	2</span>

<span class="cm">/* bitmap.c */</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">hfs_vbm_search_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_clear_vbm_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>

<span class="cm">/* catalog.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_cat_keycmp</span><span class="p">(</span><span class="k">const</span> <span class="n">btree_key</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">btree_key</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">hfs_find_data</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_cat_find_brec</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hfs_find_data</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_cat_create</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_cat_delete</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_cat_move</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hfs_cat_build_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="n">btree_key</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* dir.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">hfs_dir_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">hfs_dir_inode_operations</span><span class="p">;</span>

<span class="cm">/* extent.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_ext_keycmp</span><span class="p">(</span><span class="k">const</span> <span class="n">btree_key</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">btree_key</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_free_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hfs_cat_file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hfs_ext_write_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_extend_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hfs_file_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_get_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/* inode.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">hfs_aops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">hfs_btree_aops</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">hfs_new_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hfs_inode_write_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hfs_extent</span> <span class="o">*</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_inode_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hfs_inode_read_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hfs_extent</span> <span class="o">*</span><span class="n">ext</span><span class="p">,</span>
			<span class="n">__be32</span> <span class="n">log_size</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">phys_size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">clump_size</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">hfs_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hfs_cat_key</span> <span class="o">*</span><span class="p">,</span> <span class="n">hfs_cat_rec</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hfs_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hfs_delete_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* attr.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">hfs_getxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">hfs_listxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/* mdb.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_mdb_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hfs_mdb_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hfs_mdb_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hfs_mdb_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* part_tbl.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_part_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* string.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">hfs_dentry_operations</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_hash_dentry</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_strcmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_compare_dentry</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">pinode</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/* trans.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hfs_asc2mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hfs_name</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hfs_mac2asc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">hfs_name</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="n">sys_tz</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * There are two time systems.  Both are based on seconds since</span>
<span class="cm"> * a particular time/date.</span>
<span class="cm"> *	Unix:	unsigned lil-endian since 00:00 GMT, Jan. 1, 1970</span>
<span class="cm"> *	mac:	unsigned big-endian since 00:00 GMT, Jan. 1, 1904</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define __hfs_u_to_mtime(sec)	cpu_to_be32(sec + 2082844800U - sys_tz.tz_minuteswest * 60)</span>
<span class="cp">#define __hfs_m_to_utime(sec)	(be32_to_cpu(sec) - 2082844800U  + sys_tz.tz_minuteswest * 60)</span>

<span class="cp">#define HFS_I(inode)	(list_entry(inode, struct hfs_inode_info, vfs_inode))</span>
<span class="cp">#define HFS_SB(sb)	((struct hfs_sb_info *)(sb)-&gt;s_fs_info)</span>

<span class="cp">#define hfs_m_to_utime(time)	(struct timespec){ .tv_sec = __hfs_m_to_utime(time) }</span>
<span class="cp">#define hfs_u_to_mtime(time)	__hfs_u_to_mtime((time).tv_sec)</span>
<span class="cp">#define hfs_mtime()		__hfs_u_to_mtime(get_seconds())</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">hfs_mdb_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hfs_bitmap_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">HFS_FLG_BITMAP_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">HFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dirt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define sb_bread512(sb, sec, data) ({			\</span>
<span class="cp">	struct buffer_head *__bh;			\</span>
<span class="cp">	sector_t __block;				\</span>
<span class="cp">	loff_t __start;					\</span>
<span class="cp">	int __offset;					\</span>
<span class="cp">							\</span>
<span class="cp">	__start = (loff_t)(sec) &lt;&lt; HFS_SECTOR_SIZE_BITS;\</span>
<span class="cp">	__block = __start &gt;&gt; (sb)-&gt;s_blocksize_bits;	\</span>
<span class="cp">	__offset = __start &amp; ((sb)-&gt;s_blocksize - 1);	\</span>
<span class="cp">	__bh = sb_bread((sb), __block);			\</span>
<span class="cp">	if (likely(__bh != NULL))			\</span>
<span class="cp">		data = (void *)(__bh-&gt;b_data + __offset);\</span>
<span class="cp">	else						\</span>
<span class="cp">		data = NULL;				\</span>
<span class="cp">	__bh;						\</span>
<span class="cp">})</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
