<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ioctl.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>ioctl.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/ioctl.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/falloc.h&gt;</span>

<span class="cp">#include &lt;asm/ioctls.h&gt;</span>

<span class="cm">/* So that the fiemap access checks can&#39;t overflow on 32 bit machines. */</span>
<span class="cp">#define FIEMAP_MAX_EXTENTS	(UINT_MAX / sizeof(struct fiemap_extent))</span>

<span class="cm">/**</span>
<span class="cm"> * vfs_ioctl - call filesystem specific ioctl methods</span>
<span class="cm"> * @filp:	open file to invoke ioctl method on</span>
<span class="cm"> * @cmd:	ioctl command to execute</span>
<span class="cm"> * @arg:	command-specific argument for ioctl</span>
<span class="cm"> *</span>
<span class="cm"> * Invokes filesystem specific -&gt;unlocked_ioctl, if one exists; otherwise</span>
<span class="cm"> * returns -ENOTTY.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -errno on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">vfs_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">unlocked_ioctl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">unlocked_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioctl_fibmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="n">block</span><span class="p">;</span>

	<span class="cm">/* do we support this mess? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RAWIO</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fiemap_fill_next_extent - Fiemap helper function</span>
<span class="cm"> * @fieinfo:	Fiemap context passed into -&gt;fiemap</span>
<span class="cm"> * @logical:	Extent logical start offset, in bytes</span>
<span class="cm"> * @phys:	Extent physical start offset, in bytes</span>
<span class="cm"> * @len:	Extent length, in bytes</span>
<span class="cm"> * @flags:	FIEMAP_EXTENT flags that describe this extent</span>
<span class="cm"> *</span>
<span class="cm"> * Called from file system -&gt;fiemap callback. Will populate extent</span>
<span class="cm"> * info as passed in via arguments and copy to user memory. On</span>
<span class="cm"> * success, extent count on fieinfo is incremented.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -errno on error, 1 if this was the last</span>
<span class="cm"> * extent that will fit in user array.</span>
<span class="cm"> */</span>
<span class="cp">#define SET_UNKNOWN_FLAGS	(FIEMAP_EXTENT_DELALLOC)</span>
<span class="cp">#define SET_NO_UNMOUNTED_IO_FLAGS	(FIEMAP_EXTENT_DATA_ENCRYPTED)</span>
<span class="cp">#define SET_NOT_ALIGNED_FLAGS	(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)</span>
<span class="kt">int</span> <span class="nf">fiemap_fill_next_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">u64</span> <span class="n">logical</span><span class="p">,</span>
			    <span class="n">u64</span> <span class="n">phys</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fiemap_extent</span> <span class="n">extent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fiemap_extent</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_extents_start</span><span class="p">;</span>

	<span class="cm">/* only count the extents */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_extents_max</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_extents_mapped</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FIEMAP_EXTENT_LAST</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_extents_mapped</span> <span class="o">&gt;=</span> <span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_extents_max</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SET_UNKNOWN_FLAGS</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FIEMAP_EXTENT_UNKNOWN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SET_NO_UNMOUNTED_IO_FLAGS</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FIEMAP_EXTENT_ENCODED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SET_NOT_ALIGNED_FLAGS</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FIEMAP_EXTENT_NOT_ALIGNED</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extent</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">extent</span><span class="p">));</span>
	<span class="n">extent</span><span class="p">.</span><span class="n">fe_logical</span> <span class="o">=</span> <span class="n">logical</span><span class="p">;</span>
	<span class="n">extent</span><span class="p">.</span><span class="n">fe_physical</span> <span class="o">=</span> <span class="n">phys</span><span class="p">;</span>
	<span class="n">extent</span><span class="p">.</span><span class="n">fe_length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">extent</span><span class="p">.</span><span class="n">fe_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dest</span> <span class="o">+=</span> <span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_extents_mapped</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extent</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">extent</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_extents_mapped</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_extents_mapped</span> <span class="o">==</span> <span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_extents_max</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FIEMAP_EXTENT_LAST</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fiemap_fill_next_extent</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fiemap_check_flags - check validity of requested flags for fiemap</span>
<span class="cm"> * @fieinfo:	Fiemap context passed into -&gt;fiemap</span>
<span class="cm"> * @fs_flags:	Set of fiemap flags that the file system understands</span>
<span class="cm"> *</span>
<span class="cm"> * Called from file system -&gt;fiemap callback. This will compute the</span>
<span class="cm"> * intersection of valid fiemap flags and those that the fs supports. That</span>
<span class="cm"> * value is then compared against the user supplied flags. In case of bad user</span>
<span class="cm"> * flags, the invalid values will be written into the fieinfo structure, and</span>
<span class="cm"> * -EBADR is returned, which tells ioctl_fiemap() to return those values to</span>
<span class="cm"> * userspace. For this reason, a return code of -EBADR should be preserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -EBADR on bad flags.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fiemap_check_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fs_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">incompat_flags</span><span class="p">;</span>

	<span class="n">incompat_flags</span> <span class="o">=</span> <span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">FIEMAP_FLAGS_COMPAT</span> <span class="o">&amp;</span> <span class="n">fs_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">incompat_flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_flags</span> <span class="o">=</span> <span class="n">incompat_flags</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fiemap_check_flags</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fiemap_check_ranges</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			       <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">new_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">maxbytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span><span class="p">;</span>

	<span class="o">*</span><span class="n">new_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">maxbytes</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Shrink request scope to what the fs can actually handle.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">maxbytes</span> <span class="o">||</span> <span class="p">(</span><span class="n">maxbytes</span> <span class="o">-</span> <span class="n">len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span>
		<span class="o">*</span><span class="n">new_len</span> <span class="o">=</span> <span class="n">maxbytes</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioctl_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fiemap</span> <span class="n">fiemap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fiemap</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ufiemap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fiemap</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="n">fieinfo</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">fiemap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fiemap</span><span class="p">,</span> <span class="n">ufiemap</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fiemap</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fiemap</span><span class="p">.</span><span class="n">fm_extent_count</span> <span class="o">&gt;</span> <span class="n">FIEMAP_MAX_EXTENTS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">fiemap_check_ranges</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">fiemap</span><span class="p">.</span><span class="n">fm_start</span><span class="p">,</span> <span class="n">fiemap</span><span class="p">.</span><span class="n">fm_length</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">fieinfo</span><span class="p">.</span><span class="n">fi_flags</span> <span class="o">=</span> <span class="n">fiemap</span><span class="p">.</span><span class="n">fm_flags</span><span class="p">;</span>
	<span class="n">fieinfo</span><span class="p">.</span><span class="n">fi_extents_max</span> <span class="o">=</span> <span class="n">fiemap</span><span class="p">.</span><span class="n">fm_extent_count</span><span class="p">;</span>
	<span class="n">fieinfo</span><span class="p">.</span><span class="n">fi_extents_start</span> <span class="o">=</span> <span class="n">ufiemap</span><span class="o">-&gt;</span><span class="n">fm_extents</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fiemap</span><span class="p">.</span><span class="n">fm_extent_count</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">fieinfo</span><span class="p">.</span><span class="n">fi_extents_start</span><span class="p">,</span>
		       <span class="n">fieinfo</span><span class="p">.</span><span class="n">fi_extents_max</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fiemap_extent</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fieinfo</span><span class="p">.</span><span class="n">fi_flags</span> <span class="o">&amp;</span> <span class="n">FIEMAP_FLAG_SYNC</span><span class="p">)</span>
		<span class="n">filemap_write_and_wait</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">fiemap</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">fiemap</span><span class="p">.</span><span class="n">fm_start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">fiemap</span><span class="p">.</span><span class="n">fm_flags</span> <span class="o">=</span> <span class="n">fieinfo</span><span class="p">.</span><span class="n">fi_flags</span><span class="p">;</span>
	<span class="n">fiemap</span><span class="p">.</span><span class="n">fm_mapped_extents</span> <span class="o">=</span> <span class="n">fieinfo</span><span class="p">.</span><span class="n">fi_extents_mapped</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">ufiemap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fiemap</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fiemap</span><span class="p">)))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">sector_t</span> <span class="nf">logical_to_blk</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">blk_to_logical</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">blk</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __generic_block_fiemap - FIEMAP for block based inodes (no locking)</span>
<span class="cm"> * @inode: the inode to map</span>
<span class="cm"> * @fieinfo: the fiemap info struct that will be passed back to userspace</span>
<span class="cm"> * @start: where to start mapping in the inode</span>
<span class="cm"> * @len: how much space to map</span>
<span class="cm"> * @get_block: the fs&#39;s get_block function</span>
<span class="cm"> *</span>
<span class="cm"> * This does FIEMAP for block based inodes.  Basically it will just loop</span>
<span class="cm"> * through get_block until we hit the number of extents we want to map, or we</span>
<span class="cm"> * go past the end of the file and hit a hole.</span>
<span class="cm"> *</span>
<span class="cm"> * If it is possible to have data blocks beyond a hole past @inode-&gt;i_size, then</span>
<span class="cm"> * please do not use this function, it will stop at the first unmapped block</span>
<span class="cm"> * beyond i_size.</span>
<span class="cm"> *</span>
<span class="cm"> * If you use this function directly, you need to do your own locking. Use</span>
<span class="cm"> * generic_block_fiemap if you want the locking done for you.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">__generic_block_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span>
			   <span class="n">loff_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="n">map_bh</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">start_blk</span><span class="p">,</span> <span class="n">last_blk</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">logical</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">FIEMAP_EXTENT_MERGED</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">past_eof</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">whole_file</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">fiemap_check_flags</span><span class="p">(</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">FIEMAP_FLAG_SYNC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Either the i_mutex or other appropriate locking needs to be held</span>
<span class="cm">	 * since we expect isize to not change at all through the duration of</span>
<span class="cm">	 * this call.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">isize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">whole_file</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">isize</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some filesystems can&#39;t deal with being asked to map less than</span>
<span class="cm">	 * blocksize, so make sure our len is at least block length.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">logical_to_blk</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">blk_to_logical</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">start_blk</span> <span class="o">=</span> <span class="n">logical_to_blk</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">last_blk</span> <span class="o">=</span> <span class="n">logical_to_blk</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * we set b_size to the total size we want so it will map as</span>
<span class="cm">		 * many contiguous blocks as possible at once</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span><span class="p">));</span>
		<span class="n">map_bh</span><span class="p">.</span><span class="n">b_size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start_blk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* HOLE */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">start_blk</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * We want to handle the case where there is an</span>
<span class="cm">			 * allocated block at the front of the file, and then</span>
<span class="cm">			 * nothing but holes up to the end of the file properly,</span>
<span class="cm">			 * to make sure that extent at the front gets properly</span>
<span class="cm">			 * marked with FIEMAP_EXTENT_LAST</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">past_eof</span> <span class="o">&amp;&amp;</span>
			    <span class="n">blk_to_logical</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start_blk</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">isize</span><span class="p">)</span>
				<span class="n">past_eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * First hole after going past the EOF, this is our</span>
<span class="cm">			 * last extent</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">past_eof</span> <span class="o">&amp;&amp;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">flags</span> <span class="o">=</span> <span class="n">FIEMAP_EXTENT_MERGED</span><span class="o">|</span><span class="n">FIEMAP_EXTENT_LAST</span><span class="p">;</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">fiemap_fill_next_extent</span><span class="p">(</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span>
							      <span class="n">phys</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
							      <span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">fiemap_fill_next_extent</span><span class="p">(</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span>
							      <span class="n">phys</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* if we have holes up to/past EOF then we&#39;re done */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">start_blk</span> <span class="o">&gt;</span> <span class="n">last_blk</span> <span class="o">||</span> <span class="n">past_eof</span> <span class="o">||</span> <span class="n">ret</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We have gone over the length of what we wanted to</span>
<span class="cm">			 * map, and it wasn&#39;t the entire file, so add the extent</span>
<span class="cm">			 * we got last time and exit.</span>
<span class="cm">			 *</span>
<span class="cm">			 * This is for the case where say we want to map all the</span>
<span class="cm">			 * way up to the second to the last block in a file, but</span>
<span class="cm">			 * the last block is a hole, making the second to last</span>
<span class="cm">			 * block FIEMAP_EXTENT_LAST.  In this case we want to</span>
<span class="cm">			 * see if there is a hole after the second to last block</span>
<span class="cm">			 * so we can mark it properly.  If we found data after</span>
<span class="cm">			 * we exceeded the length we were requesting, then we</span>
<span class="cm">			 * are good to go, just add the extent to the fieinfo</span>
<span class="cm">			 * and break</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">start_blk</span> <span class="o">&gt;</span> <span class="n">last_blk</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">whole_file</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">fiemap_fill_next_extent</span><span class="p">(</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span>
							      <span class="n">phys</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
							      <span class="n">flags</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * if size != 0 then we know we already have an extent</span>
<span class="cm">			 * to add, so add it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">fiemap_fill_next_extent</span><span class="p">(</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span>
							      <span class="n">phys</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
							      <span class="n">flags</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">logical</span> <span class="o">=</span> <span class="n">blk_to_logical</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start_blk</span><span class="p">);</span>
			<span class="n">phys</span> <span class="o">=</span> <span class="n">blk_to_logical</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map_bh</span><span class="p">.</span><span class="n">b_blocknr</span><span class="p">);</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">map_bh</span><span class="p">.</span><span class="n">b_size</span><span class="p">;</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">FIEMAP_EXTENT_MERGED</span><span class="p">;</span>

			<span class="n">start_blk</span> <span class="o">+=</span> <span class="n">logical_to_blk</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * If we are past the EOF, then we need to make sure as</span>
<span class="cm">			 * soon as we find a hole that the last extent we found</span>
<span class="cm">			 * is marked with FIEMAP_EXTENT_LAST</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">past_eof</span> <span class="o">&amp;&amp;</span> <span class="n">logical</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="n">isize</span><span class="p">)</span>
				<span class="n">past_eof</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* If ret is 1 then we just hit the end of the extent array */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__generic_block_fiemap</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * generic_block_fiemap - FIEMAP for block based inodes</span>
<span class="cm"> * @inode: The inode to map</span>
<span class="cm"> * @fieinfo: The mapping information</span>
<span class="cm"> * @start: The initial block to map</span>
<span class="cm"> * @len: The length of the extect to attempt to map</span>
<span class="cm"> * @get_block: The block mapping function for the fs</span>
<span class="cm"> *</span>
<span class="cm"> * Calls __generic_block_fiemap to map the inode, after taking</span>
<span class="cm"> * the inode&#39;s mutex lock.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">generic_block_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span>
			 <span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__generic_block_fiemap</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fieinfo</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">get_block</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_block_fiemap</span><span class="p">);</span>

<span class="cp">#endif  </span><span class="cm">/*  CONFIG_BLOCK  */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * This provides compatibility with legacy XFS pre-allocation ioctls</span>
<span class="cm"> * which predate the fallocate syscall.</span>
<span class="cm"> *</span>
<span class="cm"> * Only the l_start, l_len and l_whence fields of the &#39;struct space_resv&#39;</span>
<span class="cm"> * are used here, rest are ignored.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ioctl_preallocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">space_resv</span> <span class="n">sr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sr</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sr</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sr</span><span class="p">.</span><span class="n">l_whence</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SEEK_SET</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEEK_CUR</span>:
		<span class="n">sr</span><span class="p">.</span><span class="n">l_start</span> <span class="o">+=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEEK_END</span>:
		<span class="n">sr</span><span class="p">.</span><span class="n">l_start</span> <span class="o">+=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">do_fallocate</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">FALLOC_FL_KEEP_SIZE</span><span class="p">,</span> <span class="n">sr</span><span class="p">.</span><span class="n">l_start</span><span class="p">,</span> <span class="n">sr</span><span class="p">.</span><span class="n">l_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">file_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FIBMAP</span>:
		<span class="k">return</span> <span class="n">ioctl_fibmap</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FIONREAD</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">-</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FS_IOC_RESVSP</span>:
	<span class="k">case</span> <span class="n">FS_IOC_RESVSP64</span>:
		<span class="k">return</span> <span class="n">ioctl_preallocate</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">vfs_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioctl_fionbio</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">on</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">on</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">flag</span> <span class="o">=</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>
<span class="cp">#ifdef __sparc__</span>
	<span class="cm">/* SunOS compatibility item. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">O_NONBLOCK</span> <span class="o">!=</span> <span class="n">O_NDELAY</span><span class="p">)</span>
		<span class="n">flag</span> <span class="o">|=</span> <span class="n">O_NDELAY</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">|=</span> <span class="n">flag</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">flag</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioctl_fioasync</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">on</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">on</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">flag</span> <span class="o">=</span> <span class="n">on</span> <span class="o">?</span> <span class="n">FASYNC</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Did FASYNC state change ? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">^</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FASYNC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">&amp;&amp;</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">fasync</span><span class="p">)</span>
			<span class="cm">/* fasync() adjusts filp-&gt;f_flags */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">fasync</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">on</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">error</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioctl_fsfreeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* If filesystem doesn&#39;t support freeze feature, return. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">freeze_fs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="cm">/* Freeze */</span>
	<span class="k">return</span> <span class="n">freeze_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioctl_fsthaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* Thaw */</span>
	<span class="k">return</span> <span class="n">thaw_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When you add any new common ioctls to the switches above and below</span>
<span class="cm"> * please update compat_sys_ioctl() too.</span>
<span class="cm"> *</span>
<span class="cm"> * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()&#39;d.</span>
<span class="cm"> * It&#39;s just a simple helper for sys_ioctl and compat_sys_ioctl.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">do_vfs_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
	     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FIOCLEX</span>:
		<span class="n">set_close_on_exec</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FIONCLEX</span>:
		<span class="n">set_close_on_exec</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FIONBIO</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">ioctl_fionbio</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FIOASYNC</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">ioctl_fioasync</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FIOQSIZE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">loff_t</span> <span class="n">res</span> <span class="o">=</span> <span class="n">inode_get_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">res</span><span class="p">))</span> <span class="o">?</span>
					<span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FIFREEZE</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">ioctl_fsfreeze</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FITHAW</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">ioctl_fsthaw</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FS_IOC_FIEMAP</span>:
		<span class="k">return</span> <span class="n">ioctl_fiemap</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">FIGETBSZ</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>

	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">file_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">ioctl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">;</span>

	<span class="n">filp</span> <span class="o">=</span> <span class="n">fget_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_file_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">do_vfs_ioctl</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
 <span class="nl">out_fput:</span>
	<span class="n">fput_light</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
