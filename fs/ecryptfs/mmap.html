<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ecryptfs › mmap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>mmap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * eCryptfs: Linux filesystem encryption layer</span>
<span class="cm"> * This is where eCryptfs coordinates the symmetric encryption and</span>
<span class="cm"> * decryption of the file data as it passes between the lower</span>
<span class="cm"> * encrypted file and the upper decrypted file.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1997-2003 Erez Zadok</span>
<span class="cm"> * Copyright (C) 2001-2003 Stony Brook University</span>
<span class="cm"> * Copyright (C) 2004-2007 International Business Machines Corp.</span>
<span class="cm"> *   Author(s): Michael A. Halcrow &lt;mahalcro@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation; either version 2 of the</span>
<span class="cm"> * License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</span>
<span class="cm"> * 02111-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/page-flags.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/crypto.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &quot;ecryptfs_kernel.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * ecryptfs_get_locked_page</span>
<span class="cm"> *</span>
<span class="cm"> * Get one page from cache or lower f/s, return error otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns locked and up-to-date page (if ok), with increased</span>
<span class="cm"> * refcnt.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">ecryptfs_get_locked_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">read_mapping_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ecryptfs_writepage</span>
<span class="cm"> * @page: Page that is locked before this call is made</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success; non-zero otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * This is where we encrypt the data and pass the encrypted data to</span>
<span class="cm"> * the lower filesystem.  In OpenPGP-compatible mode, we operate on</span>
<span class="cm"> * entire underlying packets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ecryptfs_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Refuse to write the page out if we are called from reclaim context</span>
<span class="cm">	 * since our writepage() path may potentially allocate memory when</span>
<span class="cm">	 * calling into the lower fs vfs_write() which may in turn invoke</span>
<span class="cm">	 * us again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_MEMALLOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">redirty_page_for_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_encrypt_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ecryptfs_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="s">&quot;Error encrypting &quot;</span>
				<span class="s">&quot;page (upper index [0x%.16lx])</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">ClearPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">strip_xattr_flag</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page_virt</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ECRYPTFS_METADATA_IN_XATTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">written</span><span class="p">;</span>

		<span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ECRYPTFS_METADATA_IN_XATTR</span><span class="p">;</span>
		<span class="n">ecryptfs_write_crypt_stat_flags</span><span class="p">(</span><span class="n">page_virt</span><span class="p">,</span> <span class="n">crypt_stat</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">written</span><span class="p">);</span>
		<span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ECRYPTFS_METADATA_IN_XATTR</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *   Header Extent:</span>
<span class="cm"> *     Octets 0-7:        Unencrypted file size (big-endian)</span>
<span class="cm"> *     Octets 8-15:       eCryptfs special marker</span>
<span class="cm"> *     Octets 16-19:      Flags</span>
<span class="cm"> *      Octet 16:         File format version number (between 0 and 255)</span>
<span class="cm"> *      Octets 17-18:     Reserved</span>
<span class="cm"> *      Octet 19:         Bit 1 (lsb): Reserved</span>
<span class="cm"> *                        Bit 2: Encrypted?</span>
<span class="cm"> *                        Bits 3-8: Reserved</span>
<span class="cm"> *     Octets 20-23:      Header extent size (big-endian)</span>
<span class="cm"> *     Octets 24-25:      Number of header extents at front of file</span>
<span class="cm"> *                        (big-endian)</span>
<span class="cm"> *     Octet  26:         Begin RFC 2440 authentication token packet set</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ecryptfs_copy_up_encrypted_with_header</span>
<span class="cm"> * @page: Sort of a ``virtual&#39;&#39; representation of the encrypted lower</span>
<span class="cm"> *        file. The actual lower file does not have the metadata in</span>
<span class="cm"> *        the header. This is locked.</span>
<span class="cm"> * @crypt_stat: The eCryptfs inode&#39;s cryptographic context</span>
<span class="cm"> *</span>
<span class="cm"> * The ``view&#39;&#39; is the version of the file that userspace winds up</span>
<span class="cm"> * seeing, with the header information inserted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ecryptfs_copy_up_encrypted_with_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">extent_num_in_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">num_extents_per_page</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span>
				       <span class="o">/</span> <span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">extent_size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">extent_num_in_page</span> <span class="o">&lt;</span> <span class="n">num_extents_per_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">view_extent_num</span> <span class="o">=</span> <span class="p">((((</span><span class="n">loff_t</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span>
					   <span class="o">*</span> <span class="n">num_extents_per_page</span><span class="p">)</span>
					  <span class="o">+</span> <span class="n">extent_num_in_page</span><span class="p">);</span>
		<span class="kt">size_t</span> <span class="n">num_header_extents_at_front</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">metadata_size</span> <span class="o">/</span> <span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">extent_size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">view_extent_num</span> <span class="o">&lt;</span> <span class="n">num_header_extents_at_front</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This is a header extent */</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">page_virt</span><span class="p">;</span>

			<span class="n">page_virt</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">page_virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
			<span class="cm">/* TODO: Support more than one header extent */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">view_extent_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">size_t</span> <span class="n">written</span><span class="p">;</span>

				<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_read_xattr_region</span><span class="p">(</span>
					<span class="n">page_virt</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
				<span class="n">strip_xattr_flag</span><span class="p">(</span><span class="n">page_virt</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="n">crypt_stat</span><span class="p">);</span>
				<span class="n">ecryptfs_write_header_metadata</span><span class="p">(</span><span class="n">page_virt</span> <span class="o">+</span> <span class="mi">20</span><span class="p">,</span>
							       <span class="n">crypt_stat</span><span class="p">,</span>
							       <span class="o">&amp;</span><span class="n">written</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">page_virt</span><span class="p">);</span>
			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Error reading xattr &quot;</span>
				       <span class="s">&quot;region; rc = [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* This is an encrypted data extent */</span>
			<span class="n">loff_t</span> <span class="n">lower_offset</span> <span class="o">=</span>
				<span class="p">((</span><span class="n">view_extent_num</span> <span class="o">*</span> <span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">extent_size</span><span class="p">)</span>
				 <span class="o">-</span> <span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">metadata_size</span><span class="p">);</span>

			<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_read_lower_page_segment</span><span class="p">(</span>
				<span class="n">page</span><span class="p">,</span> <span class="p">(</span><span class="n">lower_offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">),</span>
				<span class="p">(</span><span class="n">lower_offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">),</span>
				<span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">extent_size</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Error attempting to read &quot;</span>
				       <span class="s">&quot;extent at offset [%lld] in the lower &quot;</span>
				       <span class="s">&quot;file; rc = [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				       <span class="n">lower_offset</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">extent_num_in_page</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ecryptfs_readpage</span>
<span class="cm"> * @file: An eCryptfs file</span>
<span class="cm"> * @page: Page from eCryptfs inode mapping into which to stick the read data</span>
<span class="cm"> *</span>
<span class="cm"> * Read in a page, decrypting if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success; non-zero on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ecryptfs_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span> <span class="o">=</span>
		<span class="o">&amp;</span><span class="n">ecryptfs_inode_to_private</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">crypt_stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">crypt_stat</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ECRYPTFS_ENCRYPTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_read_lower_page_segment</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						      <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span>
						      <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ECRYPTFS_VIEW_AS_ENCRYPTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ECRYPTFS_METADATA_IN_XATTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_copy_up_encrypted_with_header</span><span class="p">(</span><span class="n">page</span><span class="p">,</span>
								    <span class="n">crypt_stat</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Error attempting to copy &quot;</span>
				       <span class="s">&quot;the encrypted content from the lower &quot;</span>
				       <span class="s">&quot;file whilst inserting the metadata &quot;</span>
				       <span class="s">&quot;from the xattr into the header; rc = &quot;</span>
				       <span class="s">&quot;[%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_read_lower_page_segment</span><span class="p">(</span>
				<span class="n">page</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span>
				<span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Error reading page; rc = &quot;</span>
				       <span class="s">&quot;[%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_decrypt_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ecryptfs_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Error decrypting page; &quot;</span>
					<span class="s">&quot;rc = [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">ClearPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ecryptfs_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="s">&quot;Unlocking page with index = [0x%.16lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Called with lower inode mutex held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fill_zeros_to_end_of_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end_byte_in_page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">end_byte_in_page</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">%</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to</span> <span class="o">&gt;</span> <span class="n">end_byte_in_page</span><span class="p">)</span>
		<span class="n">end_byte_in_page</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
	<span class="n">zero_user_segment</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">end_byte_in_page</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ecryptfs_write_begin</span>
<span class="cm"> * @file: The eCryptfs file</span>
<span class="cm"> * @mapping: The eCryptfs object</span>
<span class="cm"> * @pos: The file offset at which to start writing</span>
<span class="cm"> * @len: Length of the write</span>
<span class="cm"> * @flags: Various flags</span>
<span class="cm"> * @pagep: Pointer to return the page</span>
<span class="cm"> * @fsdata: Pointer to return fs data (unused)</span>
<span class="cm"> *</span>
<span class="cm"> * This function must zero any hole we create</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success; non-zero otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ecryptfs_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">prev_page_end_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

	<span class="n">prev_page_end_size</span> <span class="o">=</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">ecryptfs_inode_to_private</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">crypt_stat</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ECRYPTFS_ENCRYPTED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_read_lower_page_segment</span><span class="p">(</span>
				<span class="n">page</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Error attemping to read &quot;</span>
				       <span class="s">&quot;lower page segment; rc = [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="n">ClearPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ECRYPTFS_VIEW_AS_ENCRYPTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ECRYPTFS_METADATA_IN_XATTR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_copy_up_encrypted_with_header</span><span class="p">(</span>
					<span class="n">page</span><span class="p">,</span> <span class="n">crypt_stat</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Error attempting &quot;</span>
					       <span class="s">&quot;to copy the encrypted content &quot;</span>
					       <span class="s">&quot;from the lower file whilst &quot;</span>
					       <span class="s">&quot;inserting the metadata from &quot;</span>
					       <span class="s">&quot;the xattr into the header; rc &quot;</span>
					       <span class="s">&quot;= [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
					<span class="n">ClearPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_read_lower_page_segment</span><span class="p">(</span>
					<span class="n">page</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span>
					<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Error reading &quot;</span>
					       <span class="s">&quot;page; rc = [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
					<span class="n">ClearPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prev_page_end_size</span>
			    <span class="o">&gt;=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_decrypt_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Error decrypting &quot;</span>
					       <span class="s">&quot;page at index [%ld]; &quot;</span>
					       <span class="s">&quot;rc = [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">__func__</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
					<span class="n">ClearPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* If creating a page or more of holes, zero them out via truncate.</span>
<span class="cm">	 * Note, this will increase i_size. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_page_end_size</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_truncate</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span>
					       <span class="n">prev_page_end_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Error on attempt to &quot;</span>
				       <span class="s">&quot;truncate to (higher) offset [%lld];&quot;</span>
				       <span class="s">&quot; rc = [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				       <span class="n">prev_page_end_size</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Writing to a new page, and creating a small hole from start</span>
<span class="cm">	 * of page?  Zero it out. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span> <span class="o">==</span> <span class="n">prev_page_end_size</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ecryptfs_write_inode_size_to_header</span>
<span class="cm"> *</span>
<span class="cm"> * Writes the lower file size to the first 8 bytes of the header.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success; non-zero on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ecryptfs_write_inode_size_to_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ecryptfs_inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">file_size_virt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">file_size_virt</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file_size_virt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">put_unaligned_be64</span><span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">),</span> <span class="n">file_size_virt</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_write_lower</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">,</span> <span class="n">file_size_virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">file_size_virt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Error writing file size to header; &quot;</span>
		       <span class="s">&quot;rc = [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ecryptfs_xattr_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ecryptfs_write_inode_size_to_xattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ecryptfs_inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">xattr_virt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">lower_dentry</span> <span class="o">=</span>
		<span class="n">ecryptfs_inode_to_private</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lower_file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">lower_inode</span> <span class="o">=</span> <span class="n">lower_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lower_inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span> <span class="o">||</span> <span class="o">!</span><span class="n">lower_inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">setxattr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;No support for setting xattr in lower filesystem</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xattr_virt</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">ecryptfs_xattr_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xattr_virt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Out of memory whilst attempting to write &quot;</span>
		       <span class="s">&quot;inode size to xattr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lower_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">lower_inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">getxattr</span><span class="p">(</span><span class="n">lower_dentry</span><span class="p">,</span> <span class="n">ECRYPTFS_XATTR_NAME</span><span class="p">,</span>
					   <span class="n">xattr_virt</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">put_unaligned_be64</span><span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">),</span> <span class="n">xattr_virt</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lower_inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">setxattr</span><span class="p">(</span><span class="n">lower_dentry</span><span class="p">,</span> <span class="n">ECRYPTFS_XATTR_NAME</span><span class="p">,</span>
					 <span class="n">xattr_virt</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lower_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Error whilst attempting to write inode size &quot;</span>
		       <span class="s">&quot;to lower file xattr; rc = [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ecryptfs_xattr_cache</span><span class="p">,</span> <span class="n">xattr_virt</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ecryptfs_write_inode_size_to_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ecryptfs_inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">;</span>

	<span class="n">crypt_stat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ecryptfs_inode_to_private</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">crypt_stat</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ECRYPTFS_ENCRYPTED</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ECRYPTFS_METADATA_IN_XATTR</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ecryptfs_write_inode_size_to_xattr</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">ecryptfs_write_inode_size_to_header</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ecryptfs_write_end</span>
<span class="cm"> * @file: The eCryptfs file object</span>
<span class="cm"> * @mapping: The eCryptfs object</span>
<span class="cm"> * @pos: The file position</span>
<span class="cm"> * @len: The length of the data (unused)</span>
<span class="cm"> * @copied: The amount of data copied</span>
<span class="cm"> * @page: The eCryptfs page</span>
<span class="cm"> * @fsdata: The fsdata (unused)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ecryptfs_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">from</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">to</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="n">copied</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ecryptfs_inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span> <span class="o">=</span>
		<span class="o">&amp;</span><span class="n">ecryptfs_inode_to_private</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">crypt_stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_unlock_page</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ecryptfs_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="s">&quot;Calling fill_zeros_to_end_of_page&quot;</span>
			<span class="s">&quot;(page w/ index = [0x%.16lx], to = [%d])</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ECRYPTFS_ENCRYPTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_write_lower_page_segment</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						       <span class="n">to</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">copied</span><span class="p">;</span>
			<span class="n">fsstack_copy_inode_size</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">,</span>
				<span class="n">ecryptfs_inode_to_lower</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Fills in zeros if &#39;to&#39; goes beyond inode size */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">fill_zeros_to_end_of_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ecryptfs_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="s">&quot;Error attempting to fill &quot;</span>
			<span class="s">&quot;zeros in page with index = [0x%.16lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">need_unlock_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">copied</span><span class="p">);</span>
		<span class="n">ecryptfs_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="s">&quot;Expanded file size to &quot;</span>
			<span class="s">&quot;[0x%.16llx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">));</span>
		<span class="n">balance_dirty_pages_ratelimited</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ecryptfs_write_inode_size_to_metadata</span><span class="p">(</span><span class="n">ecryptfs_inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Error writing inode size to metadata; &quot;</span>
			       <span class="s">&quot;rc = [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">copied</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_unlock_page</span><span class="p">)</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">sector_t</span> <span class="nf">ecryptfs_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">lower_inode</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">)</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">lower_inode</span> <span class="o">=</span> <span class="n">ecryptfs_inode_to_lower</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lower_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lower_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">(</span><span class="n">lower_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span>
							 <span class="n">block</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ecryptfs_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">writepage</span> <span class="o">=</span> <span class="n">ecryptfs_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpage</span> <span class="o">=</span> <span class="n">ecryptfs_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span> <span class="o">=</span> <span class="n">ecryptfs_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span> <span class="o">=</span> <span class="n">ecryptfs_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmap</span> <span class="o">=</span> <span class="n">ecryptfs_bmap</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
