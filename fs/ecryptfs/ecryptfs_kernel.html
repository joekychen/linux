<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ecryptfs › ecryptfs_kernel.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ecryptfs_kernel.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * eCryptfs: Linux filesystem encryption layer</span>
<span class="cm"> * Kernel declarations.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1997-2003 Erez Zadok</span>
<span class="cm"> * Copyright (C) 2001-2003 Stony Brook University</span>
<span class="cm"> * Copyright (C) 2004-2008 International Business Machines Corp.</span>
<span class="cm"> *   Author(s): Michael A. Halcrow &lt;mahalcro@us.ibm.com&gt;</span>
<span class="cm"> *              Trevor S. Highland &lt;trevor.highland@gmail.com&gt;</span>
<span class="cm"> *              Tyler Hicks &lt;tyhicks@ou.edu&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation; either version 2 of the</span>
<span class="cm"> * License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</span>
<span class="cm"> * 02111-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef ECRYPTFS_KERNEL_H</span>
<span class="cp">#define ECRYPTFS_KERNEL_H</span>

<span class="cp">#include &lt;keys/user-type.h&gt;</span>
<span class="cp">#include &lt;keys/encrypted-type.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/fs_stack.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/ecryptfs.h&gt;</span>

<span class="cp">#define ECRYPTFS_DEFAULT_IV_BYTES 16</span>
<span class="cp">#define ECRYPTFS_DEFAULT_EXTENT_SIZE 4096</span>
<span class="cp">#define ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE 8192</span>
<span class="cp">#define ECRYPTFS_DEFAULT_MSG_CTX_ELEMS 32</span>
<span class="cp">#define ECRYPTFS_DEFAULT_SEND_TIMEOUT HZ</span>
<span class="cp">#define ECRYPTFS_MAX_MSG_CTX_TTL (HZ*3)</span>
<span class="cp">#define ECRYPTFS_DEFAULT_NUM_USERS 4</span>
<span class="cp">#define ECRYPTFS_MAX_NUM_USERS 32768</span>
<span class="cp">#define ECRYPTFS_XATTR_NAME &quot;user.ecryptfs&quot;</span>

<span class="kt">void</span> <span class="n">ecryptfs_dump_auth_tok</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_auth_tok</span> <span class="o">*</span><span class="n">auth_tok</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ecryptfs_to_hex</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">src_size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ecryptfs_from_hex</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dst_size</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ecryptfs_key_record</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">enc_key_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sig</span><span class="p">[</span><span class="n">ECRYPTFS_SIG_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">enc_key</span><span class="p">[</span><span class="n">ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ecryptfs_auth_tok_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ecryptfs_auth_tok</span> <span class="o">*</span><span class="n">auth_tok</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ecryptfs_mount_crypt_stat</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ecryptfs_page_crypt_context</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
<span class="cp">#define ECRYPTFS_PREPARE_COMMIT_MODE 0</span>
<span class="cp">#define ECRYPTFS_WRITEPAGE_MODE      1</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">lower_file</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">param</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#if defined(CONFIG_ENCRYPTED_KEYS) || defined(CONFIG_ENCRYPTED_KEYS_MODULE)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ecryptfs_auth_tok</span> <span class="o">*</span>
<span class="nf">ecryptfs_get_encrypted_key_payload_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">key_type_encrypted</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_auth_tok</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">encrypted_key_payload</span> <span class="o">*</span><span class="p">)</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">payload_data</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="nf">ecryptfs_get_encrypted_key</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">request_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key_type_encrypted</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ecryptfs_auth_tok</span> <span class="o">*</span>
<span class="nf">ecryptfs_get_encrypted_key_payload_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="nf">ecryptfs_get_encrypted_key</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOKEY</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_ENCRYPTED_KEYS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ecryptfs_auth_tok</span> <span class="o">*</span>
<span class="nf">ecryptfs_get_key_payload_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ecryptfs_auth_tok</span> <span class="o">*</span><span class="n">auth_tok</span><span class="p">;</span>

	<span class="n">auth_tok</span> <span class="o">=</span> <span class="n">ecryptfs_get_encrypted_key_payload_data</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">auth_tok</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_auth_tok</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">(((</span><span class="k">struct</span> <span class="n">user_key_payload</span> <span class="o">*</span><span class="p">)</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">.</span><span class="n">data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">auth_tok</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define ECRYPTFS_MAX_KEYSET_SIZE 1024</span>
<span class="cp">#define ECRYPTFS_MAX_CIPHER_NAME_SIZE 32</span>
<span class="cp">#define ECRYPTFS_MAX_NUM_ENC_KEYS 64</span>
<span class="cp">#define ECRYPTFS_MAX_IV_BYTES 16	</span><span class="cm">/* 128 bits */</span><span class="cp"></span>
<span class="cp">#define ECRYPTFS_SALT_BYTES 2</span>
<span class="cp">#define MAGIC_ECRYPTFS_MARKER 0x3c81b7f5</span>
<span class="cp">#define MAGIC_ECRYPTFS_MARKER_SIZE_BYTES 8	</span><span class="cm">/* 4*2 */</span><span class="cp"></span>
<span class="cp">#define ECRYPTFS_FILE_SIZE_BYTES (sizeof(u64))</span>
<span class="cp">#define ECRYPTFS_SIZE_AND_MARKER_BYTES (ECRYPTFS_FILE_SIZE_BYTES \</span>
<span class="cp">					+ MAGIC_ECRYPTFS_MARKER_SIZE_BYTES)</span>
<span class="cp">#define ECRYPTFS_DEFAULT_CIPHER &quot;aes&quot;</span>
<span class="cp">#define ECRYPTFS_DEFAULT_KEY_BYTES 16</span>
<span class="cp">#define ECRYPTFS_DEFAULT_HASH &quot;md5&quot;</span>
<span class="cp">#define ECRYPTFS_TAG_70_DIGEST ECRYPTFS_DEFAULT_HASH</span>
<span class="cp">#define ECRYPTFS_TAG_1_PACKET_TYPE 0x01</span>
<span class="cp">#define ECRYPTFS_TAG_3_PACKET_TYPE 0x8C</span>
<span class="cp">#define ECRYPTFS_TAG_11_PACKET_TYPE 0xED</span>
<span class="cp">#define ECRYPTFS_TAG_64_PACKET_TYPE 0x40</span>
<span class="cp">#define ECRYPTFS_TAG_65_PACKET_TYPE 0x41</span>
<span class="cp">#define ECRYPTFS_TAG_66_PACKET_TYPE 0x42</span>
<span class="cp">#define ECRYPTFS_TAG_67_PACKET_TYPE 0x43</span>
<span class="cp">#define ECRYPTFS_TAG_70_PACKET_TYPE 0x46 </span><span class="cm">/* FNEK-encrypted filename</span>
<span class="cm">					  * as dentry name */</span><span class="cp"></span>
<span class="cp">#define ECRYPTFS_TAG_71_PACKET_TYPE 0x47 </span><span class="cm">/* FNEK-encrypted filename in</span>
<span class="cm">					  * metadata */</span><span class="cp"></span>
<span class="cp">#define ECRYPTFS_TAG_72_PACKET_TYPE 0x48 </span><span class="cm">/* FEK-encrypted filename as</span>
<span class="cm">					  * dentry name */</span><span class="cp"></span>
<span class="cp">#define ECRYPTFS_TAG_73_PACKET_TYPE 0x49 </span><span class="cm">/* FEK-encrypted filename as</span>
<span class="cm">					  * metadata */</span><span class="cp"></span>
<span class="cp">#define ECRYPTFS_MIN_PKT_LEN_SIZE 1 </span><span class="cm">/* Min size to specify packet length */</span><span class="cp"></span>
<span class="cp">#define ECRYPTFS_MAX_PKT_LEN_SIZE 2 </span><span class="cm">/* Pass at least this many bytes to</span>
<span class="cm">				     * ecryptfs_parse_packet_length() and</span>
<span class="cm">				     * ecryptfs_write_packet_length()</span>
<span class="cm">				     */</span><span class="cp"></span>
<span class="cm">/* Constraint: ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES &gt;=</span>
<span class="cm"> * ECRYPTFS_MAX_IV_BYTES */</span>
<span class="cp">#define ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES 16</span>
<span class="cp">#define ECRYPTFS_NON_NULL 0x42 </span><span class="cm">/* A reasonable substitute for NULL */</span><span class="cp"></span>
<span class="cp">#define MD5_DIGEST_SIZE 16</span>
<span class="cp">#define ECRYPTFS_TAG_70_DIGEST_SIZE MD5_DIGEST_SIZE</span>
<span class="cp">#define ECRYPTFS_TAG_70_MIN_METADATA_SIZE (1 + ECRYPTFS_MIN_PKT_LEN_SIZE \</span>
<span class="cp">					   + ECRYPTFS_SIG_SIZE + 1 + 1)</span>
<span class="cp">#define ECRYPTFS_TAG_70_MAX_METADATA_SIZE (1 + ECRYPTFS_MAX_PKT_LEN_SIZE \</span>
<span class="cp">					   + ECRYPTFS_SIG_SIZE + 1 + 1)</span>
<span class="cp">#define ECRYPTFS_FEK_ENCRYPTED_FILENAME_PREFIX &quot;ECRYPTFS_FEK_ENCRYPTED.&quot;</span>
<span class="cp">#define ECRYPTFS_FEK_ENCRYPTED_FILENAME_PREFIX_SIZE 23</span>
<span class="cp">#define ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX &quot;ECRYPTFS_FNEK_ENCRYPTED.&quot;</span>
<span class="cp">#define ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE 24</span>
<span class="cp">#define ECRYPTFS_ENCRYPTED_DENTRY_NAME_LEN (18 + 1 + 4 + 1 + 32)</span>

<span class="k">struct</span> <span class="n">ecryptfs_key_sig</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">crypt_stat_list</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">keysig</span><span class="p">[</span><span class="n">ECRYPTFS_SIG_SIZE_HEX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ecryptfs_filename</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">crypt_stat_list</span><span class="p">;</span>
<span class="cp">#define ECRYPTFS_FILENAME_CONTAINS_DECRYPTED 0x00000001</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">seq_no</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">encrypted_filename</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">filename_size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">encrypted_filename_size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">fnek_sig</span><span class="p">[</span><span class="n">ECRYPTFS_SIG_SIZE_HEX</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">dentry_name</span><span class="p">[</span><span class="n">ECRYPTFS_ENCRYPTED_DENTRY_NAME_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * This is the primary struct associated with each encrypted file.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: cache align/pack?</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="p">{</span>
<span class="cp">#define ECRYPTFS_STRUCT_INITIALIZED   0x00000001</span>
<span class="cp">#define ECRYPTFS_POLICY_APPLIED       0x00000002</span>
<span class="cp">#define ECRYPTFS_ENCRYPTED            0x00000004</span>
<span class="cp">#define ECRYPTFS_SECURITY_WARNING     0x00000008</span>
<span class="cp">#define ECRYPTFS_ENABLE_HMAC          0x00000010</span>
<span class="cp">#define ECRYPTFS_ENCRYPT_IV_PAGES     0x00000020</span>
<span class="cp">#define ECRYPTFS_KEY_VALID            0x00000040</span>
<span class="cp">#define ECRYPTFS_METADATA_IN_XATTR    0x00000080</span>
<span class="cp">#define ECRYPTFS_VIEW_AS_ENCRYPTED    0x00000100</span>
<span class="cp">#define ECRYPTFS_KEY_SET              0x00000200</span>
<span class="cp">#define ECRYPTFS_ENCRYPT_FILENAMES    0x00000400</span>
<span class="cp">#define ECRYPTFS_ENCFN_USE_MOUNT_FNEK 0x00000800</span>
<span class="cp">#define ECRYPTFS_ENCFN_USE_FEK        0x00001000</span>
<span class="cp">#define ECRYPTFS_UNLINK_SIGS          0x00002000</span>
<span class="cp">#define ECRYPTFS_I_SIZE_INITIALIZED   0x00004000</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">file_version</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">iv_bytes</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">metadata_size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">extent_size</span><span class="p">;</span> <span class="cm">/* Data extent size; default is 4096 */</span>
	<span class="kt">size_t</span> <span class="n">key_size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">extent_shift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">extent_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ecryptfs_mount_crypt_stat</span> <span class="o">*</span><span class="n">mount_crypt_stat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_blkcipher</span> <span class="o">*</span><span class="n">tfm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_hash</span> <span class="o">*</span><span class="n">hash_tfm</span><span class="p">;</span> <span class="cm">/* Crypto context for generating</span>
<span class="cm">				       * the initialization vectors */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cipher</span><span class="p">[</span><span class="n">ECRYPTFS_MAX_CIPHER_NAME_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">key</span><span class="p">[</span><span class="n">ECRYPTFS_MAX_KEY_BYTES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">root_iv</span><span class="p">[</span><span class="n">ECRYPTFS_MAX_IV_BYTES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">keysig_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">keysig_list_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">cs_tfm_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">cs_hash_tfm_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">cs_mutex</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* inode private data. */</span>
<span class="k">struct</span> <span class="n">ecryptfs_inode_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="n">vfs_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">wii_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lower_file_mutex</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">lower_file_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">lower_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="n">crypt_stat</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* dentry private data. Each dentry must keep track of a lower</span>
<span class="cm"> * vfsmount too. */</span>
<span class="k">struct</span> <span class="n">ecryptfs_dentry_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">lower_path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ecryptfs_global_auth_tok - A key used to encrypt all new files under the mountpoint</span>
<span class="cm"> * @flags: Status flags</span>
<span class="cm"> * @mount_crypt_stat_list: These auth_toks hang off the mount-wide</span>
<span class="cm"> *                         cryptographic context. Every time a new</span>
<span class="cm"> *                         inode comes into existence, eCryptfs copies</span>
<span class="cm"> *                         the auth_toks on that list to the set of</span>
<span class="cm"> *                         auth_toks on the inode&#39;s crypt_stat</span>
<span class="cm"> * @global_auth_tok_key: The key from the user&#39;s keyring for the sig</span>
<span class="cm"> * @global_auth_tok: The key contents</span>
<span class="cm"> * @sig: The key identifier</span>
<span class="cm"> *</span>
<span class="cm"> * ecryptfs_global_auth_tok structs refer to authentication token keys</span>
<span class="cm"> * in the user keyring that apply to newly created files. A list of</span>
<span class="cm"> * these objects hangs off of the mount_crypt_stat struct for any</span>
<span class="cm"> * given eCryptfs mount. This struct maintains a reference to both the</span>
<span class="cm"> * key contents and the key itself so that the key can be put on</span>
<span class="cm"> * unmount.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ecryptfs_global_auth_tok</span> <span class="p">{</span>
<span class="cp">#define ECRYPTFS_AUTH_TOK_INVALID 0x00000001</span>
<span class="cp">#define ECRYPTFS_AUTH_TOK_FNEK    0x00000002</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">mount_crypt_stat_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">global_auth_tok_key</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sig</span><span class="p">[</span><span class="n">ECRYPTFS_SIG_SIZE_HEX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ecryptfs_key_tfm - Persistent key tfm</span>
<span class="cm"> * @key_tfm: crypto API handle to the key</span>
<span class="cm"> * @key_size: Key size in bytes</span>
<span class="cm"> * @key_tfm_mutex: Mutex to ensure only one operation in eCryptfs is</span>
<span class="cm"> *                 using the persistent TFM at any point in time</span>
<span class="cm"> * @key_tfm_list: Handle to hang this off the module-wide TFM list</span>
<span class="cm"> * @cipher_name: String name for the cipher for this TFM</span>
<span class="cm"> *</span>
<span class="cm"> * Typically, eCryptfs will use the same ciphers repeatedly throughout</span>
<span class="cm"> * the course of its operations. In order to avoid unnecessarily</span>
<span class="cm"> * destroying and initializing the same cipher repeatedly, eCryptfs</span>
<span class="cm"> * keeps a list of crypto API contexts around to use when needed.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ecryptfs_key_tfm</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypto_blkcipher</span> <span class="o">*</span><span class="n">key_tfm</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">key_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">key_tfm_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">key_tfm_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cipher_name</span><span class="p">[</span><span class="n">ECRYPTFS_MAX_CIPHER_NAME_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">key_tfm_list_mutex</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * This struct is to enable a mount-wide passphrase/salt combo. This</span>
<span class="cm"> * is more or less a stopgap to provide similar functionality to other</span>
<span class="cm"> * crypto filesystems like EncFS or CFS until full policy support is</span>
<span class="cm"> * implemented in eCryptfs.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ecryptfs_mount_crypt_stat</span> <span class="p">{</span>
	<span class="cm">/* Pointers to memory we do not own, do not free these */</span>
<span class="cp">#define ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED 0x00000001</span>
<span class="cp">#define ECRYPTFS_XATTR_METADATA_ENABLED        0x00000002</span>
<span class="cp">#define ECRYPTFS_ENCRYPTED_VIEW_ENABLED        0x00000004</span>
<span class="cp">#define ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED  0x00000008</span>
<span class="cp">#define ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES      0x00000010</span>
<span class="cp">#define ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK   0x00000020</span>
<span class="cp">#define ECRYPTFS_GLOBAL_ENCFN_USE_FEK          0x00000040</span>
<span class="cp">#define ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY    0x00000080</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">global_auth_tok_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">global_auth_tok_list_mutex</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">global_default_cipher_key_size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">global_default_fn_cipher_key_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">global_default_cipher_name</span><span class="p">[</span><span class="n">ECRYPTFS_MAX_CIPHER_NAME_SIZE</span>
						 <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">global_default_fn_cipher_name</span><span class="p">[</span>
		<span class="n">ECRYPTFS_MAX_CIPHER_NAME_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">global_default_fnek_sig</span><span class="p">[</span><span class="n">ECRYPTFS_SIG_SIZE_HEX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* superblock private data. */</span>
<span class="k">struct</span> <span class="n">ecryptfs_sb_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">wsi_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ecryptfs_mount_crypt_stat</span> <span class="n">mount_crypt_stat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="n">bdi</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* file private data. */</span>
<span class="k">struct</span> <span class="n">ecryptfs_file_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">wfi_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* auth_tok &lt;=&gt; encrypted_session_key mappings */</span>
<span class="k">struct</span> <span class="n">ecryptfs_auth_tok_list_item</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">encrypted_session_key</span><span class="p">[</span><span class="n">ECRYPTFS_MAX_KEY_BYTES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ecryptfs_auth_tok</span> <span class="n">auth_tok</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ecryptfs_message</span> <span class="p">{</span>
	<span class="cm">/* Can never be greater than ecryptfs_message_buf_len */</span>
	<span class="cm">/* Used to find the parent msg_ctx */</span>
	<span class="cm">/* Inherits from msg_ctx-&gt;index */</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ecryptfs_msg_ctx</span> <span class="p">{</span>
<span class="cp">#define ECRYPTFS_MSG_CTX_STATE_FREE     0x01</span>
<span class="cp">#define ECRYPTFS_MSG_CTX_STATE_PENDING  0x02</span>
<span class="cp">#define ECRYPTFS_MSG_CTX_STATE_DONE     0x03</span>
<span class="cp">#define ECRYPTFS_MSG_CTX_STATE_NO_REPLY 0x04</span>
	<span class="n">u8</span> <span class="n">state</span><span class="p">;</span>
<span class="cp">#define ECRYPTFS_MSG_HELO 100</span>
<span class="cp">#define ECRYPTFS_MSG_QUIT 101</span>
<span class="cp">#define ECRYPTFS_MSG_REQUEST 102</span>
<span class="cp">#define ECRYPTFS_MSG_RESPONSE 103</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="cm">/* Counter converts to a sequence number. Each message sent</span>
<span class="cm">	 * out for which we expect a response has an associated</span>
<span class="cm">	 * sequence number. The response must have the same sequence</span>
<span class="cm">	 * number as the counter for the msg_stc for the message to be</span>
<span class="cm">	 * valid. */</span>
	<span class="n">u32</span> <span class="n">counter</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">msg_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ecryptfs_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">daemon_out_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mux</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ecryptfs_daemon</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ecryptfs_daemon</span> <span class="p">{</span>
<span class="cp">#define ECRYPTFS_DAEMON_IN_READ      0x00000001</span>
<span class="cp">#define ECRYPTFS_DAEMON_IN_POLL      0x00000002</span>
<span class="cp">#define ECRYPTFS_DAEMON_ZOMBIE       0x00000004</span>
<span class="cp">#define ECRYPTFS_DAEMON_MISCDEV_OPEN 0x00000008</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_queued_msg_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">euid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">user_ns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mux</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">msg_ctx_out_queue</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">euid_chain</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">ecryptfs_daemon_hash_mux</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span>
<span class="nf">ecryptfs_lower_header_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ECRYPTFS_METADATA_IN_XATTR</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">crypt_stat</span><span class="o">-&gt;</span><span class="n">metadata_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ecryptfs_file_info</span> <span class="o">*</span>
<span class="nf">ecryptfs_file_to_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ecryptfs_set_file_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ecryptfs_file_info</span> <span class="o">*</span><span class="n">file_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">file_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">ecryptfs_file_to_lower</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">ecryptfs_file_info</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wfi_file</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ecryptfs_set_file_lower</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">lower_file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">ecryptfs_file_info</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wfi_file</span> <span class="o">=</span>
		<span class="n">lower_file</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ecryptfs_inode_info</span> <span class="o">*</span>
<span class="nf">ecryptfs_inode_to_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ecryptfs_inode_info</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ecryptfs_inode_to_lower</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ecryptfs_inode_to_private</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wii_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ecryptfs_set_inode_lower</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">lower_inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ecryptfs_inode_to_private</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wii_inode</span> <span class="o">=</span> <span class="n">lower_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ecryptfs_sb_info</span> <span class="o">*</span>
<span class="nf">ecryptfs_superblock_to_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_sb_info</span> <span class="o">*</span><span class="p">)</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ecryptfs_set_superblock_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ecryptfs_sb_info</span> <span class="o">*</span><span class="n">sb_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="n">sb_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span>
<span class="nf">ecryptfs_superblock_to_lower</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">ecryptfs_sb_info</span> <span class="o">*</span><span class="p">)</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wsi_sb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ecryptfs_set_superblock_lower</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">lower_sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">ecryptfs_sb_info</span> <span class="o">*</span><span class="p">)</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wsi_sb</span> <span class="o">=</span> <span class="n">lower_sb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ecryptfs_dentry_info</span> <span class="o">*</span>
<span class="nf">ecryptfs_dentry_to_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_dentry_info</span> <span class="o">*</span><span class="p">)</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ecryptfs_set_dentry_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ecryptfs_dentry_info</span> <span class="o">*</span><span class="n">dentry_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span> <span class="o">=</span> <span class="n">dentry_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span>
<span class="nf">ecryptfs_dentry_to_lower</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">ecryptfs_dentry_info</span> <span class="o">*</span><span class="p">)</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lower_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ecryptfs_set_dentry_lower</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">lower_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">ecryptfs_dentry_info</span> <span class="o">*</span><span class="p">)</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lower_path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span>
		<span class="n">lower_dentry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span>
<span class="nf">ecryptfs_dentry_to_lower_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">ecryptfs_dentry_info</span> <span class="o">*</span><span class="p">)</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lower_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ecryptfs_set_dentry_lower_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">lower_mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">ecryptfs_dentry_info</span> <span class="o">*</span><span class="p">)</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lower_path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span>
		<span class="n">lower_mnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define ecryptfs_printk(type, fmt, arg...) \</span>
<span class="cp">        __ecryptfs_printk(type &quot;%s: &quot; fmt, __func__, ## arg);</span>
<span class="n">__printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">__ecryptfs_printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ecryptfs_main_fops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ecryptfs_dir_fops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ecryptfs_main_iops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ecryptfs_dir_iops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ecryptfs_symlink_iops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">ecryptfs_sops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">ecryptfs_dops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ecryptfs_aops</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ecryptfs_verbosity</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecryptfs_message_buf_len</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">signed</span> <span class="kt">long</span> <span class="n">ecryptfs_message_wait_timeout</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecryptfs_number_of_users</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ecryptfs_auth_tok_list_item_cache</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ecryptfs_file_info_cache</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ecryptfs_dentry_info_cache</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ecryptfs_inode_info_cache</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ecryptfs_sb_info_cache</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ecryptfs_header_cache</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ecryptfs_xattr_cache</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ecryptfs_key_record_cache</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ecryptfs_key_sig_cache</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ecryptfs_global_auth_tok_cache</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ecryptfs_key_tfm_cache</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ecryptfs_open_req_cache</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ecryptfs_open_req</span> <span class="p">{</span>
<span class="cp">#define ECRYPTFS_REQ_PROCESSED 0x00000001</span>
<span class="cp">#define ECRYPTFS_REQ_DROPPED   0x00000002</span>
<span class="cp">#define ECRYPTFS_REQ_ZOMBIE    0x00000004</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">**</span><span class="n">lower_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">lower_dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">lower_mnt</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mux</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">kthread_ctl_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ecryptfs_get_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">lower_inode</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecryptfs_i_size_init</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page_virt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_decode_and_decrypt_filename</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">decrypted_name</span><span class="p">,</span>
					 <span class="kt">size_t</span> <span class="o">*</span><span class="n">decrypted_name_size</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ecryptfs_dentry</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">name_size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_fill_zeros</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">new_length</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_encrypt_and_encode_filename</span><span class="p">(</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">encoded_name</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="o">*</span><span class="n">encoded_name_size</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ecryptfs_mount_crypt_stat</span> <span class="o">*</span><span class="n">mount_crypt_stat</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">name_size</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ecryptfs_lower_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">this_dentry</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecryptfs_dump_hex</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">virt_to_scatterlist</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">sg_size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_compute_root_iv</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecryptfs_rotate_iv</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">iv</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecryptfs_init_crypt_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecryptfs_destroy_crypt_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecryptfs_destroy_mount_crypt_stat</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">ecryptfs_mount_crypt_stat</span> <span class="o">*</span><span class="n">mount_crypt_stat</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_init_crypt_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_write_inode_size_to_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ecryptfs_inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_encrypt_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_decrypt_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_write_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ecryptfs_dentry</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ecryptfs_inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_read_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ecryptfs_dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_new_file_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ecryptfs_inode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecryptfs_write_crypt_stat_flags</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page_virt</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">,</span>
				     <span class="kt">size_t</span> <span class="o">*</span><span class="n">written</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_read_and_validate_header_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_read_and_validate_xattr_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">ecryptfs_code_for_cipher_string</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cipher_name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">key_bytes</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_cipher_code_to_string</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cipher_code</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecryptfs_set_default_sizes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_generate_key_packet_set</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dest_base</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ecryptfs_dentry</span><span class="p">,</span>
				     <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">max</span><span class="p">);</span>
<span class="kt">int</span>
<span class="n">ecryptfs_parse_packet_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ecryptfs_dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">new_length</span><span class="p">);</span>
<span class="kt">ssize_t</span>
<span class="n">ecryptfs_getxattr_lower</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">lower_dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span>
<span class="n">ecryptfs_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
		  <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_read_xattr_region</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page_virt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ecryptfs_inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_process_helo</span><span class="p">(</span><span class="n">uid_t</span> <span class="n">euid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">user_ns</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_process_quit</span><span class="p">(</span><span class="n">uid_t</span> <span class="n">euid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">user_ns</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_process_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">euid</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">user_ns</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">seq</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_send_message</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_len</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ecryptfs_msg_ctx</span> <span class="o">**</span><span class="n">msg_ctx</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_wait_for_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_msg_ctx</span> <span class="o">*</span><span class="n">msg_ctx</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ecryptfs_message</span> <span class="o">**</span><span class="n">emsg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_init_messaging</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecryptfs_release_messaging</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span>
<span class="n">ecryptfs_write_header_metadata</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">virt</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="o">*</span><span class="n">written</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_add_keysig</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="p">);</span>
<span class="kt">int</span>
<span class="n">ecryptfs_add_global_auth_tok</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_mount_crypt_stat</span> <span class="o">*</span><span class="n">mount_crypt_stat</span><span class="p">,</span>
			   <span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="p">,</span> <span class="n">u32</span> <span class="n">global_auth_tok_flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_get_global_auth_tok_for_sig</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">ecryptfs_global_auth_tok</span> <span class="o">**</span><span class="n">global_auth_tok</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ecryptfs_mount_crypt_stat</span> <span class="o">*</span><span class="n">mount_crypt_stat</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="p">);</span>
<span class="kt">int</span>
<span class="n">ecryptfs_add_new_key_tfm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_key_tfm</span> <span class="o">**</span><span class="n">key_tfm</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cipher_name</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">key_size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_init_crypto</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_destroy_crypto</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_tfm_exists</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cipher_name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ecryptfs_key_tfm</span> <span class="o">**</span><span class="n">key_tfm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_get_tfm_and_mutex_for_cipher_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_blkcipher</span> <span class="o">**</span><span class="n">tfm</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">mutex</span> <span class="o">**</span><span class="n">tfm_mutex</span><span class="p">,</span>
					       <span class="kt">char</span> <span class="o">*</span><span class="n">cipher_name</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_keyring_auth_tok_for_sig</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">**</span><span class="n">auth_tok_key</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ecryptfs_auth_tok</span> <span class="o">**</span><span class="n">auth_tok</span><span class="p">,</span>
				      <span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_write_lower</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ecryptfs_inode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			 <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_write_lower_page_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ecryptfs_inode</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page_for_lower</span><span class="p">,</span>
				      <span class="kt">size_t</span> <span class="n">offset_in_page</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_read_lower</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ecryptfs_inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_read_lower_page_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page_for_ecryptfs</span><span class="p">,</span>
				     <span class="n">pgoff_t</span> <span class="n">page_index</span><span class="p">,</span>
				     <span class="kt">size_t</span> <span class="n">offset_in_page</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ecryptfs_inode</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">ecryptfs_get_locked_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">index</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_exorcise_daemon</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_daemon</span> <span class="o">*</span><span class="n">daemon</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_find_daemon_by_euid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_daemon</span> <span class="o">**</span><span class="n">daemon</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">euid</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">user_ns</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_parse_packet_length</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="o">*</span><span class="n">length_size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_write_packet_length</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="o">*</span><span class="n">packet_size_length</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_init_ecryptfs_miscdev</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecryptfs_destroy_ecryptfs_miscdev</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_send_miscdev</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">data_size</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ecryptfs_msg_ctx</span> <span class="o">*</span><span class="n">msg_ctx</span><span class="p">,</span> <span class="n">u8</span> <span class="n">msg_type</span><span class="p">,</span>
			  <span class="n">u16</span> <span class="n">msg_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ecryptfs_daemon</span> <span class="o">*</span><span class="n">daemon</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecryptfs_msg_ctx_alloc_to_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_msg_ctx</span> <span class="o">*</span><span class="n">msg_ctx</span><span class="p">);</span>
<span class="kt">int</span>
<span class="n">ecryptfs_spawn_daemon</span><span class="p">(</span><span class="k">struct</span> <span class="n">ecryptfs_daemon</span> <span class="o">**</span><span class="n">daemon</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">euid</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">user_ns</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_init_kthread</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecryptfs_destroy_kthread</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_privileged_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">**</span><span class="n">lower_file</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">lower_dentry</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">lower_mnt</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_get_lower_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecryptfs_put_lower_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span>
<span class="n">ecryptfs_write_tag_70_packet</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">remaining_bytes</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="o">*</span><span class="n">packet_size</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ecryptfs_mount_crypt_stat</span> <span class="o">*</span><span class="n">mount_crypt_stat</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">filename_size</span><span class="p">);</span>
<span class="kt">int</span>
<span class="n">ecryptfs_parse_tag_70_packet</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">filename</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">filename_size</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="o">*</span><span class="n">packet_size</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ecryptfs_mount_crypt_stat</span> <span class="o">*</span><span class="n">mount_crypt_stat</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">max_packet_size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_set_f_namelen</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="n">namelen</span><span class="p">,</span> <span class="kt">long</span> <span class="n">lower_namelen</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ecryptfs_mount_crypt_stat</span> <span class="o">*</span><span class="n">mount_crypt_stat</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ecryptfs_derive_iv</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ecryptfs_crypt_stat</span> <span class="o">*</span><span class="n">crypt_stat</span><span class="p">,</span>
		       <span class="n">loff_t</span> <span class="n">offset</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* #ifndef ECRYPTFS_KERNEL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
