<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_alloc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_alloc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2002,2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_bit.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_ialloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_extent_busy.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>

<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">xfs_alloc_wq</span><span class="p">;</span>

<span class="cp">#define XFS_ABSDIFF(a,b)	(((a) &lt;= (b)) ? ((b) - (a)) : ((a) - (b)))</span>

<span class="cp">#define	XFSA_FIXUP_BNO_OK	1</span>
<span class="cp">#define	XFSA_FIXUP_CNT_OK	2</span>

<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_alloc_ag_vextent_exact</span><span class="p">(</span><span class="n">xfs_alloc_arg_t</span> <span class="o">*</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_alloc_ag_vextent_near</span><span class="p">(</span><span class="n">xfs_alloc_arg_t</span> <span class="o">*</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_alloc_ag_vextent_size</span><span class="p">(</span><span class="n">xfs_alloc_arg_t</span> <span class="o">*</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_alloc_ag_vextent_small</span><span class="p">(</span><span class="n">xfs_alloc_arg_t</span> <span class="o">*</span><span class="p">,</span>
		<span class="n">xfs_btree_cur_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_agblock_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_extlen_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Lookup the record equal to [bno, len] in the btree given by cur.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_alloc_lookup_eq</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_btree_cur</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>	<span class="cm">/* btree cursor */</span>
	<span class="n">xfs_agblock_t</span>		<span class="n">bno</span><span class="p">,</span>	<span class="cm">/* starting block of extent */</span>
	<span class="n">xfs_extlen_t</span>		<span class="n">len</span><span class="p">,</span>	<span class="cm">/* length of extent */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">stat</span><span class="p">)</span>	<span class="cm">/* success/failure */</span>
<span class="p">{</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bc_rec</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">ar_startblock</span> <span class="o">=</span> <span class="n">bno</span><span class="p">;</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bc_rec</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">ar_blockcount</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">xfs_btree_lookup</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">XFS_LOOKUP_EQ</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lookup the first record greater than or equal to [bno, len]</span>
<span class="cm"> * in the btree given by cur.</span>
<span class="cm"> */</span>
<span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_alloc_lookup_ge</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_btree_cur</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>	<span class="cm">/* btree cursor */</span>
	<span class="n">xfs_agblock_t</span>		<span class="n">bno</span><span class="p">,</span>	<span class="cm">/* starting block of extent */</span>
	<span class="n">xfs_extlen_t</span>		<span class="n">len</span><span class="p">,</span>	<span class="cm">/* length of extent */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">stat</span><span class="p">)</span>	<span class="cm">/* success/failure */</span>
<span class="p">{</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bc_rec</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">ar_startblock</span> <span class="o">=</span> <span class="n">bno</span><span class="p">;</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bc_rec</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">ar_blockcount</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">xfs_btree_lookup</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">XFS_LOOKUP_GE</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lookup the first record less than or equal to [bno, len]</span>
<span class="cm"> * in the btree given by cur.</span>
<span class="cm"> */</span>
<span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_alloc_lookup_le</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_btree_cur</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>	<span class="cm">/* btree cursor */</span>
	<span class="n">xfs_agblock_t</span>		<span class="n">bno</span><span class="p">,</span>	<span class="cm">/* starting block of extent */</span>
	<span class="n">xfs_extlen_t</span>		<span class="n">len</span><span class="p">,</span>	<span class="cm">/* length of extent */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">stat</span><span class="p">)</span>	<span class="cm">/* success/failure */</span>
<span class="p">{</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bc_rec</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">ar_startblock</span> <span class="o">=</span> <span class="n">bno</span><span class="p">;</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bc_rec</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">ar_blockcount</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">xfs_btree_lookup</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">XFS_LOOKUP_LE</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the record referred to by cur to the value given</span>
<span class="cm"> * by [bno, len].</span>
<span class="cm"> * This either works (return 0) or gets an EFSCORRUPTED error.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_alloc_update</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_btree_cur</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>	<span class="cm">/* btree cursor */</span>
	<span class="n">xfs_agblock_t</span>		<span class="n">bno</span><span class="p">,</span>	<span class="cm">/* starting block of extent */</span>
	<span class="n">xfs_extlen_t</span>		<span class="n">len</span><span class="p">)</span>	<span class="cm">/* length of extent */</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">xfs_btree_rec</span>	<span class="n">rec</span><span class="p">;</span>

	<span class="n">rec</span><span class="p">.</span><span class="n">alloc</span><span class="p">.</span><span class="n">ar_startblock</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">bno</span><span class="p">);</span>
	<span class="n">rec</span><span class="p">.</span><span class="n">alloc</span><span class="p">.</span><span class="n">ar_blockcount</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">xfs_btree_update</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the data from the pointed-to record.</span>
<span class="cm"> */</span>
<span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_alloc_get_rec</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_btree_cur</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>	<span class="cm">/* btree cursor */</span>
	<span class="n">xfs_agblock_t</span>		<span class="o">*</span><span class="n">bno</span><span class="p">,</span>	<span class="cm">/* output: starting block of extent */</span>
	<span class="n">xfs_extlen_t</span>		<span class="o">*</span><span class="n">len</span><span class="p">,</span>	<span class="cm">/* output: length of extent */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">stat</span><span class="p">)</span>	<span class="cm">/* output: success/failure */</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">xfs_btree_rec</span>	<span class="o">*</span><span class="n">rec</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_get_rec</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">stat</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">bno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">.</span><span class="n">ar_startblock</span><span class="p">);</span>
		<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">.</span><span class="n">ar_blockcount</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compute aligned version of the found extent.</span>
<span class="cm"> * Takes alignment and min length into account.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="n">xfs_alloc_compute_aligned</span><span class="p">(</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="o">*</span><span class="n">args</span><span class="p">,</span>		<span class="cm">/* allocation argument structure */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">foundbno</span><span class="p">,</span>	<span class="cm">/* starting block in found extent */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">foundlen</span><span class="p">,</span>	<span class="cm">/* length in found extent */</span>
	<span class="n">xfs_agblock_t</span>	<span class="o">*</span><span class="n">resbno</span><span class="p">,</span>	<span class="cm">/* result block number */</span>
	<span class="n">xfs_extlen_t</span>	<span class="o">*</span><span class="n">reslen</span><span class="p">)</span>	<span class="cm">/* result length */</span>
<span class="p">{</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">bno</span><span class="p">;</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Trim busy sections out of found extent */</span>
	<span class="n">xfs_extent_busy_trim</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">foundbno</span><span class="p">,</span> <span class="n">foundlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_agblock_t</span>	<span class="n">aligned_bno</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">bno</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span><span class="p">);</span>
		<span class="n">xfs_extlen_t</span>	<span class="n">diff</span> <span class="o">=</span> <span class="n">aligned_bno</span> <span class="o">-</span> <span class="n">bno</span><span class="p">;</span>

		<span class="o">*</span><span class="n">resbno</span> <span class="o">=</span> <span class="n">aligned_bno</span><span class="p">;</span>
		<span class="o">*</span><span class="n">reslen</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">&gt;=</span> <span class="n">len</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">len</span> <span class="o">-</span> <span class="n">diff</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">resbno</span> <span class="o">=</span> <span class="n">bno</span><span class="p">;</span>
		<span class="o">*</span><span class="n">reslen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compute best start block and diff for &quot;near&quot; allocations.</span>
<span class="cm"> * freelen &gt;= wantlen already checked by caller.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="n">xfs_extlen_t</span>			<span class="cm">/* difference value (absolute) */</span>
<span class="n">xfs_alloc_compute_diff</span><span class="p">(</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">wantbno</span><span class="p">,</span>	<span class="cm">/* target starting block */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">wantlen</span><span class="p">,</span>	<span class="cm">/* target length */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">alignment</span><span class="p">,</span>	<span class="cm">/* target alignment */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">freebno</span><span class="p">,</span>	<span class="cm">/* freespace&#39;s starting block */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">freelen</span><span class="p">,</span>	<span class="cm">/* freespace&#39;s length */</span>
	<span class="n">xfs_agblock_t</span>	<span class="o">*</span><span class="n">newbnop</span><span class="p">)</span>	<span class="cm">/* result: best start block from free */</span>
<span class="p">{</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">freeend</span><span class="p">;</span>	<span class="cm">/* end of freespace extent */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">newbno1</span><span class="p">;</span>	<span class="cm">/* return block number */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">newbno2</span><span class="p">;</span>	<span class="cm">/* other new block number */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">newlen1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>	<span class="cm">/* length with newbno1 */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">newlen2</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>	<span class="cm">/* length with newbno2 */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">wantend</span><span class="p">;</span>	<span class="cm">/* end of target extent */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">freelen</span> <span class="o">&gt;=</span> <span class="n">wantlen</span><span class="p">);</span>
	<span class="n">freeend</span> <span class="o">=</span> <span class="n">freebno</span> <span class="o">+</span> <span class="n">freelen</span><span class="p">;</span>
	<span class="n">wantend</span> <span class="o">=</span> <span class="n">wantbno</span> <span class="o">+</span> <span class="n">wantlen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freebno</span> <span class="o">&gt;=</span> <span class="n">wantbno</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">newbno1</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">freebno</span><span class="p">,</span> <span class="n">alignment</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">freeend</span><span class="p">)</span>
			<span class="n">newbno1</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">freeend</span> <span class="o">&gt;=</span> <span class="n">wantend</span> <span class="o">&amp;&amp;</span> <span class="n">alignment</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newbno1</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">wantbno</span><span class="p">,</span> <span class="n">alignment</span><span class="p">);</span>
		<span class="n">newbno2</span> <span class="o">=</span> <span class="n">newbno1</span> <span class="o">-</span> <span class="n">alignment</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newbno1</span> <span class="o">&gt;=</span> <span class="n">freeend</span><span class="p">)</span>
			<span class="n">newbno1</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">newlen1</span> <span class="o">=</span> <span class="n">XFS_EXTLEN_MIN</span><span class="p">(</span><span class="n">wantlen</span><span class="p">,</span> <span class="n">freeend</span> <span class="o">-</span> <span class="n">newbno1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newbno2</span> <span class="o">&lt;</span> <span class="n">freebno</span><span class="p">)</span>
			<span class="n">newbno2</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">newlen2</span> <span class="o">=</span> <span class="n">XFS_EXTLEN_MIN</span><span class="p">(</span><span class="n">wantlen</span><span class="p">,</span> <span class="n">freeend</span> <span class="o">-</span> <span class="n">newbno2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newbno1</span> <span class="o">!=</span> <span class="n">NULLAGBLOCK</span> <span class="o">&amp;&amp;</span> <span class="n">newbno2</span> <span class="o">!=</span> <span class="n">NULLAGBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newlen1</span> <span class="o">&lt;</span> <span class="n">newlen2</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">newlen1</span> <span class="o">==</span> <span class="n">newlen2</span> <span class="o">&amp;&amp;</span>
			     <span class="n">XFS_ABSDIFF</span><span class="p">(</span><span class="n">newbno1</span><span class="p">,</span> <span class="n">wantbno</span><span class="p">)</span> <span class="o">&gt;</span>
			     <span class="n">XFS_ABSDIFF</span><span class="p">(</span><span class="n">newbno2</span><span class="p">,</span> <span class="n">wantbno</span><span class="p">)))</span>
				<span class="n">newbno1</span> <span class="o">=</span> <span class="n">newbno2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">newbno2</span> <span class="o">!=</span> <span class="n">NULLAGBLOCK</span><span class="p">)</span>
			<span class="n">newbno1</span> <span class="o">=</span> <span class="n">newbno2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">freeend</span> <span class="o">&gt;=</span> <span class="n">wantend</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newbno1</span> <span class="o">=</span> <span class="n">wantbno</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">alignment</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newbno1</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">freeend</span> <span class="o">-</span> <span class="n">wantlen</span><span class="p">,</span> <span class="n">alignment</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newbno1</span> <span class="o">&gt;</span> <span class="n">freeend</span> <span class="o">-</span> <span class="n">wantlen</span> <span class="o">&amp;&amp;</span>
		    <span class="n">newbno1</span> <span class="o">-</span> <span class="n">alignment</span> <span class="o">&gt;=</span> <span class="n">freebno</span><span class="p">)</span>
			<span class="n">newbno1</span> <span class="o">-=</span> <span class="n">alignment</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">newbno1</span> <span class="o">&gt;=</span> <span class="n">freeend</span><span class="p">)</span>
			<span class="n">newbno1</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">newbno1</span> <span class="o">=</span> <span class="n">freeend</span> <span class="o">-</span> <span class="n">wantlen</span><span class="p">;</span>
	<span class="o">*</span><span class="n">newbnop</span> <span class="o">=</span> <span class="n">newbno1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">newbno1</span> <span class="o">==</span> <span class="n">NULLAGBLOCK</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">XFS_ABSDIFF</span><span class="p">(</span><span class="n">newbno1</span><span class="p">,</span> <span class="n">wantbno</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fix up the length, based on mod and prod.</span>
<span class="cm"> * len should be k * prod + mod for some k.</span>
<span class="cm"> * If len is too small it is returned unchanged.</span>
<span class="cm"> * If len hits maxlen it is left alone.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="n">xfs_alloc_fix_len</span><span class="p">(</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="o">*</span><span class="n">args</span><span class="p">)</span>		<span class="cm">/* allocation argument structure */</span>
<span class="p">{</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">k</span><span class="p">;</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">rlen</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">prod</span><span class="p">);</span>
	<span class="n">rlen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">rlen</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">rlen</span> <span class="o">&lt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">prod</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">rlen</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">||</span> <span class="n">rlen</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rlen</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">prod</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">k</span> <span class="o">=</span> <span class="n">rlen</span> <span class="o">%</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">prod</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">rlen</span> <span class="o">=</span> <span class="n">rlen</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">rlen</span> <span class="o">=</span> <span class="n">rlen</span> <span class="o">-</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">prod</span> <span class="o">-</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">-</span> <span class="n">k</span><span class="p">))</span> <span class="o">&lt;</span>
		    <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">rlen</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">rlen</span> <span class="o">&lt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">);</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">rlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fix up length if there is too little space left in the a.g.</span>
<span class="cm"> * Return 1 if ok, 0 if too little, should give up.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_alloc_fix_minleft</span><span class="p">(</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="o">*</span><span class="n">args</span><span class="p">)</span>		<span class="cm">/* allocation argument structure */</span>
<span class="p">{</span>
	<span class="n">xfs_agf_t</span>	<span class="o">*</span><span class="n">agf</span><span class="p">;</span>		<span class="cm">/* a.g. freelist header */</span>
	<span class="kt">int</span>		<span class="n">diff</span><span class="p">;</span>		<span class="cm">/* free space difference */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">minleft</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">agf</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">);</span>
	<span class="n">diff</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_freeblks</span><span class="p">)</span>
		<span class="o">-</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minleft</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>		<span class="cm">/* shrink the allocated space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the two btrees, logically removing from freespace the extent</span>
<span class="cm"> * starting at rbno, rlen blocks.  The extent is contained within the</span>
<span class="cm"> * actual (current) free extent fbno for flen blocks.</span>
<span class="cm"> * Flags are passed in indicating whether the cursors are set to the</span>
<span class="cm"> * relevant records.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error code */</span>
<span class="n">xfs_alloc_fixup_trees</span><span class="p">(</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">cnt_cur</span><span class="p">,</span>	<span class="cm">/* cursor for by-size btree */</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">bno_cur</span><span class="p">,</span>	<span class="cm">/* cursor for by-block btree */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">fbno</span><span class="p">,</span>		<span class="cm">/* starting block of free extent */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">flen</span><span class="p">,</span>		<span class="cm">/* length of free extent */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">rbno</span><span class="p">,</span>		<span class="cm">/* starting block of returned extent */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">rlen</span><span class="p">,</span>		<span class="cm">/* length of returned extent */</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">)</span>		<span class="cm">/* flags, XFSA_FIXUP_... */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error code */</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>		<span class="cm">/* operation results */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">nfbno1</span><span class="p">;</span>		<span class="cm">/* first new free startblock */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">nfbno2</span><span class="p">;</span>		<span class="cm">/* second new free startblock */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">nflen1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>	<span class="cm">/* first new free length */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">nflen2</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>	<span class="cm">/* second new free length */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look up the record in the by-size tree if necessary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFSA_FIXUP_CNT_OK</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfbno1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nflen1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span>
			<span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nfbno1</span> <span class="o">==</span> <span class="n">fbno</span> <span class="o">&amp;&amp;</span> <span class="n">nflen1</span> <span class="o">==</span> <span class="n">flen</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_eq</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">fbno</span><span class="p">,</span> <span class="n">flen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Look up the record in the by-block tree if necessary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFSA_FIXUP_BNO_OK</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfbno1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nflen1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span>
			<span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nfbno1</span> <span class="o">==</span> <span class="n">fbno</span> <span class="o">&amp;&amp;</span> <span class="n">nflen1</span> <span class="o">==</span> <span class="n">flen</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_eq</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">fbno</span><span class="p">,</span> <span class="n">flen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bno_cur</span><span class="o">-&gt;</span><span class="n">bc_nlevels</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cnt_cur</span><span class="o">-&gt;</span><span class="n">bc_nlevels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xfs_btree_block</span>	<span class="o">*</span><span class="n">bnoblock</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xfs_btree_block</span>	<span class="o">*</span><span class="n">cntblock</span><span class="p">;</span>

		<span class="n">bnoblock</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_BLOCK</span><span class="p">(</span><span class="n">bno_cur</span><span class="o">-&gt;</span><span class="n">bc_bufs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">cntblock</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_BLOCK</span><span class="p">(</span><span class="n">cnt_cur</span><span class="o">-&gt;</span><span class="n">bc_bufs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span>
			<span class="n">bnoblock</span><span class="o">-&gt;</span><span class="n">bb_numrecs</span> <span class="o">==</span> <span class="n">cntblock</span><span class="o">-&gt;</span><span class="n">bb_numrecs</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Deal with all four cases: the allocated record is contained</span>
<span class="cm">	 * within the freespace record, so we can have new freespace</span>
<span class="cm">	 * at either (or both) end, or no freespace remaining.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rbno</span> <span class="o">==</span> <span class="n">fbno</span> <span class="o">&amp;&amp;</span> <span class="n">rlen</span> <span class="o">==</span> <span class="n">flen</span><span class="p">)</span>
		<span class="n">nfbno1</span> <span class="o">=</span> <span class="n">nfbno2</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">rbno</span> <span class="o">==</span> <span class="n">fbno</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfbno1</span> <span class="o">=</span> <span class="n">rbno</span> <span class="o">+</span> <span class="n">rlen</span><span class="p">;</span>
		<span class="n">nflen1</span> <span class="o">=</span> <span class="n">flen</span> <span class="o">-</span> <span class="n">rlen</span><span class="p">;</span>
		<span class="n">nfbno2</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">rbno</span> <span class="o">+</span> <span class="n">rlen</span> <span class="o">==</span> <span class="n">fbno</span> <span class="o">+</span> <span class="n">flen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfbno1</span> <span class="o">=</span> <span class="n">fbno</span><span class="p">;</span>
		<span class="n">nflen1</span> <span class="o">=</span> <span class="n">flen</span> <span class="o">-</span> <span class="n">rlen</span><span class="p">;</span>
		<span class="n">nfbno2</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">nfbno1</span> <span class="o">=</span> <span class="n">fbno</span><span class="p">;</span>
		<span class="n">nflen1</span> <span class="o">=</span> <span class="n">rbno</span> <span class="o">-</span> <span class="n">fbno</span><span class="p">;</span>
		<span class="n">nfbno2</span> <span class="o">=</span> <span class="n">rbno</span> <span class="o">+</span> <span class="n">rlen</span><span class="p">;</span>
		<span class="n">nflen2</span> <span class="o">=</span> <span class="p">(</span><span class="n">fbno</span> <span class="o">+</span> <span class="n">flen</span><span class="p">)</span> <span class="o">-</span> <span class="n">nfbno2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Delete the entry from the by-size btree.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_delete</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Add new by-size btree entry(s).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfbno1</span> <span class="o">!=</span> <span class="n">NULLAGBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_eq</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">nfbno1</span><span class="p">,</span> <span class="n">nflen1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_insert</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfbno2</span> <span class="o">!=</span> <span class="n">NULLAGBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_eq</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">nfbno2</span><span class="p">,</span> <span class="n">nflen2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_insert</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fix up the by-block btree entry(s).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfbno1</span> <span class="o">==</span> <span class="n">NULLAGBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * No remaining freespace, just delete the by-block tree entry.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_delete</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update the by-block entry to start later|be shorter.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_update</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">nfbno1</span><span class="p">,</span> <span class="n">nflen1</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfbno2</span> <span class="o">!=</span> <span class="n">NULLAGBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * 2 resulting free entries, need to add one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_eq</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">nfbno2</span><span class="p">,</span> <span class="n">nflen2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_insert</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read in the allocation group free block array.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_alloc_read_agfl</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* mount point structure */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">,</span>		<span class="cm">/* allocation group number */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">bpp</span><span class="p">)</span>		<span class="cm">/* buffer for the ag free block array */</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* return value */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">agno</span> <span class="o">!=</span> <span class="n">NULLAGNUMBER</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_read_buf</span><span class="p">(</span>
			<span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span>
			<span class="n">XFS_AG_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">XFS_AGFL_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">)),</span>
			<span class="n">XFS_FSS_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">xfs_buf_geterror</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
	<span class="n">xfs_buf_set_ref</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_AGFL_REF</span><span class="p">);</span>
	<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_alloc_update_counters</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span>	<span class="o">*</span><span class="n">pag</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">agbp</span><span class="p">,</span>
	<span class="kt">long</span>			<span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_agf</span>		<span class="o">*</span><span class="n">agf</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="n">agbp</span><span class="p">);</span>

	<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_freeblks</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_freeblks</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">xfs_trans_agblocks_delta</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_freeblks</span><span class="p">)</span> <span class="o">&gt;</span>
		     <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_length</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">EFSCORRUPTED</span><span class="p">;</span>

	<span class="n">xfs_alloc_log_agf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">XFS_AGF_FREEBLKS</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocation group level functions.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a variable extent in the allocation group agno.</span>
<span class="cm"> * Type and bno are used to determine where in the allocation group the</span>
<span class="cm"> * extent will start.</span>
<span class="cm"> * Extent&#39;s length (returned in *len) will be between minlen and maxlen,</span>
<span class="cm"> * and of the form k * prod + mod unless there&#39;s nothing that large.</span>
<span class="cm"> * Return the starting a.g. block, or NULLAGBLOCK if we can&#39;t do it.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>			<span class="cm">/* error */</span>
<span class="n">xfs_alloc_ag_vextent</span><span class="p">(</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="o">*</span><span class="n">args</span><span class="p">)</span>	<span class="cm">/* argument structure for allocation */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span> <span class="o">&lt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">prod</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Branch to correct routine based on the type.</span>
<span class="cm">	 */</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">wasfromfl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_ALLOCTYPE_THIS_AG</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_ag_vextent_size</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_ALLOCTYPE_NEAR_BNO</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_ag_vextent_near</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_ALLOCTYPE_THIS_BNO</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_ag_vextent_exact</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* NOTREACHED */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">||</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">==</span> <span class="n">NULLAGBLOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">wasfromfl</span> <span class="o">||</span> <span class="o">!</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">isfl</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">%</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">wasfromfl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_update_counters</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pag</span><span class="p">,</span>
						  <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">,</span>
						  <span class="o">-</span><span class="p">((</span><span class="kt">long</span><span class="p">)(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">xfs_extent_busy_search</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span>
					      <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">isfl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">wasdel</span> <span class="o">?</span>
				 <span class="n">XFS_TRANS_SB_RES_FDBLOCKS</span> <span class="o">:</span>
				 <span class="n">XFS_TRANS_SB_FDBLOCKS</span><span class="p">,</span>
				 <span class="o">-</span><span class="p">((</span><span class="kt">long</span><span class="p">)(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)));</span>
	<span class="p">}</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_allocx</span><span class="p">);</span>
	<span class="n">XFS_STATS_ADD</span><span class="p">(</span><span class="n">xs_allocb</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a variable extent at exactly agno/bno.</span>
<span class="cm"> * Extent&#39;s length (returned in *len) will be between minlen and maxlen,</span>
<span class="cm"> * and of the form k * prod + mod unless there&#39;s nothing that large.</span>
<span class="cm"> * Return the starting a.g. block (bno), or NULLAGBLOCK if we can&#39;t do it.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>			<span class="cm">/* error */</span>
<span class="n">xfs_alloc_ag_vextent_exact</span><span class="p">(</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="o">*</span><span class="n">args</span><span class="p">)</span>	<span class="cm">/* allocation argument structure */</span>
<span class="p">{</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">bno_cur</span><span class="p">;</span><span class="cm">/* by block-number btree cursor */</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">cnt_cur</span><span class="p">;</span><span class="cm">/* by count btree cursor */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">fbno</span><span class="p">;</span>	<span class="cm">/* start block of found extent */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">flen</span><span class="p">;</span>	<span class="cm">/* length of found extent */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">tbno</span><span class="p">;</span>	<span class="cm">/* start block of trimmed extent */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">tlen</span><span class="p">;</span>	<span class="cm">/* length of trimmed extent */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">tend</span><span class="p">;</span>	<span class="cm">/* end block of trimmed extent */</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>	<span class="cm">/* success/failure of operation */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate/initialize a cursor for the by-number freespace btree.</span>
<span class="cm">	 */</span>
	<span class="n">bno_cur</span> <span class="o">=</span> <span class="n">xfs_allocbt_init_cursor</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">,</span>
					  <span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span> <span class="n">XFS_BTNUM_BNO</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lookup bno and minlen in the btree (minlen is irrelevant, really).</span>
<span class="cm">	 * Look for the closest free block &lt;= bno, it must contain bno</span>
<span class="cm">	 * if any free block does.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_le</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Grab the freespace record.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">fbno</span> <span class="o">&lt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for overlapping busy extents.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_extent_busy_trim</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fbno</span><span class="p">,</span> <span class="n">flen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tlen</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Give up if the start of the extent is busy, or the freespace isn&#39;t</span>
<span class="cm">	 * long enough for the minimum request.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tbno</span> <span class="o">&gt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlen</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>
	<span class="n">tend</span> <span class="o">=</span> <span class="n">tbno</span> <span class="o">+</span> <span class="n">tlen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tend</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">+</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * End of extent will be smaller of the freespace end and the</span>
<span class="cm">	 * maximal requested end.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Fix the length according to mod and prod if given.</span>
<span class="cm">	 */</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">XFS_AGBLOCK_MIN</span><span class="p">(</span><span class="n">tend</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">+</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">)</span>
						<span class="o">-</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span><span class="p">;</span>
	<span class="n">xfs_alloc_fix_len</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_alloc_fix_minleft</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">+</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">tend</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are allocating agbno for args-&gt;len</span>
<span class="cm">	 * Allocate/initialize a cursor for the by-size btree.</span>
<span class="cm">	 */</span>
	<span class="n">cnt_cur</span> <span class="o">=</span> <span class="n">xfs_allocbt_init_cursor</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">,</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span> <span class="n">XFS_BTNUM_CNT</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">+</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span>
		<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">agf_length</span><span class="p">));</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_fixup_trees</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">bno_cur</span><span class="p">,</span> <span class="n">fbno</span><span class="p">,</span> <span class="n">flen</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span><span class="p">,</span>
				      <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">XFSA_FIXUP_BNO_OK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_ERROR</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>

	<span class="n">args</span><span class="o">-&gt;</span><span class="n">wasfromfl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">trace_xfs_alloc_exact_done</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">not_found:</span>
	<span class="cm">/* Didn&#39;t find it, return null. */</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
	<span class="n">trace_xfs_alloc_exact_notfound</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error0:</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_ERROR</span><span class="p">);</span>
	<span class="n">trace_xfs_alloc_exact_error</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Search the btree in a given direction via the search cursor and compare</span>
<span class="cm"> * the records found against the good extent we&#39;ve already found.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_alloc_find_best_extent</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_alloc_arg</span>	<span class="o">*</span><span class="n">args</span><span class="p">,</span>	<span class="cm">/* allocation argument structure */</span>
	<span class="k">struct</span> <span class="n">xfs_btree_cur</span>	<span class="o">**</span><span class="n">gcur</span><span class="p">,</span>	<span class="cm">/* good cursor */</span>
	<span class="k">struct</span> <span class="n">xfs_btree_cur</span>	<span class="o">**</span><span class="n">scur</span><span class="p">,</span>	<span class="cm">/* searching cursor */</span>
	<span class="n">xfs_agblock_t</span>		<span class="n">gdiff</span><span class="p">,</span>	<span class="cm">/* difference for search comparison */</span>
	<span class="n">xfs_agblock_t</span>		<span class="o">*</span><span class="n">sbno</span><span class="p">,</span>	<span class="cm">/* extent found by search */</span>
	<span class="n">xfs_extlen_t</span>		<span class="o">*</span><span class="n">slen</span><span class="p">,</span>	<span class="cm">/* extent length */</span>
	<span class="n">xfs_agblock_t</span>		<span class="o">*</span><span class="n">sbnoa</span><span class="p">,</span>	<span class="cm">/* aligned extent found by search */</span>
	<span class="n">xfs_extlen_t</span>		<span class="o">*</span><span class="n">slena</span><span class="p">,</span>	<span class="cm">/* aligned extent length */</span>
	<span class="kt">int</span>			<span class="n">dir</span><span class="p">)</span>	<span class="cm">/* 0 = search right, 1 = search left */</span>
<span class="p">{</span>
	<span class="n">xfs_agblock_t</span>		<span class="n">new</span><span class="p">;</span>
	<span class="n">xfs_agblock_t</span>		<span class="n">sdiff</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="cm">/* The good extent is perfect, no need to  search. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gdiff</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_use_good</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look until we find a better one, run out of space or run off the end.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="o">*</span><span class="n">scur</span><span class="p">,</span> <span class="n">sbno</span><span class="p">,</span> <span class="n">slen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="n">xfs_alloc_compute_aligned</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="n">sbno</span><span class="p">,</span> <span class="o">*</span><span class="n">slen</span><span class="p">,</span> <span class="n">sbnoa</span><span class="p">,</span> <span class="n">slena</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The good extent is closer than this one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">sbnoa</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">+</span> <span class="n">gdiff</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_use_good</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">sbnoa</span> <span class="o">&lt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">-</span> <span class="n">gdiff</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_use_good</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Same distance, compare length and pick the best.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">slena</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">XFS_EXTLEN_MIN</span><span class="p">(</span><span class="o">*</span><span class="n">slena</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">);</span>
			<span class="n">xfs_alloc_fix_len</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

			<span class="n">sdiff</span> <span class="o">=</span> <span class="n">xfs_alloc_compute_diff</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
						       <span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span><span class="p">,</span> <span class="o">*</span><span class="n">sbnoa</span><span class="p">,</span>
						       <span class="o">*</span><span class="n">slena</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Choose closer size and invalidate other cursor.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sdiff</span> <span class="o">&lt;</span> <span class="n">gdiff</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_use_search</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_use_good</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_increment</span><span class="p">(</span><span class="o">*</span><span class="n">scur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_decrement</span><span class="p">(</span><span class="o">*</span><span class="n">scur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>

<span class="nl">out_use_good:</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="o">*</span><span class="n">scur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="o">*</span><span class="n">scur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_use_search:</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="o">*</span><span class="n">gcur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="o">*</span><span class="n">gcur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error0:</span>
	<span class="cm">/* caller invalidates cursors */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a variable extent near bno in the allocation group agno.</span>
<span class="cm"> * Extent&#39;s length (returned in len) will be between minlen and maxlen,</span>
<span class="cm"> * and of the form k * prod + mod unless there&#39;s nothing that large.</span>
<span class="cm"> * Return the starting a.g. block, or NULLAGBLOCK if we can&#39;t do it.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_alloc_ag_vextent_near</span><span class="p">(</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="o">*</span><span class="n">args</span><span class="p">)</span>		<span class="cm">/* allocation argument structure */</span>
<span class="p">{</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">bno_cur_gt</span><span class="p">;</span>	<span class="cm">/* cursor for bno btree, right side */</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">bno_cur_lt</span><span class="p">;</span>	<span class="cm">/* cursor for bno btree, left side */</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">cnt_cur</span><span class="p">;</span>	<span class="cm">/* cursor for count btree */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">gtbno</span><span class="p">;</span>		<span class="cm">/* start bno of right side entry */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">gtbnoa</span><span class="p">;</span>		<span class="cm">/* aligned ... */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">gtdiff</span><span class="p">;</span>		<span class="cm">/* difference to right side entry */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">gtlen</span><span class="p">;</span>		<span class="cm">/* length of right side entry */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">gtlena</span><span class="p">;</span>		<span class="cm">/* aligned ... */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">gtnew</span><span class="p">;</span>		<span class="cm">/* useful start bno of right side */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error code */</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>		<span class="cm">/* result code, temporary */</span>
	<span class="kt">int</span>		<span class="n">j</span><span class="p">;</span>		<span class="cm">/* result code, temporary */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">ltbno</span><span class="p">;</span>		<span class="cm">/* start bno of left side entry */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">ltbnoa</span><span class="p">;</span>		<span class="cm">/* aligned ... */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">ltdiff</span><span class="p">;</span>		<span class="cm">/* difference to left side entry */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">ltlen</span><span class="p">;</span>		<span class="cm">/* length of left side entry */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">ltlena</span><span class="p">;</span>		<span class="cm">/* aligned ... */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">ltnew</span><span class="p">;</span>		<span class="cm">/* useful start bno of left side */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">rlen</span><span class="p">;</span>		<span class="cm">/* length of returned extent */</span>
	<span class="kt">int</span>		<span class="n">forced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#if defined(DEBUG) &amp;&amp; defined(__KERNEL__)</span>
	<span class="cm">/*</span>
<span class="cm">	 * Randomly don&#39;t execute the first algorithm.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>		<span class="n">dofirst</span><span class="p">;</span>	<span class="cm">/* set to do first algorithm */</span>

	<span class="n">dofirst</span> <span class="o">=</span> <span class="n">random32</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="nl">restart:</span>
	<span class="n">bno_cur_lt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bno_cur_gt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ltlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">gtlena</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ltlena</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get a cursor for the by-size btree.</span>
<span class="cm">	 */</span>
	<span class="n">cnt_cur</span> <span class="o">=</span> <span class="n">xfs_allocbt_init_cursor</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">,</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span> <span class="n">XFS_BTNUM_CNT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if there are any free extents as big as maxlen.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_ge</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If none, then pick up the last entry in the tree unless the</span>
<span class="cm">	 * tree is empty.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_ag_vextent_small</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltbno</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">ltlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ltlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
			<span class="n">trace_xfs_alloc_near_noentry</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">wasfromfl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First algorithm.</span>
<span class="cm">	 * If the requested extent is large wrt the freespaces available</span>
<span class="cm">	 * in this a.g., then the cursor will be pointing to a btree entry</span>
<span class="cm">	 * near the right edge of the tree.  If it&#39;s in the last btree leaf</span>
<span class="cm">	 * block, then we just examine all the entries in that block</span>
<span class="cm">	 * that are big enough, and pick the best one.</span>
<span class="cm">	 * This is written as a while loop so we can break out of it,</span>
<span class="cm">	 * but we never loop back to the top.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">xfs_btree_islastblock</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_extlen_t</span>	<span class="n">bdiff</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">besti</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">xfs_extlen_t</span>	<span class="n">blen</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">xfs_agblock_t</span>	<span class="n">bnew</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

<span class="cp">#if defined(DEBUG) &amp;&amp; defined(__KERNEL__)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dofirst</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="cm">/*</span>
<span class="cm">		 * Start from the entry that lookup found, sequence through</span>
<span class="cm">		 * all larger free blocks.  If we&#39;re actually pointing at a</span>
<span class="cm">		 * record smaller than maxlen, go to the start of this block,</span>
<span class="cm">		 * and skip all those smaller than minlen.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ltlen</span> <span class="o">||</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cnt_cur</span><span class="o">-&gt;</span><span class="n">bc_ptrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltbno</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">ltlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
					<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
				<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ltlen</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_increment</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
					<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">ltlen</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">cnt_cur</span><span class="o">-&gt;</span><span class="n">bc_ptrs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bdiff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">blen</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span> <span class="o">||</span> <span class="n">bdiff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		     <span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_increment</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">j</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * For each entry, decide if it&#39;s better than</span>
<span class="cm">			 * the previous best entry.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
			<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
			<span class="n">xfs_alloc_compute_aligned</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ltbno</span><span class="p">,</span> <span class="n">ltlen</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">ltbnoa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltlena</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ltlena</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">XFS_EXTLEN_MIN</span><span class="p">(</span><span class="n">ltlena</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">);</span>
			<span class="n">xfs_alloc_fix_len</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">blen</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">ltdiff</span> <span class="o">=</span> <span class="n">xfs_alloc_compute_diff</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span><span class="p">,</span> <span class="n">ltbnoa</span><span class="p">,</span> <span class="n">ltlena</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltnew</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ltnew</span> <span class="o">!=</span> <span class="n">NULLAGBLOCK</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">blen</span> <span class="o">||</span> <span class="n">ltdiff</span> <span class="o">&lt;</span> <span class="n">bdiff</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">bdiff</span> <span class="o">=</span> <span class="n">ltdiff</span><span class="p">;</span>
				<span class="n">bnew</span> <span class="o">=</span> <span class="n">ltnew</span><span class="p">;</span>
				<span class="n">blen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
				<span class="n">besti</span> <span class="o">=</span> <span class="n">cnt_cur</span><span class="o">-&gt;</span><span class="n">bc_ptrs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * It didn&#39;t work.  We COULD be in a case where</span>
<span class="cm">		 * there&#39;s a good record somewhere, so try again.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Point at the best entry, and retrieve it again.</span>
<span class="cm">		 */</span>
		<span class="n">cnt_cur</span><span class="o">-&gt;</span><span class="n">bc_ptrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">besti</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ltbno</span> <span class="o">+</span> <span class="n">ltlen</span> <span class="o">&lt;=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">agf_length</span><span class="p">));</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">blen</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_alloc_fix_minleft</span><span class="p">(</span><span class="n">args</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
			<span class="n">trace_xfs_alloc_near_nominleft</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">blen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are allocating starting at bnew for blen blocks.</span>
<span class="cm">		 */</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">bnew</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">bnew</span> <span class="o">&gt;=</span> <span class="n">ltbno</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">bnew</span> <span class="o">+</span> <span class="n">blen</span> <span class="o">&lt;=</span> <span class="n">ltbno</span> <span class="o">+</span> <span class="n">ltlen</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set up a cursor for the by-bno tree.</span>
<span class="cm">		 */</span>
		<span class="n">bno_cur_lt</span> <span class="o">=</span> <span class="n">xfs_allocbt_init_cursor</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">,</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span> <span class="n">XFS_BTNUM_BNO</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Fix up the btree entries.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_fixup_trees</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">bno_cur_lt</span><span class="p">,</span> <span class="n">ltbno</span><span class="p">,</span>
				<span class="n">ltlen</span><span class="p">,</span> <span class="n">bnew</span><span class="p">,</span> <span class="n">blen</span><span class="p">,</span> <span class="n">XFSA_FIXUP_CNT_OK</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur_lt</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>

		<span class="n">trace_xfs_alloc_near_first</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Second algorithm.</span>
<span class="cm">	 * Search in the by-bno tree to the left and to the right</span>
<span class="cm">	 * simultaneously, until in each case we find a space big enough,</span>
<span class="cm">	 * or run into the edge of the tree.  When we run into the edge,</span>
<span class="cm">	 * we deallocate that cursor.</span>
<span class="cm">	 * If both searches succeed, we compare the two spaces and pick</span>
<span class="cm">	 * the better one.</span>
<span class="cm">	 * With alignment, it&#39;s possible for both to fail; the upper</span>
<span class="cm">	 * level algorithm that picks allocation groups for allocations</span>
<span class="cm">	 * is not supposed to do this.</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocate and initialize the cursor for the leftward search.</span>
<span class="cm">	 */</span>
	<span class="n">bno_cur_lt</span> <span class="o">=</span> <span class="n">xfs_allocbt_init_cursor</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">,</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span> <span class="n">XFS_BTNUM_BNO</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Lookup &lt;= bno to find the leftward search&#39;s starting point.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_le</span><span class="p">(</span><span class="n">bno_cur_lt</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Didn&#39;t find anything; use this cursor for the rightward</span>
<span class="cm">		 * search.</span>
<span class="cm">		 */</span>
		<span class="n">bno_cur_gt</span> <span class="o">=</span> <span class="n">bno_cur_lt</span><span class="p">;</span>
		<span class="n">bno_cur_lt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Found something.  Duplicate the cursor for the rightward search.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_dup_cursor</span><span class="p">(</span><span class="n">bno_cur_lt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bno_cur_gt</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Increment the cursor, so we will point at the entry just right</span>
<span class="cm">	 * of the leftward entry if any, or to the leftmost entry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_increment</span><span class="p">(</span><span class="n">bno_cur_gt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * It failed, there are no rightward entries.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur_gt</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
		<span class="n">bno_cur_gt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Loop going left with the leftward cursor, right with the</span>
<span class="cm">	 * rightward cursor, until either both directions give up or</span>
<span class="cm">	 * we find an entry at least as big as minlen.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bno_cur_lt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="n">bno_cur_lt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
			<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
			<span class="n">xfs_alloc_compute_aligned</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ltbno</span><span class="p">,</span> <span class="n">ltlen</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">ltbnoa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltlena</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ltlena</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_decrement</span><span class="p">(</span><span class="n">bno_cur_lt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur_lt</span><span class="p">,</span>
						     <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
				<span class="n">bno_cur_lt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bno_cur_gt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="n">bno_cur_gt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gtbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gtlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
			<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
			<span class="n">xfs_alloc_compute_aligned</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">gtbno</span><span class="p">,</span> <span class="n">gtlen</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">gtbnoa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gtlena</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">gtlena</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_increment</span><span class="p">(</span><span class="n">bno_cur_gt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur_gt</span><span class="p">,</span>
						     <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
				<span class="n">bno_cur_gt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bno_cur_lt</span> <span class="o">||</span> <span class="n">bno_cur_gt</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Got both cursors still active, need to find better entry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bno_cur_lt</span> <span class="o">&amp;&amp;</span> <span class="n">bno_cur_gt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ltlena</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Left side is good, look for a right side entry.</span>
<span class="cm">			 */</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">XFS_EXTLEN_MIN</span><span class="p">(</span><span class="n">ltlena</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">);</span>
			<span class="n">xfs_alloc_fix_len</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
			<span class="n">ltdiff</span> <span class="o">=</span> <span class="n">xfs_alloc_compute_diff</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span><span class="p">,</span> <span class="n">ltbnoa</span><span class="p">,</span> <span class="n">ltlena</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltnew</span><span class="p">);</span>

			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_find_best_extent</span><span class="p">(</span><span class="n">args</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">bno_cur_lt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bno_cur_gt</span><span class="p">,</span>
						<span class="n">ltdiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gtbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gtlen</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">gtbnoa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gtlena</span><span class="p">,</span>
						<span class="mi">0</span> <span class="cm">/* search right */</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">gtlena</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Right side is good, look for a left side entry.</span>
<span class="cm">			 */</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">XFS_EXTLEN_MIN</span><span class="p">(</span><span class="n">gtlena</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">);</span>
			<span class="n">xfs_alloc_fix_len</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
			<span class="n">gtdiff</span> <span class="o">=</span> <span class="n">xfs_alloc_compute_diff</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span><span class="p">,</span> <span class="n">gtbnoa</span><span class="p">,</span> <span class="n">gtlena</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gtnew</span><span class="p">);</span>

			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_find_best_extent</span><span class="p">(</span><span class="n">args</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">bno_cur_gt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bno_cur_lt</span><span class="p">,</span>
						<span class="n">gtdiff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltlen</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">ltbnoa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltlena</span><span class="p">,</span>
						<span class="mi">1</span> <span class="cm">/* search left */</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we couldn&#39;t get anything, give up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bno_cur_lt</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">bno_cur_gt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">forced</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trace_xfs_alloc_near_busy</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
			<span class="n">xfs_log_force</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_LOG_SYNC</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
		<span class="n">trace_xfs_alloc_size_neither</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point we have selected a freespace entry, either to the</span>
<span class="cm">	 * left or to the right.  If it&#39;s on the right, copy all the</span>
<span class="cm">	 * useful variables to the &quot;left&quot; set so we only have one</span>
<span class="cm">	 * copy of this code.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bno_cur_gt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bno_cur_lt</span> <span class="o">=</span> <span class="n">bno_cur_gt</span><span class="p">;</span>
		<span class="n">bno_cur_gt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ltbno</span> <span class="o">=</span> <span class="n">gtbno</span><span class="p">;</span>
		<span class="n">ltbnoa</span> <span class="o">=</span> <span class="n">gtbnoa</span><span class="p">;</span>
		<span class="n">ltlen</span> <span class="o">=</span> <span class="n">gtlen</span><span class="p">;</span>
		<span class="n">ltlena</span> <span class="o">=</span> <span class="n">gtlena</span><span class="p">;</span>
		<span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fix up the length and compute the useful address.</span>
<span class="cm">	 */</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">XFS_EXTLEN_MIN</span><span class="p">(</span><span class="n">ltlena</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">);</span>
	<span class="n">xfs_alloc_fix_len</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_alloc_fix_minleft</span><span class="p">(</span><span class="n">args</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trace_xfs_alloc_near_nominleft</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur_lt</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rlen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">xfs_alloc_compute_diff</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span><span class="p">,</span> <span class="n">rlen</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span><span class="p">,</span>
				     <span class="n">ltbnoa</span><span class="p">,</span> <span class="n">ltlena</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltnew</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ltnew</span> <span class="o">&gt;=</span> <span class="n">ltbno</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ltnew</span> <span class="o">+</span> <span class="n">rlen</span> <span class="o">&lt;=</span> <span class="n">ltbnoa</span> <span class="o">+</span> <span class="n">ltlena</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ltnew</span> <span class="o">+</span> <span class="n">rlen</span> <span class="o">&lt;=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">agf_length</span><span class="p">));</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">ltnew</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_fixup_trees</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">bno_cur_lt</span><span class="p">,</span> <span class="n">ltbno</span><span class="p">,</span> <span class="n">ltlen</span><span class="p">,</span>
			<span class="n">ltnew</span><span class="p">,</span> <span class="n">rlen</span><span class="p">,</span> <span class="n">XFSA_FIXUP_BNO_OK</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="p">)</span>
		<span class="n">trace_xfs_alloc_near_greater</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">trace_xfs_alloc_near_lesser</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur_lt</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">error0:</span>
	<span class="n">trace_xfs_alloc_near_error</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt_cur</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_ERROR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bno_cur_lt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur_lt</span><span class="p">,</span> <span class="n">XFS_BTREE_ERROR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bno_cur_gt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur_gt</span><span class="p">,</span> <span class="n">XFS_BTREE_ERROR</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a variable extent anywhere in the allocation group agno.</span>
<span class="cm"> * Extent&#39;s length (returned in len) will be between minlen and maxlen,</span>
<span class="cm"> * and of the form k * prod + mod unless there&#39;s nothing that large.</span>
<span class="cm"> * Return the starting a.g. block, or NULLAGBLOCK if we can&#39;t do it.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_alloc_ag_vextent_size</span><span class="p">(</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="o">*</span><span class="n">args</span><span class="p">)</span>		<span class="cm">/* allocation argument structure */</span>
<span class="p">{</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">bno_cur</span><span class="p">;</span>	<span class="cm">/* cursor for bno btree */</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">cnt_cur</span><span class="p">;</span>	<span class="cm">/* cursor for cnt btree */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error result */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">fbno</span><span class="p">;</span>		<span class="cm">/* start of found freespace */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">flen</span><span class="p">;</span>		<span class="cm">/* length of found freespace */</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>		<span class="cm">/* temp status variable */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">rbno</span><span class="p">;</span>		<span class="cm">/* returned block number */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">rlen</span><span class="p">;</span>		<span class="cm">/* length of returned extent */</span>
	<span class="kt">int</span>		<span class="n">forced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocate and initialize a cursor for the by-size btree.</span>
<span class="cm">	 */</span>
	<span class="n">cnt_cur</span> <span class="o">=</span> <span class="n">xfs_allocbt_init_cursor</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">,</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span> <span class="n">XFS_BTNUM_CNT</span><span class="p">);</span>
	<span class="n">bno_cur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look for an entry &gt;= maxlen+alignment-1 blocks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_ge</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span> <span class="o">+</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If none or we have busy extents that we cannot allocate from, then</span>
<span class="cm">	 * we have to settle for a smaller extent. In the case that there are</span>
<span class="cm">	 * no large extents, this will return the last entry in the tree unless</span>
<span class="cm">	 * the tree is empty. In the case that there are only busy large</span>
<span class="cm">	 * extents, this will return the largest small extent unless there</span>
<span class="cm">	 * are no smaller extents available.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span> <span class="o">||</span> <span class="n">forced</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_ag_vextent_small</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">cnt_cur</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">fbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">flen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
			<span class="n">trace_xfs_alloc_size_noentry</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">xfs_alloc_compute_aligned</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fbno</span><span class="p">,</span> <span class="n">flen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rlen</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Search for a non-busy extent that is large enough.</span>
<span class="cm">		 * If we are at low space, don&#39;t check, or if we fall of</span>
<span class="cm">		 * the end of the btree, turn off the busy check and</span>
<span class="cm">		 * restart.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
			<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>

			<span class="n">xfs_alloc_compute_aligned</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fbno</span><span class="p">,</span> <span class="n">flen</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">rbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rlen</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">rlen</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_increment</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Our only valid extents must have been busy.</span>
<span class="cm">				 * Make it unbusy by forcing the log out and</span>
<span class="cm">				 * retrying. If we&#39;ve been here before, forcing</span>
<span class="cm">				 * the log isn&#39;t making the extents available,</span>
<span class="cm">				 * which means they have probably been freed in</span>
<span class="cm">				 * this transaction.  In that case, we have to</span>
<span class="cm">				 * give up on them and we&#39;ll attempt a minlen</span>
<span class="cm">				 * allocation the next time around.</span>
<span class="cm">				 */</span>
				<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span>
						     <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
				<span class="n">trace_xfs_alloc_size_busy</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">forced</span><span class="o">++</span><span class="p">)</span>
					<span class="n">xfs_log_force</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_LOG_SYNC</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * In the first case above, we got the last entry in the</span>
<span class="cm">	 * by-size btree.  Now we check to see if the space hits maxlen</span>
<span class="cm">	 * once aligned; if not, we search left for something better.</span>
<span class="cm">	 * This can&#39;t happen in the second case above.</span>
<span class="cm">	 */</span>
	<span class="n">rlen</span> <span class="o">=</span> <span class="n">XFS_EXTLEN_MIN</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">,</span> <span class="n">rlen</span><span class="p">);</span>
	<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">rlen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">rlen</span> <span class="o">&lt;=</span> <span class="n">flen</span> <span class="o">&amp;&amp;</span> <span class="n">rbno</span> <span class="o">+</span> <span class="n">rlen</span> <span class="o">&lt;=</span> <span class="n">fbno</span> <span class="o">+</span> <span class="n">flen</span><span class="p">),</span> <span class="n">error0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rlen</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_agblock_t</span>	<span class="n">bestfbno</span><span class="p">;</span>
		<span class="n">xfs_extlen_t</span>	<span class="n">bestflen</span><span class="p">;</span>
		<span class="n">xfs_agblock_t</span>	<span class="n">bestrbno</span><span class="p">;</span>
		<span class="n">xfs_extlen_t</span>	<span class="n">bestrlen</span><span class="p">;</span>

		<span class="n">bestrlen</span> <span class="o">=</span> <span class="n">rlen</span><span class="p">;</span>
		<span class="n">bestrbno</span> <span class="o">=</span> <span class="n">rbno</span><span class="p">;</span>
		<span class="n">bestflen</span> <span class="o">=</span> <span class="n">flen</span><span class="p">;</span>
		<span class="n">bestfbno</span> <span class="o">=</span> <span class="n">fbno</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_decrement</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flen</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
			<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flen</span> <span class="o">&lt;</span> <span class="n">bestrlen</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">xfs_alloc_compute_aligned</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fbno</span><span class="p">,</span> <span class="n">flen</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">rbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rlen</span><span class="p">);</span>
			<span class="n">rlen</span> <span class="o">=</span> <span class="n">XFS_EXTLEN_MIN</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">,</span> <span class="n">rlen</span><span class="p">);</span>
			<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">rlen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">rlen</span> <span class="o">&lt;=</span> <span class="n">flen</span> <span class="o">&amp;&amp;</span> <span class="n">rbno</span> <span class="o">+</span> <span class="n">rlen</span> <span class="o">&lt;=</span> <span class="n">fbno</span> <span class="o">+</span> <span class="n">flen</span><span class="p">),</span>
				<span class="n">error0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rlen</span> <span class="o">&gt;</span> <span class="n">bestrlen</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bestrlen</span> <span class="o">=</span> <span class="n">rlen</span><span class="p">;</span>
				<span class="n">bestrbno</span> <span class="o">=</span> <span class="n">rbno</span><span class="p">;</span>
				<span class="n">bestflen</span> <span class="o">=</span> <span class="n">flen</span><span class="p">;</span>
				<span class="n">bestfbno</span> <span class="o">=</span> <span class="n">fbno</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rlen</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_eq</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">bestfbno</span><span class="p">,</span> <span class="n">bestflen</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="n">rlen</span> <span class="o">=</span> <span class="n">bestrlen</span><span class="p">;</span>
		<span class="n">rbno</span> <span class="o">=</span> <span class="n">bestrbno</span><span class="p">;</span>
		<span class="n">flen</span> <span class="o">=</span> <span class="n">bestflen</span><span class="p">;</span>
		<span class="n">fbno</span> <span class="o">=</span> <span class="n">bestfbno</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">wasfromfl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fix up the length.</span>
<span class="cm">	 */</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">rlen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rlen</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">forced</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
			<span class="n">trace_xfs_alloc_size_busy</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
			<span class="n">xfs_log_force</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_LOG_SYNC</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out_nominleft</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_alloc_fix_len</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_alloc_fix_minleft</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_nominleft</span><span class="p">;</span>
	<span class="n">rlen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">rlen</span> <span class="o">&lt;=</span> <span class="n">flen</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocate and initialize a cursor for the by-block tree.</span>
<span class="cm">	 */</span>
	<span class="n">bno_cur</span> <span class="o">=</span> <span class="n">xfs_allocbt_init_cursor</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">,</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span> <span class="n">XFS_BTNUM_BNO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_fixup_trees</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">bno_cur</span><span class="p">,</span> <span class="n">fbno</span><span class="p">,</span> <span class="n">flen</span><span class="p">,</span>
			<span class="n">rbno</span><span class="p">,</span> <span class="n">rlen</span><span class="p">,</span> <span class="n">XFSA_FIXUP_CNT_OK</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="n">cnt_cur</span> <span class="o">=</span> <span class="n">bno_cur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">rlen</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">rbno</span><span class="p">;</span>
	<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">+</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">agf_length</span><span class="p">),</span>
		<span class="n">error0</span><span class="p">);</span>
	<span class="n">trace_xfs_alloc_size_done</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error0:</span>
	<span class="n">trace_xfs_alloc_size_error</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt_cur</span><span class="p">)</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_ERROR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bno_cur</span><span class="p">)</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_ERROR</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">out_nominleft:</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="n">trace_xfs_alloc_size_nominleft</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Deal with the case where only small freespaces remain.</span>
<span class="cm"> * Either return the contents of the last freespace record,</span>
<span class="cm"> * or allocate space from the freelist if there is nothing in the tree.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>			<span class="cm">/* error */</span>
<span class="n">xfs_alloc_ag_vextent_small</span><span class="p">(</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="o">*</span><span class="n">args</span><span class="p">,</span>	<span class="cm">/* allocation argument structure */</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">ccur</span><span class="p">,</span>	<span class="cm">/* by-size cursor */</span>
	<span class="n">xfs_agblock_t</span>	<span class="o">*</span><span class="n">fbnop</span><span class="p">,</span>	<span class="cm">/* result block number */</span>
	<span class="n">xfs_extlen_t</span>	<span class="o">*</span><span class="n">flenp</span><span class="p">,</span>	<span class="cm">/* result length */</span>
	<span class="kt">int</span>		<span class="o">*</span><span class="n">stat</span><span class="p">)</span>	<span class="cm">/* status: 0-freelist, 1-normal/none */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">fbno</span><span class="p">;</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">flen</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_decrement</span><span class="p">(</span><span class="n">ccur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="n">ccur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Nothing in the btree, try the freelist.  Make sure</span>
<span class="cm">	 * to respect minleft even when pulling from the</span>
<span class="cm">	 * freelist.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">isfl</span> <span class="o">&amp;&amp;</span>
		 <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">)</span>
		  <span class="o">&gt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minleft</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_freelist</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbno</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fbno</span> <span class="o">!=</span> <span class="n">NULLAGBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_extent_busy_reuse</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span> <span class="n">fbno</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					     <span class="n">args</span><span class="o">-&gt;</span><span class="n">userdata</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">userdata</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>

				<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_btree_get_bufs</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">,</span>
					<span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span> <span class="n">fbno</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">xfs_trans_binval</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">fbno</span><span class="p">;</span>
			<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span>
				<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">+</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span>
				<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">agf_length</span><span class="p">),</span>
				<span class="n">error0</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">wasfromfl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">trace_xfs_alloc_small_freelist</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
			<span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Nothing in the freelist.</span>
<span class="cm">		 */</span>
		<span class="k">else</span>
			<span class="n">flen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Can&#39;t allocate from the freelist for some reason.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">fbno</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
		<span class="n">flen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Can&#39;t do the allocation, give up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flen</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
		<span class="n">trace_xfs_alloc_small_notenough</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="n">flen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">fbnop</span> <span class="o">=</span> <span class="n">fbno</span><span class="p">;</span>
	<span class="o">*</span><span class="n">flenp</span> <span class="o">=</span> <span class="n">flen</span><span class="p">;</span>
	<span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">trace_xfs_alloc_small_done</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error0:</span>
	<span class="n">trace_xfs_alloc_small_error</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free the extent starting at agno/bno for length.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>			<span class="cm">/* error */</span>
<span class="n">xfs_free_ag_extent</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>	<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agbp</span><span class="p">,</span>	<span class="cm">/* buffer for a.g. freelist header */</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">,</span>	<span class="cm">/* allocation group number */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">bno</span><span class="p">,</span>	<span class="cm">/* starting block number */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">len</span><span class="p">,</span>	<span class="cm">/* length of extent */</span>
	<span class="kt">int</span>		<span class="n">isfl</span><span class="p">)</span>	<span class="cm">/* set if is freelist blocks - no sb acctg */</span>
<span class="p">{</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">bno_cur</span><span class="p">;</span>	<span class="cm">/* cursor for by-block btree */</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">cnt_cur</span><span class="p">;</span>	<span class="cm">/* cursor for by-size btree */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">gtbno</span><span class="p">;</span>		<span class="cm">/* start of right neighbor block */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">gtlen</span><span class="p">;</span>		<span class="cm">/* length of right neighbor block */</span>
	<span class="kt">int</span>		<span class="n">haveleft</span><span class="p">;</span>	<span class="cm">/* have a left neighbor block */</span>
	<span class="kt">int</span>		<span class="n">haveright</span><span class="p">;</span>	<span class="cm">/* have a right neighbor block */</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>		<span class="cm">/* temp, result code */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">ltbno</span><span class="p">;</span>		<span class="cm">/* start of left neighbor block */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">ltlen</span><span class="p">;</span>		<span class="cm">/* length of left neighbor block */</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* mount point struct for filesystem */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">nbno</span><span class="p">;</span>		<span class="cm">/* new starting block of freespace */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">nlen</span><span class="p">;</span>		<span class="cm">/* new length of freespace */</span>
	<span class="n">xfs_perag_t</span>	<span class="o">*</span><span class="n">pag</span><span class="p">;</span>		<span class="cm">/* per allocation group data */</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocate and initialize a cursor for the by-block btree.</span>
<span class="cm">	 */</span>
	<span class="n">bno_cur</span> <span class="o">=</span> <span class="n">xfs_allocbt_init_cursor</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">XFS_BTNUM_BNO</span><span class="p">);</span>
	<span class="n">cnt_cur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Look for a neighboring block on the left (lower block numbers)</span>
<span class="cm">	 * that is contiguous with this space.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_le</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">haveleft</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">haveleft</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * There is a block to our left.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ltlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s not contiguous, though.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ltbno</span> <span class="o">+</span> <span class="n">ltlen</span> <span class="o">&lt;</span> <span class="n">bno</span><span class="p">)</span>
			<span class="n">haveleft</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If this failure happens the request to free this</span>
<span class="cm">			 * space was invalid, it&#39;s (partly) already free.</span>
<span class="cm">			 * Very bad.</span>
<span class="cm">			 */</span>
			<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">ltbno</span> <span class="o">+</span> <span class="n">ltlen</span> <span class="o">&lt;=</span> <span class="n">bno</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Look for a neighboring block on the right (higher block numbers)</span>
<span class="cm">	 * that is contiguous with this space.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_increment</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">haveright</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">haveright</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * There is a block to our right.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gtbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gtlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s not contiguous, though.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bno</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">gtbno</span><span class="p">)</span>
			<span class="n">haveright</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If this failure happens the request to free this</span>
<span class="cm">			 * space was invalid, it&#39;s (partly) already free.</span>
<span class="cm">			 * Very bad.</span>
<span class="cm">			 */</span>
			<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">gtbno</span> <span class="o">&gt;=</span> <span class="n">bno</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now allocate and initialize a cursor for the by-size tree.</span>
<span class="cm">	 */</span>
	<span class="n">cnt_cur</span> <span class="o">=</span> <span class="n">xfs_allocbt_init_cursor</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">XFS_BTNUM_CNT</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Have both left and right contiguous neighbors.</span>
<span class="cm">	 * Merge all three into a single free block.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">haveleft</span> <span class="o">&amp;&amp;</span> <span class="n">haveright</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Delete the old by-size entry on the left.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_eq</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">ltbno</span><span class="p">,</span> <span class="n">ltlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_delete</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Delete the old by-size entry on the right.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_eq</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">gtbno</span><span class="p">,</span> <span class="n">gtlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_delete</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Delete the old by-block entry for the right block.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_delete</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Move the by-block cursor back to the left neighbor.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_decrement</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check that this is the right record: delete didn&#39;t</span>
<span class="cm">		 * mangle the cursor.</span>
<span class="cm">		 */</span>
		<span class="p">{</span>
			<span class="n">xfs_agblock_t</span>	<span class="n">xxbno</span><span class="p">;</span>
			<span class="n">xfs_extlen_t</span>	<span class="n">xxlen</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_rec</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xxbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xxlen</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
			<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span>
				<span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">xxbno</span> <span class="o">==</span> <span class="n">ltbno</span> <span class="o">&amp;&amp;</span> <span class="n">xxlen</span> <span class="o">==</span> <span class="n">ltlen</span><span class="p">,</span>
				<span class="n">error0</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update remaining by-block entry to the new, joined block.</span>
<span class="cm">		 */</span>
		<span class="n">nbno</span> <span class="o">=</span> <span class="n">ltbno</span><span class="p">;</span>
		<span class="n">nlen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">+</span> <span class="n">ltlen</span> <span class="o">+</span> <span class="n">gtlen</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_update</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">nbno</span><span class="p">,</span> <span class="n">nlen</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Have only a left contiguous neighbor.</span>
<span class="cm">	 * Merge it together with the new freespace.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">haveleft</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Delete the old by-size entry on the left.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_eq</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">ltbno</span><span class="p">,</span> <span class="n">ltlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_delete</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Back up the by-block cursor to the left neighbor, and</span>
<span class="cm">		 * update its length.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_decrement</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="n">nbno</span> <span class="o">=</span> <span class="n">ltbno</span><span class="p">;</span>
		<span class="n">nlen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">+</span> <span class="n">ltlen</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_update</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">nbno</span><span class="p">,</span> <span class="n">nlen</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Have only a right contiguous neighbor.</span>
<span class="cm">	 * Merge it together with the new freespace.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">haveright</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Delete the old by-size entry on the right.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_eq</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">gtbno</span><span class="p">,</span> <span class="n">gtlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_delete</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update the starting block and length of the right</span>
<span class="cm">		 * neighbor in the by-block tree.</span>
<span class="cm">		 */</span>
		<span class="n">nbno</span> <span class="o">=</span> <span class="n">bno</span><span class="p">;</span>
		<span class="n">nlen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">+</span> <span class="n">gtlen</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_update</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">nbno</span><span class="p">,</span> <span class="n">nlen</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * No contiguous neighbors.</span>
<span class="cm">	 * Insert the new freespace into the by-block tree.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">nbno</span> <span class="o">=</span> <span class="n">bno</span><span class="p">;</span>
		<span class="n">nlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_insert</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="n">bno_cur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * In all cases we need to insert the new freespace in the by-size tree.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_lookup_eq</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">nbno</span><span class="p">,</span> <span class="n">nlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_insert</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="n">cnt_cur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the freespace totals in the ag and superblock.</span>
<span class="cm">	 */</span>
	<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_update_counters</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">pag</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isfl</span><span class="p">)</span>
		<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_FDBLOCKS</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">len</span><span class="p">);</span>
	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_freex</span><span class="p">);</span>
	<span class="n">XFS_STATS_ADD</span><span class="p">(</span><span class="n">xs_freeb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">trace_xfs_free_extent</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">isfl</span><span class="p">,</span> <span class="n">haveleft</span><span class="p">,</span> <span class="n">haveright</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">error0:</span>
	<span class="n">trace_xfs_free_extent</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">isfl</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bno_cur</span><span class="p">)</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">bno_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_ERROR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt_cur</span><span class="p">)</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cnt_cur</span><span class="p">,</span> <span class="n">XFS_BTREE_ERROR</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Visible (exported) allocation/free functions.</span>
<span class="cm"> * Some of these are used just by xfs_alloc_btree.c and this file.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Compute and fill in value of m_ag_maxlevels.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="n">xfs_alloc_compute_maxlevels</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>	<span class="cm">/* file system mount structure */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">level</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">maxblocks</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">maxleafents</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">minleafrecs</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">minnoderecs</span><span class="p">;</span>

	<span class="n">maxleafents</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agblocks</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">minleafrecs</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_alloc_mnr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">minnoderecs</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_alloc_mnr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">maxblocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxleafents</span> <span class="o">+</span> <span class="n">minleafrecs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">minleafrecs</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">maxblocks</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span>
		<span class="n">maxblocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxblocks</span> <span class="o">+</span> <span class="n">minnoderecs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">minnoderecs</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ag_maxlevels</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the length of the longest extent in an AG.</span>
<span class="cm"> */</span>
<span class="n">xfs_extlen_t</span>
<span class="n">xfs_alloc_longest_free_extent</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span>	<span class="o">*</span><span class="n">pag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_extlen_t</span>		<span class="n">need</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">need</span> <span class="o">=</span> <span class="n">XFS_MIN_FREELIST_PAG</span><span class="p">(</span><span class="n">pag</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need</span> <span class="o">&gt;</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_flcount</span><span class="p">)</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">need</span> <span class="o">-</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_flcount</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_longest</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_longest</span> <span class="o">-</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_flcount</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_longest</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decide whether to use this allocation group for this allocation.</span>
<span class="cm"> * If so, fix up the btree freelist&#39;s size.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>			<span class="cm">/* error */</span>
<span class="n">xfs_alloc_fix_freelist</span><span class="p">(</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="o">*</span><span class="n">args</span><span class="p">,</span>	<span class="cm">/* allocation argument structure */</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">)</span>	<span class="cm">/* XFS_ALLOC_FLAG_... */</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agbp</span><span class="p">;</span>	<span class="cm">/* agf buffer pointer */</span>
	<span class="n">xfs_agf_t</span>	<span class="o">*</span><span class="n">agf</span><span class="p">;</span>	<span class="cm">/* a.g. freespace structure pointer */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agflbp</span><span class="p">;</span><span class="cm">/* agfl buffer pointer */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">bno</span><span class="p">;</span>	<span class="cm">/* freelist block */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">delta</span><span class="p">;</span>	<span class="cm">/* new blocks needed in freelist */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>	<span class="cm">/* error result code */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">longest</span><span class="p">;</span><span class="cm">/* longest extent in allocation group */</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>	<span class="cm">/* file system mount point structure */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">need</span><span class="p">;</span>	<span class="cm">/* total blocks needed in freelist */</span>
	<span class="n">xfs_perag_t</span>	<span class="o">*</span><span class="n">pag</span><span class="p">;</span>	<span class="cm">/* per-ag information structure */</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="n">targs</span><span class="p">;</span>	<span class="cm">/* local allocation arguments */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>	<span class="cm">/* transaction pointer */</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">;</span>

	<span class="n">pag</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pag</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_init</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_read_agf</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">agbp</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_init</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ALLOC_FLAG_TRYLOCK</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ALLOC_FLAG_FREEING</span><span class="p">));</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">agbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a metadata preferred pag and we are user data</span>
<span class="cm">	 * then try somewhere else if we are not being asked to</span>
<span class="cm">	 * try harder at this point</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_metadata</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">userdata</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ALLOC_FLAG_TRYLOCK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ALLOC_FLAG_FREEING</span><span class="p">));</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ALLOC_FLAG_FREEING</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it looks like there isn&#39;t a long enough extent, or enough</span>
<span class="cm">		 * total blocks, reject it.</span>
<span class="cm">		 */</span>
		<span class="n">need</span> <span class="o">=</span> <span class="n">XFS_MIN_FREELIST_PAG</span><span class="p">(</span><span class="n">pag</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
		<span class="n">longest</span> <span class="o">=</span> <span class="n">xfs_alloc_longest_free_extent</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">pag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span> <span class="o">+</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">+</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minalignslop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span>
				<span class="n">longest</span> <span class="o">||</span>
		    <span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_freeblks</span> <span class="o">+</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_flcount</span> <span class="o">-</span>
			   <span class="n">need</span> <span class="o">-</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">total</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">minleft</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">agbp</span><span class="p">)</span>
				<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the a.g. freespace buffer.</span>
<span class="cm">	 * Can fail if we&#39;re not blocking on locks, and it&#39;s held.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">agbp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_read_agf</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">agbp</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">agbp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ALLOC_FLAG_TRYLOCK</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ALLOC_FLAG_FREEING</span><span class="p">));</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Figure out how many blocks we should have in the freelist.</span>
<span class="cm">	 */</span>
	<span class="n">agf</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="n">agbp</span><span class="p">);</span>
	<span class="n">need</span> <span class="o">=</span> <span class="n">XFS_MIN_FREELIST</span><span class="p">(</span><span class="n">agf</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there isn&#39;t enough total or single-extent, reject it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ALLOC_FLAG_FREEING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">need</span> <span class="o">&gt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">)</span> <span class="o">?</span>
			<span class="p">(</span><span class="n">need</span> <span class="o">-</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">))</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">longest</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_longest</span><span class="p">);</span>
		<span class="n">longest</span> <span class="o">=</span> <span class="p">(</span><span class="n">longest</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">longest</span> <span class="o">-</span> <span class="n">delta</span><span class="p">)</span> <span class="o">:</span>
			<span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">longest</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span> <span class="o">+</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">+</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minalignslop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span>
				<span class="n">longest</span> <span class="o">||</span>
		    <span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_freeblks</span><span class="p">)</span> <span class="o">+</span>
		     <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">)</span> <span class="o">-</span> <span class="n">need</span> <span class="o">-</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">total</span><span class="p">)</span> <span class="o">&lt;</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">minleft</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make the freelist shorter if it&#39;s too long.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">need</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_get_freelist</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bno</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_free_ag_extent</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_btree_get_bufs</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">xfs_trans_binval</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initialize the args structure.</span>
<span class="cm">	 */</span>
	<span class="n">targs</span><span class="p">.</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tp</span><span class="p">;</span>
	<span class="n">targs</span><span class="p">.</span><span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
	<span class="n">targs</span><span class="p">.</span><span class="n">agbp</span> <span class="o">=</span> <span class="n">agbp</span><span class="p">;</span>
	<span class="n">targs</span><span class="p">.</span><span class="n">agno</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">;</span>
	<span class="n">targs</span><span class="p">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">targs</span><span class="p">.</span><span class="n">minleft</span> <span class="o">=</span> <span class="n">targs</span><span class="p">.</span><span class="n">wasdel</span> <span class="o">=</span> <span class="n">targs</span><span class="p">.</span><span class="n">userdata</span> <span class="o">=</span>
		<span class="n">targs</span><span class="p">.</span><span class="n">minalignslop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">targs</span><span class="p">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="n">targs</span><span class="p">.</span><span class="n">minlen</span> <span class="o">=</span> <span class="n">targs</span><span class="p">.</span><span class="n">prod</span> <span class="o">=</span> <span class="n">targs</span><span class="p">.</span><span class="n">isfl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">targs</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">XFS_ALLOCTYPE_THIS_AG</span><span class="p">;</span>
	<span class="n">targs</span><span class="p">.</span><span class="n">pag</span> <span class="o">=</span> <span class="n">pag</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_read_agfl</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">targs</span><span class="p">.</span><span class="n">agno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">agflbp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make the freelist longer if it&#39;s too short.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">need</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">targs</span><span class="p">.</span><span class="n">agbno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">targs</span><span class="p">.</span><span class="n">maxlen</span> <span class="o">=</span> <span class="n">need</span> <span class="o">-</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allocate as many blocks as possible at once.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_ag_vextent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">targs</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agflbp</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Stop if we run out.  Won&#39;t happen if callers are obeying</span>
<span class="cm">		 * the restrictions correctly.  Can happen for free calls</span>
<span class="cm">		 * on a completely full ag.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">targs</span><span class="p">.</span><span class="n">agbno</span> <span class="o">==</span> <span class="n">NULLAGBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ALLOC_FLAG_FREEING</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agflbp</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Put each allocated block on the list.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">bno</span> <span class="o">=</span> <span class="n">targs</span><span class="p">.</span><span class="n">agbno</span><span class="p">;</span> <span class="n">bno</span> <span class="o">&lt;</span> <span class="n">targs</span><span class="p">.</span><span class="n">agbno</span> <span class="o">+</span> <span class="n">targs</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">bno</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_put_freelist</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span>
							<span class="n">agflbp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agflbp</span><span class="p">);</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span> <span class="o">=</span> <span class="n">agbp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get a block from the freelist.</span>
<span class="cm"> * Returns with the buffer for the block gotten.</span>
<span class="cm"> */</span>
<span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_alloc_get_freelist</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>	<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agbp</span><span class="p">,</span>	<span class="cm">/* buffer containing the agf structure */</span>
	<span class="n">xfs_agblock_t</span>	<span class="o">*</span><span class="n">bnop</span><span class="p">,</span>	<span class="cm">/* block address retrieved from freelist */</span>
	<span class="kt">int</span>		<span class="n">btreeblk</span><span class="p">)</span> <span class="cm">/* destination is a AGF btree */</span>
<span class="p">{</span>
	<span class="n">xfs_agf_t</span>	<span class="o">*</span><span class="n">agf</span><span class="p">;</span>	<span class="cm">/* a.g. freespace structure */</span>
	<span class="n">xfs_agfl_t</span>	<span class="o">*</span><span class="n">agfl</span><span class="p">;</span>	<span class="cm">/* a.g. freelist structure */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agflbp</span><span class="p">;</span><span class="cm">/* buffer for a.g. freelist structure */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">bno</span><span class="p">;</span>	<span class="cm">/* block number returned */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">logflags</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>	<span class="cm">/* mount structure */</span>
	<span class="n">xfs_perag_t</span>	<span class="o">*</span><span class="n">pag</span><span class="p">;</span>	<span class="cm">/* per allocation group data */</span>

	<span class="n">agf</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="n">agbp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Freelist is empty, give up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">bnop</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read the array of free blocks.</span>
<span class="cm">	 */</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_read_agfl</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_seqno</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">agflbp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">agfl</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGFL</span><span class="p">(</span><span class="n">agflbp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the block number and update the data structures.</span>
<span class="cm">	 */</span>
	<span class="n">bno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agfl</span><span class="o">-&gt;</span><span class="n">agfl_bno</span><span class="p">[</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flfirst</span><span class="p">)]);</span>
	<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flfirst</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agflbp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flfirst</span><span class="p">)</span> <span class="o">==</span> <span class="n">XFS_AGFL_SIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flfirst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_seqno</span><span class="p">));</span>
	<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_trans_agflist_delta</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_flcount</span><span class="o">--</span><span class="p">;</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>

	<span class="n">logflags</span> <span class="o">=</span> <span class="n">XFS_AGF_FLFIRST</span> <span class="o">|</span> <span class="n">XFS_AGF_FLCOUNT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btreeblk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_btreeblks</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_btreeblks</span><span class="o">++</span><span class="p">;</span>
		<span class="n">logflags</span> <span class="o">|=</span> <span class="n">XFS_AGF_BTREEBLKS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_alloc_log_agf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">logflags</span><span class="p">);</span>
	<span class="o">*</span><span class="n">bnop</span> <span class="o">=</span> <span class="n">bno</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Log the given fields from the agf structure.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="n">xfs_alloc_log_agf</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>	<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">,</span>	<span class="cm">/* buffer for a.g. freelist header */</span>
	<span class="kt">int</span>		<span class="n">fields</span><span class="p">)</span>	<span class="cm">/* mask of fields to be logged (XFS_AGF_...) */</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">first</span><span class="p">;</span>		<span class="cm">/* first byte offset */</span>
	<span class="kt">int</span>	<span class="n">last</span><span class="p">;</span>		<span class="cm">/* last byte offset */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">short</span>	<span class="n">offsets</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agf_t</span><span class="p">,</span> <span class="n">agf_magicnum</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agf_t</span><span class="p">,</span> <span class="n">agf_versionnum</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agf_t</span><span class="p">,</span> <span class="n">agf_seqno</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agf_t</span><span class="p">,</span> <span class="n">agf_length</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agf_t</span><span class="p">,</span> <span class="n">agf_roots</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agf_t</span><span class="p">,</span> <span class="n">agf_levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agf_t</span><span class="p">,</span> <span class="n">agf_flfirst</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agf_t</span><span class="p">,</span> <span class="n">agf_fllast</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agf_t</span><span class="p">,</span> <span class="n">agf_flcount</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agf_t</span><span class="p">,</span> <span class="n">agf_freeblks</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agf_t</span><span class="p">,</span> <span class="n">agf_longest</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agf_t</span><span class="p">,</span> <span class="n">agf_btreeblks</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_agf_t</span><span class="p">)</span>
	<span class="p">};</span>

	<span class="n">trace_xfs_agf</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">,</span> <span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">fields</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="n">xfs_btree_offsets</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">XFS_AGF_NUM_BITS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">);</span>
	<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="n">first</span><span class="p">,</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="n">last</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interface for inode allocation to force the pag data to be initialized.</span>
<span class="cm"> */</span>
<span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_alloc_pagf_init</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">,</span>	<span class="cm">/* file system mount structure */</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">,</span>	<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_agnumber_t</span>		<span class="n">agno</span><span class="p">,</span>	<span class="cm">/* allocation group number */</span>
	<span class="kt">int</span>			<span class="n">flags</span><span class="p">)</span>	<span class="cm">/* XFS_ALLOC_FLAGS_... */</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_read_agf</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="p">)</span>
		<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Put the block on the freelist for the allocation group.</span>
<span class="cm"> */</span>
<span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_alloc_put_freelist</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">,</span>	<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">agbp</span><span class="p">,</span>	<span class="cm">/* buffer for a.g. freelist header */</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">agflbp</span><span class="p">,</span><span class="cm">/* buffer for a.g. free block array */</span>
	<span class="n">xfs_agblock_t</span>		<span class="n">bno</span><span class="p">,</span>	<span class="cm">/* block being freed */</span>
	<span class="kt">int</span>			<span class="n">btreeblk</span><span class="p">)</span> <span class="cm">/* block came from a AGF btree */</span>
<span class="p">{</span>
	<span class="n">xfs_agf_t</span>		<span class="o">*</span><span class="n">agf</span><span class="p">;</span>	<span class="cm">/* a.g. freespace structure */</span>
	<span class="n">xfs_agfl_t</span>		<span class="o">*</span><span class="n">agfl</span><span class="p">;</span>	<span class="cm">/* a.g. free block array */</span>
	<span class="n">__be32</span>			<span class="o">*</span><span class="n">blockp</span><span class="p">;</span><span class="cm">/* pointer to array entry */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">logflags</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>	<span class="cm">/* mount structure */</span>
	<span class="n">xfs_perag_t</span>		<span class="o">*</span><span class="n">pag</span><span class="p">;</span>	<span class="cm">/* per allocation group data */</span>

	<span class="n">agf</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="n">agbp</span><span class="p">);</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">agflbp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_read_agfl</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_seqno</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">agflbp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">agfl</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGFL</span><span class="p">(</span><span class="n">agflbp</span><span class="p">);</span>
	<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_fllast</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_fllast</span><span class="p">)</span> <span class="o">==</span> <span class="n">XFS_AGFL_SIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_fllast</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_seqno</span><span class="p">));</span>
	<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_trans_agflist_delta</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_flcount</span><span class="o">++</span><span class="p">;</span>

	<span class="n">logflags</span> <span class="o">=</span> <span class="n">XFS_AGF_FLLAST</span> <span class="o">|</span> <span class="n">XFS_AGF_FLCOUNT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btreeblk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_btreeblks</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_btreeblks</span><span class="o">--</span><span class="p">;</span>
		<span class="n">logflags</span> <span class="o">|=</span> <span class="n">XFS_AGF_BTREEBLKS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>

	<span class="n">xfs_alloc_log_agf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">logflags</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">XFS_AGFL_SIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
	<span class="n">blockp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">agfl</span><span class="o">-&gt;</span><span class="n">agfl_bno</span><span class="p">[</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_fllast</span><span class="p">)];</span>
	<span class="o">*</span><span class="n">blockp</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">bno</span><span class="p">);</span>
	<span class="n">xfs_alloc_log_agf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">logflags</span><span class="p">);</span>
	<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agflbp</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">xfs_caddr_t</span><span class="p">)</span><span class="n">blockp</span> <span class="o">-</span> <span class="p">(</span><span class="n">xfs_caddr_t</span><span class="p">)</span><span class="n">agfl</span><span class="p">),</span>
		<span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">xfs_caddr_t</span><span class="p">)</span><span class="n">blockp</span> <span class="o">-</span> <span class="p">(</span><span class="n">xfs_caddr_t</span><span class="p">)</span><span class="n">agfl</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_agblock_t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read in the allocation group header (free/alloc section).</span>
<span class="cm"> */</span>
<span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_read_agf</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>	<span class="cm">/* mount point structure */</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>	<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_agnumber_t</span>		<span class="n">agno</span><span class="p">,</span>	<span class="cm">/* allocation group number */</span>
	<span class="kt">int</span>			<span class="n">flags</span><span class="p">,</span>	<span class="cm">/* XFS_BUF_ */</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">**</span><span class="n">bpp</span><span class="p">)</span>	<span class="cm">/* buffer for the ag freelist header */</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_agf</span>	<span class="o">*</span><span class="n">agf</span><span class="p">;</span>		<span class="cm">/* ag freelist header */</span>
	<span class="kt">int</span>		<span class="n">agf_ok</span><span class="p">;</span>		<span class="cm">/* set if agf is consistent */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">agno</span> <span class="o">!=</span> <span class="n">NULLAGNUMBER</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_read_buf</span><span class="p">(</span>
			<span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span>
			<span class="n">XFS_AG_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">XFS_AGF_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">)),</span>
			<span class="n">XFS_FSS_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">flags</span><span class="p">,</span> <span class="n">bpp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">bpp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">bpp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_error</span><span class="p">);</span>
	<span class="n">agf</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="o">*</span><span class="n">bpp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate the magic number of the agf block.</span>
<span class="cm">	 */</span>
	<span class="n">agf_ok</span> <span class="o">=</span>
		<span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_magicnum</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_AGF_MAGIC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">XFS_AGF_GOOD_VERSION</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_versionnum</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_freeblks</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_length</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flfirst</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">XFS_AGFL_SIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_fllast</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">XFS_AGFL_SIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">XFS_AGFL_SIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_seqno</span><span class="p">)</span> <span class="o">==</span> <span class="n">agno</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_haslazysbcount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span>
		<span class="n">agf_ok</span> <span class="o">=</span> <span class="n">agf_ok</span> <span class="o">&amp;&amp;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_btreeblks</span><span class="p">)</span> <span class="o">&lt;=</span>
						<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">XFS_TEST_ERROR</span><span class="p">(</span><span class="o">!</span><span class="n">agf_ok</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">XFS_ERRTAG_ALLOC_READ_AGF</span><span class="p">,</span>
			<span class="n">XFS_RANDOM_ALLOC_READ_AGF</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_alloc_read_agf&quot;</span><span class="p">,</span>
				     <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">agf</span><span class="p">);</span>
		<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="o">*</span><span class="n">bpp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xfs_buf_set_ref</span><span class="p">(</span><span class="o">*</span><span class="n">bpp</span><span class="p">,</span> <span class="n">XFS_AGF_REF</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read in the allocation group header (free/alloc section).</span>
<span class="cm"> */</span>
<span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_alloc_read_agf</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>	<span class="cm">/* mount point structure */</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>	<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_agnumber_t</span>		<span class="n">agno</span><span class="p">,</span>	<span class="cm">/* allocation group number */</span>
	<span class="kt">int</span>			<span class="n">flags</span><span class="p">,</span>	<span class="cm">/* XFS_ALLOC_FLAG_... */</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">**</span><span class="n">bpp</span><span class="p">)</span>	<span class="cm">/* buffer for the ag freelist header */</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_agf</span>		<span class="o">*</span><span class="n">agf</span><span class="p">;</span>		<span class="cm">/* ag freelist header */</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span>	<span class="o">*</span><span class="n">pag</span><span class="p">;</span>		<span class="cm">/* per allocation group data */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">agno</span> <span class="o">!=</span> <span class="n">NULLAGNUMBER</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_read_agf</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span>
			<span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ALLOC_FLAG_TRYLOCK</span><span class="p">)</span> <span class="o">?</span> <span class="n">XBF_TRYLOCK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">bpp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">bpp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">bpp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_error</span><span class="p">);</span>

	<span class="n">agf</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="o">*</span><span class="n">bpp</span><span class="p">);</span>
	<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_init</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_freeblks</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_freeblks</span><span class="p">);</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_btreeblks</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_btreeblks</span><span class="p">);</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_flcount</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">);</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_longest</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_longest</span><span class="p">);</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_levels</span><span class="p">[</span><span class="n">XFS_BTNUM_BNOi</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_levels</span><span class="p">[</span><span class="n">XFS_BTNUM_BNOi</span><span class="p">]);</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_levels</span><span class="p">[</span><span class="n">XFS_BTNUM_CNTi</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_levels</span><span class="p">[</span><span class="n">XFS_BTNUM_CNTi</span><span class="p">]);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagb_lock</span><span class="p">);</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagb_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagb_tree</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_init</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_freeblks</span> <span class="o">==</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_freeblks</span><span class="p">));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_btreeblks</span> <span class="o">==</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_btreeblks</span><span class="p">));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_flcount</span> <span class="o">==</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_longest</span> <span class="o">==</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_longest</span><span class="p">));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_levels</span><span class="p">[</span><span class="n">XFS_BTNUM_BNOi</span><span class="p">]</span> <span class="o">==</span>
		       <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_levels</span><span class="p">[</span><span class="n">XFS_BTNUM_BNOi</span><span class="p">]));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_levels</span><span class="p">[</span><span class="n">XFS_BTNUM_CNTi</span><span class="p">]</span> <span class="o">==</span>
		       <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agf</span><span class="o">-&gt;</span><span class="n">agf_levels</span><span class="p">[</span><span class="n">XFS_BTNUM_CNTi</span><span class="p">]));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate an extent (variable-size).</span>
<span class="cm"> * Depending on the allocation type, we either look in a single allocation</span>
<span class="cm"> * group or loop over the allocation groups to find the result.</span>
<span class="cm"> */</span>
<span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">__xfs_alloc_vextent</span><span class="p">(</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="o">*</span><span class="n">args</span><span class="p">)</span>	<span class="cm">/* allocation argument structure */</span>
<span class="p">{</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">agsize</span><span class="p">;</span>	<span class="cm">/* allocation group size */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>	<span class="cm">/* XFS_ALLOC_FLAG_... locking flags */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">minleft</span><span class="p">;</span><span class="cm">/* minimum left value, temp copy */</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>	<span class="cm">/* mount structure pointer */</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">sagno</span><span class="p">;</span>	<span class="cm">/* starting allocation group number */</span>
	<span class="n">xfs_alloctype_t</span>	<span class="n">type</span><span class="p">;</span>	<span class="cm">/* input allocation type */</span>
	<span class="kt">int</span>		<span class="n">bump_rotor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">no_min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">rotorstep</span> <span class="o">=</span> <span class="n">xfs_rotorstep</span><span class="p">;</span> <span class="cm">/* inode32 agf stepper */</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">otype</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Just fix this up, for the case where the last a.g. is shorter</span>
<span class="cm">	 * (or there&#39;s only one a.g.) and the caller couldn&#39;t easily figure</span>
<span class="cm">	 * that out (xfs_bmap_alloc).</span>
<span class="cm">	 */</span>
	<span class="n">agsize</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agblocks</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span> <span class="o">&gt;</span> <span class="n">agsize</span><span class="p">)</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span> <span class="o">=</span> <span class="n">agsize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_FSB_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_FSB_TO_AGBNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">agsize</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span> <span class="o">&lt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span> <span class="o">&lt;=</span> <span class="n">agsize</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">prod</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FSB_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span> <span class="o">||</span>
	    <span class="n">XFS_FSB_TO_AGBNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">agsize</span> <span class="o">||</span>
	    <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span> <span class="o">&gt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span> <span class="o">||</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span> <span class="o">&gt;</span> <span class="n">agsize</span> <span class="o">||</span>
	    <span class="n">args</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">prod</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span> <span class="o">=</span> <span class="n">NULLFSBLOCK</span><span class="p">;</span>
		<span class="n">trace_xfs_alloc_vextent_badargs</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">minleft</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minleft</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_ALLOCTYPE_THIS_AG</span>:
	<span class="k">case</span> <span class="n">XFS_ALLOCTYPE_NEAR_BNO</span>:
	<span class="k">case</span> <span class="n">XFS_ALLOCTYPE_THIS_BNO</span>:
		<span class="cm">/*</span>
<span class="cm">		 * These three force us into a single a.g.</span>
<span class="cm">		 */</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span><span class="p">);</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">);</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">minleft</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_fix_freelist</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">minleft</span> <span class="o">=</span> <span class="n">minleft</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trace_xfs_alloc_vextent_nofix</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trace_xfs_alloc_vextent_noagbp</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_AGBNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_ag_vextent</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_ALLOCTYPE_START_BNO</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Try near allocation first, then anywhere-in-ag after</span>
<span class="cm">		 * the first a.g. fails.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">userdata</span>  <span class="o">==</span> <span class="n">XFS_ALLOC_INITIAL_USER_DATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_32BITINODES</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span> <span class="o">=</span> <span class="n">XFS_AGB_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
					<span class="p">((</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agfrotor</span> <span class="o">/</span> <span class="n">rotorstep</span><span class="p">)</span> <span class="o">%</span>
					<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">bump_rotor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_AGBNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span><span class="p">);</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">XFS_ALLOCTYPE_NEAR_BNO</span><span class="p">;</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">XFS_ALLOCTYPE_ANY_AG</span>:
	<span class="k">case</span> <span class="n">XFS_ALLOCTYPE_START_AG</span>:
	<span class="k">case</span> <span class="n">XFS_ALLOCTYPE_FIRST_AG</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Rotate through the allocation groups looking for a winner.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">XFS_ALLOCTYPE_ANY_AG</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Start with the last place we left off.</span>
<span class="cm">			 */</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span> <span class="o">=</span> <span class="n">sagno</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agfrotor</span> <span class="o">/</span> <span class="n">rotorstep</span><span class="p">)</span> <span class="o">%</span>
					<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">;</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">XFS_ALLOCTYPE_THIS_AG</span><span class="p">;</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">XFS_ALLOC_FLAG_TRYLOCK</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">XFS_ALLOCTYPE_FIRST_AG</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Start with allocation group given by bno.</span>
<span class="cm">			 */</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">XFS_ALLOCTYPE_THIS_AG</span><span class="p">;</span>
			<span class="n">sagno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">XFS_ALLOCTYPE_START_AG</span><span class="p">)</span>
				<span class="n">args</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">XFS_ALLOCTYPE_THIS_AG</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Start with the given allocation group.</span>
<span class="cm">			 */</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span> <span class="o">=</span> <span class="n">sagno</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span><span class="p">);</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">XFS_ALLOC_FLAG_TRYLOCK</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Loop over allocation groups twice; first time with</span>
<span class="cm">		 * trylock set, second time without.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">no_min</span><span class="p">)</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minleft</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_fix_freelist</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">minleft</span> <span class="o">=</span> <span class="n">minleft</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">trace_xfs_alloc_vextent_nofix</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we get a buffer back then the allocation will fly.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbp</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_ag_vextent</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>
					<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">trace_xfs_alloc_vextent_loopfailed</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Didn&#39;t work, figure out the next iteration.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span> <span class="o">==</span> <span class="n">sagno</span> <span class="o">&amp;&amp;</span>
			    <span class="n">type</span> <span class="o">==</span> <span class="n">XFS_ALLOCTYPE_START_BNO</span><span class="p">)</span>
				<span class="n">args</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">XFS_ALLOCTYPE_THIS_AG</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			* For the first allocation, we can try any AG to get</span>
<span class="cm">			* space.  However, if we already have allocated a</span>
<span class="cm">			* block, we don&#39;t want to try AGs whose number is below</span>
<span class="cm">			* sagno. Otherwise, we may end up with out-of-order</span>
<span class="cm">			* locking of AGF, which might cause deadlock.</span>
<span class="cm">			*/</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">)</span> <span class="o">==</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span> <span class="o">!=</span> <span class="n">NULLFSBLOCK</span><span class="p">)</span>
					<span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span> <span class="o">=</span> <span class="n">sagno</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Reached the starting a.g., must either be done</span>
<span class="cm">			 * or switch to non-trylock mode.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span> <span class="o">==</span> <span class="n">sagno</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">no_min</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">NULLAGBLOCK</span><span class="p">;</span>
					<span class="n">trace_xfs_alloc_vextent_allfailed</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">no_min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">XFS_ALLOCTYPE_START_BNO</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_AGBNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
							<span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span><span class="p">);</span>
						<span class="n">args</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">XFS_ALLOCTYPE_NEAR_BNO</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">pag</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bump_rotor</span> <span class="o">||</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">XFS_ALLOCTYPE_ANY_AG</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span> <span class="o">==</span> <span class="n">sagno</span><span class="p">)</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agfrotor</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agfrotor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span>
					<span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span> <span class="o">*</span> <span class="n">rotorstep</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agfrotor</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span> <span class="o">*</span> <span class="n">rotorstep</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span>
					<span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span> <span class="o">*</span> <span class="n">rotorstep</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* NOTREACHED */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">==</span> <span class="n">NULLAGBLOCK</span><span class="p">)</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span> <span class="o">=</span> <span class="n">NULLFSBLOCK</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span> <span class="o">=</span> <span class="n">XFS_AGB_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agno</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">agbno</span> <span class="o">%</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">XFS_AG_CHECK_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_FSB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fsbno</span><span class="p">),</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">pag</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error0:</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">pag</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">xfs_alloc_vextent_worker</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_alloc_arg</span>	<span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">xfs_alloc_arg</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">pflags</span><span class="p">;</span>

	<span class="cm">/* we are in a transaction context here */</span>
	<span class="n">current_set_flags_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pflags</span><span class="p">,</span> <span class="n">PF_FSTRANS</span><span class="p">);</span>

	<span class="n">args</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">__xfs_alloc_vextent</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>

	<span class="n">current_restore_flags_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pflags</span><span class="p">,</span> <span class="n">PF_FSTRANS</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_alloc_vextent</span><span class="p">(</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="o">*</span><span class="n">args</span><span class="p">)</span>	<span class="cm">/* allocation argument structure */</span>
<span class="p">{</span>
	<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>

	<span class="n">args</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">done</span><span class="p">;</span>
	<span class="n">INIT_WORK_ONSTACK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">xfs_alloc_vextent_worker</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">xfs_alloc_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free an extent.</span>
<span class="cm"> * Just break up the extent address and hand off to xfs_free_ag_extent</span>
<span class="cm"> * after fixing up the freelist.</span>
<span class="cm"> */</span>
<span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_free_extent</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>	<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="n">bno</span><span class="p">,</span>	<span class="cm">/* starting block number of extent */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">len</span><span class="p">)</span>	<span class="cm">/* length of extent */</span>
<span class="p">{</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_alloc_arg_t</span><span class="p">));</span>
	<span class="n">args</span><span class="p">.</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tp</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">mp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * validate that the block number is legal - the enables us to detect</span>
<span class="cm">	 * and handle a silent filesystem corruption rather than crashing.</span>
<span class="cm">	 */</span>
	<span class="n">args</span><span class="p">.</span><span class="n">agno</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_AGNO</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="p">,</span> <span class="n">bno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">agno</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EFSCORRUPTED</span><span class="p">;</span>

	<span class="n">args</span><span class="p">.</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_AGBNO</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="p">,</span> <span class="n">bno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">agbno</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agblocks</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EFSCORRUPTED</span><span class="p">;</span>

	<span class="n">args</span><span class="p">.</span><span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">agno</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">pag</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_fix_freelist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">XFS_ALLOC_FLAG_FREEING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>

	<span class="cm">/* validate the extent size is legal now we have the agf locked */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">agbno</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">agbp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">agf_length</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">EFSCORRUPTED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_free_ag_extent</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">agbp</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">agno</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">agbno</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">xfs_extent_busy_insert</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">agno</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">agbno</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">error0:</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">pag</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
