<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_rtalloc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_rtalloc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_bit.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_dir2.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap.h&quot;</span>
<span class="cp">#include &quot;xfs_rtalloc.h&quot;</span>
<span class="cp">#include &quot;xfs_fsops.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_inode_item.h&quot;</span>
<span class="cp">#include &quot;xfs_trans_space.h&quot;</span>
<span class="cp">#include &quot;xfs_utils.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>
<span class="cp">#include &quot;xfs_buf.h&quot;</span>


<span class="cm">/*</span>
<span class="cm"> * Prototypes for internal functions.</span>
<span class="cm"> */</span>


<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_rtallocate_range</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_trans_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_rtblock_t</span><span class="p">,</span>
		<span class="n">xfs_extlen_t</span><span class="p">,</span> <span class="n">xfs_buf_t</span> <span class="o">**</span><span class="p">,</span> <span class="n">xfs_fsblock_t</span> <span class="o">*</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_rtany_summary</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_trans_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
		<span class="n">xfs_rtblock_t</span><span class="p">,</span> <span class="n">xfs_buf_t</span> <span class="o">**</span><span class="p">,</span> <span class="n">xfs_fsblock_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_rtcheck_range</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_trans_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_rtblock_t</span><span class="p">,</span>
		<span class="n">xfs_extlen_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">xfs_rtblock_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_rtfind_back</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_trans_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_rtblock_t</span><span class="p">,</span>
		<span class="n">xfs_rtblock_t</span><span class="p">,</span> <span class="n">xfs_rtblock_t</span> <span class="o">*</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_rtfind_forw</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_trans_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_rtblock_t</span><span class="p">,</span>
		<span class="n">xfs_rtblock_t</span><span class="p">,</span> <span class="n">xfs_rtblock_t</span> <span class="o">*</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_rtget_summary</span><span class="p">(</span> <span class="n">xfs_mount_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_trans_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
		<span class="n">xfs_rtblock_t</span><span class="p">,</span> <span class="n">xfs_buf_t</span> <span class="o">**</span><span class="p">,</span> <span class="n">xfs_fsblock_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_suminfo_t</span> <span class="o">*</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_rtmodify_range</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_trans_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_rtblock_t</span><span class="p">,</span>
		<span class="n">xfs_extlen_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_rtmodify_summary</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_trans_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
		<span class="n">xfs_rtblock_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">xfs_buf_t</span> <span class="o">**</span><span class="p">,</span> <span class="n">xfs_fsblock_t</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Internal functions.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate space to the bitmap or summary file, and zero it, for growfs.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_growfs_rt_alloc</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount point */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">oblocks</span><span class="p">,</span>	<span class="cm">/* old count of blocks */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">nblocks</span><span class="p">,</span>	<span class="cm">/* new count of blocks */</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>		<span class="cm">/* inode (bitmap/summary) */</span>
<span class="p">{</span>
	<span class="n">xfs_fileoff_t</span>	<span class="n">bno</span><span class="p">;</span>		<span class="cm">/* block number in file */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* temporary buffer for zeroing */</span>
	<span class="kt">int</span>		<span class="n">committed</span><span class="p">;</span>	<span class="cm">/* transaction committed flag */</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">d</span><span class="p">;</span>		<span class="cm">/* disk block address */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="n">firstblock</span><span class="p">;</span>	<span class="cm">/* first block allocated in xaction */</span>
	<span class="n">xfs_bmap_free_t</span>	<span class="n">flist</span><span class="p">;</span>		<span class="cm">/* list of freed blocks */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="n">fsbno</span><span class="p">;</span>		<span class="cm">/* filesystem block for bno */</span>
	<span class="n">xfs_bmbt_irec_t</span>	<span class="n">map</span><span class="p">;</span>		<span class="cm">/* block map output */</span>
	<span class="kt">int</span>		<span class="n">nmap</span><span class="p">;</span>		<span class="cm">/* number of block maps */</span>
	<span class="kt">int</span>		<span class="n">resblks</span><span class="p">;</span>	<span class="cm">/* space reservation */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate space to the file, as necessary.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">oblocks</span> <span class="o">&lt;</span> <span class="n">nblocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>		<span class="n">cancelflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>

		<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_GROWFSRT_ALLOC</span><span class="p">);</span>
		<span class="n">resblks</span> <span class="o">=</span> <span class="n">XFS_GROWFSRT_SPACE_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">nblocks</span> <span class="o">-</span> <span class="n">oblocks</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Reserve space &amp; log for one extent added to the file.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">resblks</span><span class="p">,</span>
				<span class="n">XFS_GROWRTALLOC_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span>
				<span class="n">XFS_DEFAULT_PERM_LOG_COUNT</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error_cancel</span><span class="p">;</span>
		<span class="n">cancelflags</span> <span class="o">=</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Lock the inode.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

		<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">firstblock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allocate blocks to the bitmap file.</span>
<span class="cm">		 */</span>
		<span class="n">nmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cancelflags</span> <span class="o">|=</span> <span class="n">XFS_TRANS_ABORT</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_write</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">oblocks</span><span class="p">,</span> <span class="n">nblocks</span> <span class="o">-</span> <span class="n">oblocks</span><span class="p">,</span>
					<span class="n">XFS_BMAPI_METADATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">firstblock</span><span class="p">,</span>
					<span class="n">resblks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flist</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">nmap</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSPC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_cancel</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Free any blocks freed up in the transaction, then commit.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_cancel</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Now we need to clear the allocated blocks.</span>
<span class="cm">		 * Do this one block per transaction, to keep it simple.</span>
<span class="cm">		 */</span>
		<span class="n">cancelflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">bno</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">br_startoff</span><span class="p">,</span> <span class="n">fsbno</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span><span class="p">;</span>
		     <span class="n">bno</span> <span class="o">&lt;</span> <span class="n">map</span><span class="p">.</span><span class="n">br_startoff</span> <span class="o">+</span> <span class="n">map</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">;</span>
		     <span class="n">bno</span><span class="o">++</span><span class="p">,</span> <span class="n">fsbno</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_GROWFSRT_ZERO</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Reserve log for one block zeroing.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">XFS_GROWRTZERO_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">error_cancel</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Lock the bitmap inode.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
			<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Get a buffer for the block.</span>
<span class="cm">			 */</span>
			<span class="n">d</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">fsbno</span><span class="p">);</span>
			<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_trans_get_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_bsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
<span class="nl">error_cancel:</span>
				<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">cancelflags</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span><span class="p">);</span>
			<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Commit the transaction.</span>
<span class="cm">			 */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Go on to the next extent, if any.</span>
<span class="cm">		 */</span>
		<span class="n">oblocks</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">br_startoff</span> <span class="o">+</span> <span class="n">map</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attempt to allocate an extent minlen&lt;=len&lt;=maxlen starting from</span>
<span class="cm"> * bitmap block bbno.  If we don&#39;t get maxlen then use prod to trim</span>
<span class="cm"> * the length, if given.  Returns error; returns starting block in *rtblock.</span>
<span class="cm"> * The lengths are all in rtextents.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtallocate_extent_block</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount point */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">bbno</span><span class="p">,</span>		<span class="cm">/* bitmap block number */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">minlen</span><span class="p">,</span>		<span class="cm">/* minimum length to allocate */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">maxlen</span><span class="p">,</span>		<span class="cm">/* maximum length to allocate */</span>
	<span class="n">xfs_extlen_t</span>	<span class="o">*</span><span class="n">len</span><span class="p">,</span>		<span class="cm">/* out: actual length allocated */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="o">*</span><span class="n">nextp</span><span class="p">,</span>		<span class="cm">/* out: next block to try */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">rbpp</span><span class="p">,</span>		<span class="cm">/* in/out: summary block buffer */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="o">*</span><span class="n">rsb</span><span class="p">,</span>		<span class="cm">/* in/out: summary block number */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">prod</span><span class="p">,</span>		<span class="cm">/* extent product factor */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="o">*</span><span class="n">rtblock</span><span class="p">)</span>	<span class="cm">/* out: start block allocated */</span>
<span class="p">{</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">besti</span><span class="p">;</span>		<span class="cm">/* best rtblock found so far */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">bestlen</span><span class="p">;</span>	<span class="cm">/* best length found so far */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">end</span><span class="p">;</span>		<span class="cm">/* last rtblock in chunk */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">i</span><span class="p">;</span>		<span class="cm">/* current rtblock trying */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">next</span><span class="p">;</span>		<span class="cm">/* next rtblock to try */</span>
	<span class="kt">int</span>		<span class="n">stat</span><span class="p">;</span>		<span class="cm">/* status from internal calls */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Loop over all the extents starting in this bitmap block,</span>
<span class="cm">	 * looking for one that&#39;s long enough.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">XFS_BLOCKTOBIT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">bbno</span><span class="p">),</span> <span class="n">besti</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bestlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">XFS_BLOCKTOBIT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">bbno</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span>
	     <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * See if there&#39;s a free extent of maxlen starting at i.</span>
<span class="cm">		 * If it&#39;s not so then next will contain the first non-free.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtcheck_range</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * i for maxlen is all free, allocate and return that.</span>
<span class="cm">			 */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtallocate_range</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span>
				<span class="n">rsb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">maxlen</span><span class="p">;</span>
			<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * In the case where we have a variable-sized allocation</span>
<span class="cm">		 * request, figure out how big this free piece is,</span>
<span class="cm">		 * and if it&#39;s big enough for the minimum, and the best</span>
<span class="cm">		 * so far, remember it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">minlen</span> <span class="o">&lt;</span> <span class="n">maxlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_rtblock_t</span>	<span class="n">thislen</span><span class="p">;</span>	<span class="cm">/* this extent size */</span>

			<span class="n">thislen</span> <span class="o">=</span> <span class="n">next</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">thislen</span> <span class="o">&gt;=</span> <span class="n">minlen</span> <span class="o">&amp;&amp;</span> <span class="n">thislen</span> <span class="o">&gt;</span> <span class="n">bestlen</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">besti</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">bestlen</span> <span class="o">=</span> <span class="n">thislen</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If not done yet, find the start of the next free space.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtfind_forw</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Searched the whole thing &amp; didn&#39;t find a maxlen free extent.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">minlen</span> <span class="o">&lt;</span> <span class="n">maxlen</span> <span class="o">&amp;&amp;</span> <span class="n">besti</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_extlen_t</span>	<span class="n">p</span><span class="p">;</span>	<span class="cm">/* amount to trim length by */</span>

		<span class="cm">/*</span>
<span class="cm">		 * If size should be a multiple of prod, make that so.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prod</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">do_mod</span><span class="p">(</span><span class="n">bestlen</span><span class="p">,</span> <span class="n">prod</span><span class="p">)))</span>
			<span class="n">bestlen</span> <span class="o">-=</span> <span class="n">p</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allocate besti for bestlen &amp; return that.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtallocate_range</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">besti</span><span class="p">,</span> <span class="n">bestlen</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">bestlen</span><span class="p">;</span>
		<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">besti</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocation failed.  Set *nextp to the next block to try.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">nextp</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">NULLRTBLOCK</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate an extent of length minlen&lt;=len&lt;=maxlen, starting at block</span>
<span class="cm"> * bno.  If we don&#39;t get maxlen then use prod to trim the length, if given.</span>
<span class="cm"> * Returns error; returns starting block in *rtblock.</span>
<span class="cm"> * The lengths are all in rtextents.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtallocate_extent_exact</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount point */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">bno</span><span class="p">,</span>		<span class="cm">/* starting block number to allocate */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">minlen</span><span class="p">,</span>		<span class="cm">/* minimum length to allocate */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">maxlen</span><span class="p">,</span>		<span class="cm">/* maximum length to allocate */</span>
	<span class="n">xfs_extlen_t</span>	<span class="o">*</span><span class="n">len</span><span class="p">,</span>		<span class="cm">/* out: actual length allocated */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">rbpp</span><span class="p">,</span>		<span class="cm">/* in/out: summary block buffer */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="o">*</span><span class="n">rsb</span><span class="p">,</span>		<span class="cm">/* in/out: summary block number */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">prod</span><span class="p">,</span>		<span class="cm">/* extent product factor */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="o">*</span><span class="n">rtblock</span><span class="p">)</span>	<span class="cm">/* out: start block allocated */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">i</span><span class="p">;</span>		<span class="cm">/* extent length trimmed due to prod */</span>
	<span class="kt">int</span>		<span class="n">isfree</span><span class="p">;</span>		<span class="cm">/* extent is free */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">next</span><span class="p">;</span>		<span class="cm">/* next block to try (dummy) */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">minlen</span> <span class="o">%</span> <span class="n">prod</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">maxlen</span> <span class="o">%</span> <span class="n">prod</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check if the range in question (for maxlen) is free.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtcheck_range</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">isfree</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isfree</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it is, allocate it and return success.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtallocate_range</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">maxlen</span><span class="p">;</span>
		<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">bno</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If not, allocate what there is, if it&#39;s at least minlen.</span>
<span class="cm">	 */</span>
	<span class="n">maxlen</span> <span class="o">=</span> <span class="n">next</span> <span class="o">-</span> <span class="n">bno</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxlen</span> <span class="o">&lt;</span> <span class="n">minlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Failed, return failure status.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">NULLRTBLOCK</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Trim off tail of extent, if prod is specified.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prod</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">maxlen</span> <span class="o">%</span> <span class="n">prod</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">maxlen</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxlen</span> <span class="o">&lt;</span> <span class="n">minlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Now we can&#39;t do it, return failure status.</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">NULLRTBLOCK</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocate what we can and return it.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtallocate_range</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">maxlen</span><span class="p">;</span>
	<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">bno</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate an extent of length minlen&lt;=len&lt;=maxlen, starting as near</span>
<span class="cm"> * to bno as possible.  If we don&#39;t get maxlen then use prod to trim</span>
<span class="cm"> * the length, if given.  The lengths are all in rtextents.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtallocate_extent_near</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount point */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">bno</span><span class="p">,</span>		<span class="cm">/* starting block number to allocate */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">minlen</span><span class="p">,</span>		<span class="cm">/* minimum length to allocate */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">maxlen</span><span class="p">,</span>		<span class="cm">/* maximum length to allocate */</span>
	<span class="n">xfs_extlen_t</span>	<span class="o">*</span><span class="n">len</span><span class="p">,</span>		<span class="cm">/* out: actual length allocated */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">rbpp</span><span class="p">,</span>		<span class="cm">/* in/out: summary block buffer */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="o">*</span><span class="n">rsb</span><span class="p">,</span>		<span class="cm">/* in/out: summary block number */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">prod</span><span class="p">,</span>		<span class="cm">/* extent product factor */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="o">*</span><span class="n">rtblock</span><span class="p">)</span>	<span class="cm">/* out: start block allocated */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">any</span><span class="p">;</span>		<span class="cm">/* any useful extents from summary */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">bbno</span><span class="p">;</span>		<span class="cm">/* bitmap block number */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>		<span class="cm">/* bitmap block offset (loop control) */</span>
	<span class="kt">int</span>		<span class="n">j</span><span class="p">;</span>		<span class="cm">/* secondary loop control */</span>
	<span class="kt">int</span>		<span class="n">log2len</span><span class="p">;</span>	<span class="cm">/* log2 of minlen */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">n</span><span class="p">;</span>		<span class="cm">/* next block to try */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">r</span><span class="p">;</span>		<span class="cm">/* result block */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">minlen</span> <span class="o">%</span> <span class="n">prod</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">maxlen</span> <span class="o">%</span> <span class="n">prod</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the block number given is off the end, silently set it to</span>
<span class="cm">	 * the last block.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bno</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextents</span><span class="p">)</span>
		<span class="n">bno</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextents</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Try the exact allocation first.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtallocate_extent_exact</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="n">minlen</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
		<span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the exact allocation worked, return that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">NULLRTBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bbno</span> <span class="o">=</span> <span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">bno</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">minlen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">log2len</span> <span class="o">=</span> <span class="n">xfs_highbit32</span><span class="p">(</span><span class="n">minlen</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Loop over all bitmap blocks (bbno + i is current block).</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get summary information of extents of all useful levels</span>
<span class="cm">		 * starting in this bitmap block.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtany_summary</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">log2len</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumlevels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">bbno</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">any</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there are any useful extents starting here, try</span>
<span class="cm">		 * allocating one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">any</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * On the positive side of the starting location.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Try to allocate an extent starting in</span>
<span class="cm">				 * this block.</span>
<span class="cm">				 */</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtallocate_extent_block</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span>
					<span class="n">bbno</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">minlen</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span>
					<span class="n">rsb</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/*</span>
<span class="cm">				 * If it worked, return it.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">NULLRTBLOCK</span><span class="p">)</span> <span class="p">{</span>
					<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * On the negative side of the starting location.</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="p">{</span>		<span class="cm">/* i &lt; 0 */</span>
				<span class="cm">/*</span>
<span class="cm">				 * Loop backwards through the bitmap blocks from</span>
<span class="cm">				 * the starting point-1 up to where we are now.</span>
<span class="cm">				 * There should be an extent which ends in this</span>
<span class="cm">				 * bitmap block and is long enough.</span>
<span class="cm">				 */</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * Grab the summary information for</span>
<span class="cm">					 * this bitmap block.</span>
<span class="cm">					 */</span>
					<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtany_summary</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span>
						<span class="n">log2len</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumlevels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
						<span class="n">bbno</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">any</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="cm">/*</span>
<span class="cm">					 * If there&#39;s no extent given in the</span>
<span class="cm">					 * summary that means the extent we</span>
<span class="cm">					 * found must carry over from an</span>
<span class="cm">					 * earlier block.  If there is an</span>
<span class="cm">					 * extent given, we&#39;ve already tried</span>
<span class="cm">					 * that allocation, don&#39;t do it again.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">any</span><span class="p">)</span>
						<span class="k">continue</span><span class="p">;</span>
					<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtallocate_extent_block</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
						<span class="n">tp</span><span class="p">,</span> <span class="n">bbno</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">minlen</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span>
						<span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="cm">/*</span>
<span class="cm">					 * If it works, return the extent.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">NULLRTBLOCK</span><span class="p">)</span> <span class="p">{</span>
						<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
						<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="cm">/*</span>
<span class="cm">				 * There weren&#39;t intervening bitmap blocks</span>
<span class="cm">				 * with a long enough extent, or the</span>
<span class="cm">				 * allocation didn&#39;t work for some reason</span>
<span class="cm">				 * (i.e. it&#39;s a little * too short).</span>
<span class="cm">				 * Try to allocate from the summary block</span>
<span class="cm">				 * that we found.</span>
<span class="cm">				 */</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtallocate_extent_block</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span>
					<span class="n">bbno</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">minlen</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span>
					<span class="n">rsb</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/*</span>
<span class="cm">				 * If it works, return the extent.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">NULLRTBLOCK</span><span class="p">)</span> <span class="p">{</span>
					<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Loop control.  If we were on the positive side, and there&#39;s</span>
<span class="cm">		 * still more blocks on the negative side, go there.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">bbno</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="n">i</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If positive, and no more negative, but there are more</span>
<span class="cm">		 * positive, go there.</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">bbno</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rbmblocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If negative or 0 (just started), and there are positive</span>
<span class="cm">		 * blocks to go, go there.  The 0 case moves to block 1.</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">bbno</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rbmblocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If negative or 0 and there are more negative blocks,</span>
<span class="cm">		 * go there.</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">bbno</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">i</span><span class="o">--</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Must be done.  Return failure.</span>
<span class="cm">		 */</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">NULLRTBLOCK</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate an extent of length minlen&lt;=len&lt;=maxlen, with no position</span>
<span class="cm"> * specified.  If we don&#39;t get maxlen then use prod to trim</span>
<span class="cm"> * the length, if given.  The lengths are all in rtextents.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtallocate_extent_size</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount point */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">minlen</span><span class="p">,</span>		<span class="cm">/* minimum length to allocate */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">maxlen</span><span class="p">,</span>		<span class="cm">/* maximum length to allocate */</span>
	<span class="n">xfs_extlen_t</span>	<span class="o">*</span><span class="n">len</span><span class="p">,</span>		<span class="cm">/* out: actual length allocated */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">rbpp</span><span class="p">,</span>		<span class="cm">/* in/out: summary block buffer */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="o">*</span><span class="n">rsb</span><span class="p">,</span>		<span class="cm">/* in/out: summary block number */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">prod</span><span class="p">,</span>		<span class="cm">/* extent product factor */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="o">*</span><span class="n">rtblock</span><span class="p">)</span>	<span class="cm">/* out: start block allocated */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>		<span class="cm">/* bitmap block number */</span>
	<span class="kt">int</span>		<span class="n">l</span><span class="p">;</span>		<span class="cm">/* level number (loop control) */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">n</span><span class="p">;</span>		<span class="cm">/* next block to be tried */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">r</span><span class="p">;</span>		<span class="cm">/* result block number */</span>
	<span class="n">xfs_suminfo_t</span>	<span class="n">sum</span><span class="p">;</span>		<span class="cm">/* summary information for extents */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">minlen</span> <span class="o">%</span> <span class="n">prod</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">maxlen</span> <span class="o">%</span> <span class="n">prod</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">maxlen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Loop over all the levels starting with maxlen.</span>
<span class="cm">	 * At each level, look at all the bitmap blocks, to see if there</span>
<span class="cm">	 * are extents starting there that are long enough (&gt;= maxlen).</span>
<span class="cm">	 * Note, only on the initial level can the allocation fail if</span>
<span class="cm">	 * the summary says there&#39;s an extent.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">xfs_highbit32</span><span class="p">(</span><span class="n">maxlen</span><span class="p">);</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumlevels</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Loop over all the bitmap blocks.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rbmblocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Get the summary for this level/block.</span>
<span class="cm">			 */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtget_summary</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Nothing there, on to the next block.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sum</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Try allocating the extent.</span>
<span class="cm">			 */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtallocate_extent_block</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span>
				<span class="n">maxlen</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * If it worked, return that.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">NULLRTBLOCK</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the &quot;next block to try&quot; returned from the</span>
<span class="cm">			 * allocator is beyond the next bitmap block,</span>
<span class="cm">			 * skip to that bitmap block.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Didn&#39;t find any maxlen blocks.  Try smaller ones, unless</span>
<span class="cm">	 * we&#39;re asking for a fixed size extent.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">minlen</span> <span class="o">&gt;</span> <span class="o">--</span><span class="n">maxlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">NULLRTBLOCK</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">minlen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">maxlen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Loop over sizes, from maxlen down to minlen.</span>
<span class="cm">	 * This time, when we do the allocations, allow smaller ones</span>
<span class="cm">	 * to succeed.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">xfs_highbit32</span><span class="p">(</span><span class="n">maxlen</span><span class="p">);</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="n">xfs_highbit32</span><span class="p">(</span><span class="n">minlen</span><span class="p">);</span> <span class="n">l</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Loop over all the bitmap blocks, try an allocation</span>
<span class="cm">		 * starting in that block.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rbmblocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Get the summary information for this level/block.</span>
<span class="cm">			 */</span>
			<span class="n">error</span> <span class="o">=</span>	<span class="n">xfs_rtget_summary</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">sum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * If nothing there, go on to next.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sum</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Try the allocation.  Make sure the specified</span>
<span class="cm">			 * minlen/maxlen are in the possible range for</span>
<span class="cm">			 * this summary level.</span>
<span class="cm">			 */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtallocate_extent_block</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">XFS_RTMAX</span><span class="p">(</span><span class="n">minlen</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">l</span><span class="p">),</span>
					<span class="n">XFS_RTMIN</span><span class="p">(</span><span class="n">maxlen</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
					<span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * If it worked, return that extent.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">NULLRTBLOCK</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the &quot;next block to try&quot; returned from the</span>
<span class="cm">			 * allocator is beyond the next bitmap block,</span>
<span class="cm">			 * skip to that bitmap block.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Got nothing, return failure.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">NULLRTBLOCK</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mark an extent specified by start and len allocated.</span>
<span class="cm"> * Updates all the summary information as well as the bitmap.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtallocate_range</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount point */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">start</span><span class="p">,</span>		<span class="cm">/* start block to allocate */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">len</span><span class="p">,</span>		<span class="cm">/* length to allocate */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">rbpp</span><span class="p">,</span>		<span class="cm">/* in/out: summary block buffer */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="o">*</span><span class="n">rsb</span><span class="p">)</span>		<span class="cm">/* in/out: summary block number */</span>
<span class="p">{</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">end</span><span class="p">;</span>		<span class="cm">/* end of the allocated extent */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">postblock</span><span class="p">;</span>	<span class="cm">/* first block allocated &gt; end */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">preblock</span><span class="p">;</span>	<span class="cm">/* first block allocated &lt; start */</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Assume we&#39;re allocating out of the middle of a free extent.</span>
<span class="cm">	 * We need to find the beginning and end of the extent so we can</span>
<span class="cm">	 * properly update the summary.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtfind_back</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">preblock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Find the next allocated block (end of free extent).</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtfind_forw</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextents</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">postblock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Decrement the summary information corresponding to the entire</span>
<span class="cm">	 * (old) free extent.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtmodify_summary</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span>
		<span class="n">XFS_RTBLOCKLOG</span><span class="p">(</span><span class="n">postblock</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">preblock</span><span class="p">),</span>
		<span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">preblock</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there are blocks not being allocated at the front of the</span>
<span class="cm">	 * old extent, add summary data for them to be free.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">preblock</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtmodify_summary</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span>
			<span class="n">XFS_RTBLOCKLOG</span><span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">preblock</span><span class="p">),</span>
			<span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">preblock</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there are blocks not being allocated at the end of the</span>
<span class="cm">	 * old extent, add summary data for them to be free.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">postblock</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtmodify_summary</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span>
			<span class="n">XFS_RTBLOCKLOG</span><span class="p">(</span><span class="n">postblock</span> <span class="o">-</span> <span class="n">end</span><span class="p">),</span>
			<span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Modify the bitmap to mark this extent allocated.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtmodify_range</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return whether there are any free extents in the size range given</span>
<span class="cm"> * by low and high, for the bitmap block bbno.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtany_summary</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount structure */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="kt">int</span>		<span class="n">low</span><span class="p">,</span>		<span class="cm">/* low log2 extent size */</span>
	<span class="kt">int</span>		<span class="n">high</span><span class="p">,</span>		<span class="cm">/* high log2 extent size */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">bbno</span><span class="p">,</span>		<span class="cm">/* bitmap block number */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">rbpp</span><span class="p">,</span>		<span class="cm">/* in/out: summary block buffer */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="o">*</span><span class="n">rsb</span><span class="p">,</span>		<span class="cm">/* in/out: summary block number */</span>
	<span class="kt">int</span>		<span class="o">*</span><span class="n">stat</span><span class="p">)</span>		<span class="cm">/* out: any good extents here? */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="kt">int</span>		<span class="n">log</span><span class="p">;</span>		<span class="cm">/* loop counter, log2 of ext. size */</span>
	<span class="n">xfs_suminfo_t</span>	<span class="n">sum</span><span class="p">;</span>		<span class="cm">/* summary data */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Loop over logs of extent sizes.  Order is irrelevant.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">log</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span> <span class="n">log</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">;</span> <span class="n">log</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get one summary datum.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtget_summary</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">bbno</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there are any, return success.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sum</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Found nothing, return failure.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get a buffer for the bitmap or summary file block specified.</span>
<span class="cm"> * The buffer is returned read and locked.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtbuf_get</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount structure */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">block</span><span class="p">,</span>		<span class="cm">/* block number in bitmap or summary */</span>
	<span class="kt">int</span>		<span class="n">issum</span><span class="p">,</span>		<span class="cm">/* is summary not bitmap */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">bpp</span><span class="p">)</span>		<span class="cm">/* output: buffer for the block */</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* block buffer, result */</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">;</span>		<span class="cm">/* bitmap or summary inode */</span>
	<span class="n">xfs_bmbt_irec_t</span>	<span class="n">map</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">nmap</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>

	<span class="n">ip</span> <span class="o">=</span> <span class="n">issum</span> <span class="o">?</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumip</span> <span class="o">:</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmap</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">NULLFSBLOCK</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_read_buf</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span>
				   <span class="n">XFS_FSB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span><span class="p">),</span>
				   <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_bsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">xfs_buf_geterror</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
	<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cm">/*</span>
<span class="cm"> * Check that the given extent (block range) is allocated already.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtcheck_alloc_range</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount point */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">bno</span><span class="p">,</span>		<span class="cm">/* starting block number of extent */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">len</span><span class="p">,</span>		<span class="cm">/* length of extent */</span>
	<span class="kt">int</span>		<span class="o">*</span><span class="n">stat</span><span class="p">)</span>		<span class="cm">/* out: 1 for allocated, 0 for not */</span>
<span class="p">{</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">new</span><span class="p">;</span>		<span class="cm">/* dummy for xfs_rtcheck_range */</span>

	<span class="k">return</span> <span class="n">xfs_rtcheck_range</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Check that the given range is either all allocated (val = 0) or</span>
<span class="cm"> * all free (val = 1).</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtcheck_range</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount point */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">start</span><span class="p">,</span>		<span class="cm">/* starting block number of extent */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">len</span><span class="p">,</span>		<span class="cm">/* length of extent */</span>
	<span class="kt">int</span>		<span class="n">val</span><span class="p">,</span>		<span class="cm">/* 1 for free, 0 for allocated */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="o">*</span><span class="n">new</span><span class="p">,</span>		<span class="cm">/* out: first block not matching */</span>
	<span class="kt">int</span>		<span class="o">*</span><span class="n">stat</span><span class="p">)</span>		<span class="cm">/* out: 1 for matches, 0 for not */</span>
<span class="p">{</span>
	<span class="n">xfs_rtword_t</span>	<span class="o">*</span><span class="n">b</span><span class="p">;</span>		<span class="cm">/* current word in buffer */</span>
	<span class="kt">int</span>		<span class="n">bit</span><span class="p">;</span>		<span class="cm">/* bit number in the word */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">block</span><span class="p">;</span>		<span class="cm">/* bitmap block number */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* buf for the block */</span>
	<span class="n">xfs_rtword_t</span>	<span class="o">*</span><span class="n">bufp</span><span class="p">;</span>		<span class="cm">/* starting word in buffer */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">i</span><span class="p">;</span>		<span class="cm">/* current bit number rel. to start */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">lastbit</span><span class="p">;</span>	<span class="cm">/* last useful bit in word */</span>
	<span class="n">xfs_rtword_t</span>	<span class="n">mask</span><span class="p">;</span>		<span class="cm">/* mask of relevant bits for value */</span>
	<span class="n">xfs_rtword_t</span>	<span class="n">wdiff</span><span class="p">;</span>		<span class="cm">/* difference from wanted value */</span>
	<span class="kt">int</span>		<span class="n">word</span><span class="p">;</span>		<span class="cm">/* word number in the buffer */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute starting bitmap block number</span>
<span class="cm">	 */</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read the bitmap block.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtbuf_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bufp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Compute the starting word&#39;s address, and starting bit.</span>
<span class="cm">	 */</span>
	<span class="n">word</span> <span class="o">=</span> <span class="n">XFS_BITTOWORD</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bufp</span><span class="p">[</span><span class="n">word</span><span class="p">];</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_NBWORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * 0 (allocated) =&gt; all zero&#39;s; 1 (free) =&gt; all one&#39;s.</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="o">-</span><span class="n">val</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If not starting on a word boundary, deal with the first</span>
<span class="cm">	 * (partial) word.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compute first bit not examined.</span>
<span class="cm">		 */</span>
		<span class="n">lastbit</span> <span class="o">=</span> <span class="n">XFS_RTMIN</span><span class="p">(</span><span class="n">bit</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">XFS_NBWORD</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Mask of relevant bits.</span>
<span class="cm">		 */</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="p">(((</span><span class="n">xfs_rtword_t</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">lastbit</span> <span class="o">-</span> <span class="n">bit</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compute difference between actual and desired value.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">wdiff</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">^</span> <span class="n">val</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Different, compute first wrong bit and return.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">XFS_RTLOBIT</span><span class="p">(</span><span class="n">wdiff</span><span class="p">)</span> <span class="o">-</span> <span class="n">bit</span><span class="p">;</span>
			<span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">lastbit</span> <span class="o">-</span> <span class="n">bit</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Go on to next block if that&#39;s where the next word is</span>
<span class="cm">		 * and we need the next word.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">word</span> <span class="o">==</span> <span class="n">XFS_BLOCKWSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If done with this block, get the next one.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtbuf_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="o">++</span><span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">bufp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
			<span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Go on to the next word in the buffer.</span>
<span class="cm">			 */</span>
			<span class="n">b</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Starting on a word boundary, no partial word.</span>
<span class="cm">		 */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Loop over whole words in buffers.  When we use up one buffer</span>
<span class="cm">	 * we move on to the next one.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">XFS_NBWORD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compute difference between actual and desired value.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">wdiff</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span> <span class="o">^</span> <span class="n">val</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Different, compute first wrong bit and return.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">XFS_RTLOBIT</span><span class="p">(</span><span class="n">wdiff</span><span class="p">);</span>
			<span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="n">XFS_NBWORD</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Go on to next block if that&#39;s where the next word is</span>
<span class="cm">		 * and we need the next word.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">word</span> <span class="o">==</span> <span class="n">XFS_BLOCKWSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If done with this block, get the next one.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtbuf_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="o">++</span><span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">bufp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
			<span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Go on to the next word in the buffer.</span>
<span class="cm">			 */</span>
			<span class="n">b</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If not ending on a word boundary, deal with the last</span>
<span class="cm">	 * (partial) word.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">lastbit</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Mask of relevant bits.</span>
<span class="cm">		 */</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">xfs_rtword_t</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lastbit</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compute difference between actual and desired value.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">wdiff</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">^</span> <span class="n">val</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Different, compute first wrong bit and return.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">XFS_RTLOBIT</span><span class="p">(</span><span class="n">wdiff</span><span class="p">);</span>
			<span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Successful, return.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
	<span class="o">*</span><span class="n">stat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy and transform the summary file, given the old and new</span>
<span class="cm"> * parameters in the mount structures.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtcopy_summary</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">omp</span><span class="p">,</span>		<span class="cm">/* old file system mount point */</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">nmp</span><span class="p">,</span>		<span class="cm">/* new file system mount point */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">)</span>		<span class="cm">/* transaction pointer */</span>
<span class="p">{</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">bbno</span><span class="p">;</span>		<span class="cm">/* bitmap block number */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* summary buffer */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="kt">int</span>		<span class="n">log</span><span class="p">;</span>		<span class="cm">/* summary level number (log length) */</span>
	<span class="n">xfs_suminfo_t</span>	<span class="n">sum</span><span class="p">;</span>		<span class="cm">/* summary data */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="n">sumbno</span><span class="p">;</span>		<span class="cm">/* summary block number */</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">log</span> <span class="o">=</span> <span class="n">omp</span><span class="o">-&gt;</span><span class="n">m_rsumlevels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">log</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">log</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">bbno</span> <span class="o">=</span> <span class="n">omp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rbmblocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		     <span class="p">(</span><span class="n">xfs_srtblock_t</span><span class="p">)</span><span class="n">bbno</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">bbno</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtget_summary</span><span class="p">(</span><span class="n">omp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">bbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sumbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtmodify_summary</span><span class="p">(</span><span class="n">omp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">bbno</span><span class="p">,</span> <span class="o">-</span><span class="n">sum</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sumbno</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtmodify_summary</span><span class="p">(</span><span class="n">nmp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">bbno</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sumbno</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Searching backward from start to limit, find the first block whose</span>
<span class="cm"> * allocated/free state is different from start&#39;s.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtfind_back</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount point */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">start</span><span class="p">,</span>		<span class="cm">/* starting block to look at */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">limit</span><span class="p">,</span>		<span class="cm">/* last block to look at */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="o">*</span><span class="n">rtblock</span><span class="p">)</span>	<span class="cm">/* out: start block found */</span>
<span class="p">{</span>
	<span class="n">xfs_rtword_t</span>	<span class="o">*</span><span class="n">b</span><span class="p">;</span>		<span class="cm">/* current word in buffer */</span>
	<span class="kt">int</span>		<span class="n">bit</span><span class="p">;</span>		<span class="cm">/* bit number in the word */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">block</span><span class="p">;</span>		<span class="cm">/* bitmap block number */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* buf for the block */</span>
	<span class="n">xfs_rtword_t</span>	<span class="o">*</span><span class="n">bufp</span><span class="p">;</span>		<span class="cm">/* starting word in buffer */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">firstbit</span><span class="p">;</span>	<span class="cm">/* first useful bit in the word */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">i</span><span class="p">;</span>		<span class="cm">/* current bit number rel. to start */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">len</span><span class="p">;</span>		<span class="cm">/* length of inspected area */</span>
	<span class="n">xfs_rtword_t</span>	<span class="n">mask</span><span class="p">;</span>		<span class="cm">/* mask of relevant bits for value */</span>
	<span class="n">xfs_rtword_t</span>	<span class="n">want</span><span class="p">;</span>		<span class="cm">/* mask for &quot;good&quot; values */</span>
	<span class="n">xfs_rtword_t</span>	<span class="n">wdiff</span><span class="p">;</span>		<span class="cm">/* difference from wanted value */</span>
	<span class="kt">int</span>		<span class="n">word</span><span class="p">;</span>		<span class="cm">/* word number in the buffer */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute and read in starting bitmap block for starting block.</span>
<span class="cm">	 */</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtbuf_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bufp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the first word&#39;s index &amp; point to it.</span>
<span class="cm">	 */</span>
	<span class="n">word</span> <span class="o">=</span> <span class="n">XFS_BITTOWORD</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bufp</span><span class="p">[</span><span class="n">word</span><span class="p">];</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_NBWORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">limit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Compute match value, based on the bit at start: if 1 (free)</span>
<span class="cm">	 * then all-ones, else all-zeroes.</span>
<span class="cm">	 */</span>
	<span class="n">want</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">xfs_rtword_t</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the starting position is not word-aligned, deal with the</span>
<span class="cm">	 * partial word.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&lt;</span> <span class="n">XFS_NBWORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Calculate first (leftmost) bit number to look at,</span>
<span class="cm">		 * and mask for all the relevant bits in this word.</span>
<span class="cm">		 */</span>
		<span class="n">firstbit</span> <span class="o">=</span> <span class="n">XFS_RTMAX</span><span class="p">((</span><span class="n">xfs_srtblock_t</span><span class="p">)(</span><span class="n">bit</span> <span class="o">-</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="p">(((</span><span class="n">xfs_rtword_t</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bit</span> <span class="o">-</span> <span class="n">firstbit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
			<span class="n">firstbit</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Calculate the difference between the value there</span>
<span class="cm">		 * and what we&#39;re looking for.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">wdiff</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">^</span> <span class="n">want</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Different.  Mark where we are and return.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">bit</span> <span class="o">-</span> <span class="n">XFS_RTHIBIT</span><span class="p">(</span><span class="n">wdiff</span><span class="p">);</span>
			<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">bit</span> <span class="o">-</span> <span class="n">firstbit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Go on to previous block if that&#39;s where the previous word is</span>
<span class="cm">		 * and we need the previous word.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">word</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If done with this block, get the previous one.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtbuf_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="o">--</span><span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">bufp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
			<span class="n">word</span> <span class="o">=</span> <span class="n">XFS_BLOCKWMASK</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bufp</span><span class="p">[</span><span class="n">word</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Go on to the previous word in the buffer.</span>
<span class="cm">			 */</span>
			<span class="n">b</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Starting on a word boundary, no partial word.</span>
<span class="cm">		 */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Loop over whole words in buffers.  When we use up one buffer</span>
<span class="cm">	 * we move on to the previous one.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">XFS_NBWORD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compute difference between actual and desired value.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">wdiff</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span> <span class="o">^</span> <span class="n">want</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Different, mark where we are and return.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">XFS_NBWORD</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">XFS_RTHIBIT</span><span class="p">(</span><span class="n">wdiff</span><span class="p">);</span>
			<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="n">XFS_NBWORD</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Go on to previous block if that&#39;s where the previous word is</span>
<span class="cm">		 * and we need the previous word.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">word</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If done with this block, get the previous one.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtbuf_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="o">--</span><span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">bufp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
			<span class="n">word</span> <span class="o">=</span> <span class="n">XFS_BLOCKWMASK</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bufp</span><span class="p">[</span><span class="n">word</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Go on to the previous word in the buffer.</span>
<span class="cm">			 */</span>
			<span class="n">b</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If not ending on a word boundary, deal with the last</span>
<span class="cm">	 * (partial) word.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Calculate first (leftmost) bit number to look at,</span>
<span class="cm">		 * and mask for all the relevant bits in this word.</span>
<span class="cm">		 */</span>
		<span class="n">firstbit</span> <span class="o">=</span> <span class="n">XFS_NBWORD</span> <span class="o">-</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="p">(((</span><span class="n">xfs_rtword_t</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">firstbit</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compute difference between actual and desired value.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">wdiff</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">^</span> <span class="n">want</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Different, mark where we are and return.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">XFS_NBWORD</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">XFS_RTHIBIT</span><span class="p">(</span><span class="n">wdiff</span><span class="p">);</span>
			<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * No match, return that we scanned the whole area.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Searching forward from start to limit, find the first block whose</span>
<span class="cm"> * allocated/free state is different from start&#39;s.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtfind_forw</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount point */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">start</span><span class="p">,</span>		<span class="cm">/* starting block to look at */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">limit</span><span class="p">,</span>		<span class="cm">/* last block to look at */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="o">*</span><span class="n">rtblock</span><span class="p">)</span>	<span class="cm">/* out: start block found */</span>
<span class="p">{</span>
	<span class="n">xfs_rtword_t</span>	<span class="o">*</span><span class="n">b</span><span class="p">;</span>		<span class="cm">/* current word in buffer */</span>
	<span class="kt">int</span>		<span class="n">bit</span><span class="p">;</span>		<span class="cm">/* bit number in the word */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">block</span><span class="p">;</span>		<span class="cm">/* bitmap block number */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* buf for the block */</span>
	<span class="n">xfs_rtword_t</span>	<span class="o">*</span><span class="n">bufp</span><span class="p">;</span>		<span class="cm">/* starting word in buffer */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">i</span><span class="p">;</span>		<span class="cm">/* current bit number rel. to start */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">lastbit</span><span class="p">;</span>	<span class="cm">/* last useful bit in the word */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">len</span><span class="p">;</span>		<span class="cm">/* length of inspected area */</span>
	<span class="n">xfs_rtword_t</span>	<span class="n">mask</span><span class="p">;</span>		<span class="cm">/* mask of relevant bits for value */</span>
	<span class="n">xfs_rtword_t</span>	<span class="n">want</span><span class="p">;</span>		<span class="cm">/* mask for &quot;good&quot; values */</span>
	<span class="n">xfs_rtword_t</span>	<span class="n">wdiff</span><span class="p">;</span>		<span class="cm">/* difference from wanted value */</span>
	<span class="kt">int</span>		<span class="n">word</span><span class="p">;</span>		<span class="cm">/* word number in the buffer */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute and read in starting bitmap block for starting block.</span>
<span class="cm">	 */</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtbuf_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bufp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the first word&#39;s index &amp; point to it.</span>
<span class="cm">	 */</span>
	<span class="n">word</span> <span class="o">=</span> <span class="n">XFS_BITTOWORD</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bufp</span><span class="p">[</span><span class="n">word</span><span class="p">];</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_NBWORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">limit</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Compute match value, based on the bit at start: if 1 (free)</span>
<span class="cm">	 * then all-ones, else all-zeroes.</span>
<span class="cm">	 */</span>
	<span class="n">want</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">xfs_rtword_t</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the starting position is not word-aligned, deal with the</span>
<span class="cm">	 * partial word.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Calculate last (rightmost) bit number to look at,</span>
<span class="cm">		 * and mask for all the relevant bits in this word.</span>
<span class="cm">		 */</span>
		<span class="n">lastbit</span> <span class="o">=</span> <span class="n">XFS_RTMIN</span><span class="p">(</span><span class="n">bit</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">XFS_NBWORD</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="p">(((</span><span class="n">xfs_rtword_t</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">lastbit</span> <span class="o">-</span> <span class="n">bit</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Calculate the difference between the value there</span>
<span class="cm">		 * and what we&#39;re looking for.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">wdiff</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">^</span> <span class="n">want</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Different.  Mark where we are and return.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">XFS_RTLOBIT</span><span class="p">(</span><span class="n">wdiff</span><span class="p">)</span> <span class="o">-</span> <span class="n">bit</span><span class="p">;</span>
			<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">lastbit</span> <span class="o">-</span> <span class="n">bit</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Go on to next block if that&#39;s where the next word is</span>
<span class="cm">		 * and we need the next word.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">word</span> <span class="o">==</span> <span class="n">XFS_BLOCKWSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If done with this block, get the previous one.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtbuf_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="o">++</span><span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">bufp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
			<span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Go on to the previous word in the buffer.</span>
<span class="cm">			 */</span>
			<span class="n">b</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Starting on a word boundary, no partial word.</span>
<span class="cm">		 */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Loop over whole words in buffers.  When we use up one buffer</span>
<span class="cm">	 * we move on to the next one.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">XFS_NBWORD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compute difference between actual and desired value.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">wdiff</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span> <span class="o">^</span> <span class="n">want</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Different, mark where we are and return.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">XFS_RTLOBIT</span><span class="p">(</span><span class="n">wdiff</span><span class="p">);</span>
			<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="n">XFS_NBWORD</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Go on to next block if that&#39;s where the next word is</span>
<span class="cm">		 * and we need the next word.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">word</span> <span class="o">==</span> <span class="n">XFS_BLOCKWSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If done with this block, get the next one.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtbuf_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="o">++</span><span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">bufp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
			<span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Go on to the next word in the buffer.</span>
<span class="cm">			 */</span>
			<span class="n">b</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If not ending on a word boundary, deal with the last</span>
<span class="cm">	 * (partial) word.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">lastbit</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Calculate mask for all the relevant bits in this word.</span>
<span class="cm">		 */</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">xfs_rtword_t</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lastbit</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compute difference between actual and desired value.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">wdiff</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span> <span class="o">^</span> <span class="n">want</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Different, mark where we are and return.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">XFS_RTLOBIT</span><span class="p">(</span><span class="n">wdiff</span><span class="p">);</span>
			<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * No match, return that we scanned the whole area.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mark an extent specified by start and len freed.</span>
<span class="cm"> * Updates all the summary information as well as the bitmap.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtfree_range</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount point */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">start</span><span class="p">,</span>		<span class="cm">/* starting block to free */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">len</span><span class="p">,</span>		<span class="cm">/* length to free */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">rbpp</span><span class="p">,</span>		<span class="cm">/* in/out: summary block buffer */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="o">*</span><span class="n">rsb</span><span class="p">)</span>		<span class="cm">/* in/out: summary block number */</span>
<span class="p">{</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">end</span><span class="p">;</span>		<span class="cm">/* end of the freed extent */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">postblock</span><span class="p">;</span>	<span class="cm">/* first block freed &gt; end */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">preblock</span><span class="p">;</span>	<span class="cm">/* first block freed &lt; start */</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Modify the bitmap to mark this extent freed.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtmodify_range</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Assume we&#39;re freeing out of the middle of an allocated extent.</span>
<span class="cm">	 * We need to find the beginning and end of the extent so we can</span>
<span class="cm">	 * properly update the summary.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtfind_back</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">preblock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Find the next allocated block (end of allocated extent).</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtfind_forw</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextents</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">postblock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there are blocks not being freed at the front of the</span>
<span class="cm">	 * old extent, add summary data for them to be allocated.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">preblock</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtmodify_summary</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span>
			<span class="n">XFS_RTBLOCKLOG</span><span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">preblock</span><span class="p">),</span>
			<span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">preblock</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there are blocks not being freed at the end of the</span>
<span class="cm">	 * old extent, add summary data for them to be allocated.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">postblock</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtmodify_summary</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span>
			<span class="n">XFS_RTBLOCKLOG</span><span class="p">(</span><span class="n">postblock</span> <span class="o">-</span> <span class="n">end</span><span class="p">),</span>
			<span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Increment the summary information corresponding to the entire</span>
<span class="cm">	 * (new) free extent.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtmodify_summary</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span>
		<span class="n">XFS_RTBLOCKLOG</span><span class="p">(</span><span class="n">postblock</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">preblock</span><span class="p">),</span>
		<span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">preblock</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rbpp</span><span class="p">,</span> <span class="n">rsb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read and return the summary information for a given extent size,</span>
<span class="cm"> * bitmap block combination.</span>
<span class="cm"> * Keeps track of a current summary block, so we don&#39;t keep reading</span>
<span class="cm"> * it from the buffer cache.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtget_summary</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount structure */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="kt">int</span>		<span class="n">log</span><span class="p">,</span>		<span class="cm">/* log2 of extent size */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">bbno</span><span class="p">,</span>		<span class="cm">/* bitmap block number */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">rbpp</span><span class="p">,</span>		<span class="cm">/* in/out: summary block buffer */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="o">*</span><span class="n">rsb</span><span class="p">,</span>		<span class="cm">/* in/out: summary block number */</span>
	<span class="n">xfs_suminfo_t</span>	<span class="o">*</span><span class="n">sum</span><span class="p">)</span>		<span class="cm">/* out: summary info for this block */</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* buffer for summary block */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="n">sb</span><span class="p">;</span>		<span class="cm">/* summary fsblock */</span>
	<span class="kt">int</span>		<span class="n">so</span><span class="p">;</span>		<span class="cm">/* index into the summary file */</span>
	<span class="n">xfs_suminfo_t</span>	<span class="o">*</span><span class="n">sp</span><span class="p">;</span>		<span class="cm">/* pointer to returned data */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute entry number in the summary file.</span>
<span class="cm">	 */</span>
	<span class="n">so</span> <span class="o">=</span> <span class="n">XFS_SUMOFFS</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">bbno</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Compute the block number in the summary file.</span>
<span class="cm">	 */</span>
	<span class="n">sb</span> <span class="o">=</span> <span class="n">XFS_SUMOFFSTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">so</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we have an old buffer, and the block number matches, use that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rbpp</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">rbpp</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">rsb</span> <span class="o">==</span> <span class="n">sb</span><span class="p">)</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="o">*</span><span class="n">rbpp</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Otherwise we have to get the buffer.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there was an old one, get rid of it first.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rbpp</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">rbpp</span><span class="p">)</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="o">*</span><span class="n">rbpp</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtbuf_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Remember this buffer and block for the next call.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rbpp</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">rbpp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
			<span class="o">*</span><span class="n">rsb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Point to the summary information &amp; copy it out.</span>
<span class="cm">	 */</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">XFS_SUMPTR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">so</span><span class="p">);</span>
	<span class="o">*</span><span class="n">sum</span> <span class="o">=</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Drop the buffer if we&#39;re not asked to remember it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rbpp</span><span class="p">)</span>
		<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the given range of bitmap bits to the given value.</span>
<span class="cm"> * Do whatever I/O and logging is required.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtmodify_range</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount point */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">start</span><span class="p">,</span>		<span class="cm">/* starting block to modify */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">len</span><span class="p">,</span>		<span class="cm">/* length of extent to modify */</span>
	<span class="kt">int</span>		<span class="n">val</span><span class="p">)</span>		<span class="cm">/* 1 for free, 0 for allocated */</span>
<span class="p">{</span>
	<span class="n">xfs_rtword_t</span>	<span class="o">*</span><span class="n">b</span><span class="p">;</span>		<span class="cm">/* current word in buffer */</span>
	<span class="kt">int</span>		<span class="n">bit</span><span class="p">;</span>		<span class="cm">/* bit number in the word */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">block</span><span class="p">;</span>		<span class="cm">/* bitmap block number */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* buf for the block */</span>
	<span class="n">xfs_rtword_t</span>	<span class="o">*</span><span class="n">bufp</span><span class="p">;</span>		<span class="cm">/* starting word in buffer */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="n">xfs_rtword_t</span>	<span class="o">*</span><span class="n">first</span><span class="p">;</span>		<span class="cm">/* first used word in the buffer */</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>		<span class="cm">/* current bit number rel. to start */</span>
	<span class="kt">int</span>		<span class="n">lastbit</span><span class="p">;</span>	<span class="cm">/* last useful bit in word */</span>
	<span class="n">xfs_rtword_t</span>	<span class="n">mask</span><span class="p">;</span>		<span class="cm">/* mask o frelevant bits for value */</span>
	<span class="kt">int</span>		<span class="n">word</span><span class="p">;</span>		<span class="cm">/* word number in the buffer */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute starting bitmap block number.</span>
<span class="cm">	 */</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">XFS_BITTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read the bitmap block, and point to its data.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtbuf_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bufp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Compute the starting word&#39;s address, and starting bit.</span>
<span class="cm">	 */</span>
	<span class="n">word</span> <span class="o">=</span> <span class="n">XFS_BITTOWORD</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">first</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bufp</span><span class="p">[</span><span class="n">word</span><span class="p">];</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_NBWORD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * 0 (allocated) =&gt; all zeroes; 1 (free) =&gt; all ones.</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="o">-</span><span class="n">val</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If not starting on a word boundary, deal with the first</span>
<span class="cm">	 * (partial) word.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compute first bit not changed and mask of relevant bits.</span>
<span class="cm">		 */</span>
		<span class="n">lastbit</span> <span class="o">=</span> <span class="n">XFS_RTMIN</span><span class="p">(</span><span class="n">bit</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">XFS_NBWORD</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="p">(((</span><span class="n">xfs_rtword_t</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">lastbit</span> <span class="o">-</span> <span class="n">bit</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set/clear the active bits.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
			<span class="o">*</span><span class="n">b</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">b</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">lastbit</span> <span class="o">-</span> <span class="n">bit</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Go on to the next block if that&#39;s where the next word is</span>
<span class="cm">		 * and we need the next word.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">word</span> <span class="o">==</span> <span class="n">XFS_BLOCKWSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Log the changed part of this block.</span>
<span class="cm">			 * Get the next one.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
				<span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">first</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bufp</span><span class="p">),</span>
				<span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bufp</span><span class="p">));</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtbuf_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="o">++</span><span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">first</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">bufp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
			<span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Go on to the next word in the buffer</span>
<span class="cm">			 */</span>
			<span class="n">b</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Starting on a word boundary, no partial word.</span>
<span class="cm">		 */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Loop over whole words in buffers.  When we use up one buffer</span>
<span class="cm">	 * we move on to the next one.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">XFS_NBWORD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set the word value correctly.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="n">XFS_NBWORD</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Go on to the next block if that&#39;s where the next word is</span>
<span class="cm">		 * and we need the next word.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">word</span> <span class="o">==</span> <span class="n">XFS_BLOCKWSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Log the changed part of this block.</span>
<span class="cm">			 * Get the next one.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
				<span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">first</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bufp</span><span class="p">),</span>
				<span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bufp</span><span class="p">));</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtbuf_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="o">++</span><span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">first</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">bufp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
			<span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Go on to the next word in the buffer</span>
<span class="cm">			 */</span>
			<span class="n">b</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If not ending on a word boundary, deal with the last</span>
<span class="cm">	 * (partial) word.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">lastbit</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compute a mask of relevant bits.</span>
<span class="cm">		 */</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">xfs_rtword_t</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lastbit</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set/clear the active bits.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
			<span class="o">*</span><span class="n">b</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">b</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">b</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Log any remaining changed bytes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="n">first</span><span class="p">)</span>
		<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">first</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bufp</span><span class="p">),</span>
			<span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bufp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read and modify the summary information for a given extent size,</span>
<span class="cm"> * bitmap block combination.</span>
<span class="cm"> * Keeps track of a current summary block, so we don&#39;t keep reading</span>
<span class="cm"> * it from the buffer cache.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtmodify_summary</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount point */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="kt">int</span>		<span class="n">log</span><span class="p">,</span>		<span class="cm">/* log2 of extent size */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">bbno</span><span class="p">,</span>		<span class="cm">/* bitmap block number */</span>
	<span class="kt">int</span>		<span class="n">delta</span><span class="p">,</span>		<span class="cm">/* change to make to summary info */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">rbpp</span><span class="p">,</span>		<span class="cm">/* in/out: summary block buffer */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="o">*</span><span class="n">rsb</span><span class="p">)</span>		<span class="cm">/* in/out: summary block number */</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* buffer for the summary block */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="n">sb</span><span class="p">;</span>		<span class="cm">/* summary fsblock */</span>
	<span class="kt">int</span>		<span class="n">so</span><span class="p">;</span>		<span class="cm">/* index into the summary file */</span>
	<span class="n">xfs_suminfo_t</span>	<span class="o">*</span><span class="n">sp</span><span class="p">;</span>		<span class="cm">/* pointer to returned data */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute entry number in the summary file.</span>
<span class="cm">	 */</span>
	<span class="n">so</span> <span class="o">=</span> <span class="n">XFS_SUMOFFS</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">bbno</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Compute the block number in the summary file.</span>
<span class="cm">	 */</span>
	<span class="n">sb</span> <span class="o">=</span> <span class="n">XFS_SUMOFFSTOBLOCK</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">so</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we have an old buffer, and the block number matches, use that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rbpp</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">rbpp</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">rsb</span> <span class="o">==</span> <span class="n">sb</span><span class="p">)</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="o">*</span><span class="n">rbpp</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Otherwise we have to get the buffer.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there was an old one, get rid of it first.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rbpp</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">rbpp</span><span class="p">)</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="o">*</span><span class="n">rbpp</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtbuf_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Remember this buffer and block for the next call.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rbpp</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">rbpp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
			<span class="o">*</span><span class="n">rsb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Point to the summary information, modify and log it.</span>
<span class="cm">	 */</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">XFS_SUMPTR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">so</span><span class="p">);</span>
	<span class="o">*</span><span class="n">sp</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sp</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">),</span>
		<span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sp</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Visible (exported) functions.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Grow the realtime area of the filesystem.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xfs_growfs_rt</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* mount point for filesystem */</span>
	<span class="n">xfs_growfs_rt_t</span>	<span class="o">*</span><span class="n">in</span><span class="p">)</span>		<span class="cm">/* growfs rt input struct */</span>
<span class="p">{</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">bmbno</span><span class="p">;</span>		<span class="cm">/* bitmap block number */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* temporary buffer */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">nmp</span><span class="p">;</span>		<span class="cm">/* new (fake) mount structure */</span>
	<span class="n">xfs_drfsbno_t</span>	<span class="n">nrblocks</span><span class="p">;</span>	<span class="cm">/* new number of realtime blocks */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">nrbmblocks</span><span class="p">;</span>	<span class="cm">/* new number of rt bitmap blocks */</span>
	<span class="n">xfs_drtbno_t</span>	<span class="n">nrextents</span><span class="p">;</span>	<span class="cm">/* new number of realtime extents */</span>
	<span class="kt">uint8_t</span>		<span class="n">nrextslog</span><span class="p">;</span>	<span class="cm">/* new log2 of sb_rextents */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">nrsumblocks</span><span class="p">;</span>	<span class="cm">/* new number of summary blocks */</span>
	<span class="n">uint</span>		<span class="n">nrsumlevels</span><span class="p">;</span>	<span class="cm">/* new rt summary levels */</span>
	<span class="n">uint</span>		<span class="n">nrsumsize</span><span class="p">;</span>	<span class="cm">/* new size of rt summary, bytes */</span>
	<span class="n">xfs_sb_t</span>	<span class="o">*</span><span class="n">nsbp</span><span class="p">;</span>		<span class="cm">/* new superblock */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">rbmblocks</span><span class="p">;</span>	<span class="cm">/* current number of rt bitmap blocks */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">rsumblocks</span><span class="p">;</span>	<span class="cm">/* current number of rt summary blks */</span>
	<span class="n">xfs_sb_t</span>	<span class="o">*</span><span class="n">sbp</span><span class="p">;</span>		<span class="cm">/* old superblock */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="n">sumbno</span><span class="p">;</span>		<span class="cm">/* summary block number */</span>

	<span class="n">sbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initial error checking.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EPERM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rtdev_targp</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">nrblocks</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">newblocks</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rblocks</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rblocks</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">extsize</span> <span class="o">!=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rextsize</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_sb_validate_fsb_count</span><span class="p">(</span><span class="n">sbp</span><span class="p">,</span> <span class="n">nrblocks</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read in the last block of the device, make sure it exists.</span>
<span class="cm">	 */</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_read_uncached</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rtdev_targp</span><span class="p">,</span>
				<span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">nrblocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
				<span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EIO</span><span class="p">;</span>
	<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate new parameters.  These are the final values to be reached.</span>
<span class="cm">	 */</span>
	<span class="n">nrextents</span> <span class="o">=</span> <span class="n">nrblocks</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">nrextents</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">extsize</span><span class="p">);</span>
	<span class="n">nrbmblocks</span> <span class="o">=</span> <span class="n">howmany_64</span><span class="p">(</span><span class="n">nrextents</span><span class="p">,</span> <span class="n">NBBY</span> <span class="o">*</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span><span class="p">);</span>
	<span class="n">nrextslog</span> <span class="o">=</span> <span class="n">xfs_highbit32</span><span class="p">(</span><span class="n">nrextents</span><span class="p">);</span>
	<span class="n">nrsumlevels</span> <span class="o">=</span> <span class="n">nrextslog</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">nrsumsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_suminfo_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">nrsumlevels</span> <span class="o">*</span> <span class="n">nrbmblocks</span><span class="p">;</span>
	<span class="n">nrsumblocks</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">nrsumsize</span><span class="p">);</span>
	<span class="n">nrsumsize</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">nrsumblocks</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * New summary size can&#39;t be more than half the size of</span>
<span class="cm">	 * the log.  This prevents us from getting a log overflow,</span>
<span class="cm">	 * since we&#39;ll log basically the whole summary file at once.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nrsumblocks</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_logblocks</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the old block counts for bitmap and summary inodes.</span>
<span class="cm">	 * These can&#39;t change since other growfs callers are locked out.</span>
<span class="cm">	 */</span>
	<span class="n">rbmblocks</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span><span class="p">);</span>
	<span class="n">rsumblocks</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocate space to the bitmap and summary files, as necessary.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_growfs_rt_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">rbmblocks</span><span class="p">,</span> <span class="n">nrbmblocks</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_growfs_rt_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">rsumblocks</span><span class="p">,</span> <span class="n">nrsumblocks</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocate a new (fake) mount/sb.</span>
<span class="cm">	 */</span>
	<span class="n">nmp</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nmp</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Loop over the bitmap blocks.</span>
<span class="cm">	 * We will do everything one bitmap block at a time.</span>
<span class="cm">	 * Skip the current block if it is exactly full.</span>
<span class="cm">	 * This also deals with the case where there were no rtextents before.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bmbno</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rbmblocks</span> <span class="o">-</span>
		     <span class="p">((</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rextents</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_blkbit_log</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	     <span class="n">bmbno</span> <span class="o">&lt;</span> <span class="n">nrbmblocks</span><span class="p">;</span>
	     <span class="n">bmbno</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">cancelflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="o">*</span><span class="n">nmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
		<span class="n">nsbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nmp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Calculate new sb and mount fields for this round.</span>
<span class="cm">		 */</span>
		<span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextsize</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">extsize</span><span class="p">;</span>
		<span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rbmblocks</span> <span class="o">=</span> <span class="n">bmbno</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rblocks</span> <span class="o">=</span>
			<span class="n">XFS_RTMIN</span><span class="p">(</span><span class="n">nrblocks</span><span class="p">,</span>
				  <span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rbmblocks</span> <span class="o">*</span> <span class="n">NBBY</span> <span class="o">*</span>
				  <span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span> <span class="o">*</span> <span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextsize</span><span class="p">);</span>
		<span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextents</span> <span class="o">=</span> <span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rblocks</span><span class="p">;</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextents</span><span class="p">,</span> <span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextsize</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextents</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextslog</span> <span class="o">=</span> <span class="n">xfs_highbit32</span><span class="p">(</span><span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextents</span><span class="p">);</span>
		<span class="n">nrsumlevels</span> <span class="o">=</span> <span class="n">nmp</span><span class="o">-&gt;</span><span class="n">m_rsumlevels</span> <span class="o">=</span> <span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextslog</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">nrsumsize</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_suminfo_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">nrsumlevels</span> <span class="o">*</span>
			<span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rbmblocks</span><span class="p">;</span>
		<span class="n">nrsumblocks</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">nrsumsize</span><span class="p">);</span>
		<span class="n">nmp</span><span class="o">-&gt;</span><span class="n">m_rsumsize</span> <span class="o">=</span> <span class="n">nrsumsize</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">nrsumblocks</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Start a transaction, get the log reservation.</span>
<span class="cm">		 */</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_GROWFSRT_FREE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">XFS_GROWRTFREE_LOG_RES</span><span class="p">(</span><span class="n">nmp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error_cancel</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Lock out other callers by grabbing the bitmap inode lock.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update the bitmap inode&#39;s size.</span>
<span class="cm">		 */</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">=</span>
			<span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rbmblocks</span> <span class="o">*</span> <span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span><span class="p">;</span>
		<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>
		<span class="n">cancelflags</span> <span class="o">|=</span> <span class="n">XFS_TRANS_ABORT</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get the summary inode into the transaction.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update the summary inode&#39;s size.</span>
<span class="cm">		 */</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">=</span> <span class="n">nmp</span><span class="o">-&gt;</span><span class="n">m_rsumsize</span><span class="p">;</span>
		<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Copy summary data from old to new sizes.</span>
<span class="cm">		 * Do this when the real size (not block-aligned) changes.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rbmblocks</span> <span class="o">!=</span> <span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rbmblocks</span> <span class="o">||</span>
		    <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumlevels</span> <span class="o">!=</span> <span class="n">nmp</span><span class="o">-&gt;</span><span class="n">m_rsumlevels</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtcopy_summary</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">nmp</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error_cancel</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update superblock fields.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextsize</span> <span class="o">!=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rextsize</span><span class="p">)</span>
			<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_REXTSIZE</span><span class="p">,</span>
				<span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextsize</span> <span class="o">-</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rextsize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rbmblocks</span> <span class="o">!=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rbmblocks</span><span class="p">)</span>
			<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_RBMBLOCKS</span><span class="p">,</span>
				<span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rbmblocks</span> <span class="o">-</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rbmblocks</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rblocks</span> <span class="o">!=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rblocks</span><span class="p">)</span>
			<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_RBLOCKS</span><span class="p">,</span>
				<span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rblocks</span> <span class="o">-</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rblocks</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextents</span> <span class="o">!=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rextents</span><span class="p">)</span>
			<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_REXTENTS</span><span class="p">,</span>
				<span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextents</span> <span class="o">-</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rextents</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextslog</span> <span class="o">!=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rextslog</span><span class="p">)</span>
			<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_REXTSLOG</span><span class="p">,</span>
				<span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextslog</span> <span class="o">-</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rextslog</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Free new extent.</span>
<span class="cm">		 */</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtfree_range</span><span class="p">(</span><span class="n">nmp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rextents</span><span class="p">,</span>
			<span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextents</span> <span class="o">-</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rextents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sumbno</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">error_cancel:</span>
			<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">cancelflags</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Mark more blocks free in the superblock.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_FREXTENTS</span><span class="p">,</span>
			<span class="n">nsbp</span><span class="o">-&gt;</span><span class="n">sb_rextents</span> <span class="o">-</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rextents</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update mp values into the real mp structure.</span>
<span class="cm">		 */</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumlevels</span> <span class="o">=</span> <span class="n">nrsumlevels</span><span class="p">;</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumsize</span> <span class="o">=</span> <span class="n">nrsumsize</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Free the fake mp structure.</span>
<span class="cm">	 */</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">nmp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate an extent in the realtime subvolume, with the usual allocation</span>
<span class="cm"> * parameters.  The length units are all in realtime extents, as is the</span>
<span class="cm"> * result block number.</span>
<span class="cm"> */</span>
<span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_rtallocate_extent</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">bno</span><span class="p">,</span>		<span class="cm">/* starting block number to allocate */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">minlen</span><span class="p">,</span>		<span class="cm">/* minimum length to allocate */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">maxlen</span><span class="p">,</span>		<span class="cm">/* maximum length to allocate */</span>
	<span class="n">xfs_extlen_t</span>	<span class="o">*</span><span class="n">len</span><span class="p">,</span>		<span class="cm">/* out: actual length allocated */</span>
	<span class="n">xfs_alloctype_t</span>	<span class="n">type</span><span class="p">,</span>		<span class="cm">/* allocation type XFS_ALLOCTYPE... */</span>
	<span class="kt">int</span>		<span class="n">wasdel</span><span class="p">,</span>		<span class="cm">/* was a delayed allocation extent */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">prod</span><span class="p">,</span>		<span class="cm">/* extent product factor */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="o">*</span><span class="n">rtblock</span><span class="p">)</span>	<span class="cm">/* out: start block allocated */</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">r</span><span class="p">;</span>		<span class="cm">/* result allocated block */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="n">sb</span><span class="p">;</span>		<span class="cm">/* summary file block number */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">sumbp</span><span class="p">;</span>		<span class="cm">/* summary file block buffer */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_isilocked</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">minlen</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">minlen</span> <span class="o">&lt;=</span> <span class="n">maxlen</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If prod is set then figure out what to do to minlen and maxlen.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prod</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_extlen_t</span>	<span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">maxlen</span> <span class="o">%</span> <span class="n">prod</span><span class="p">))</span>
			<span class="n">maxlen</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">minlen</span> <span class="o">%</span> <span class="n">prod</span><span class="p">))</span>
			<span class="n">minlen</span> <span class="o">+=</span> <span class="n">prod</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxlen</span> <span class="o">&lt;</span> <span class="n">minlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">NULLRTBLOCK</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">sumbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocate by size, or near another block, or exactly at some block.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_ALLOCTYPE_ANY_AG</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtallocate_extent_size</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">minlen</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">sumbp</span><span class="p">,</span>	<span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_ALLOCTYPE_NEAR_BNO</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtallocate_extent_near</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="n">minlen</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span>
				<span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sumbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_ALLOCTYPE_THIS_BNO</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtallocate_extent_exact</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="n">minlen</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span>
				<span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sumbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">EIO</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If it worked, update the superblock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">NULLRTBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span>	<span class="n">slen</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">len</span><span class="p">;</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="o">*</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">minlen</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">maxlen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wasdel</span><span class="p">)</span>
			<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_RES_FREXTENTS</span><span class="p">,</span> <span class="o">-</span><span class="n">slen</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_FREXTENTS</span><span class="p">,</span> <span class="o">-</span><span class="n">slen</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">rtblock</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free an extent in the realtime subvolume.  Length is expressed in</span>
<span class="cm"> * realtime extents, as is the block number.</span>
<span class="cm"> */</span>
<span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_rtfree_extent</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">bno</span><span class="p">,</span>		<span class="cm">/* starting block number to free */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">len</span><span class="p">)</span>		<span class="cm">/* length of extent freed */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error value */</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* file system mount structure */</span>
	<span class="n">xfs_fsblock_t</span>	<span class="n">sb</span><span class="p">;</span>		<span class="cm">/* summary file block number */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">sumbp</span><span class="p">;</span>		<span class="cm">/* summary file block buffer */</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="o">-&gt;</span><span class="n">i_itemp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_isilocked</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">));</span>

<span class="cp">#if defined(__KERNEL__) &amp;&amp; defined(DEBUG)</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check to see that this whole range is currently allocated.</span>
<span class="cm">	 */</span>
	<span class="p">{</span>
		<span class="kt">int</span>	<span class="n">stat</span><span class="p">;</span>		<span class="cm">/* result from checking range */</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtcheck_alloc_range</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">stat</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">sumbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Free the range of realtime blocks.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtfree_range</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sumbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Mark more blocks free in the superblock.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_FREXTENTS</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">len</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;ve now freed all the blocks, reset the file sequence</span>
<span class="cm">	 * number to 0.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_frextents_delta</span> <span class="o">+</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_frextents</span> <span class="o">==</span>
	    <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextents</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_NEWRTBM</span><span class="p">))</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">|=</span> <span class="n">XFS_DIFLAG_NEWRTBM</span><span class="p">;</span>
		<span class="o">*</span><span class="p">(</span><span class="n">__uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_atime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize realtime fields in the mount structure.</span>
<span class="cm"> */</span>
<span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_rtmount_init</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>	<span class="cm">/* file system mount structure */</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>	<span class="cm">/* buffer for last block of subvolume */</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">d</span><span class="p">;</span>	<span class="cm">/* address of last block of subvolume */</span>
	<span class="n">xfs_sb_t</span>	<span class="o">*</span><span class="n">sbp</span><span class="p">;</span>	<span class="cm">/* filesystem superblock copy in mount */</span>

	<span class="n">sbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rblocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rtdev_targp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
	<span class="s">&quot;Filesystem has a realtime volume, use rtdev=device option&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENODEV</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumlevels</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rextslog</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumsize</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_suminfo_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumlevels</span> <span class="o">*</span>
		<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rbmblocks</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumsize</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumsize</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check that the realtime section is an ok size.</span>
<span class="cm">	 */</span>
	<span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_daddr_t</span><span class="p">)</span><span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rblocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_BB_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rblocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;realtime mount -- %llu != %llu&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">XFS_BB_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rblocks</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFBIG</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_read_uncached</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rtdev_targp</span><span class="p">,</span>
					<span class="n">d</span> <span class="o">-</span> <span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
					<span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;realtime device size check failed&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the bitmap and summary inodes into the mount structure</span>
<span class="cm"> * at mount time.</span>
<span class="cm"> */</span>
<span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_rtmount_inodes</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>		<span class="cm">/* file system mount structure */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="n">xfs_sb_t</span>	<span class="o">*</span><span class="n">sbp</span><span class="p">;</span>

	<span class="n">sbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rbmino</span> <span class="o">==</span> <span class="n">NULLFSINO</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iget</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rbmino</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rsumino</span> <span class="o">!=</span> <span class="n">NULLFSINO</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iget</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rsumino</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRELE</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumip</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">xfs_rtunmount_inodes</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="p">)</span>
		<span class="n">IRELE</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumip</span><span class="p">)</span>
		<span class="n">IRELE</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rsumip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pick an extent for allocation at the start of a new realtime file.</span>
<span class="cm"> * Use the sequence number stored in the atime field of the bitmap inode.</span>
<span class="cm"> * Translate this to a fraction of the rtextents, and return the product</span>
<span class="cm"> * of rtextents and the fraction.</span>
<span class="cm"> * The fraction sequence is 0, 1/2, 1/4, 3/4, 1/8, ..., 7/8, 1/16, ...</span>
<span class="cm"> */</span>
<span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_rtpick_extent</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount point */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">len</span><span class="p">,</span>		<span class="cm">/* allocation length (rtextents) */</span>
	<span class="n">xfs_rtblock_t</span>	<span class="o">*</span><span class="n">pick</span><span class="p">)</span>		<span class="cm">/* result rt extent */</span>
<span class="p">{</span>
	<span class="n">xfs_rtblock_t</span>	<span class="n">b</span><span class="p">;</span>		<span class="cm">/* result block */</span>
	<span class="kt">int</span>		<span class="n">log2</span><span class="p">;</span>		<span class="cm">/* log of sequence number */</span>
	<span class="n">__uint64_t</span>	<span class="n">resid</span><span class="p">;</span>		<span class="cm">/* residual after log removed */</span>
	<span class="n">__uint64_t</span>	<span class="n">seq</span><span class="p">;</span>		<span class="cm">/* sequence number of file creation */</span>
	<span class="n">__uint64_t</span>	<span class="o">*</span><span class="n">seqp</span><span class="p">;</span>		<span class="cm">/* pointer to seqno in inode */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_isilocked</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">));</span>

	<span class="n">seqp</span> <span class="o">=</span> <span class="p">(</span><span class="n">__uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_atime</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_NEWRTBM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">|=</span> <span class="n">XFS_DIFLAG_NEWRTBM</span><span class="p">;</span>
		<span class="o">*</span><span class="n">seqp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="o">*</span><span class="n">seqp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">log2</span> <span class="o">=</span> <span class="n">xfs_highbit64</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">resid</span> <span class="o">=</span> <span class="n">seq</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">log2</span><span class="p">);</span>
		<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextents</span> <span class="o">*</span> <span class="p">((</span><span class="n">resid</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1ULL</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
		    <span class="p">(</span><span class="n">log2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextents</span><span class="p">)</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">do_mod</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextents</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextents</span><span class="p">)</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextents</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">seqp</span> <span class="o">=</span> <span class="n">seq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rbmip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>
	<span class="o">*</span><span class="n">pick</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
