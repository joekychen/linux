<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_log_cil.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_log_cil.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2010 Red Hat, Inc. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_trans_priv.h&quot;</span>
<span class="cp">#include &quot;xfs_log_priv.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_extent_busy.h&quot;</span>
<span class="cp">#include &quot;xfs_discard.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a new ticket. Failing to get a new ticket makes it really hard to</span>
<span class="cm"> * recover, so we don&#39;t allow failure here. Also, we allocate in a context that</span>
<span class="cm"> * we don&#39;t want to be issuing transactions from, so we need to tell the</span>
<span class="cm"> * allocation code this as well.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t reserve any space for the ticket - we are going to steal whatever</span>
<span class="cm"> * space we require from transactions as they commit. To ensure we reserve all</span>
<span class="cm"> * the space required, we need to set the current reservation of the ticket to</span>
<span class="cm"> * zero so that we know to steal the initial transaction overhead from the</span>
<span class="cm"> * first transaction commit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">xlog_ticket</span> <span class="o">*</span>
<span class="nf">xlog_cil_ticket_alloc</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span> <span class="o">*</span><span class="n">tic</span><span class="p">;</span>

	<span class="n">tic</span> <span class="o">=</span> <span class="n">xlog_ticket_alloc</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">XFS_TRANSACTION</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">KM_SLEEP</span><span class="o">|</span><span class="n">KM_NOFS</span><span class="p">);</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_trans_type</span> <span class="o">=</span> <span class="n">XFS_TRANS_CHECKPOINT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * set the current reservation to zero so we know to steal the basic</span>
<span class="cm">	 * transaction overhead reservation from the first transaction commit.</span>
<span class="cm">	 */</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tic</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * After the first stage of log recovery is done, we know where the head and</span>
<span class="cm"> * tail of the log are. We need this log initialisation done before we can</span>
<span class="cm"> * initialise the first CIL checkpoint context.</span>
<span class="cm"> *</span>
<span class="cm"> * Here we allocate a log ticket to track space usage during a CIL push.  This</span>
<span class="cm"> * ticket is passed to xlog_write() directly so that we don&#39;t slowly leak log</span>
<span class="cm"> * space by failing to account for space used by log headers and additional</span>
<span class="cm"> * region headers for split regions.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xlog_cil_init_post_recovery</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="o">-&gt;</span><span class="n">ticket</span> <span class="o">=</span> <span class="n">xlog_cil_ticket_alloc</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="o">-&gt;</span><span class="n">commit_lsn</span> <span class="o">=</span> <span class="n">xlog_assign_lsn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span><span class="p">,</span>
								<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Format log item into a flat buffers</span>
<span class="cm"> *</span>
<span class="cm"> * For delayed logging, we need to hold a formatted buffer containing all the</span>
<span class="cm"> * changes on the log item. This enables us to relog the item in memory and</span>
<span class="cm"> * write it out asynchronously without needing to relock the object that was</span>
<span class="cm"> * modified at the time it gets written into the iclog.</span>
<span class="cm"> *</span>
<span class="cm"> * This function builds a vector for the changes in each log item in the</span>
<span class="cm"> * transaction. It then works out the length of the buffer needed for each log</span>
<span class="cm"> * item, allocates them and formats the vector for the item into the buffer.</span>
<span class="cm"> * The buffer is then attached to the log item are then inserted into the</span>
<span class="cm"> * Committed Item List for tracking until the next checkpoint is written out.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t set up region headers during this process; we simply copy the</span>
<span class="cm"> * regions into the flat buffer. We can do this because we still have to do a</span>
<span class="cm"> * formatting step to write the regions into the iclog buffer.  Writing the</span>
<span class="cm"> * ophdrs during the iclog write means that we can support splitting large</span>
<span class="cm"> * regions across iclog boundares without needing a change in the format of the</span>
<span class="cm"> * item/region encapsulation.</span>
<span class="cm"> *</span>
<span class="cm"> * Hence what we need to do now is change the rewrite the vector array to point</span>
<span class="cm"> * to the copied region inside the buffer we just allocated. This allows us to</span>
<span class="cm"> * format the regions into the iclog as though they are being formatted</span>
<span class="cm"> * directly out of the objects themselves.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">xfs_log_vec</span> <span class="o">*</span>
<span class="nf">xlog_cil_prepare_log_vecs</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_log_item_desc</span> <span class="o">*</span><span class="n">lidp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">lv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">ret_lv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>


	<span class="cm">/* Bail out if we didn&#39;t find a log item.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_items</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lidp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_items</span><span class="p">,</span> <span class="n">lid_trans</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xfs_log_vec</span> <span class="o">*</span><span class="n">new_lv</span><span class="p">;</span>
		<span class="kt">void</span>	<span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
		<span class="kt">int</span>	<span class="n">index</span><span class="p">;</span>
		<span class="kt">int</span>	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">uint</span>	<span class="n">niovecs</span><span class="p">;</span>

		<span class="cm">/* Skip items which aren&#39;t dirty in this transaction. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lidp</span><span class="o">-&gt;</span><span class="n">lid_flags</span> <span class="o">&amp;</span> <span class="n">XFS_LID_DIRTY</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Skip items that do not have any vectors for writing */</span>
		<span class="n">niovecs</span> <span class="o">=</span> <span class="n">IOP_SIZE</span><span class="p">(</span><span class="n">lidp</span><span class="o">-&gt;</span><span class="n">lid_item</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">niovecs</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">new_lv</span> <span class="o">=</span> <span class="n">kmem_zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_lv</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">niovecs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_log_iovec</span><span class="p">),</span>
				<span class="n">KM_SLEEP</span><span class="p">);</span>

		<span class="cm">/* The allocated iovec region lies beyond the log vector. */</span>
		<span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_iovecp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xfs_log_iovec</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">new_lv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_niovecs</span> <span class="o">=</span> <span class="n">niovecs</span><span class="p">;</span>
		<span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_item</span> <span class="o">=</span> <span class="n">lidp</span><span class="o">-&gt;</span><span class="n">lid_item</span><span class="p">;</span>

		<span class="cm">/* build the vector array and calculate it&#39;s length */</span>
		<span class="n">IOP_FORMAT</span><span class="p">(</span><span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_item</span><span class="p">,</span> <span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_iovecp</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_niovecs</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_iovecp</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">i_len</span><span class="p">;</span>

		<span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_buf_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_buf</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_buf_len</span><span class="p">,</span>
				<span class="n">KM_SLEEP</span><span class="o">|</span><span class="n">KM_NOFS</span><span class="p">);</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_buf</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_niovecs</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">xfs_log_iovec</span> <span class="o">*</span><span class="n">vec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_iovecp</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">i_addr</span><span class="p">,</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">i_len</span><span class="p">);</span>
			<span class="n">vec</span><span class="o">-&gt;</span><span class="n">i_addr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
			<span class="n">ptr</span> <span class="o">+=</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">i_len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_buf</span> <span class="o">+</span> <span class="n">new_lv</span><span class="o">-&gt;</span><span class="n">lv_buf_len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_lv</span><span class="p">)</span>
			<span class="n">ret_lv</span> <span class="o">=</span> <span class="n">new_lv</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_next</span> <span class="o">=</span> <span class="n">new_lv</span><span class="p">;</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="n">new_lv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_lv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Prepare the log item for insertion into the CIL. Calculate the difference in</span>
<span class="cm"> * log space and vectors it will consume, and if it is a new item pin it as</span>
<span class="cm"> * well.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_cil_prepare_item</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">lv</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">len</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">diff_iovecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_item</span><span class="o">-&gt;</span><span class="n">li_lv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* existing lv on log item, space used is a delta */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_item</span><span class="o">-&gt;</span><span class="n">li_cil</span><span class="p">));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">lv_buf</span> <span class="o">&amp;&amp;</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">lv_buf_len</span> <span class="o">&amp;&amp;</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">lv_niovecs</span><span class="p">);</span>

		<span class="o">*</span><span class="n">len</span> <span class="o">+=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_buf_len</span> <span class="o">-</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">lv_buf_len</span><span class="p">;</span>
		<span class="o">*</span><span class="n">diff_iovecs</span> <span class="o">+=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_niovecs</span> <span class="o">-</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">lv_niovecs</span><span class="p">;</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">lv_buf</span><span class="p">);</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* new lv, must pin the log item */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_item</span><span class="o">-&gt;</span><span class="n">li_lv</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_item</span><span class="o">-&gt;</span><span class="n">li_cil</span><span class="p">));</span>

		<span class="o">*</span><span class="n">len</span> <span class="o">+=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_buf_len</span><span class="p">;</span>
		<span class="o">*</span><span class="n">diff_iovecs</span> <span class="o">+=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_niovecs</span><span class="p">;</span>
		<span class="n">IOP_PIN</span><span class="p">(</span><span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_item</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="cm">/* attach new log vector to log item */</span>
	<span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_item</span><span class="o">-&gt;</span><span class="n">li_lv</span> <span class="o">=</span> <span class="n">lv</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is the first time the item is being committed to the</span>
<span class="cm">	 * CIL, store the sequence number on the log item so we can</span>
<span class="cm">	 * tell in future commits whether this is the first checkpoint</span>
<span class="cm">	 * the item is being committed into.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_item</span><span class="o">-&gt;</span><span class="n">li_seq</span><span class="p">)</span>
		<span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_item</span><span class="o">-&gt;</span><span class="n">li_seq</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Insert the log items into the CIL and calculate the difference in space</span>
<span class="cm"> * consumed by the item. Add the space to the checkpoint ticket and calculate</span>
<span class="cm"> * if the change requires additional log metadata. If it does, take that space</span>
<span class="cm"> * as well. Remove the amount of space we added to the checkpoint ticket from</span>
<span class="cm"> * the current transaction ticket so that the accounting works out correctly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xlog_cil_insert_items</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">log_vector</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">ticket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_cil</span>		<span class="o">*</span><span class="n">cil</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_cil_ctx</span>	<span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">diff_iovecs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">iclog_space</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">log_vector</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do all the accounting aggregation and switching of log vectors</span>
<span class="cm">	 * around in a separate loop to the insertion of items into the CIL.</span>
<span class="cm">	 * Then we can do a separate loop to update the CIL within a single</span>
<span class="cm">	 * lock/unlock pair. This reduces the number of round trips on the CIL</span>
<span class="cm">	 * lock from O(nr_logvectors) to O(1) and greatly reduces the overall</span>
<span class="cm">	 * hold time for the transaction commit.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If this is the first time the item is being placed into the CIL in</span>
<span class="cm">	 * this context, pin it so it can&#39;t be written to disk until the CIL is</span>
<span class="cm">	 * flushed to the iclog and the iclog written to disk.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We can do this safely because the context can&#39;t checkpoint until we</span>
<span class="cm">	 * are done so it doesn&#39;t matter exactly how we update the CIL.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lv</span> <span class="o">=</span> <span class="n">log_vector</span><span class="p">;</span> <span class="n">lv</span><span class="p">;</span> <span class="n">lv</span> <span class="o">=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_next</span><span class="p">)</span>
		<span class="n">xfs_cil_prepare_item</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">lv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">diff_iovecs</span><span class="p">);</span>

	<span class="cm">/* account for space used by new iovec headers  */</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">diff_iovecs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>

	<span class="cm">/* move the items to the tail of the CIL */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lv</span> <span class="o">=</span> <span class="n">log_vector</span><span class="p">;</span> <span class="n">lv</span><span class="p">;</span> <span class="n">lv</span> <span class="o">=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_next</span><span class="p">)</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_item</span><span class="o">-&gt;</span><span class="n">li_cil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil</span><span class="p">);</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nvecs</span> <span class="o">+=</span> <span class="n">diff_iovecs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now transfer enough transaction reservation to the context ticket</span>
<span class="cm">	 * for the checkpoint. The context ticket is special - the unit</span>
<span class="cm">	 * reservation has to grow as well as the current reservation as we</span>
<span class="cm">	 * steal from tickets so we can correctly determine the space used</span>
<span class="cm">	 * during the transaction commit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* first commit in checkpoint, steal the header reservation */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">&gt;=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_unit_res</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_unit_res</span><span class="p">;</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">-=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_unit_res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* do we need space for more log record headers? */</span>
	<span class="n">iclog_space</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_size</span> <span class="o">-</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">space_used</span> <span class="o">/</span> <span class="n">iclog_space</span> <span class="o">!=</span>
				<span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">space_used</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="o">/</span> <span class="n">iclog_space</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">hdrs</span><span class="p">;</span>

		<span class="n">hdrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">iclog_space</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">iclog_space</span><span class="p">;</span>
		<span class="cm">/* need to take into account split region headers, too */</span>
		<span class="n">hdrs</span> <span class="o">*=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xlog_op_header</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_unit_res</span> <span class="o">+=</span> <span class="n">hdrs</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">+=</span> <span class="n">hdrs</span><span class="p">;</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">-=</span> <span class="n">hdrs</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">space_used</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xlog_cil_free_logvec</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">log_vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">lv</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">lv</span> <span class="o">=</span> <span class="n">log_vector</span><span class="p">;</span> <span class="n">lv</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xfs_log_vec</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_next</span><span class="p">;</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_buf</span><span class="p">);</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">lv</span><span class="p">);</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mark all items committed and clear busy extents. We free the log vector</span>
<span class="cm"> * chains in a separate pass so that we unpin the log items as quickly as</span>
<span class="cm"> * possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xlog_cil_committed</span><span class="p">(</span>
	<span class="kt">void</span>	<span class="o">*</span><span class="n">args</span><span class="p">,</span>
	<span class="kt">int</span>	<span class="n">abort</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_cil_ctx</span>	<span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">;</span>

	<span class="n">xfs_trans_committed_bulk</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_log</span><span class="o">-&gt;</span><span class="n">l_ailp</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lv_chain</span><span class="p">,</span>
					<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">start_lsn</span><span class="p">,</span> <span class="n">abort</span><span class="p">);</span>

	<span class="n">xfs_extent_busy_sort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">busy_extents</span><span class="p">);</span>
	<span class="n">xfs_extent_busy_clear</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">busy_extents</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_DISCARD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">abort</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>

	<span class="n">xlog_cil_free_logvec</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lv_chain</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">busy_extents</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_DISCARD</span><span class="p">);</span>

		<span class="n">xfs_discard_extents</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">busy_extents</span><span class="p">);</span>
		<span class="n">xfs_extent_busy_clear</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">busy_extents</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kmem_free</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Push the Committed Item List to the log. If @push_seq flag is zero, then it</span>
<span class="cm"> * is a background flush and so we can chose to ignore it. Otherwise, if the</span>
<span class="cm"> * current sequence is the same as @push_seq we need to do a flush. If</span>
<span class="cm"> * @push_seq is less than the current sequence, then it has already been</span>
<span class="cm"> * flushed and we don&#39;t need to do anything - the caller will wait for it to</span>
<span class="cm"> * complete if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * @push_seq is a value rather than a flag because that allows us to do an</span>
<span class="cm"> * unlocked check of the sequence number for a match. Hence we can allows log</span>
<span class="cm"> * forces to run racily and not issue pushes for the same sequence twice. If we</span>
<span class="cm"> * get a race between multiple pushes for the same sequence they will block on</span>
<span class="cm"> * the first one and then abort, hence avoiding needless pushes.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_cil_push</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_cil</span>		<span class="o">*</span><span class="n">cil</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_cil_ctx</span>	<span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_cil_ctx</span>	<span class="o">*</span><span class="n">new_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">*</span><span class="n">commit_iclog</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">tic</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">num_lv</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">num_iovecs</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_trans_header</span> <span class="n">thdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_log_iovec</span>	<span class="n">lhdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="n">lvhdr</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">commit_lsn</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">push_seq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cil</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">new_ctx</span> <span class="o">=</span> <span class="n">kmem_zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_ctx</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="o">|</span><span class="n">KM_NOFS</span><span class="p">);</span>
	<span class="n">new_ctx</span><span class="o">-&gt;</span><span class="n">ticket</span> <span class="o">=</span> <span class="n">xlog_cil_ticket_alloc</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_ctx_lock</span><span class="p">);</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
	<span class="n">push_seq</span> <span class="o">=</span> <span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_push_seq</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">push_seq</span> <span class="o">&lt;=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we&#39;ve anything to push. If there is nothing, then we don&#39;t</span>
<span class="cm">	 * move on to a new sequence number and so we have to be able to push</span>
<span class="cm">	 * this sequence again later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_push_seq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_skip</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>


	<span class="cm">/* check for a previously pushed seqeunce */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">push_seq</span> <span class="o">&lt;</span> <span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_skip</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * pull all the log vectors off the items in the CIL, and</span>
<span class="cm">	 * remove the items from the CIL. We don&#39;t need the CIL lock</span>
<span class="cm">	 * here because it&#39;s only needed on the transaction commit</span>
<span class="cm">	 * side which is currently locked out by the flush lock.</span>
<span class="cm">	 */</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">num_lv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">num_iovecs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xfs_log_item</span>	<span class="o">*</span><span class="n">item</span><span class="p">;</span>
		<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

		<span class="n">item</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">xfs_log_item</span><span class="p">,</span> <span class="n">li_cil</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">li_cil</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lv_chain</span><span class="p">)</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lv_chain</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">li_lv</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_next</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">li_lv</span><span class="p">;</span>
		<span class="n">lv</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">li_lv</span><span class="p">;</span>
		<span class="n">item</span><span class="o">-&gt;</span><span class="n">li_lv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">num_lv</span><span class="o">++</span><span class="p">;</span>
		<span class="n">num_iovecs</span> <span class="o">+=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_niovecs</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_niovecs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_iovecp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">i_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialise the new context and attach it to the CIL. Then attach</span>
<span class="cm">	 * the current context to the CIL committing lsit so it can be found</span>
<span class="cm">	 * during log forces to extract the commit lsn of the sequence that</span>
<span class="cm">	 * needs to be forced.</span>
<span class="cm">	 */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ctx</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ctx</span><span class="o">-&gt;</span><span class="n">busy_extents</span><span class="p">);</span>
	<span class="n">new_ctx</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">new_ctx</span><span class="o">-&gt;</span><span class="n">cil</span> <span class="o">=</span> <span class="n">cil</span><span class="p">;</span>
	<span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_ctx</span> <span class="o">=</span> <span class="n">new_ctx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * mirror the new sequence into the cil structure so that we can do</span>
<span class="cm">	 * unlocked checks against the current sequence in log forces without</span>
<span class="cm">	 * risking deferencing a freed context pointer.</span>
<span class="cm">	 */</span>
	<span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_current_sequence</span> <span class="o">=</span> <span class="n">new_ctx</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The switch is now done, so we can drop the context lock and move out</span>
<span class="cm">	 * of a shared context. We can&#39;t just go straight to the commit record,</span>
<span class="cm">	 * though - we need to synchronise with previous and future commits so</span>
<span class="cm">	 * that the commit records are correctly ordered in the log to ensure</span>
<span class="cm">	 * that we process items during log IO completion in the correct order.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For example, if we get an EFI in one checkpoint and the EFD in the</span>
<span class="cm">	 * next (e.g. due to log forces), we do not want the checkpoint with</span>
<span class="cm">	 * the EFD to be committed before the checkpoint with the EFI.  Hence</span>
<span class="cm">	 * we must strictly order the commit records of the checkpoints so</span>
<span class="cm">	 * that: a) the checkpoint callbacks are attached to the iclogs in the</span>
<span class="cm">	 * correct order; and b) the checkpoints are replayed in correct order</span>
<span class="cm">	 * in log recovery.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Hence we need to add this context to the committing context list so</span>
<span class="cm">	 * that higher sequences will wait for us to write out a commit record</span>
<span class="cm">	 * before they do.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_committing</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_ctx_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build a checkpoint transaction header and write it to the log to</span>
<span class="cm">	 * begin the transaction. We need to account for the space used by the</span>
<span class="cm">	 * transaction header here as it is not accounted for in xlog_write().</span>
<span class="cm">	 *</span>
<span class="cm">	 * The LSN we need to pass to the log items on transaction commit is</span>
<span class="cm">	 * the LSN reported by the first log vector write. If we use the commit</span>
<span class="cm">	 * record lsn then we can move the tail beyond the grant write head.</span>
<span class="cm">	 */</span>
	<span class="n">tic</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ticket</span><span class="p">;</span>
	<span class="n">thdr</span><span class="p">.</span><span class="n">th_magic</span> <span class="o">=</span> <span class="n">XFS_TRANS_HEADER_MAGIC</span><span class="p">;</span>
	<span class="n">thdr</span><span class="p">.</span><span class="n">th_type</span> <span class="o">=</span> <span class="n">XFS_TRANS_CHECKPOINT</span><span class="p">;</span>
	<span class="n">thdr</span><span class="p">.</span><span class="n">th_tid</span> <span class="o">=</span> <span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
	<span class="n">thdr</span><span class="p">.</span><span class="n">th_num_items</span> <span class="o">=</span> <span class="n">num_iovecs</span><span class="p">;</span>
	<span class="n">lhdr</span><span class="p">.</span><span class="n">i_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">thdr</span><span class="p">;</span>
	<span class="n">lhdr</span><span class="p">.</span><span class="n">i_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_trans_header_t</span><span class="p">);</span>
	<span class="n">lhdr</span><span class="p">.</span><span class="n">i_type</span> <span class="o">=</span> <span class="n">XLOG_REG_TYPE_TRANSHDR</span><span class="p">;</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">-=</span> <span class="n">lhdr</span><span class="p">.</span><span class="n">i_len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">);</span>

	<span class="n">lvhdr</span><span class="p">.</span><span class="n">lv_niovecs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lvhdr</span><span class="p">.</span><span class="n">lv_iovecp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lhdr</span><span class="p">;</span>
	<span class="n">lvhdr</span><span class="p">.</span><span class="n">lv_next</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lv_chain</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_write</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lvhdr</span><span class="p">,</span> <span class="n">tic</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">start_lsn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_abort_free_ticket</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * now that we&#39;ve written the checkpoint into the log, strictly</span>
<span class="cm">	 * order the commit records so replay will get them in the right order.</span>
<span class="cm">	 */</span>
<span class="nl">restart:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">new_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_committing</span><span class="p">,</span> <span class="n">committing</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Higher sequences will wait for this one so skip them.</span>
<span class="cm">		 * Don&#39;t wait for own own sequence, either.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_ctx</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">&gt;=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_ctx</span><span class="o">-&gt;</span><span class="n">commit_lsn</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * It is still being pushed! Wait for the push to</span>
<span class="cm">			 * complete, then start again from the beginning.</span>
<span class="cm">			 */</span>
			<span class="n">xlog_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_commit_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>

	<span class="cm">/* xfs_log_done always frees the ticket on error. */</span>
	<span class="n">commit_lsn</span> <span class="o">=</span> <span class="n">xfs_log_done</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">tic</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">commit_iclog</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">commit_lsn</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_abort</span><span class="p">;</span>

	<span class="cm">/* attach all the transactions w/ busy extents to iclog */</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">log_cb</span><span class="p">.</span><span class="n">cb_func</span> <span class="o">=</span> <span class="n">xlog_cil_committed</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">log_cb</span><span class="p">.</span><span class="n">cb_arg</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_log_notify</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">commit_iclog</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">log_cb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_abort</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * now the checkpoint commit is complete and we&#39;ve attached the</span>
<span class="cm">	 * callbacks to the iclog we can assign the commit LSN to the context</span>
<span class="cm">	 * and wake up anyone who is waiting for the commit to complete.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">commit_lsn</span> <span class="o">=</span> <span class="n">commit_lsn</span><span class="p">;</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_commit_wait</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>

	<span class="cm">/* release the hounds! */</span>
	<span class="k">return</span> <span class="n">xfs_log_release_iclog</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">commit_iclog</span><span class="p">);</span>

<span class="nl">out_skip:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_ctx_lock</span><span class="p">);</span>
	<span class="n">xfs_log_ticket_put</span><span class="p">(</span><span class="n">new_ctx</span><span class="o">-&gt;</span><span class="n">ticket</span><span class="p">);</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">new_ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_abort_free_ticket:</span>
	<span class="n">xfs_log_ticket_put</span><span class="p">(</span><span class="n">tic</span><span class="p">);</span>
<span class="nl">out_abort:</span>
	<span class="n">xlog_cil_committed</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">XFS_LI_ABORTED</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xlog_cil_push_work</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_cil</span>		<span class="o">*</span><span class="n">cil</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_cil</span><span class="p">,</span>
							<span class="n">xc_push_work</span><span class="p">);</span>
	<span class="n">xlog_cil_push</span><span class="p">(</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_log</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We need to push CIL every so often so we don&#39;t cache more than we can fit in</span>
<span class="cm"> * the log. The limit really is that a checkpoint can&#39;t be more than half the</span>
<span class="cm"> * log (the current checkpoint is not allowed to overwrite the previous</span>
<span class="cm"> * checkpoint), but commit latency and memory usage limit this to a smaller</span>
<span class="cm"> * size.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xlog_cil_push_background</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_cil</span>	<span class="o">*</span><span class="n">cil</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The cil won&#39;t be empty because we are called while holding the</span>
<span class="cm">	 * context lock so whatever we added to the CIL will still be there</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * don&#39;t do a background push if we haven&#39;t used up all the</span>
<span class="cm">	 * space available yet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="o">-&gt;</span><span class="n">space_used</span> <span class="o">&lt;</span> <span class="n">XLOG_CIL_SPACE_LIMIT</span><span class="p">(</span><span class="n">log</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_push_seq</span> <span class="o">&lt;</span> <span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_current_sequence</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_push_seq</span> <span class="o">=</span> <span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_current_sequence</span><span class="p">;</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_cil_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_push_work</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xlog_cil_push_foreground</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>	<span class="n">push_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_cil</span>	<span class="o">*</span><span class="n">cil</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cil</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">push_seq</span> <span class="o">&amp;&amp;</span> <span class="n">push_seq</span> <span class="o">&lt;=</span> <span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_current_sequence</span><span class="p">);</span>

	<span class="cm">/* start on any pending background push to minimise wait time on it */</span>
	<span class="n">flush_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_push_work</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the CIL is empty or we&#39;ve already pushed the sequence then</span>
<span class="cm">	 * there&#39;s no work we need to do.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil</span><span class="p">)</span> <span class="o">||</span> <span class="n">push_seq</span> <span class="o">&lt;=</span> <span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_push_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_push_seq</span> <span class="o">=</span> <span class="n">push_seq</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>

	<span class="cm">/* do the push now */</span>
	<span class="n">xlog_cil_push</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Commit a transaction with the given vector to the Committed Item List.</span>
<span class="cm"> *</span>
<span class="cm"> * To do this, we need to format the item, pin it in memory if required and</span>
<span class="cm"> * account for the space used by the transaction. Once we have done that we</span>
<span class="cm"> * need to release the unused reservation for the transaction, attach the</span>
<span class="cm"> * transaction to the checkpoint context so we carry the busy extents through</span>
<span class="cm"> * to checkpoint completion, and then unlock all the items in the transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * For more specific information about the order of operations in</span>
<span class="cm"> * xfs_log_commit_cil() please refer to the comments in</span>
<span class="cm"> * xfs_trans_commit_iclog().</span>
<span class="cm"> *</span>
<span class="cm"> * Called with the context lock already held in read mode to lock out</span>
<span class="cm"> * background commit, returns without it held once background commits are</span>
<span class="cm"> * allowed again.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_log_commit_cil</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>		<span class="o">*</span><span class="n">commit_lsn</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">log_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">log_vector</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">)</span>
		<span class="n">log_flags</span> <span class="o">=</span> <span class="n">XFS_LOG_REL_PERM_RESERV</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do all the hard work of formatting items (including memory</span>
<span class="cm">	 * allocation) outside the CIL context lock. This prevents stalling CIL</span>
<span class="cm">	 * pushes when we are low on memory and a transaction commit spends a</span>
<span class="cm">	 * lot of time in memory reclaim.</span>
<span class="cm">	 */</span>
	<span class="n">log_vector</span> <span class="o">=</span> <span class="n">xlog_cil_prepare_log_vecs</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">log_vector</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* lock out background commit */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_ctx_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">commit_lsn</span><span class="p">)</span>
		<span class="o">*</span><span class="n">commit_lsn</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">;</span>

	<span class="n">xlog_cil_insert_items</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">log_vector</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_ticket</span><span class="p">);</span>

	<span class="cm">/* check we didn&#39;t blow the reservation */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">xlog_print_tic_res</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_ticket</span><span class="p">);</span>

	<span class="cm">/* attach the transaction to the CIL if it has any busy extents */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_busy</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_busy</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="o">-&gt;</span><span class="n">busy_extents</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_commit_lsn</span> <span class="o">=</span> <span class="o">*</span><span class="n">commit_lsn</span><span class="p">;</span>
	<span class="n">xfs_log_done</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_ticket</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">log_flags</span><span class="p">);</span>
	<span class="n">xfs_trans_unreserve_and_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Once all the items of the transaction have been copied to the CIL,</span>
<span class="cm">	 * the items can be unlocked and freed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This needs to be done before we drop the CIL context lock because we</span>
<span class="cm">	 * have to update state in the log items and unlock them before they go</span>
<span class="cm">	 * to disk. If we don&#39;t, then the CIL checkpoint can race with us and</span>
<span class="cm">	 * we can run checkpoint completion before we&#39;ve updated and unlocked</span>
<span class="cm">	 * the log items. This affects (at least) processing of stale buffers,</span>
<span class="cm">	 * inodes and EFIs.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_free_items</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="o">*</span><span class="n">commit_lsn</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">xlog_cil_push_background</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>

	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_ctx_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Conditionally push the CIL based on the sequence passed in.</span>
<span class="cm"> *</span>
<span class="cm"> * We only need to push if we haven&#39;t already pushed the sequence</span>
<span class="cm"> * number given. Hence the only time we will trigger a push here is</span>
<span class="cm"> * if the push sequence is the same as the current context.</span>
<span class="cm"> *</span>
<span class="cm"> * We return the current commit lsn to allow the callers to determine if a</span>
<span class="cm"> * iclog flush is necessary following this call.</span>
<span class="cm"> */</span>
<span class="n">xfs_lsn_t</span>
<span class="nf">xlog_cil_force_lsn</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>	<span class="n">sequence</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_cil</span>		<span class="o">*</span><span class="n">cil</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_cil_ctx</span>	<span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">commit_lsn</span> <span class="o">=</span> <span class="n">NULLCOMMITLSN</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">sequence</span> <span class="o">&lt;=</span> <span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_current_sequence</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * check to see if we need to force out the current context.</span>
<span class="cm">	 * xlog_cil_push() handles racing pushes for the same sequence,</span>
<span class="cm">	 * so no need to deal with it here.</span>
<span class="cm">	 */</span>
	<span class="n">xlog_cil_push_foreground</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">sequence</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if we can find a previous sequence still committing.</span>
<span class="cm">	 * We need to wait for all previous sequence commits to complete</span>
<span class="cm">	 * before allowing the force of push_seq to go ahead. Hence block</span>
<span class="cm">	 * on commits for those as well.</span>
<span class="cm">	 */</span>
<span class="nl">restart:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_committing</span><span class="p">,</span> <span class="n">committing</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">&gt;</span> <span class="n">sequence</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">commit_lsn</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * It is still being pushed! Wait for the push to</span>
<span class="cm">			 * complete, then start again from the beginning.</span>
<span class="cm">			 */</span>
			<span class="n">xlog_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_commit_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">!=</span> <span class="n">sequence</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* found it! */</span>
		<span class="n">commit_lsn</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">commit_lsn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">commit_lsn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if the current log item was first committed in this sequence.</span>
<span class="cm"> * We can&#39;t rely on just the log item being in the CIL, we have to check</span>
<span class="cm"> * the recorded commit sequence number.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: for this to be used in a non-racy manner, it has to be called with</span>
<span class="cm"> * CIL flushing locked out. As a result, it should only be used during the</span>
<span class="cm"> * transaction commit process when deciding what to format into the item.</span>
<span class="cm"> */</span>
<span class="n">bool</span>
<span class="nf">xfs_log_item_in_current_chkpt</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_log_item</span> <span class="o">*</span><span class="n">lip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_cil_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_cil</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_mountp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * li_seq is written on the first commit of a log item to record the</span>
<span class="cm">	 * first checkpoint it is written to. Hence if it is different to the</span>
<span class="cm">	 * current sequence, we&#39;re in a new checkpoint.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_LSN_CMP</span><span class="p">(</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_seq</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform initial CIL structure initialisation.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xlog_cil_init</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_cil</span>	<span class="o">*</span><span class="n">cil</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_cil_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="n">cil</span> <span class="o">=</span> <span class="n">kmem_zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cil</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="o">|</span><span class="n">KM_MAYFAIL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cil</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">kmem_zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="o">|</span><span class="n">KM_MAYFAIL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">cil</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_push_work</span><span class="p">,</span> <span class="n">xlog_cil_push_work</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_committing</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_cil_lock</span><span class="p">);</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_ctx_lock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_commit_wait</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">committing</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">busy_extents</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cil</span> <span class="o">=</span> <span class="n">cil</span><span class="p">;</span>
	<span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_current_sequence</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">;</span>

	<span class="n">cil</span><span class="o">-&gt;</span><span class="n">xc_log</span> <span class="o">=</span> <span class="n">log</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span> <span class="o">=</span> <span class="n">cil</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xlog_cil_destroy</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="o">-&gt;</span><span class="n">ticket</span><span class="p">)</span>
			<span class="n">xfs_log_ticket_put</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="o">-&gt;</span><span class="n">ticket</span><span class="p">);</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_ctx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_cil</span><span class="p">));</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
