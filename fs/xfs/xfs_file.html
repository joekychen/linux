<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_file.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_file.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode_item.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_vnodeops.h&quot;</span>
<span class="cp">#include &quot;xfs_da_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_ioctl.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>

<span class="cp">#include &lt;linux/dcache.h&gt;</span>
<span class="cp">#include &lt;linux/falloc.h&gt;</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">xfs_file_vm_ops</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Locking primitives for read and write IO paths to ensure we consistently use</span>
<span class="cm"> * and order the inode-&gt;i_mutex, ip-&gt;i_lock and ip-&gt;i_iolock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xfs_rw_ilock</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">)</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xfs_rw_iunlock</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xfs_rw_ilock_demote</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_ilock_demote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	xfs_iozero</span>
<span class="cm"> *</span>
<span class="cm"> *	xfs_iozero clears the specified range of buffer supplied,</span>
<span class="cm"> *	and marks all the affected blocks as valid and modified.  If</span>
<span class="cm"> *	an affected block is not allocated, it will be allocated.  If</span>
<span class="cm"> *	an affected block is not completely overwritten, and is not</span>
<span class="cm"> *	valid before the operation, it will be read from disk before</span>
<span class="cm"> *	being partially zeroed.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_iozero</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>	<span class="cm">/* inode			*/</span>
	<span class="n">loff_t</span>			<span class="n">pos</span><span class="p">,</span>	<span class="cm">/* offset in file		*/</span>
	<span class="kt">size_t</span>			<span class="n">count</span><span class="p">)</span>	<span class="cm">/* size of data to zero		*/</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span> <span class="cm">/* Within page */</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">pagecache_write_begin</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span>
					<span class="n">AOP_FLAG_UNINTERRUPTIBLE</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsdata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">pagecache_write_end</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span>
					<span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">status</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* can&#39;t return less than zero! */</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fsync operations on directories are much simpler than on regular files,</span>
<span class="cm"> * as there is no file data to flush, and thus also no need for explicit</span>
<span class="cm"> * cache flush operations, and there are no non-transaction metadata updates</span>
<span class="cm"> * on directories either.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_dir_fsync</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">file</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">start</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">end</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">trace_xfs_dir_fsync</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_ipincount</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
		<span class="n">lsn</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_itemp</span><span class="o">-&gt;</span><span class="n">ili_last_lsn</span><span class="p">;</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lsn</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">_xfs_log_force_lsn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">lsn</span><span class="p">,</span> <span class="n">XFS_LOG_SYNC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_file_fsync</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">file</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">start</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">end</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">log_flushed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">trace_xfs_file_fsync</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">xfs_iflags_clear</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ITRUNCATED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_BARRIER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we have an RT and/or log subvolume we need to make sure</span>
<span class="cm">		 * to flush the write cache the device used for file data</span>
<span class="cm">		 * first.  This is to ensure newly written file data make</span>
<span class="cm">		 * it to disk before logging the new inode size in case of</span>
<span class="cm">		 * an extending write.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">XFS_IS_REALTIME_INODE</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
			<span class="n">xfs_blkdev_issue_flush</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rtdev_targp</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span> <span class="o">!=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">)</span>
			<span class="n">xfs_blkdev_issue_flush</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * All metadata updates are logged, which means that we just have</span>
<span class="cm">	 * to flush the log up to the latest LSN that touched the inode.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_ipincount</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">datasync</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_itemp</span><span class="o">-&gt;</span><span class="n">ili_fields</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">XFS_ILOG_TIMESTAMP</span><span class="p">))</span>
			<span class="n">lsn</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_itemp</span><span class="o">-&gt;</span><span class="n">ili_last_lsn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lsn</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">_xfs_log_force_lsn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">lsn</span><span class="p">,</span> <span class="n">XFS_LOG_SYNC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log_flushed</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we only have a single device, and the log force about was</span>
<span class="cm">	 * a no-op we might have to flush the data device cache here.</span>
<span class="cm">	 * This can only happen for fdatasync/O_DSYNC if we were overwriting</span>
<span class="cm">	 * an already allocated file and thus do not have any metadata to</span>
<span class="cm">	 * commit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_BARRIER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span> <span class="o">==</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">XFS_IS_REALTIME_INODE</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">log_flushed</span><span class="p">)</span>
		<span class="n">xfs_blkdev_issue_flush</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">ssize_t</span>
<span class="nf">xfs_file_aio_read</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">kiocb</span>		<span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span>	<span class="o">*</span><span class="n">iovp</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">nr_segs</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ioflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_fsize_t</span>		<span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">seg</span><span class="p">;</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_read_calls</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_DIRECT</span><span class="p">))</span>
		<span class="n">ioflags</span> <span class="o">|=</span> <span class="n">IO_ISDIRECT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_NOCMTIME</span><span class="p">)</span>
		<span class="n">ioflags</span> <span class="o">|=</span> <span class="n">IO_INVIS</span><span class="p">;</span>

	<span class="cm">/* START copy &amp; waste from filemap.c */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="n">nr_segs</span><span class="p">;</span> <span class="n">seg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iovp</span><span class="p">[</span><span class="n">seg</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * If any segment has a negative length, or the cumulative</span>
<span class="cm">		 * length ever wraps negative then return -EINVAL.</span>
<span class="cm">		 */</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">iv</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="kt">ssize_t</span><span class="p">)(</span><span class="n">size</span><span class="o">|</span><span class="n">iv</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* END copy &amp; waste from filemap.c */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ioflags</span> <span class="o">&amp;</span> <span class="n">IO_ISDIRECT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_buftarg_t</span>	<span class="o">*</span><span class="n">target</span> <span class="o">=</span>
			<span class="n">XFS_IS_REALTIME_INODE</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rtdev_targp</span> <span class="o">:</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">&amp;</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">bt_smask</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">bt_smask</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">==</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">XFS_MAXIOFFSET</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">-</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Locking is a bit tricky here. If we take an exclusive lock</span>
<span class="cm">	 * for direct IO, we effectively serialise all new concurrent</span>
<span class="cm">	 * read IO to this file and block it behind IO that is currently in</span>
<span class="cm">	 * progress because IO in progress holds the IO lock shared. We only</span>
<span class="cm">	 * need to hold the lock exclusive to blow away the page cache, so</span>
<span class="cm">	 * only take lock exclusively if the page cache needs invalidation.</span>
<span class="cm">	 * This allows the normal direct IO case of no page cache pages to</span>
<span class="cm">	 * proceeed concurrently without serialisation.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_rw_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_SHARED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ioflags</span> <span class="o">&amp;</span> <span class="n">IO_ISDIRECT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_rw_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_SHARED</span><span class="p">);</span>
		<span class="n">xfs_rw_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">xfs_flushinval_pages</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span>
					<span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">&amp;</span> <span class="n">PAGE_CACHE_MASK</span><span class="p">),</span>
					<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">FI_REMAPF_LOCKED</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_rw_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">xfs_rw_ilock_demote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">trace_xfs_file_read</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">,</span> <span class="n">ioflags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">generic_file_aio_read</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iovp</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">XFS_STATS_ADD</span><span class="p">(</span><span class="n">xs_read_bytes</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="n">xfs_rw_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_SHARED</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">ssize_t</span>
<span class="nf">xfs_file_splice_read</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">infilp</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pipe_inode_info</span>	<span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">count</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">infilp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">ioflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">ret</span><span class="p">;</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_read_calls</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">infilp</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_NOCMTIME</span><span class="p">)</span>
		<span class="n">ioflags</span> <span class="o">|=</span> <span class="n">IO_INVIS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">xfs_rw_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_SHARED</span><span class="p">);</span>

	<span class="n">trace_xfs_file_splice_read</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="n">ioflags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">generic_file_splice_read</span><span class="p">(</span><span class="n">infilp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">XFS_STATS_ADD</span><span class="p">(</span><span class="n">xs_read_bytes</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="n">xfs_rw_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_SHARED</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_file_splice_write() does not use xfs_rw_ilock() because</span>
<span class="cm"> * generic_file_splice_write() takes the i_mutex itself. This, in theory,</span>
<span class="cm"> * couuld cause lock inversions between the aio_write path and the splice path</span>
<span class="cm"> * if someone is doing concurrent splice(2) based writes and write(2) based</span>
<span class="cm"> * writes to the same inode. The only real way to fix this is to re-implement</span>
<span class="cm"> * the generic code here with correct locking orders.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">ssize_t</span>
<span class="nf">xfs_file_splice_write</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pipe_inode_info</span>	<span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">outfilp</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">count</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">outfilp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">ioflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">ret</span><span class="p">;</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_write_calls</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">outfilp</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_NOCMTIME</span><span class="p">)</span>
		<span class="n">ioflags</span> <span class="o">|=</span> <span class="n">IO_INVIS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>

	<span class="n">trace_xfs_file_splice_write</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="n">ioflags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">generic_file_splice_write</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">outfilp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">XFS_STATS_ADD</span><span class="p">(</span><span class="n">xs_write_bytes</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine is called to handle zeroing any space in the last block of the</span>
<span class="cm"> * file that is beyond the EOF.  We do this since the size is being increased</span>
<span class="cm"> * without writing anything to that block and we don&#39;t want to read the</span>
<span class="cm"> * garbage on the disk.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error (positive) */</span>
<span class="n">xfs_zero_last_block</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_fsize_t</span>		<span class="n">offset</span><span class="p">,</span>
	<span class="n">xfs_fsize_t</span>		<span class="n">isize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">last_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSBT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">isize</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">zero_offset</span> <span class="o">=</span> <span class="n">XFS_B_FSB_OFFSET</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">isize</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">zero_len</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nimaps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_bmbt_irec</span>	<span class="n">imap</span><span class="p">;</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">last_fsb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nimaps</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">nimaps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the block underlying isize is just a hole, then there</span>
<span class="cm">	 * is nothing to zero.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">==</span> <span class="n">HOLESTARTBLOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">zero_len</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span> <span class="o">-</span> <span class="n">zero_offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isize</span> <span class="o">+</span> <span class="n">zero_len</span> <span class="o">&gt;</span> <span class="n">offset</span><span class="p">)</span>
		<span class="n">zero_len</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">isize</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">xfs_iozero</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">isize</span><span class="p">,</span> <span class="n">zero_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Zero any on disk space between the current EOF and the new, larger EOF.</span>
<span class="cm"> *</span>
<span class="cm"> * This handles the normal case of zeroing the remainder of the last block in</span>
<span class="cm"> * the file and the unusual case of zeroing blocks out beyond the size of the</span>
<span class="cm"> * file.  This second case only happens with fixed size extents and when the</span>
<span class="cm"> * system crashes before the inode size was updated but after blocks were</span>
<span class="cm"> * allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * Expects the iolock to be held exclusive, and will take the ilock internally.</span>
<span class="cm"> */</span>
<span class="kt">int</span>					<span class="cm">/* error (positive) */</span>
<span class="n">xfs_zero_eof</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_off_t</span>		<span class="n">offset</span><span class="p">,</span>		<span class="cm">/* starting I/O offset */</span>
	<span class="n">xfs_fsize_t</span>		<span class="n">isize</span><span class="p">)</span>		<span class="cm">/* current inode size */</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">start_zero_fsb</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">end_zero_fsb</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">zero_count_fsb</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">last_fsb</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">zero_off</span><span class="p">;</span>
	<span class="n">xfs_fsize_t</span>		<span class="n">zero_len</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nimaps</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_bmbt_irec</span>	<span class="n">imap</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_isilocked</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">isize</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * First handle zeroing the block on which isize resides.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We only zero a part of that block so it is handled specially.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_B_FSB_OFFSET</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">isize</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_zero_last_block</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">isize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the range between the new size and the old where blocks</span>
<span class="cm">	 * needing to be zeroed may exist.</span>
<span class="cm">	 *</span>
<span class="cm">	 * To get the block where the last byte in the file currently resides,</span>
<span class="cm">	 * we need to subtract one from the size and truncate back to a block</span>
<span class="cm">	 * boundary.  We subtract 1 in case the size is exactly on a block</span>
<span class="cm">	 * boundary.</span>
<span class="cm">	 */</span>
	<span class="n">last_fsb</span> <span class="o">=</span> <span class="n">isize</span> <span class="o">?</span> <span class="n">XFS_B_TO_FSBT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">isize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">xfs_fileoff_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">start_zero_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_ufsize_t</span><span class="p">)</span><span class="n">isize</span><span class="p">);</span>
	<span class="n">end_zero_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSBT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">xfs_sfiloff_t</span><span class="p">)</span><span class="n">last_fsb</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">xfs_sfiloff_t</span><span class="p">)</span><span class="n">start_zero_fsb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_fsb</span> <span class="o">==</span> <span class="n">end_zero_fsb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The size was only incremented on its last block.</span>
<span class="cm">		 * We took care of that above, so just return.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">start_zero_fsb</span> <span class="o">&lt;=</span> <span class="n">end_zero_fsb</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">start_zero_fsb</span> <span class="o">&lt;=</span> <span class="n">end_zero_fsb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nimaps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">zero_count_fsb</span> <span class="o">=</span> <span class="n">end_zero_fsb</span> <span class="o">-</span> <span class="n">start_zero_fsb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">start_zero_fsb</span><span class="p">,</span> <span class="n">zero_count_fsb</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nimaps</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nimaps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">imap</span><span class="p">.</span><span class="n">br_state</span> <span class="o">==</span> <span class="n">XFS_EXT_UNWRITTEN</span> <span class="o">||</span>
		    <span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">==</span> <span class="n">HOLESTARTBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">start_zero_fsb</span> <span class="o">=</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_startoff</span> <span class="o">+</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">;</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">start_zero_fsb</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">end_zero_fsb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * There are blocks we need to zero.</span>
<span class="cm">		 */</span>
		<span class="n">zero_off</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">start_zero_fsb</span><span class="p">);</span>
		<span class="n">zero_len</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">zero_off</span> <span class="o">+</span> <span class="n">zero_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">offset</span><span class="p">)</span>
			<span class="n">zero_len</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">zero_off</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iozero</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">zero_off</span><span class="p">,</span> <span class="n">zero_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">start_zero_fsb</span> <span class="o">=</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_startoff</span> <span class="o">+</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">start_zero_fsb</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">end_zero_fsb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Common pre-write limit and setup checks.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with the iolocked held either shared and exclusive according to</span>
<span class="cm"> * @iolock, and returns with it held.  Might upgrade the iolock to exclusive</span>
<span class="cm"> * if called for a direct write beyond i_size.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">ssize_t</span>
<span class="n">xfs_file_aio_write_checks</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">file</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="o">*</span><span class="n">pos</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="o">*</span><span class="n">count</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">iolock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">generic_write_checks</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the offset is beyond the size of the file, we need to zero any</span>
<span class="cm">	 * blocks that fall between the existing EOF and the start of this</span>
<span class="cm">	 * write.  If zeroing is needed and we are currently holding the</span>
<span class="cm">	 * iolock shared, we need to update it to exclusive which implies</span>
<span class="cm">	 * having to redo all checks before.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">iolock</span> <span class="o">==</span> <span class="n">XFS_IOLOCK_SHARED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_rw_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">*</span><span class="n">iolock</span><span class="p">);</span>
			<span class="o">*</span><span class="n">iolock</span> <span class="o">=</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">;</span>
			<span class="n">xfs_rw_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">*</span><span class="n">iolock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">xfs_zero_eof</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Updating the timestamps will grab the ilock again from</span>
<span class="cm">	 * xfs_fs_dirty_inode, so we have to call it after dropping the</span>
<span class="cm">	 * lock above.  Eventually we should look into a way to avoid</span>
<span class="cm">	 * the pointless lock roundtrip.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_NOCMTIME</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">file_update_time</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re writing the file then make sure to clear the setuid and</span>
<span class="cm">	 * setgid bits if the process is not being run by root.  This keeps</span>
<span class="cm">	 * people from modifying setuid and setgid binaries.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">file_remove_suid</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_file_dio_aio_write - handle direct IO writes</span>
<span class="cm"> *</span>
<span class="cm"> * Lock the inode appropriately to prepare for and issue a direct IO write.</span>
<span class="cm"> * By separating it from the buffered write path we remove all the tricky to</span>
<span class="cm"> * follow locking changes and looping.</span>
<span class="cm"> *</span>
<span class="cm"> * If there are cached pages or we&#39;re extending the file, we need IOLOCK_EXCL</span>
<span class="cm"> * until we&#39;re sure the bytes at the new EOF have been zeroed and/or the cached</span>
<span class="cm"> * pages are flushed out.</span>
<span class="cm"> *</span>
<span class="cm"> * In most cases the direct IO writes will be done holding IOLOCK_SHARED</span>
<span class="cm"> * allowing them to be done in parallel with reads and other direct IO writes.</span>
<span class="cm"> * However, if the IO is not aligned to filesystem blocks, the direct IO layer</span>
<span class="cm"> * needs to do sub-block zeroing and that requires serialisation against other</span>
<span class="cm"> * direct IOs to the same block. In this case we need to serialise the</span>
<span class="cm"> * submission of the unaligned IOs so that we don&#39;t get racing block zeroing in</span>
<span class="cm"> * the dio layer.  To avoid the problem with aio, we also need to wait for</span>
<span class="cm"> * outstanding IOs to complete so that unwritten extent conversion is completed</span>
<span class="cm"> * before we try to map the overlapping block. This is currently implemented by</span>
<span class="cm"> * hitting it with a big hammer (i.e. inode_dio_wait()).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns with locks held indicated by @iolock and errors indicated by</span>
<span class="cm"> * negative return values.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">ssize_t</span>
<span class="n">xfs_file_dio_aio_write</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">kiocb</span>		<span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span>	<span class="o">*</span><span class="n">iovp</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">nr_segs</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">pos</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">ocount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">count</span> <span class="o">=</span> <span class="n">ocount</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">unaligned_io</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">iolock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_buftarg</span>	<span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="n">XFS_IS_REALTIME_INODE</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">?</span>
					<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rtdev_targp</span> <span class="o">:</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">bt_smask</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">count</span> <span class="o">&amp;</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">bt_smask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_blockmask</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">pos</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_blockmask</span><span class="p">))</span>
		<span class="n">unaligned_io</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t need to take an exclusive lock unless there page cache needs</span>
<span class="cm">	 * to be invalidated or unaligned IO is being executed. We don&#39;t need to</span>
<span class="cm">	 * consider the EOF extension case here because</span>
<span class="cm">	 * xfs_file_aio_write_checks() will relock the inode as necessary for</span>
<span class="cm">	 * EOF zeroing cases and fill out the new inode size as appropriate.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unaligned_io</span> <span class="o">||</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="p">)</span>
		<span class="n">iolock</span> <span class="o">=</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">iolock</span> <span class="o">=</span> <span class="n">XFS_IOLOCK_SHARED</span><span class="p">;</span>
	<span class="n">xfs_rw_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">iolock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Recheck if there are cached pages that need invalidate after we got</span>
<span class="cm">	 * the iolock to protect against other threads adding new pages while</span>
<span class="cm">	 * we were waiting for the iolock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span> <span class="o">&amp;&amp;</span> <span class="n">iolock</span> <span class="o">==</span> <span class="n">XFS_IOLOCK_SHARED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_rw_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">iolock</span><span class="p">);</span>
		<span class="n">iolock</span> <span class="o">=</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">;</span>
		<span class="n">xfs_rw_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">iolock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xfs_file_aio_write_checks</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iolock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">xfs_flushinval_pages</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="n">PAGE_CACHE_MASK</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
							<span class="n">FI_REMAPF_LOCKED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are doing unaligned IO, wait for all other IO to drain,</span>
<span class="cm">	 * otherwise demote the lock if we had to flush cached pages</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unaligned_io</span><span class="p">)</span>
		<span class="n">inode_dio_wait</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">iolock</span> <span class="o">==</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_rw_ilock_demote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
		<span class="n">iolock</span> <span class="o">=</span> <span class="n">XFS_IOLOCK_SHARED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_xfs_file_direct_write</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">generic_file_direct_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iovp</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">nr_segs</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ocount</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">xfs_rw_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">iolock</span><span class="p">);</span>

	<span class="cm">/* No fallback to buffered IO on errors for XFS. */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">ssize_t</span>
<span class="n">xfs_file_buffered_aio_write</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">kiocb</span>		<span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span>	<span class="o">*</span><span class="n">iovp</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">nr_segs</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">pos</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">ocount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">ssize_t</span>			<span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">enospc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">iolock</span> <span class="o">=</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">count</span> <span class="o">=</span> <span class="n">ocount</span><span class="p">;</span>

	<span class="n">xfs_rw_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">iolock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xfs_file_aio_write_checks</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iolock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* We can write back this queue in page reclaim */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>

<span class="nl">write_retry:</span>
	<span class="n">trace_xfs_file_buffered_write</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">generic_file_buffered_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iovp</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span>
			<span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * if we just got an ENOSPC, flush the inode now we aren&#39;t holding any</span>
<span class="cm">	 * page locks and retry *once*</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">enospc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enospc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">xfs_flush_pages</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FI_NONE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">write_retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">xfs_rw_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">iolock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">ssize_t</span>
<span class="n">xfs_file_aio_write</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">kiocb</span>		<span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span>	<span class="o">*</span><span class="n">iovp</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">nr_segs</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">ssize_t</span>			<span class="n">ret</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">ocount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_write_calls</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">generic_segment_checks</span><span class="p">(</span><span class="n">iovp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_segs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ocount</span><span class="p">,</span> <span class="n">VERIFY_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ocount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">xfs_wait_for_freeze</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">SB_FREEZE_WRITE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_DIRECT</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xfs_file_dio_aio_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iovp</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ocount</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xfs_file_buffered_aio_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iovp</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
						  <span class="n">ocount</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">ssize_t</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">XFS_STATS_ADD</span><span class="p">(</span><span class="n">xs_write_bytes</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

		<span class="cm">/* Handle various SYNC-type writes */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">generic_write_sync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">long</span>
<span class="n">xfs_file_fallocate</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">file</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">mode</span><span class="p">,</span>
	<span class="n">loff_t</span>		<span class="n">offset</span><span class="p">,</span>
	<span class="n">loff_t</span>		<span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">long</span>		<span class="n">error</span><span class="p">;</span>
	<span class="n">loff_t</span>		<span class="n">new_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_flock64_t</span>	<span class="n">bf</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">cmd</span> <span class="o">=</span> <span class="n">XFS_IOC_RESVSP</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">attr_flags</span> <span class="o">=</span> <span class="n">XFS_ATTR_NOLOCK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">FALLOC_FL_KEEP_SIZE</span> <span class="o">|</span> <span class="n">FALLOC_FL_PUNCH_HOLE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">bf</span><span class="p">.</span><span class="n">l_whence</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bf</span><span class="p">.</span><span class="n">l_start</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">bf</span><span class="p">.</span><span class="n">l_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FALLOC_FL_PUNCH_HOLE</span><span class="p">)</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">XFS_IOC_UNRESVSP</span><span class="p">;</span>

	<span class="cm">/* check the new inode size is valid before allocating */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FALLOC_FL_KEEP_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">new_size</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">inode_newsize_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_DSYNC</span><span class="p">)</span>
		<span class="n">attr_flags</span> <span class="o">|=</span> <span class="n">XFS_ATTR_SYNC</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">xfs_change_file_space</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">attr_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* Change file size if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iattr</span> <span class="n">iattr</span><span class="p">;</span>

		<span class="n">iattr</span><span class="p">.</span><span class="n">ia_valid</span> <span class="o">=</span> <span class="n">ATTR_SIZE</span><span class="p">;</span>
		<span class="n">iattr</span><span class="p">.</span><span class="n">ia_size</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">xfs_setattr_size</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iattr</span><span class="p">,</span> <span class="n">XFS_ATTR_NOLOCK</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_file_open</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_LARGEFILE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_NON_LFS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">XFS_M</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_dir_open</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">mode</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_file_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are any blocks, read-ahead block 0 as we&#39;re almost</span>
<span class="cm">	 * certain to have the next operation be a read there.</span>
<span class="cm">	 */</span>
	<span class="n">mode</span> <span class="o">=</span> <span class="n">xfs_ilock_map_shared</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nextents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">xfs_da_reada_buf</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_file_release</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">xfs_release</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_file_readdir</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">filp</span><span class="p">,</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">dirent</span><span class="p">,</span>
	<span class="n">filldir_t</span>	<span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="kt">size_t</span>		<span class="n">bufsize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The Linux API doesn&#39;t pass down the total size of the buffer</span>
<span class="cm">	 * we read into down to the filesystem.  With the filldir concept</span>
<span class="cm">	 * it&#39;s not needed for correct information, but the XFS dir2 leaf</span>
<span class="cm">	 * code wants an estimate of the buffer size to calculate it&#39;s</span>
<span class="cm">	 * readahead window and size the buffers used for mapping to</span>
<span class="cm">	 * physical blocks.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Try to give it an estimate that&#39;s good enough, maybe at some</span>
<span class="cm">	 * point we can change the -&gt;readdir prototype to include the</span>
<span class="cm">	 * buffer size.  For now we use the current glibc buffer size.</span>
<span class="cm">	 */</span>
	<span class="n">bufsize</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">min_t</span><span class="p">(</span><span class="n">loff_t</span><span class="p">,</span> <span class="mi">32768</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_readdir</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">,</span>
				<span class="p">(</span><span class="n">xfs_off_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span> <span class="n">filldir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_file_mmap</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">filp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfs_file_vm_ops</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_CAN_NONLINEAR</span><span class="p">;</span>

	<span class="n">file_accessed</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mmap()d file has taken write protection fault and is being made</span>
<span class="cm"> * writable. We can set the page state up correctly for a writable</span>
<span class="cm"> * page, which means we can do correct delalloc accounting (ENOSPC</span>
<span class="cm"> * checking!) and unwritten extent mapping.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_vm_page_mkwrite</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span>	<span class="o">*</span><span class="n">vma</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vm_fault</span>		<span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">block_page_mkwrite</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="p">,</span> <span class="n">xfs_get_blocks</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="n">loff_t</span>
<span class="n">xfs_seek_data</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">file</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">start</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_bmbt_irec</span>	<span class="n">map</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">nmap</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">uninitialized_var</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">xfs_fsize_t</span>		<span class="n">isize</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">fsbno</span><span class="p">;</span>
	<span class="n">xfs_filblks_t</span>		<span class="n">end</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">lock</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">lock</span> <span class="o">=</span> <span class="n">xfs_ilock_map_shared</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">isize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fsbno</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSBT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to read extents from the first block indicated</span>
<span class="cm">	 * by fsbno to the end block of the file.</span>
<span class="cm">	 */</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">isize</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">fsbno</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">fsbno</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmap</span><span class="p">,</span>
			       <span class="n">XFS_BMAPI_ENTIRE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Treat unwritten extent as data extent since it might</span>
<span class="cm">	 * contains dirty data in page cache.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">HOLESTARTBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">loff_t</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
			       <span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">br_startoff</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nmap</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">ENXIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">loff_t</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
			       <span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">map</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">br_startoff</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">)</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">xfs_iunlock_map_shared</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="n">loff_t</span>
<span class="n">xfs_seek_hole</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">file</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">start</span><span class="p">,</span>
	<span class="n">u32</span>			<span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">uninitialized_var</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">loff_t</span>			<span class="n">holeoff</span><span class="p">;</span>
	<span class="n">xfs_fsize_t</span>		<span class="n">isize</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">fsbno</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">lock</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">lock</span> <span class="o">=</span> <span class="n">xfs_ilock_map_shared</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">isize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fsbno</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSBT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_first_unused</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsbno</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">holeoff</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">fsbno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">holeoff</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * xfs_bmap_first_unused() could return a value bigger than</span>
<span class="cm">		 * isize if there are no more holes past the supplied offset.</span>
<span class="cm">		 */</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">loff_t</span><span class="p">,</span> <span class="n">holeoff</span><span class="p">,</span> <span class="n">isize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">)</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">xfs_iunlock_map_shared</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="n">loff_t</span>
<span class="n">xfs_file_llseek</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">file</span><span class="p">,</span>
	<span class="n">loff_t</span>		<span class="n">offset</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">origin</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SEEK_END</span>:
	<span class="k">case</span> <span class="n">SEEK_CUR</span>:
	<span class="k">case</span> <span class="n">SEEK_SET</span>:
		<span class="k">return</span> <span class="n">generic_file_llseek</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">origin</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SEEK_DATA</span>:
		<span class="k">return</span> <span class="n">xfs_seek_data</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">origin</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SEEK_HOLE</span>:
		<span class="k">return</span> <span class="n">xfs_seek_hole</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">origin</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">xfs_file_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">xfs_file_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">do_sync_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">do_sync_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_read</span>	<span class="o">=</span> <span class="n">xfs_file_aio_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_write</span>	<span class="o">=</span> <span class="n">xfs_file_aio_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span>	<span class="o">=</span> <span class="n">xfs_file_splice_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_write</span>	<span class="o">=</span> <span class="n">xfs_file_splice_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">xfs_file_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>	<span class="o">=</span> <span class="n">xfs_file_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">mmap</span>		<span class="o">=</span> <span class="n">xfs_file_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">xfs_file_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">xfs_file_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span>		<span class="o">=</span> <span class="n">xfs_file_fsync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fallocate</span>	<span class="o">=</span> <span class="n">xfs_file_fallocate</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">xfs_dir_file_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">xfs_dir_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">generic_read_dir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readdir</span>	<span class="o">=</span> <span class="n">xfs_file_readdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">xfs_file_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>	<span class="o">=</span> <span class="n">xfs_file_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">fsync</span>		<span class="o">=</span> <span class="n">xfs_dir_fsync</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">xfs_file_vm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span>		<span class="o">=</span> <span class="n">filemap_fault</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_mkwrite</span>	<span class="o">=</span> <span class="n">xfs_vm_page_mkwrite</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
