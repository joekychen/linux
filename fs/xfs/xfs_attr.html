<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_attr.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_attr.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_bit.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_da_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_attr_sf.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_inode_item.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap.h&quot;</span>
<span class="cp">#include &quot;xfs_attr.h&quot;</span>
<span class="cp">#include &quot;xfs_attr_leaf.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_quota.h&quot;</span>
<span class="cp">#include &quot;xfs_trans_space.h&quot;</span>
<span class="cp">#include &quot;xfs_vnodeops.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_attr.c</span>
<span class="cm"> *</span>
<span class="cm"> * Provide the external interfaces to manage attribute lists.</span>
<span class="cm"> */</span>

<span class="cm">/*========================================================================</span>
<span class="cm"> * Function prototypes for the kernel.</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Internal routines when attribute list fits inside the inode.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_shortform_addname</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Internal routines when attribute list is one block.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_leaf_get</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_leaf_addname</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_leaf_removename</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_leaf_list</span><span class="p">(</span><span class="n">xfs_attr_list_context_t</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Internal routines when attribute list is more than one block.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_node_get</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_node_addname</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_node_removename</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_node_list</span><span class="p">(</span><span class="n">xfs_attr_list_context_t</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_fillstate</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_refillstate</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Routines to manipulate out-of-line attribute values.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_rmtval_set</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_rmtval_remove</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>

<span class="cp">#define ATTR_RMTVALUE_MAPSIZE	1	</span><span class="cm">/* # of map entries at once */</span><span class="cp"></span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_name_to_xname</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="o">*</span><span class="n">xname</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">aname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aname</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">xname</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">aname</span><span class="p">;</span>
	<span class="n">xname</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">aname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xname</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">MAXNAMELEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EFAULT</span><span class="p">;</span>		<span class="cm">/* match IRIX behaviour */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_inode_hasattr</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XFS_IFORK_Q</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">==</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span> <span class="o">&amp;&amp;</span>
	     <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_anextents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*========================================================================</span>
<span class="cm"> * Overall external interface routines.</span>
<span class="cm"> *========================================================================*/</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_get_int</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>		<span class="o">*</span><span class="n">name</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">value</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">valuelenp</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_args_t</span>   <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span>             <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_inode_hasattr</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ENOATTR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in the arg structure for this request.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">));</span>
	<span class="n">args</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">valuelen</span> <span class="o">=</span> <span class="o">*</span><span class="n">valuelenp</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">xfs_da_hashname</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">namelen</span><span class="p">);</span>
	<span class="n">args</span><span class="p">.</span><span class="n">dp</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">whichfork</span> <span class="o">=</span> <span class="n">XFS_ATTR_FORK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Decide on what work routines to call based on the inode size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">==</span> <span class="n">XFS_DINODE_FMT_LOCAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_shortform_getvalue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">xfs_bmap_one_block</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_node_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return the number of bytes in the value to the caller.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">valuelenp</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">valuelen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">EEXIST</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_attr_get</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">value</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="o">*</span><span class="n">valuelenp</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="n">xname</span><span class="p">;</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_attr_get</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">))</span>
		<span class="k">return</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_name_to_xname</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xname</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_get_int</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xname</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">valuelenp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate how many blocks we need for the new attribute,</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_calc_size</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span> 	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">namelen</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">valuelen</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span> 	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nblks</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine space new attribute will use, and if it would be</span>
<span class="cm">	 * &quot;local&quot; or &quot;remote&quot; (note: local != inline).</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_newentsize</span><span class="p">(</span><span class="n">namelen</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">,</span>
					<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span><span class="p">,</span> <span class="n">local</span><span class="p">);</span>

	<span class="n">nblks</span> <span class="o">=</span> <span class="n">XFS_DAENTER_SPACE_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">local</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Double split possible */</span>
			<span class="n">nblks</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Out of line attribute, cannot double split, but</span>
<span class="cm">		 * make room for the attribute value itself.</span>
<span class="cm">		 */</span>
		<span class="n">uint</span>	<span class="n">dblocks</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">);</span>
		<span class="n">nblks</span> <span class="o">+=</span> <span class="n">dblocks</span><span class="p">;</span>
		<span class="n">nblks</span> <span class="o">+=</span> <span class="n">XFS_NEXTENTADD_SPACE_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">dblocks</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">nblks</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_set_int</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="o">*</span><span class="n">name</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">value</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">valuelen</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_args_t</span>	<span class="n">args</span><span class="p">;</span>
	<span class="n">xfs_fsblock_t</span>	<span class="n">firstblock</span><span class="p">;</span>
	<span class="n">xfs_bmap_free_t</span> <span class="n">flist</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">,</span> <span class="n">err2</span><span class="p">,</span> <span class="n">committed</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="kt">int</span>             <span class="n">rsvd</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_ROOT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">local</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Attach the dquots to the inode.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_dqattach</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the inode doesn&#39;t have an attribute fork, add one.</span>
<span class="cm">	 * (inode must not be locked when we call this routine)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_IFORK_Q</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">sf_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_sf_hdr_t</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">XFS_ATTR_SF_ENTSIZE_BYNAME</span><span class="p">(</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_add_attrfork</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">sf_size</span><span class="p">,</span> <span class="n">rsvd</span><span class="p">)))</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in the arg structure for this request.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">));</span>
	<span class="n">args</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">valuelen</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">xfs_da_hashname</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">namelen</span><span class="p">);</span>
	<span class="n">args</span><span class="p">.</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dp</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">firstblock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">firstblock</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">flist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">flist</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">whichfork</span> <span class="o">=</span> <span class="n">XFS_ATTR_FORK</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">op_flags</span> <span class="o">=</span> <span class="n">XFS_DA_OP_ADDNAME</span> <span class="o">|</span> <span class="n">XFS_DA_OP_OKNOENT</span><span class="p">;</span>

	<span class="cm">/* Size is now blocks for attribute data */</span>
	<span class="n">args</span><span class="p">.</span><span class="n">total</span> <span class="o">=</span> <span class="n">xfs_attr_calc_size</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start our first transaction of the day.</span>
<span class="cm">	 *</span>
<span class="cm">	 * All future transactions during this code must be &quot;chained&quot; off</span>
<span class="cm">	 * this one via the trans_dup() call.  All transactions will contain</span>
<span class="cm">	 * the inode, and the inode will always be marked with trans_ihold().</span>
<span class="cm">	 * Since the inode will be locked in all transactions, we must log</span>
<span class="cm">	 * the inode in every transaction to let it float upward through</span>
<span class="cm">	 * the log.</span>
<span class="cm">	 */</span>
	<span class="n">args</span><span class="p">.</span><span class="n">trans</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_ATTR_SET</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Root fork attributes can use reserved data blocks for this</span>
<span class="cm">	 * operation if necessary</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rsvd</span><span class="p">)</span>
		<span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">|=</span> <span class="n">XFS_TRANS_RESERVE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">total</span><span class="p">,</span>
			<span class="n">XFS_ATTRSET_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">total</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span> <span class="n">XFS_ATTRSET_LOG_COUNT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve_quota_nblks</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">total</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">rsvd</span> <span class="o">?</span> <span class="n">XFS_QMOPT_RES_REGBLKS</span> <span class="o">|</span> <span class="n">XFS_QMOPT_FORCE_RES</span> <span class="o">:</span>
				       <span class="n">XFS_QMOPT_RES_REGBLKS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the attribute list is non-existent or a shortform list,</span>
<span class="cm">	 * upgrade it to a single-leaf-block attribute list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">==</span> <span class="n">XFS_DINODE_FMT_LOCAL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">==</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_anextents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * Build initial attribute list (if required).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">==</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span><span class="p">)</span>
			<span class="n">xfs_attr_shortform_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Try to add the attr to the attribute list in</span>
<span class="cm">		 * the inode.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_shortform_addname</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Commit the shortform mods, and we&#39;re done.</span>
<span class="cm">			 * NOTE: this is also the error path (EEXIST, etc).</span>
<span class="cm">			 */</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * If this is a synchronous mount, make sure that</span>
<span class="cm">			 * the transaction goes to disk before returning</span>
<span class="cm">			 * to the user.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_WSYNC</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_trans_set_sync</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_KERNOTIME</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_trans_ichgtime</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span>
							<span class="n">XFS_ICHGTIME_CHG</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">err2</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span>
						 <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
			<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

			<span class="k">return</span><span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">err2</span> <span class="o">:</span> <span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * It won&#39;t fit in the shortform, transform to a leaf block.</span>
<span class="cm">		 * GROT: another possible req&#39;mt for a double-split btree op.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">flist</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">firstblock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_shortform_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">flist</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">committed</span><span class="p">);</span>
			<span class="n">args</span><span class="p">.</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flist</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * bmap_finish() may have committed the last trans and started</span>
<span class="cm">		 * a new one.  We need the inode to be in all transactions.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">committed</span><span class="p">)</span>
			<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Commit the leaf transformation.  We&#39;ll need another (linked)</span>
<span class="cm">		 * transaction to add the new attribute to the leaf.</span>
<span class="cm">		 */</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_bmap_one_block</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_addname</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_node_addname</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a synchronous mount, make sure that the</span>
<span class="cm">	 * transaction goes to disk before returning to the user.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_WSYNC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_trans_set_sync</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_KERNOTIME</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">xfs_trans_ichgtime</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ICHGTIME_CHG</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Commit the last in the sequence of transactions.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">)</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span>
			<span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="o">|</span><span class="n">XFS_TRANS_ABORT</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_attr_set</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">dp</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">value</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">valuelen</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>             <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="n">xname</span><span class="p">;</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_attr_set</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_name_to_xname</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xname</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">xfs_attr_set_int</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xname</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Generic handler routine to remove a name from an attribute list.</span>
<span class="cm"> * Transitions attribute list from Btree to shortform as necessary.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_remove_int</span><span class="p">(</span><span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_name</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_args_t</span>	<span class="n">args</span><span class="p">;</span>
	<span class="n">xfs_fsblock_t</span>	<span class="n">firstblock</span><span class="p">;</span>
	<span class="n">xfs_bmap_free_t</span>	<span class="n">flist</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in the arg structure for this request.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">));</span>
	<span class="n">args</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">xfs_da_hashname</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">namelen</span><span class="p">);</span>
	<span class="n">args</span><span class="p">.</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dp</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">firstblock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">firstblock</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">flist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">flist</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">whichfork</span> <span class="o">=</span> <span class="n">XFS_ATTR_FORK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we have no control over the attribute names that userspace passes us</span>
<span class="cm">	 * to remove, so we have to allow the name lookup prior to attribute</span>
<span class="cm">	 * removal to fail.</span>
<span class="cm">	 */</span>
	<span class="n">args</span><span class="p">.</span><span class="n">op_flags</span> <span class="o">=</span> <span class="n">XFS_DA_OP_OKNOENT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Attach the dquots to the inode.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_dqattach</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start our first transaction of the day.</span>
<span class="cm">	 *</span>
<span class="cm">	 * All future transactions during this code must be &quot;chained&quot; off</span>
<span class="cm">	 * this one via the trans_dup() call.  All transactions will contain</span>
<span class="cm">	 * the inode, and the inode will always be marked with trans_ihold().</span>
<span class="cm">	 * Since the inode will be locked in all transactions, we must log</span>
<span class="cm">	 * the inode in every transaction to let it float upward through</span>
<span class="cm">	 * the log.</span>
<span class="cm">	 */</span>
	<span class="n">args</span><span class="p">.</span><span class="n">trans</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_ATTR_RM</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Root fork attributes can use reserved data blocks for this</span>
<span class="cm">	 * operation if necessary</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_ROOT</span><span class="p">)</span>
		<span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">|=</span> <span class="n">XFS_TRANS_RESERVE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span>
				      <span class="n">XFS_ATTRRM_SPACE_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span>
				      <span class="n">XFS_ATTRRM_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span>
				      <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span>
				      <span class="n">XFS_ATTRRM_LOG_COUNT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * No need to make quota reservations here. We expect to release some</span>
<span class="cm">	 * blocks not allocate in the common case.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Decide on what work routines to call based on the inode size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_inode_hasattr</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOATTR</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">==</span> <span class="n">XFS_DINODE_FMT_LOCAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_afp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFINLINE</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_shortform_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">xfs_bmap_one_block</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_removename</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_node_removename</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a synchronous mount, make sure that the</span>
<span class="cm">	 * transaction goes to disk before returning to the user.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_WSYNC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_trans_set_sync</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_KERNOTIME</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">xfs_trans_ichgtime</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ICHGTIME_CHG</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Commit the last in the sequence of transactions.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">)</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trans</span><span class="p">,</span>
			<span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="o">|</span><span class="n">XFS_TRANS_ABORT</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_attr_remove</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">dp</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="n">xname</span><span class="p">;</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_attr_remove</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_name_to_xname</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xname</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_inode_hasattr</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOATTR</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">xfs_attr_remove_int</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xname</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_attr_list_int</span><span class="p">(</span><span class="n">xfs_attr_list_context_t</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_attr_list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">EIO</span><span class="p">;</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Decide on what work routines to call based on the inode size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_inode_hasattr</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">==</span> <span class="n">XFS_DINODE_FMT_LOCAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_shortform_list</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">xfs_bmap_one_block</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_list</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_node_list</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define	ATTR_ENTBASESIZE		</span><span class="cm">/* minimum bytes used by an attr */</span><span class="cp"> \</span>
<span class="cp">	(((struct attrlist_ent *) 0)-&gt;a_name - (char *) 0)</span>
<span class="cp">#define	ATTR_ENTSIZE(namelen)		</span><span class="cm">/* actual bytes used by an attr */</span><span class="cp"> \</span>
<span class="cp">	((ATTR_ENTBASESIZE + (namelen) + 1 + sizeof(u_int32_t)-1) \</span>
<span class="cp">	 &amp; ~(sizeof(u_int32_t)-1))</span>

<span class="cm">/*</span>
<span class="cm"> * Format an attribute and copy it out to the user&#39;s buffer.</span>
<span class="cm"> * Take care to check values and protect against them changing later,</span>
<span class="cm"> * we may be reading them directly out of a user buffer.</span>
<span class="cm"> */</span>
<span class="cm">/*ARGSUSED*/</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_put_listent</span><span class="p">(</span>
	<span class="n">xfs_attr_list_context_t</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">namelen</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">valuelen</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">attrlist</span> <span class="o">*</span><span class="n">alist</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">attrlist</span> <span class="o">*</span><span class="p">)</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">alist</span><span class="p">;</span>
	<span class="n">attrlist_ent_t</span> <span class="o">*</span><span class="n">aep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">arraytop</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_KERNOVAL</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ATTR_MAX_VALUELEN</span><span class="o">/</span><span class="mi">8</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">firstu</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">alist</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">firstu</span> <span class="o">&lt;=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">bufsize</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only list entries in the right namespace.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_SECURE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_SECURE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_ROOT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_ROOT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">arraytop</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">alist</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">context</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">alist</span><span class="o">-&gt;</span><span class="n">al_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">firstu</span> <span class="o">-=</span> <span class="n">ATTR_ENTSIZE</span><span class="p">(</span><span class="n">namelen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">firstu</span> <span class="o">&lt;</span> <span class="n">arraytop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_xfs_attr_list_full</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
		<span class="n">alist</span><span class="o">-&gt;</span><span class="n">al_more</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">context</span><span class="o">-&gt;</span><span class="n">seen_enough</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">aep</span> <span class="o">=</span> <span class="p">(</span><span class="n">attrlist_ent_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">alist</span><span class="p">[</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">firstu</span><span class="p">];</span>
	<span class="n">aep</span><span class="o">-&gt;</span><span class="n">a_valuelen</span> <span class="o">=</span> <span class="n">valuelen</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">aep</span><span class="o">-&gt;</span><span class="n">a_name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
	<span class="n">aep</span><span class="o">-&gt;</span><span class="n">a_name</span><span class="p">[</span><span class="n">namelen</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">alist</span><span class="o">-&gt;</span><span class="n">al_offset</span><span class="p">[</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">firstu</span><span class="p">;</span>
	<span class="n">alist</span><span class="o">-&gt;</span><span class="n">al_count</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">trace_xfs_attr_list_add</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Generate a list of extended attribute names and optionally</span>
<span class="cm"> * also value lengths.  Positive return value follows the XFS</span>
<span class="cm"> * convention of being an error, zero or negative return code</span>
<span class="cm"> * is the length of the buffer returned (negated), indicating</span>
<span class="cm"> * success.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_list</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">dp</span><span class="p">,</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">bufsize</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">,</span>
	<span class="n">attrlist_cursor_kern_t</span> <span class="o">*</span><span class="n">cursor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_list_context_t</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">attrlist</span> <span class="o">*</span><span class="n">alist</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate the cursor.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">pad1</span> <span class="o">||</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">pad2</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">initted</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">||</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">||</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for a properly aligned buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="kt">long</span><span class="p">)</span><span class="n">buffer</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFAULT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_KERNOVAL</span><span class="p">)</span>
		<span class="n">bufsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the output buffer.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">context</span><span class="p">));</span>
	<span class="n">context</span><span class="p">.</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dp</span><span class="p">;</span>
	<span class="n">context</span><span class="p">.</span><span class="n">cursor</span> <span class="o">=</span> <span class="n">cursor</span><span class="p">;</span>
	<span class="n">context</span><span class="p">.</span><span class="n">resynch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">context</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">context</span><span class="p">.</span><span class="n">alist</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="n">context</span><span class="p">.</span><span class="n">bufsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">bufsize</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>  <span class="cm">/* align */</span>
	<span class="n">context</span><span class="p">.</span><span class="n">firstu</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">bufsize</span><span class="p">;</span>
	<span class="n">context</span><span class="p">.</span><span class="n">put_listent</span> <span class="o">=</span> <span class="n">xfs_attr_put_listent</span><span class="p">;</span>

	<span class="n">alist</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">attrlist</span> <span class="o">*</span><span class="p">)</span><span class="n">context</span><span class="p">.</span><span class="n">alist</span><span class="p">;</span>
	<span class="n">alist</span><span class="o">-&gt;</span><span class="n">al_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">alist</span><span class="o">-&gt;</span><span class="n">al_more</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">alist</span><span class="o">-&gt;</span><span class="n">al_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">bufsize</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_list_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">error</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>								<span class="cm">/* error */</span>
<span class="n">xfs_attr_inactive</span><span class="p">(</span><span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span> <span class="n">XFS_NOT_DQATTACHED</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">dp</span><span class="p">));</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_inode_hasattr</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">==</span> <span class="n">XFS_DINODE_FMT_LOCAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start our first transaction of the day.</span>
<span class="cm">	 *</span>
<span class="cm">	 * All future transactions during this code must be &quot;chained&quot; off</span>
<span class="cm">	 * this one via the trans_dup() call.  All transactions will contain</span>
<span class="cm">	 * the inode, and the inode will always be marked with trans_ihold().</span>
<span class="cm">	 * Since the inode will be locked in all transactions, we must log</span>
<span class="cm">	 * the inode in every transaction to let it float upward through</span>
<span class="cm">	 * the log.</span>
<span class="cm">	 */</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_ATTRINVAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_ATTRINVAL_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span>
				      <span class="n">XFS_ATTRINVAL_LOG_COUNT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * No need to make quota reservations here. We expect to release some</span>
<span class="cm">	 * blocks, not allocate, in the common case.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Decide on what work routines to call based on the inode size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_inode_hasattr</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">==</span> <span class="n">XFS_DINODE_FMT_LOCAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_root_inactive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_itruncate_extents</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="o">|</span><span class="n">XFS_TRANS_ABORT</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/*========================================================================</span>
<span class="cm"> * External routines when attribute list is inside the inode</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Add a name to the shortform attribute list structure</span>
<span class="cm"> * This is the external routine.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_attr_shortform_addname</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">newsize</span><span class="p">,</span> <span class="n">forkoff</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_sf_addname</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">xfs_attr_shortform_lookup</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_REPLACE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">ENOATTR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_CREATE</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">xfs_attr_shortform_remove</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">&gt;=</span> <span class="n">XFS_ATTR_SF_ENTSIZE_MAX</span> <span class="o">||</span>
	    <span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">&gt;=</span> <span class="n">XFS_ATTR_SF_ENTSIZE_MAX</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSPC</span><span class="p">));</span>

	<span class="n">newsize</span> <span class="o">=</span> <span class="n">XFS_ATTR_SF_TOTSIZE</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">);</span>
	<span class="n">newsize</span> <span class="o">+=</span> <span class="n">XFS_ATTR_SF_ENTSIZE_BYNAME</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>

	<span class="n">forkoff</span> <span class="o">=</span> <span class="n">xfs_attr_shortform_bytesfit</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">forkoff</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSPC</span><span class="p">));</span>

	<span class="n">xfs_attr_shortform_add</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">forkoff</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*========================================================================</span>
<span class="cm"> * External routines when attribute list is one block</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Add a name to the leaf attribute list structure</span>
<span class="cm"> *</span>
<span class="cm"> * This leaf block cannot have a &quot;remote&quot; value, we only call this routine</span>
<span class="cm"> * if bmap_one_block() says there is only one block (ie: no remote blks).</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_attr_leaf_addname</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">committed</span><span class="p">,</span> <span class="n">forkoff</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_leaf_addname</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the (only) block in the attribute list in.</span>
<span class="cm">	 */</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span>
					     <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look up the given attribute in the leaf block.  Figure out if</span>
<span class="cm">	 * the given flags produce an error or call for an atomic rename.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_lookup_int</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_REPLACE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">ENOATTR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_CREATE</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* pure create op */</span>
			<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">trace_xfs_attr_leaf_replace</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

		<span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">|=</span> <span class="n">XFS_DA_OP_RENAME</span><span class="p">;</span>	<span class="cm">/* an atomic rename */</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno2</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">;</span>		<span class="cm">/* set 2nd entry info*/</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno2</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt2</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add the attribute to the leaf block, transitioning to a Btree</span>
<span class="cm">	 * if required.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_add</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Promote the attribute list to the Btree format, then</span>
<span class="cm">		 * Commit that transaction so that the node_addname() call</span>
<span class="cm">		 * can manage its own transactions.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_to_node</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">committed</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * bmap_finish() may have committed the last trans and started</span>
<span class="cm">		 * a new one.  We need the inode to be in all transactions.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">committed</span><span class="p">)</span>
			<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Commit the current trans (including the inode) and start</span>
<span class="cm">		 * a new one.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Fob the whole rest of the problem off on the Btree code.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_node_addname</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Commit the transaction that added the attr name so that</span>
<span class="cm">	 * later routines can manage their own transactions.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there was an out-of-line value, allocate the blocks we</span>
<span class="cm">	 * identified for its storage and copy the value.  This is done</span>
<span class="cm">	 * after we create the attribute so that we don&#39;t overflow the</span>
<span class="cm">	 * maximum size of a transaction and/or hit a deadlock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_rmtval_set</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is an atomic rename operation, we must &quot;flip&quot; the</span>
<span class="cm">	 * incomplete flags on the &quot;new&quot; and &quot;old&quot; attribute/value pairs</span>
<span class="cm">	 * so that one disappears and one appears atomically.  Then we</span>
<span class="cm">	 * must remove the &quot;old&quot; attribute/value pair.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_RENAME</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In a separate transaction, set the incomplete flag on the</span>
<span class="cm">		 * &quot;old&quot; attr and clear the incomplete flag on the &quot;new&quot; attr.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_flipflags</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Dismantle the &quot;old&quot; attribute/value pair by removing</span>
<span class="cm">		 * a &quot;remote&quot; value (if it exists).</span>
<span class="cm">		 */</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno2</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno2</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_rmtval_remove</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Read in the block containing the &quot;old&quot; attr, then</span>
<span class="cm">		 * remove the &quot;old&quot; attr from that block (neat, huh!)</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">xfs_attr_leaf_remove</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the result is small enough, shrink it all into the inode.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">forkoff</span> <span class="o">=</span> <span class="n">xfs_attr_shortform_allfit</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">dp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_to_shortform</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">forkoff</span><span class="p">);</span>
			<span class="cm">/* bp is gone due to xfs_da_shrink_inode */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span>
							<span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">committed</span><span class="p">);</span>
				<span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * bmap_finish() may have committed the last trans</span>
<span class="cm">			 * and started a new one.  We need the inode to be</span>
<span class="cm">			 * in all transactions.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">committed</span><span class="p">)</span>
				<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Commit the remove and start the next trans in series.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Added a &quot;remote&quot; value, just clear the incomplete flag.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_clearflag</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a name from the leaf attribute list structure</span>
<span class="cm"> *</span>
<span class="cm"> * This leaf block cannot have a &quot;remote&quot; value, we only call this routine</span>
<span class="cm"> * if bmap_one_block() says there is only one block (ie: no remote blks).</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_attr_leaf_removename</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">committed</span><span class="p">,</span> <span class="n">forkoff</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_leaf_removename</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove the attribute.</span>
<span class="cm">	 */</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span>
					     <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_lookup_int</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ENOATTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">xfs_attr_leaf_remove</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the result is small enough, shrink it all into the inode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">forkoff</span> <span class="o">=</span> <span class="n">xfs_attr_shortform_allfit</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">dp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_to_shortform</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">forkoff</span><span class="p">);</span>
		<span class="cm">/* bp is gone due to xfs_da_shrink_inode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">committed</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * bmap_finish() may have committed the last trans and started</span>
<span class="cm">		 * a new one.  We need the inode to be in all transactions.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">committed</span><span class="p">)</span>
			<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up a name in a leaf attribute list structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This leaf block cannot have a &quot;remote&quot; value, we only call this routine</span>
<span class="cm"> * if bmap_one_block() says there is only one block (ie: no remote blks).</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_attr_leaf_get</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span>
					     <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_lookup_int</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">EEXIST</span><span class="p">)</span>  <span class="p">{</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_getvalue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_KERNOVAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_rmtval_get</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy out attribute entries for attr_list(), for leaf attribute lists.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_attr_leaf_list</span><span class="p">(</span><span class="n">xfs_attr_list_context_t</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="n">context</span><span class="o">-&gt;</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_attr_leaf_list&quot;</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
				     <span class="n">context</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_list_int</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
	<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*========================================================================</span>
<span class="cm"> * External routines when attribute list size &gt; XFS_LBSIZE(mp).</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Add a name to a Btree-format attribute list.</span>
<span class="cm"> *</span>
<span class="cm"> * This will involve walking down the Btree, and may involve splitting</span>
<span class="cm"> * leaf nodes and even splitting intermediate nodes up to and including</span>
<span class="cm"> * the root node (a special case of an intermediate node).</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;Remote&quot; attribute values confuse the issue and atomic rename operations</span>
<span class="cm"> * add a whole extra layer of confusion on top of that.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_attr_node_addname</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
	<span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">committed</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_node_addname</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in bucket of arguments/results/context to carry around.</span>
<span class="cm">	 */</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
<span class="nl">restart:</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">xfs_da_state_alloc</span><span class="p">();</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">node_ents</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_attr_node_ents</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search to see if name already exists, and get back a pointer</span>
<span class="cm">	 * to where it should go.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_node_lookup_int</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="o">-</span><span class="mi">1</span> <span class="p">];</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_REPLACE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">ENOATTR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_CREATE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">trace_xfs_attr_node_replace</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

		<span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">|=</span> <span class="n">XFS_DA_OP_RENAME</span><span class="p">;</span>	<span class="cm">/* atomic rename op */</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno2</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">;</span>		<span class="cm">/* set 2nd entry info*/</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno2</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt2</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_add</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Its really a single leaf node, but it had</span>
<span class="cm">			 * out-of-line values so it looked like it *might*</span>
<span class="cm">			 * have been a b-tree.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_da_state_free</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
			<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_to_node</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span>
							<span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">committed</span><span class="p">);</span>
				<span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * bmap_finish() may have committed the last trans</span>
<span class="cm">			 * and started a new one.  We need the inode to be</span>
<span class="cm">			 * in all transactions.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">committed</span><span class="p">)</span>
				<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Commit the node conversion and start the next</span>
<span class="cm">			 * trans in the chain.</span>
<span class="cm">			 */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Split as many Btree elements as required.</span>
<span class="cm">		 * This code tracks the new and old attr&#39;s location</span>
<span class="cm">		 * in the index/blkno/rmtblkno/rmtblkcnt fields and</span>
<span class="cm">		 * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_split</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">committed</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * bmap_finish() may have committed the last trans and started</span>
<span class="cm">		 * a new one.  We need the inode to be in all transactions.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">committed</span><span class="p">)</span>
			<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Addition succeeded, update Btree hashvals.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_da_fixhashpath</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Kill the state structure, we&#39;re done with it and need to</span>
<span class="cm">	 * allow the buffers to come back later.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_da_state_free</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="n">state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Commit the leaf addition or btree split and start the next</span>
<span class="cm">	 * trans in the chain.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there was an out-of-line value, allocate the blocks we</span>
<span class="cm">	 * identified for its storage and copy the value.  This is done</span>
<span class="cm">	 * after we create the attribute so that we don&#39;t overflow the</span>
<span class="cm">	 * maximum size of a transaction and/or hit a deadlock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_rmtval_set</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is an atomic rename operation, we must &quot;flip&quot; the</span>
<span class="cm">	 * incomplete flags on the &quot;new&quot; and &quot;old&quot; attribute/value pairs</span>
<span class="cm">	 * so that one disappears and one appears atomically.  Then we</span>
<span class="cm">	 * must remove the &quot;old&quot; attribute/value pair.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_RENAME</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In a separate transaction, set the incomplete flag on the</span>
<span class="cm">		 * &quot;old&quot; attr and clear the incomplete flag on the &quot;new&quot; attr.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_flipflags</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Dismantle the &quot;old&quot; attribute/value pair by removing</span>
<span class="cm">		 * a &quot;remote&quot; value (if it exists).</span>
<span class="cm">		 */</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno2</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno2</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_rmtval_remove</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Re-find the &quot;old&quot; attribute entry after any split ops.</span>
<span class="cm">		 * The INCOMPLETE flag means that we will find the &quot;old&quot;</span>
<span class="cm">		 * attr, not the &quot;new&quot; one.</span>
<span class="cm">		 */</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">;</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">xfs_da_state_alloc</span><span class="p">();</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">node_ents</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_attr_node_ents</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_node_lookup_int</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Remove the name and update the hashvals in the tree.</span>
<span class="cm">		 */</span>
		<span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="o">-</span><span class="mi">1</span> <span class="p">];</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_remove</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
		<span class="n">xfs_da_fixhashpath</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check to see if the tree needs to be collapsed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_join</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span>
							<span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">committed</span><span class="p">);</span>
				<span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * bmap_finish() may have committed the last trans</span>
<span class="cm">			 * and started a new one.  We need the inode to be</span>
<span class="cm">			 * in all transactions.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">committed</span><span class="p">)</span>
				<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Commit and start the next trans in the chain.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Added a &quot;remote&quot; value, just clear the incomplete flag.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_clearflag</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span>
		<span class="n">xfs_da_state_free</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a name from a B-tree attribute list.</span>
<span class="cm"> *</span>
<span class="cm"> * This will involve walking down the Btree, and may involve joining</span>
<span class="cm"> * leaf nodes and even joining intermediate nodes up to and including</span>
<span class="cm"> * the root node (a special case of an intermediate node).</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_attr_node_removename</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
	<span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">committed</span><span class="p">,</span> <span class="n">forkoff</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_node_removename</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tie a string around our finger to remind us where we are.</span>
<span class="cm">	 */</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">xfs_da_state_alloc</span><span class="p">();</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">node_ents</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_attr_node_ents</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search to see if name exists, and get back a pointer to it.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_node_lookup_int</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">||</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">EEXIST</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is an out-of-line value, de-allocate the blocks.</span>
<span class="cm">	 * This is done before we remove the attribute so that we don&#39;t</span>
<span class="cm">	 * overflow the maximum size of a transaction and/or hit a deadlock.</span>
<span class="cm">	 */</span>
	<span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="o">-</span><span class="mi">1</span> <span class="p">];</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Fill in disk block numbers in the state structure</span>
<span class="cm">		 * so that we can get the buffers back after we commit</span>
<span class="cm">		 * several transactions in the following calls.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_fillstate</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Mark the attribute as INCOMPLETE, then bunmapi() the</span>
<span class="cm">		 * remote value.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_setflag</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_rmtval_remove</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Refill the state structure with buffers, the prior calls</span>
<span class="cm">		 * released our buffers.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_refillstate</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove the name and update the hashvals in the tree.</span>
<span class="cm">	 */</span>
	<span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="o">-</span><span class="mi">1</span> <span class="p">];</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_remove</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">xfs_da_fixhashpath</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check to see if the tree needs to be collapsed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_join</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">committed</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * bmap_finish() may have committed the last trans and started</span>
<span class="cm">		 * a new one.  We need the inode to be in all transactions.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">committed</span><span class="p">)</span>
			<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Commit the Btree join operation and start a new trans.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the result is small enough, push it all into the inode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_bmap_one_block</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Have to get rid of the copy of this dabuf in the state.</span>
<span class="cm">		 */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span>
						     <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">((((</span><span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span><span class="p">)</span> <span class="o">==</span>
		       <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">forkoff</span> <span class="o">=</span> <span class="n">xfs_attr_shortform_allfit</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">dp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_to_shortform</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">forkoff</span><span class="p">);</span>
			<span class="cm">/* bp is gone due to xfs_da_shrink_inode */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span>
							<span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">committed</span><span class="p">);</span>
				<span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * bmap_finish() may have committed the last trans</span>
<span class="cm">			 * and started a new one.  We need the inode to be</span>
<span class="cm">			 * in all transactions.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">committed</span><span class="p">)</span>
				<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">xfs_da_state_free</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fill in the disk block numbers in the state structure for the buffers</span>
<span class="cm"> * that are attached to the state structure.</span>
<span class="cm"> * This is done so that we can quickly reattach ourselves to those buffers</span>
<span class="cm"> * after some set of transaction commits have released these buffers.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_attr_fillstate</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_state_path_t</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Roll down the &quot;path&quot; in the state structure, storing the on-disk</span>
<span class="cm">	 * block number for those buffers in the &quot;path&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">path</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">&lt;</span> <span class="n">XFS_DA_NODE_MAXDEPTH</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">blk</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span> <span class="n">blk</span><span class="o">++</span><span class="p">,</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">disk_blkno</span> <span class="o">=</span> <span class="n">xfs_da_blkno</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">disk_blkno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Roll down the &quot;altpath&quot; in the state structure, storing the on-disk</span>
<span class="cm">	 * block number for those buffers in the &quot;altpath&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">path</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">&lt;</span> <span class="n">XFS_DA_NODE_MAXDEPTH</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">blk</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span> <span class="n">blk</span><span class="o">++</span><span class="p">,</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">disk_blkno</span> <span class="o">=</span> <span class="n">xfs_da_blkno</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">disk_blkno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reattach the buffers to the state structure based on the disk block</span>
<span class="cm"> * numbers stored in the state structure.</span>
<span class="cm"> * This is done after some set of transaction commits have released those</span>
<span class="cm"> * buffers from our grip.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_attr_refillstate</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_state_path_t</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Roll down the &quot;path&quot; in the state structure, storing the on-disk</span>
<span class="cm">	 * block number for those buffers in the &quot;path&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">path</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">&lt;</span> <span class="n">XFS_DA_NODE_MAXDEPTH</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">blk</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span> <span class="n">blk</span><span class="o">++</span><span class="p">,</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">disk_blkno</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span>
						<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span>
						<span class="n">blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">disk_blkno</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Roll down the &quot;altpath&quot; in the state structure, storing the on-disk</span>
<span class="cm">	 * block number for those buffers in the &quot;altpath&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">path</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">&lt;</span> <span class="n">XFS_DA_NODE_MAXDEPTH</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">blk</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span> <span class="n">blk</span><span class="o">++</span><span class="p">,</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">disk_blkno</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span>
						<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span>
						<span class="n">blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">disk_blkno</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up a filename in a node attribute list.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine gets called for any attribute fork that has more than one</span>
<span class="cm"> * block, ie: both true Btree attr lists and for single-leaf-blocks with</span>
<span class="cm"> * &quot;remote&quot; values taking up more blocks.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_attr_node_get</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
	<span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">xfs_da_state_alloc</span><span class="p">();</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">node_ents</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_attr_node_ents</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search to see if name exists, and get back a pointer to it.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_node_lookup_int</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="o">-</span><span class="mi">1</span> <span class="p">];</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get the value, local or &quot;remote&quot;</span>
<span class="cm">		 */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_getvalue</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_KERNOVAL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">xfs_attr_rmtval_get</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If not in a transaction, we have to release all the buffers.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_da_state_free</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>							<span class="cm">/* error */</span>
<span class="n">xfs_attr_node_list</span><span class="p">(</span><span class="n">xfs_attr_list_context_t</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">attrlist_cursor_kern_t</span> <span class="o">*</span><span class="n">cursor</span><span class="p">;</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">xfs_da_node_entry_t</span> <span class="o">*</span><span class="n">btree</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="n">cursor</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">cursor</span><span class="p">;</span>
	<span class="n">cursor</span><span class="o">-&gt;</span><span class="n">initted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do all sorts of validation on the passed-in cursor structure.</span>
<span class="cm">	 * If anything is amiss, ignore the cursor and look up the hashval</span>
<span class="cm">	 * starting from the btree root.</span>
<span class="cm">	 */</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">EFSCORRUPTED</span><span class="p">))</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">XFS_DA_NODE_MAGIC</span>:
				<span class="n">trace_xfs_attr_list_wrong_blk</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
				<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
				<span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span>:
				<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">&gt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span>
				    <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">trace_xfs_attr_list_wrong_blk</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
					<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
					<span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">&lt;=</span>
					     <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hashval</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">trace_xfs_attr_list_wrong_blk</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
					<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
					<span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">trace_xfs_attr_list_wrong_blk</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
				<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
				<span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We did not find what we expected given the cursor&#39;s contents,</span>
<span class="cm">	 * so we start from the top and work down based on the hash value.</span>
<span class="cm">	 * Note that start of node block is same as start of leaf block.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cursor</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span>
						      <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span>
						      <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_attr_node_list(2)&quot;</span><span class="p">,</span>
						 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
						 <span class="n">context</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span>
			    <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">!=</span>
				     <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_attr_node_list(3)&quot;</span><span class="p">,</span>
						     <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
						     <span class="n">context</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
						     <span class="n">node</span><span class="p">);</span>
				<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">btree</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
								<span class="n">btree</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">hashval</span>
						<span class="o">&lt;=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">cursor</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">before</span><span class="p">);</span>
					<span class="n">trace_xfs_attr_list_node_descend</span><span class="p">(</span><span class="n">context</span><span class="p">,</span>
									 <span class="n">btree</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
				<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Roll upward through the blocks, processing each leaf block in</span>
<span class="cm">	 * order.  As long as there is space in the result buffer, keep</span>
<span class="cm">	 * adding the information.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">!=</span>
			     <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_attr_node_list(4)&quot;</span><span class="p">,</span>
					     <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
					     <span class="n">context</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
			<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_list_int</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">seen_enough</span> <span class="o">||</span> <span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">forw</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cursor</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">forw</span><span class="p">);</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">bp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_attr_node_list(5)&quot;</span><span class="p">,</span>
					 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
					 <span class="n">context</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*========================================================================</span>
<span class="cm"> * External routines for manipulating out-of-line attribute values.</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Read the value associated with an attribute from the out-of-line buffer</span>
<span class="cm"> * that we stored it in.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xfs_attr_rmtval_get</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_bmbt_irec_t</span> <span class="n">map</span><span class="p">[</span><span class="n">ATTR_RMTVALUE_MAPSIZE</span><span class="p">];</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span> <span class="n">dblkno</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nmap</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">,</span> <span class="n">blkcnt</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_dablk_t</span> <span class="n">lblkno</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_KERNOVAL</span><span class="p">));</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">dst</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
	<span class="n">valuelen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">;</span>
	<span class="n">lblkno</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">valuelen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nmap</span> <span class="o">=</span> <span class="n">ATTR_RMTVALUE_MAPSIZE</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_fileoff_t</span><span class="p">)</span><span class="n">lblkno</span><span class="p">,</span>
				       <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmap</span><span class="p">,</span>
				       <span class="n">XFS_BMAPI_ATTRFORK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nmap</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nmap</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">valuelen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">((</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			       <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">HOLESTARTBLOCK</span><span class="p">));</span>
			<span class="n">dblkno</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_startblock</span><span class="p">);</span>
			<span class="n">blkcnt</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_blockcount</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_read_buf</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span>
						   <span class="n">dblkno</span><span class="p">,</span> <span class="n">blkcnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

			<span class="n">tmp</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">,</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">));</span>
			<span class="n">xfs_buf_iomove</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">XBRW_READ</span><span class="p">);</span>
			<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">dst</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">valuelen</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>

			<span class="n">lblkno</span> <span class="o">+=</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_blockcount</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">valuelen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write the value associated with an attribute into the out-of-line buffer</span>
<span class="cm"> * that we have defined for it.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_attr_rmtval_set</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span> <span class="n">lfileoff</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">xfs_bmbt_irec_t</span> <span class="n">map</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span> <span class="n">dblkno</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_dablk_t</span> <span class="n">lblkno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blkcnt</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">,</span> <span class="n">nmap</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">committed</span><span class="p">;</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">src</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find a &quot;hole&quot; in the attribute address space large enough for</span>
<span class="cm">	 * us to drop the new attribute&#39;s value into.</span>
<span class="cm">	 */</span>
	<span class="n">blkcnt</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>
	<span class="n">lfileoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_first_unused</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">blkcnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lfileoff</span><span class="p">,</span>
						   <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span> <span class="o">=</span> <span class="n">lblkno</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dablk_t</span><span class="p">)</span><span class="n">lfileoff</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt</span> <span class="o">=</span> <span class="n">blkcnt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Roll through the &quot;value&quot;, allocating blocks on disk as required.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">blkcnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allocate a single extent, up to the size of the value.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">);</span>
		<span class="n">nmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_write</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_fileoff_t</span><span class="p">)</span><span class="n">lblkno</span><span class="p">,</span>
				  <span class="n">blkcnt</span><span class="p">,</span>
				  <span class="n">XFS_BMAPI_ATTRFORK</span> <span class="o">|</span> <span class="n">XFS_BMAPI_METADATA</span><span class="p">,</span>
				  <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">total</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmap</span><span class="p">,</span>
				  <span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">committed</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * bmap_finish() may have committed the last trans and started</span>
<span class="cm">		 * a new one.  We need the inode to be in all transactions.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">committed</span><span class="p">)</span>
			<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nmap</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">((</span><span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">HOLESTARTBLOCK</span><span class="p">));</span>
		<span class="n">lblkno</span> <span class="o">+=</span> <span class="n">map</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">;</span>
		<span class="n">blkcnt</span> <span class="o">-=</span> <span class="n">map</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Start the next trans in the chain.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Roll through the &quot;value&quot;, copying the attribute value to the</span>
<span class="cm">	 * already-allocated blocks.  Blocks are written synchronously</span>
<span class="cm">	 * so that we can know they are all on disk before we turn off</span>
<span class="cm">	 * the INCOMPLETE flag.</span>
<span class="cm">	 */</span>
	<span class="n">lblkno</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span><span class="p">;</span>
	<span class="n">valuelen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">valuelen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">buflen</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Try to remember where we decided to put the value.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">);</span>
		<span class="n">nmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_fileoff_t</span><span class="p">)</span><span class="n">lblkno</span><span class="p">,</span>
				       <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmap</span><span class="p">,</span>
				       <span class="n">XFS_BMAPI_ATTRFORK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nmap</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">((</span><span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">HOLESTARTBLOCK</span><span class="p">));</span>

		<span class="n">dblkno</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span><span class="p">),</span>
		<span class="n">blkcnt</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">);</span>

		<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_get</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span> <span class="n">dblkno</span><span class="p">,</span> <span class="n">blkcnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">buflen</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
		<span class="n">xfs_buf_iomove</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">XBRW_WRITE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">buflen</span><span class="p">)</span>
			<span class="n">xfs_buf_zero</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">buflen</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">);</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bwrite</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>	<span class="cm">/* GROT: NOTE: synchronous write */</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">src</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">valuelen</span> <span class="o">-=</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="n">lblkno</span> <span class="o">+=</span> <span class="n">map</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">valuelen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove the value associated with an attribute by deleting the</span>
<span class="cm"> * out-of-line buffer that it is stored on.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_attr_rmtval_remove</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_bmbt_irec_t</span> <span class="n">map</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span> <span class="n">dblkno</span><span class="p">;</span>
	<span class="n">xfs_dablk_t</span> <span class="n">lblkno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">valuelen</span><span class="p">,</span> <span class="n">blkcnt</span><span class="p">,</span> <span class="n">nmap</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">committed</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Roll through the &quot;value&quot;, invalidating the attribute value&#39;s</span>
<span class="cm">	 * blocks.</span>
<span class="cm">	 */</span>
	<span class="n">lblkno</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span><span class="p">;</span>
	<span class="n">valuelen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">valuelen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Try to remember where we decided to put the value.</span>
<span class="cm">		 */</span>
		<span class="n">nmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_fileoff_t</span><span class="p">)</span><span class="n">lblkno</span><span class="p">,</span>
				       <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmap</span><span class="p">,</span>
				       <span class="n">XFS_BMAPI_ATTRFORK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nmap</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">((</span><span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">HOLESTARTBLOCK</span><span class="p">));</span>

		<span class="n">dblkno</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span><span class="p">),</span>
		<span class="n">blkcnt</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the &quot;remote&quot; value is in the cache, remove it.</span>
<span class="cm">		 */</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_incore</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span> <span class="n">dblkno</span><span class="p">,</span> <span class="n">blkcnt</span><span class="p">,</span> <span class="n">XBF_TRYLOCK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_buf_stale</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">valuelen</span> <span class="o">-=</span> <span class="n">map</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">;</span>

		<span class="n">lblkno</span> <span class="o">+=</span> <span class="n">map</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Keep de-allocating extents until the remote-value region is gone.</span>
<span class="cm">	 */</span>
	<span class="n">lblkno</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span><span class="p">;</span>
	<span class="n">blkcnt</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt</span><span class="p">;</span>
	<span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bunmapi</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">lblkno</span><span class="p">,</span> <span class="n">blkcnt</span><span class="p">,</span>
				    <span class="n">XFS_BMAPI_ATTRFORK</span> <span class="o">|</span> <span class="n">XFS_BMAPI_METADATA</span><span class="p">,</span>
				    <span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">committed</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * bmap_finish() may have committed the last trans and started</span>
<span class="cm">		 * a new one.  We need the inode to be in all transactions.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">committed</span><span class="p">)</span>
			<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Close out trans and start the next one in the chain.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
