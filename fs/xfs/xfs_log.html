<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_log.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_log.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_log_priv.h&quot;</span>
<span class="cp">#include &quot;xfs_buf_item.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_ialloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_log_recover.h&quot;</span>
<span class="cp">#include &quot;xfs_trans_priv.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>

<span class="n">kmem_zone_t</span>	<span class="o">*</span><span class="n">xfs_log_ticket_zone</span><span class="p">;</span>

<span class="cm">/* Local miscellaneous function prototypes */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xlog_commit_record</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">ticket</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">**</span><span class="n">iclog</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>		<span class="o">*</span><span class="n">commitlsnp</span><span class="p">);</span>

<span class="n">STATIC</span> <span class="n">xlog_t</span> <span class="o">*</span>  <span class="n">xlog_alloc_log</span><span class="p">(</span><span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
				<span class="n">xfs_buftarg_t</span>	<span class="o">*</span><span class="n">log_target</span><span class="p">,</span>
				<span class="n">xfs_daddr_t</span>	<span class="n">blk_offset</span><span class="p">,</span>
				<span class="kt">int</span>		<span class="n">num_bblks</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xlog_space_left</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">atomic64_t</span>		<span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span>	 <span class="n">xlog_sync</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">xlog_in_core_t</span> <span class="o">*</span><span class="n">iclog</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span>	 <span class="n">xlog_dealloc_log</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="n">log</span><span class="p">);</span>

<span class="cm">/* local state machine functions */</span>
<span class="n">STATIC</span> <span class="kt">void</span> <span class="n">xlog_state_done_syncing</span><span class="p">(</span><span class="n">xlog_in_core_t</span> <span class="o">*</span><span class="n">iclog</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span> <span class="n">xlog_state_do_callback</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span><span class="kt">int</span> <span class="n">aborted</span><span class="p">,</span> <span class="n">xlog_in_core_t</span> <span class="o">*</span><span class="n">iclog</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span>  <span class="n">xlog_state_get_iclog_space</span><span class="p">(</span><span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
				       <span class="kt">int</span>		<span class="n">len</span><span class="p">,</span>
				       <span class="n">xlog_in_core_t</span>	<span class="o">**</span><span class="n">iclog</span><span class="p">,</span>
				       <span class="n">xlog_ticket_t</span>	<span class="o">*</span><span class="n">ticket</span><span class="p">,</span>
				       <span class="kt">int</span>		<span class="o">*</span><span class="n">continued_write</span><span class="p">,</span>
				       <span class="kt">int</span>		<span class="o">*</span><span class="n">logoffsetp</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span>  <span class="n">xlog_state_release_iclog</span><span class="p">(</span><span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
				     <span class="n">xlog_in_core_t</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span> <span class="n">xlog_state_switch_iclogs</span><span class="p">(</span><span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
				     <span class="n">xlog_in_core_t</span> <span class="o">*</span><span class="n">iclog</span><span class="p">,</span>
				     <span class="kt">int</span>		<span class="n">eventual_size</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span> <span class="n">xlog_state_want_sync</span><span class="p">(</span><span class="n">xlog_t</span>	<span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">xlog_in_core_t</span> <span class="o">*</span><span class="n">iclog</span><span class="p">);</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="n">xlog_grant_push_ail</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">need_bytes</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span> <span class="n">xlog_regrant_reserve_log_space</span><span class="p">(</span><span class="n">xlog_t</span>	 <span class="o">*</span><span class="n">log</span><span class="p">,</span>
					   <span class="n">xlog_ticket_t</span> <span class="o">*</span><span class="n">ticket</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span> <span class="n">xlog_ungrant_log_space</span><span class="p">(</span><span class="n">xlog_t</span>	 <span class="o">*</span><span class="n">log</span><span class="p">,</span>
				   <span class="n">xlog_ticket_t</span> <span class="o">*</span><span class="n">ticket</span><span class="p">);</span>

<span class="cp">#if defined(DEBUG)</span>
<span class="n">STATIC</span> <span class="kt">void</span>	<span class="n">xlog_verify_dest_ptr</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="n">xlog_verify_grant_tail</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span>	<span class="n">xlog_verify_iclog</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">xlog_in_core_t</span> <span class="o">*</span><span class="n">iclog</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">boolean_t</span> <span class="n">syncing</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span>	<span class="n">xlog_verify_tail_lsn</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">xlog_in_core_t</span> <span class="o">*</span><span class="n">iclog</span><span class="p">,</span>
				     <span class="n">xfs_lsn_t</span> <span class="n">tail_lsn</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define xlog_verify_dest_ptr(a,b)</span>
<span class="cp">#define xlog_verify_grant_tail(a)</span>
<span class="cp">#define xlog_verify_iclog(a,b,c,d)</span>
<span class="cp">#define xlog_verify_tail_lsn(a,b,c)</span>
<span class="cp">#endif</span>

<span class="n">STATIC</span> <span class="kt">int</span>	<span class="n">xlog_iclogs_empty</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="n">log</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xlog_grant_sub_space</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">atomic64_t</span>		<span class="o">*</span><span class="n">head</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int64_t</span>	<span class="n">head_val</span> <span class="o">=</span> <span class="n">atomic64_read</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
	<span class="kt">int64_t</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">cycle</span><span class="p">,</span> <span class="n">space</span><span class="p">;</span>

		<span class="n">xlog_crack_grant_head_val</span><span class="p">(</span><span class="n">head_val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cycle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">space</span><span class="p">);</span>

		<span class="n">space</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">space</span> <span class="o">+=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logsize</span><span class="p">;</span>
			<span class="n">cycle</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">old</span> <span class="o">=</span> <span class="n">head_val</span><span class="p">;</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">xlog_assign_grant_head_val</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">space</span><span class="p">);</span>
		<span class="n">head_val</span> <span class="o">=</span> <span class="n">atomic64_cmpxchg</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">head_val</span> <span class="o">!=</span> <span class="n">old</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xlog_grant_add_space</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">atomic64_t</span>		<span class="o">*</span><span class="n">head</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int64_t</span>	<span class="n">head_val</span> <span class="o">=</span> <span class="n">atomic64_read</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
	<span class="kt">int64_t</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span>		<span class="n">tmp</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">cycle</span><span class="p">,</span> <span class="n">space</span><span class="p">;</span>

		<span class="n">xlog_crack_grant_head_val</span><span class="p">(</span><span class="n">head_val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cycle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">space</span><span class="p">);</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logsize</span> <span class="o">-</span> <span class="n">space</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">bytes</span><span class="p">)</span>
			<span class="n">space</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">space</span> <span class="o">=</span> <span class="n">bytes</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">cycle</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">old</span> <span class="o">=</span> <span class="n">head_val</span><span class="p">;</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">xlog_assign_grant_head_val</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">space</span><span class="p">);</span>
		<span class="n">head_val</span> <span class="o">=</span> <span class="n">atomic64_cmpxchg</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">head_val</span> <span class="o">!=</span> <span class="n">old</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_grant_head_init</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog_grant_head</span>	<span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_assign_grant_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">grant</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">waiters</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_grant_head_wake_all</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog_grant_head</span>	<span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">tic</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tic</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">waiters</span><span class="p">,</span> <span class="n">t_queue</span><span class="p">)</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_task</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xlog_ticket_reservation</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_grant_head</span>	<span class="o">*</span><span class="n">head</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">tic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_TIC_PERM_RESERV</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_unit_res</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_TIC_PERM_RESERV</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_unit_res</span> <span class="o">*</span> <span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_cnt</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_unit_res</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="n">bool</span>
<span class="nf">xlog_grant_head_wake</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_grant_head</span>	<span class="o">*</span><span class="n">head</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">free_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">tic</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">need_bytes</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tic</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">waiters</span><span class="p">,</span> <span class="n">t_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">need_bytes</span> <span class="o">=</span> <span class="n">xlog_ticket_reservation</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tic</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">free_bytes</span> <span class="o">&lt;</span> <span class="n">need_bytes</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="o">*</span><span class="n">free_bytes</span> <span class="o">-=</span> <span class="n">need_bytes</span><span class="p">;</span>
		<span class="n">trace_xfs_log_grant_wake_up</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tic</span><span class="p">);</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_task</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_grant_head_wait</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_grant_head</span>	<span class="o">*</span><span class="n">head</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">tic</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">need_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">waiters</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">XLOG_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">log</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">shutdown</span><span class="p">;</span>
		<span class="n">xlog_grant_push_ail</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">need_bytes</span><span class="p">);</span>

		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_sleep_logspace</span><span class="p">);</span>

		<span class="n">trace_xfs_log_grant_sleep</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tic</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">trace_xfs_log_grant_wake</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tic</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">XLOG_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">log</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">shutdown</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">xlog_space_left</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">grant</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">need_bytes</span><span class="p">);</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_queue</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">shutdown:</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_queue</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Atomically get the log space required for a log ticket.</span>
<span class="cm"> *</span>
<span class="cm"> * Once a ticket gets put onto head-&gt;waiters, it will only return after the</span>
<span class="cm"> * needed reservation is satisfied.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is structured so that it has a lock free fast path. This is</span>
<span class="cm"> * necessary because every new transaction reservation will come through this</span>
<span class="cm"> * path. Hence any lock will be globally hot if we take it unconditionally on</span>
<span class="cm"> * every pass.</span>
<span class="cm"> *</span>
<span class="cm"> * As tickets are only ever moved on and off head-&gt;waiters under head-&gt;lock, we</span>
<span class="cm"> * only need to take that lock if we are going to add the ticket to the queue</span>
<span class="cm"> * and sleep. We can avoid taking the lock if the ticket was never added to</span>
<span class="cm"> * head-&gt;waiters because the t_queue list head will be empty and we hold the</span>
<span class="cm"> * only reference to it so it can safely be checked unlocked.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_grant_head_check</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_grant_head</span>	<span class="o">*</span><span class="n">head</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">tic</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">need_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">free_bytes</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_ACTIVE_RECOVERY</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are other waiters on the queue then give them a chance at</span>
<span class="cm">	 * logspace before us.  Wake up the first waiters, if we do not wake</span>
<span class="cm">	 * up all the waiters then go to sleep waiting for more free space,</span>
<span class="cm">	 * otherwise try to get some space for this transaction.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">need_bytes</span> <span class="o">=</span> <span class="n">xlog_ticket_reservation</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tic</span><span class="p">);</span>
	<span class="n">free_bytes</span> <span class="o">=</span> <span class="n">xlog_space_left</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">grant</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty_careful</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">waiters</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xlog_grant_head_wake</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_bytes</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">free_bytes</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">need_bytes</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_grant_head_wait</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tic</span><span class="p">,</span>
						     <span class="o">*</span><span class="n">need_bytes</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">free_bytes</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">need_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_grant_head_wait</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tic</span><span class="p">,</span> <span class="o">*</span><span class="n">need_bytes</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xlog_tic_reset_res</span><span class="p">(</span><span class="n">xlog_ticket_t</span> <span class="o">*</span><span class="n">tic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_res_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_res_arr_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_res_num_ophdrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xlog_tic_add_region</span><span class="p">(</span><span class="n">xlog_ticket_t</span> <span class="o">*</span><span class="n">tic</span><span class="p">,</span> <span class="n">uint</span> <span class="n">len</span><span class="p">,</span> <span class="n">uint</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_res_num</span> <span class="o">==</span> <span class="n">XLOG_TIC_LEN_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* add to overflow and start again */</span>
		<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_res_o_flow</span> <span class="o">+=</span> <span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_res_arr_sum</span><span class="p">;</span>
		<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_res_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_res_arr_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_res_arr</span><span class="p">[</span><span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_res_num</span><span class="p">].</span><span class="n">r_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_res_arr</span><span class="p">[</span><span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_res_num</span><span class="p">].</span><span class="n">r_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_res_arr_sum</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_res_num</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Replenish the byte reservation required by moving the grant write head.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_log_regrant</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">tic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">need_bytes</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XLOG_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">log</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_try_logspace</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a new transaction on the ticket, so we need to change the</span>
<span class="cm">	 * transaction ID so that the next transaction has a different TID in</span>
<span class="cm">	 * the log. Just add one to the existing tid so that we can see chains</span>
<span class="cm">	 * of rolling transactions in the log easily.</span>
<span class="cm">	 */</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="o">++</span><span class="p">;</span>

	<span class="n">xlog_grant_push_ail</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_unit_res</span><span class="p">);</span>

	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">=</span> <span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_unit_res</span><span class="p">;</span>
	<span class="n">xlog_tic_reset_res</span><span class="p">(</span><span class="n">tic</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">trace_xfs_log_regrant</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tic</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_grant_head_check</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">,</span> <span class="n">tic</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">need_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>

	<span class="n">xlog_grant_add_space</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">.</span><span class="n">grant</span><span class="p">,</span> <span class="n">need_bytes</span><span class="p">);</span>
	<span class="n">trace_xfs_log_regrant_exit</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tic</span><span class="p">);</span>
	<span class="n">xlog_verify_grant_tail</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_error:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we are failing, make sure the ticket doesn&#39;t have any current</span>
<span class="cm">	 * reservations.  We don&#39;t want to add this back when the ticket/</span>
<span class="cm">	 * transaction gets cancelled.</span>
<span class="cm">	 */</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* ungrant will give back unit_res * t_cnt. */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reserve log space and return a ticket corresponding the reservation.</span>
<span class="cm"> *</span>
<span class="cm"> * Each reservation is going to reserve extra space for a log record header.</span>
<span class="cm"> * When writes happen to the on-disk log, we don&#39;t subtract the length of the</span>
<span class="cm"> * log record header from any reservation.  By wasting space in each</span>
<span class="cm"> * reservation, we prevent over allocation problems.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_log_reserve</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="kt">int</span>		 	<span class="n">unit_bytes</span><span class="p">,</span>
	<span class="kt">int</span>		 	<span class="n">cnt</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">**</span><span class="n">ticp</span><span class="p">,</span>
	<span class="n">__uint8_t</span>	 	<span class="n">client</span><span class="p">,</span>
	<span class="n">bool</span>			<span class="n">permanent</span><span class="p">,</span>
	<span class="n">uint</span>		 	<span class="n">t_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">tic</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">need_bytes</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">client</span> <span class="o">==</span> <span class="n">XFS_TRANSACTION</span> <span class="o">||</span> <span class="n">client</span> <span class="o">==</span> <span class="n">XFS_LOG</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XLOG_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">log</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_try_logspace</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">*</span><span class="n">ticp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">tic</span> <span class="o">=</span> <span class="n">xlog_ticket_alloc</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">unit_bytes</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">client</span><span class="p">,</span> <span class="n">permanent</span><span class="p">,</span>
				<span class="n">KM_SLEEP</span> <span class="o">|</span> <span class="n">KM_MAYFAIL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tic</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_trans_type</span> <span class="o">=</span> <span class="n">t_type</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ticp</span> <span class="o">=</span> <span class="n">tic</span><span class="p">;</span>

	<span class="n">xlog_grant_push_ail</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_unit_res</span> <span class="o">*</span> <span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_cnt</span><span class="p">);</span>

	<span class="n">trace_xfs_log_reserve</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tic</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_grant_head_check</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">,</span> <span class="n">tic</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">need_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>

	<span class="n">xlog_grant_add_space</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">.</span><span class="n">grant</span><span class="p">,</span> <span class="n">need_bytes</span><span class="p">);</span>
	<span class="n">xlog_grant_add_space</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">.</span><span class="n">grant</span><span class="p">,</span> <span class="n">need_bytes</span><span class="p">);</span>
	<span class="n">trace_xfs_log_reserve_exit</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tic</span><span class="p">);</span>
	<span class="n">xlog_verify_grant_tail</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_error:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we are failing, make sure the ticket doesn&#39;t have any current</span>
<span class="cm">	 * reservations.  We don&#39;t want to add this back when the ticket/</span>
<span class="cm">	 * transaction gets cancelled.</span>
<span class="cm">	 */</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* ungrant will give back unit_res * t_cnt. */</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NOTES:</span>
<span class="cm"> *</span>
<span class="cm"> *	1. currblock field gets updated at startup and after in-core logs</span>
<span class="cm"> *		marked as with WANT_SYNC.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This routine is called when a user of a log manager ticket is done with</span>
<span class="cm"> * the reservation.  If the ticket was ever used, then a commit record for</span>
<span class="cm"> * the associated transaction is written out as a log operation header with</span>
<span class="cm"> * no data.  The flag XLOG_TIC_INITED is set when the first write occurs with</span>
<span class="cm"> * a given ticket.  If the ticket was one with a permanent reservation, then</span>
<span class="cm"> * a few operations are done differently.  Permanent reservation tickets by</span>
<span class="cm"> * default don&#39;t release the reservation.  They just commit the current</span>
<span class="cm"> * transaction with the belief that the reservation is still needed.  A flag</span>
<span class="cm"> * must be passed in before permanent reservations are actually released.</span>
<span class="cm"> * When these type of tickets are not released, they need to be set into</span>
<span class="cm"> * the inited state again.  By doing this, a start record will be written</span>
<span class="cm"> * out when the next write occurs.</span>
<span class="cm"> */</span>
<span class="n">xfs_lsn_t</span>
<span class="nf">xfs_log_done</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">ticket</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">**</span><span class="n">iclog</span><span class="p">,</span>
	<span class="n">uint</span>			<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XLOG_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">log</span><span class="p">)</span> <span class="o">||</span>
	    <span class="cm">/*</span>
<span class="cm">	     * If nothing was ever written, don&#39;t write out commit record.</span>
<span class="cm">	     * If we get an error, just continue and give back the log ticket.</span>
<span class="cm">	     */</span>
	    <span class="p">(((</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_TIC_INITED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">xlog_commit_record</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">ticket</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lsn</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">lsn</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_lsn_t</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_TIC_PERM_RESERV</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_LOG_REL_PERM_RESERV</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">((</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_TIC_PERM_RESERV</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_LOG_REL_PERM_RESERV</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trace_xfs_log_done_nonperm</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">ticket</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Release ticket if not permanent reservation or a specific</span>
<span class="cm">		 * request has been made to release a permanent reservation.</span>
<span class="cm">		 */</span>
		<span class="n">xlog_ungrant_log_space</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">ticket</span><span class="p">);</span>
		<span class="n">xfs_log_ticket_put</span><span class="p">(</span><span class="n">ticket</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">trace_xfs_log_done_perm</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">ticket</span><span class="p">);</span>

		<span class="n">xlog_regrant_reserve_log_space</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">ticket</span><span class="p">);</span>
		<span class="cm">/* If this ticket was a permanent reservation and we aren&#39;t</span>
<span class="cm">		 * trying to release it, reset the inited flags; so next time</span>
<span class="cm">		 * we write, a start record will be written out.</span>
<span class="cm">		 */</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">|=</span> <span class="n">XLOG_TIC_INITED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">lsn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attaches a new iclog I/O completion callback routine during</span>
<span class="cm"> * transaction commit.  If the log is in error state, a non-zero</span>
<span class="cm"> * return code is handed back and the caller is responsible for</span>
<span class="cm"> * executing the callback at an appropriate time.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_log_notify</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">,</span>
	<span class="n">xfs_log_callback_t</span>	<span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">abortflg</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback_lock</span><span class="p">);</span>
	<span class="n">abortflg</span> <span class="o">=</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">abortflg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT_ALWAYS</span><span class="p">((</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_ACTIVE</span><span class="p">)</span> <span class="o">||</span>
			      <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_WANT_SYNC</span><span class="p">));</span>
		<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="o">*</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback_tail</span><span class="p">)</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback_tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_next</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">abortflg</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_log_release_iclog</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xlog_state_release_iclog</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_force_shutdown</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">SHUTDOWN_LOG_IO_ERROR</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mount a log filesystem</span>
<span class="cm"> *</span>
<span class="cm"> * mp		- ubiquitous xfs mount point structure</span>
<span class="cm"> * log_target	- buftarg of on-disk log device</span>
<span class="cm"> * blk_offset	- Start block # where block size is 512 bytes (BBSIZE)</span>
<span class="cm"> * num_bblocks	- Number of BBSIZE blocks in on-disk log</span>
<span class="cm"> *</span>
<span class="cm"> * Return error or zero.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_log_mount</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_buftarg_t</span>	<span class="o">*</span><span class="n">log_target</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">blk_offset</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">num_bblks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_NORECOVERY</span><span class="p">))</span>
		<span class="n">xfs_notice</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;Mounting Filesystem&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">xfs_notice</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
<span class="s">&quot;Mounting filesystem in no-recovery mode.  Filesystem will be inconsistent.&quot;</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RDONLY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span> <span class="o">=</span> <span class="n">xlog_alloc_log</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">log_target</span><span class="p">,</span> <span class="n">blk_offset</span><span class="p">,</span> <span class="n">num_bblks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the AIL now we have a log.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_ail_init</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;AIL initialisation failed: error %d&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_log</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="o">-&gt;</span><span class="n">l_ailp</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * skip log recovery on a norecovery mount.  pretend it all</span>
<span class="cm">	 * just worked.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_NORECOVERY</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">readonly</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RDONLY</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">readonly</span><span class="p">)</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XFS_MOUNT_RDONLY</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">readonly</span><span class="p">)</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">XFS_MOUNT_RDONLY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;log mount/recovery failed: error %d&quot;</span><span class="p">,</span>
				<span class="n">error</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_destroy_ail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Normal transactions can now occur */</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="o">-&gt;</span><span class="n">l_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XLOG_ACTIVE_RECOVERY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now the log has been fully initialised and we know were our</span>
<span class="cm">	 * space grant counters are, we can initialise the permanent ticket</span>
<span class="cm">	 * needed for delayed logging to work.</span>
<span class="cm">	 */</span>
	<span class="n">xlog_cil_init_post_recovery</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_destroy_ail:</span>
	<span class="n">xfs_trans_ail_destroy</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
<span class="nl">out_free_log:</span>
	<span class="n">xlog_dealloc_log</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Finish the recovery of the file system.  This is separate from</span>
<span class="cm"> * the xfs_log_mount() call, because it depends on the code in</span>
<span class="cm"> * xfs_mountfs() to read in the root and real-time bitmap inodes</span>
<span class="cm"> * between calling xfs_log_mount() and here.</span>
<span class="cm"> *</span>
<span class="cm"> * mp		- ubiquitous xfs mount point structure</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_log_mount_finish</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_NORECOVERY</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover_finish</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RDONLY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Final log writes as part of unmount.</span>
<span class="cm"> *</span>
<span class="cm"> * Mark the filesystem clean as unmount happens.  Note that during relocation</span>
<span class="cm"> * this routine needs to be executed as part of source-bag while the</span>
<span class="cm"> * deallocation must not be done until source-end.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Unmount record used to have a string &quot;Unmount filesystem--&quot; in the</span>
<span class="cm"> * data section where the &quot;Un&quot; was really a magic number (XLOG_UNMOUNT_TYPE).</span>
<span class="cm"> * We just write the magic number now since that particular field isn&#39;t</span>
<span class="cm"> * currently architecture converted and &quot;nUmount&quot; is a bit foo.</span>
<span class="cm"> * As far as I know, there weren&#39;t any dependencies on the old behaviour.</span>
<span class="cm"> */</span>

<span class="kt">int</span>
<span class="nf">xfs_log_unmount_write</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_t</span>		 <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">;</span>
	<span class="n">xlog_in_core_t</span>	 <span class="o">*</span><span class="n">iclog</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">xlog_in_core_t</span>	 <span class="o">*</span><span class="n">first_iclog</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">xlog_ticket_t</span>	<span class="o">*</span><span class="n">tic</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>	 <span class="n">lsn</span><span class="p">;</span>
	<span class="kt">int</span>		 <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t write out unmount record on read-only mounts.</span>
<span class="cm">	 * Or, if we are doing a forced umount (typically because of IO errors).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">_xfs_log_force</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_LOG_SYNC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">error</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">XLOG_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">log</span><span class="p">)));</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">first_iclog</span> <span class="o">=</span> <span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_ACTIVE</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iclog</span> <span class="o">!=</span> <span class="n">first_iclog</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">XLOG_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">log</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_log_reserve</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tic</span><span class="p">,</span>
					<span class="n">XFS_LOG</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XLOG_UNMOUNT_REC_TYPE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* the data section must be 32 bit size aligned */</span>
			<span class="k">struct</span> <span class="p">{</span>
			    <span class="n">__uint16_t</span> <span class="n">magic</span><span class="p">;</span>
			    <span class="n">__uint16_t</span> <span class="n">pad1</span><span class="p">;</span>
			    <span class="n">__uint32_t</span> <span class="n">pad2</span><span class="p">;</span> <span class="cm">/* may as well make it 64 bits */</span>
			<span class="p">}</span> <span class="n">magic</span> <span class="o">=</span> <span class="p">{</span>
				<span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="n">XLOG_UNMOUNT_TYPE</span><span class="p">,</span>
			<span class="p">};</span>
			<span class="k">struct</span> <span class="n">xfs_log_iovec</span> <span class="n">reg</span> <span class="o">=</span> <span class="p">{</span>
				<span class="p">.</span><span class="n">i_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">magic</span><span class="p">,</span>
				<span class="p">.</span><span class="n">i_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">magic</span><span class="p">),</span>
				<span class="p">.</span><span class="n">i_type</span> <span class="o">=</span> <span class="n">XLOG_REG_TYPE_UNMOUNT</span><span class="p">,</span>
			<span class="p">};</span>
			<span class="k">struct</span> <span class="n">xfs_log_vec</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span>
				<span class="p">.</span><span class="n">lv_niovecs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
				<span class="p">.</span><span class="n">lv_iovecp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span>
			<span class="p">};</span>

			<span class="cm">/* remove inited flag, and account for space used */</span>
			<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">magic</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_write</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">,</span> <span class="n">tic</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lsn</span><span class="p">,</span>
					   <span class="nb">NULL</span><span class="p">,</span> <span class="n">XLOG_UNMOUNT_TRANS</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * At this point, we&#39;re umounting anyway,</span>
<span class="cm">			 * so there&#39;s no point in transitioning log state</span>
<span class="cm">			 * to IOERROR. Just continue...</span>
<span class="cm">			 */</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: unmount record failed&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>


		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_refcnt</span><span class="p">);</span>
		<span class="n">xlog_state_want_sync</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_state_release_iclog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_ACTIVE</span> <span class="o">||</span>
		      <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_DIRTY</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XLOG_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">log</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">xlog_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_force_wait</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tic</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trace_xfs_log_umount_write</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tic</span><span class="p">);</span>
			<span class="n">xlog_ungrant_log_space</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tic</span><span class="p">);</span>
			<span class="n">xfs_log_ticket_put</span><span class="p">(</span><span class="n">tic</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re already in forced_shutdown mode, couldn&#39;t</span>
<span class="cm">		 * even attempt to write out the unmount transaction.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Go through the motions of sync&#39;ing and releasing</span>
<span class="cm">		 * the iclog, even though no I/O will actually happen,</span>
<span class="cm">		 * we need to wait for other log I/Os that may already</span>
<span class="cm">		 * be in progress.  Do this as a separate section of</span>
<span class="cm">		 * code so we&#39;ll know if we ever get stuck here that</span>
<span class="cm">		 * we&#39;re in this odd situation of trying to unmount</span>
<span class="cm">		 * a file system that went into forced_shutdown as</span>
<span class="cm">		 * the result of an unmount..</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_refcnt</span><span class="p">);</span>

		<span class="n">xlog_state_want_sync</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span>  <span class="n">xlog_state_release_iclog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="p">(</span>   <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_ACTIVE</span>
			<span class="o">||</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_DIRTY</span>
			<span class="o">||</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>

				<span class="n">xlog_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_force_wait</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>	<span class="cm">/* xfs_log_unmount_write */</span>

<span class="cm">/*</span>
<span class="cm"> * Deallocate log structures for unmount/relocation.</span>
<span class="cm"> *</span>
<span class="cm"> * We need to stop the aild from running before we destroy</span>
<span class="cm"> * and deallocate the log as the aild references the log.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_log_unmount</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sync_work</span><span class="p">);</span>
	<span class="n">xfs_trans_ail_destroy</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">xlog_dealloc_log</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_log_item_init</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_log_item</span>	<span class="o">*</span><span class="n">item</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">type</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">xfs_item_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">li_mountp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">li_ailp</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ail</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">li_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">li_ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">li_lv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">li_ail</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">li_cil</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wake up processes waiting for log space after we have moved the log tail.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_log_space_wake</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">free_bytes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XLOG_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">log</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty_careful</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">.</span><span class="n">waiters</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_ACTIVE_RECOVERY</span><span class="p">));</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">free_bytes</span> <span class="o">=</span> <span class="n">xlog_space_left</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">.</span><span class="n">grant</span><span class="p">);</span>
		<span class="n">xlog_grant_head_wake</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_bytes</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty_careful</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">.</span><span class="n">waiters</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_ACTIVE_RECOVERY</span><span class="p">));</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">free_bytes</span> <span class="o">=</span> <span class="n">xlog_space_left</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">.</span><span class="n">grant</span><span class="p">);</span>
		<span class="n">xlog_grant_head_wake</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_bytes</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine if we have a transaction that has gone to disk</span>
<span class="cm"> * that needs to be covered. To begin the transition to the idle state</span>
<span class="cm"> * firstly the log needs to be idle (no AIL and nothing in the iclogs).</span>
<span class="cm"> * If we are then in a state where covering is needed, the caller is informed</span>
<span class="cm"> * that dummy transactions are required to move the log into the idle state.</span>
<span class="cm"> *</span>
<span class="cm"> * Because this is called as part of the sync process, we should also indicate</span>
<span class="cm"> * that dummy transactions should be issued in anything but the covered or</span>
<span class="cm"> * idle states. This ensures that the log tail is accurately reflected in</span>
<span class="cm"> * the log at the end of the sync, hence if a crash occurrs avoids replay</span>
<span class="cm"> * of transactions where the metadata is already on disk.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_log_need_covered</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_fs_writable</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_covered_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XLOG_STATE_COVER_DONE</span>:
	<span class="k">case</span> <span class="n">XLOG_STATE_COVER_DONE2</span>:
	<span class="k">case</span> <span class="n">XLOG_STATE_COVER_IDLE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XLOG_STATE_COVER_NEED</span>:
	<span class="k">case</span> <span class="n">XLOG_STATE_COVER_NEED2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_ail_min_lsn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_ailp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">xlog_iclogs_empty</span><span class="p">(</span><span class="n">log</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_covered_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_COVER_NEED</span><span class="p">)</span>
				<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_covered_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_COVER_DONE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_covered_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_COVER_DONE2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FALLTHRU */</span>
	<span class="nl">default:</span>
		<span class="n">needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">needed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We may be holding the log iclog lock upon entering this routine.</span>
<span class="cm"> */</span>
<span class="n">xfs_lsn_t</span>
<span class="nf">xlog_assign_tail_lsn_locked</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_log_item</span>	<span class="o">*</span><span class="n">lip</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">tail_lsn</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ail</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * To make sure we always have a valid LSN for the log tail we keep</span>
<span class="cm">	 * track of the last LSN which was committed in log-&gt;l_last_sync_lsn,</span>
<span class="cm">	 * and use that when the AIL was empty.</span>
<span class="cm">	 */</span>
	<span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_ail_min</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ail</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lip</span><span class="p">)</span>
		<span class="n">tail_lsn</span> <span class="o">=</span> <span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tail_lsn</span> <span class="o">=</span> <span class="n">atomic64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_last_sync_lsn</span><span class="p">);</span>
	<span class="n">atomic64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_tail_lsn</span><span class="p">,</span> <span class="n">tail_lsn</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tail_lsn</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">xfs_lsn_t</span>
<span class="nf">xlog_assign_tail_lsn</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">tail_lsn</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ail</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
	<span class="n">tail_lsn</span> <span class="o">=</span> <span class="n">xlog_assign_tail_lsn_locked</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ail</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tail_lsn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the space in the log between the tail and the head.  The head</span>
<span class="cm"> * is passed in the cycle/bytes formal parms.  In the special case where</span>
<span class="cm"> * the reserve head has wrapped passed the tail, this calculation is no</span>
<span class="cm"> * longer valid.  In this case, just return 0 which means there is no space</span>
<span class="cm"> * in the log.  This works for all places where this function is called</span>
<span class="cm"> * with the reserve head.  Of course, if the write head were to ever</span>
<span class="cm"> * wrap the tail, we should blow up.  Rather than catch this case here,</span>
<span class="cm"> * we depend on other ASSERTions in other parts of the code.   XXXmiken</span>
<span class="cm"> *</span>
<span class="cm"> * This code also handles the case where the reservation head is behind</span>
<span class="cm"> * the tail.  The details of this case are described below, but the end</span>
<span class="cm"> * result is that we return the size of the log as the amount of space left.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_space_left</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">atomic64_t</span>	<span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">free_bytes</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">tail_bytes</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">tail_cycle</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">head_cycle</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">head_bytes</span><span class="p">;</span>

	<span class="n">xlog_crack_grant_head</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head_cycle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head_bytes</span><span class="p">);</span>
	<span class="n">xlog_crack_atomic_lsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_tail_lsn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail_cycle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail_bytes</span><span class="p">);</span>
	<span class="n">tail_bytes</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">tail_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tail_cycle</span> <span class="o">==</span> <span class="n">head_cycle</span> <span class="o">&amp;&amp;</span> <span class="n">head_bytes</span> <span class="o">&gt;=</span> <span class="n">tail_bytes</span><span class="p">)</span>
		<span class="n">free_bytes</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logsize</span> <span class="o">-</span> <span class="p">(</span><span class="n">head_bytes</span> <span class="o">-</span> <span class="n">tail_bytes</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tail_cycle</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">head_cycle</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tail_cycle</span> <span class="o">&lt;</span> <span class="n">head_cycle</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">tail_cycle</span> <span class="o">==</span> <span class="p">(</span><span class="n">head_cycle</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">free_bytes</span> <span class="o">=</span> <span class="n">tail_bytes</span> <span class="o">-</span> <span class="n">head_bytes</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The reservation head is behind the tail.</span>
<span class="cm">		 * In this case we just want to return the size of the</span>
<span class="cm">		 * log as the amount of space left.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_alert</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span>
			<span class="s">&quot;xlog_space_left: head behind tail</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;  tail_cycle = %d, tail_bytes = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;  GH   cycle = %d, GH   bytes = %d&quot;</span><span class="p">,</span>
			<span class="n">tail_cycle</span><span class="p">,</span> <span class="n">tail_bytes</span><span class="p">,</span> <span class="n">head_cycle</span><span class="p">,</span> <span class="n">head_bytes</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">free_bytes</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logsize</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">free_bytes</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Log function which is called when an io completes.</span>
<span class="cm"> *</span>
<span class="cm"> * The log manager needs its own routine, in order to control what</span>
<span class="cm"> * happens with the buffer after the write completes.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xlog_iodone</span><span class="p">(</span><span class="n">xfs_buf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_in_core_t</span>	<span class="o">*</span><span class="n">iclog</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_fspriv</span><span class="p">;</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_log</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">aborted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Race to shutdown the filesystem if we see an error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_TEST_ERROR</span><span class="p">((</span><span class="n">xfs_buf_geterror</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span>
			<span class="n">XFS_ERRTAG_IODONE_IOERR</span><span class="p">,</span> <span class="n">XFS_RANDOM_IODONE_IOERR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_buf_ioerror_alert</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">xfs_buf_stale</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">xfs_force_shutdown</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">SHUTDOWN_LOG_IO_ERROR</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * This flag will be propagated to the trans-committed</span>
<span class="cm">		 * callback routines to let them know that the log-commit</span>
<span class="cm">		 * didn&#39;t succeed.</span>
<span class="cm">		 */</span>
		<span class="n">aborted</span> <span class="o">=</span> <span class="n">XFS_LI_ABORTED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">aborted</span> <span class="o">=</span> <span class="n">XFS_LI_ABORTED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* log I/O is always issued ASYNC */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_BUF_ISASYNC</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
	<span class="n">xlog_state_done_syncing</span><span class="p">(</span><span class="n">iclog</span><span class="p">,</span> <span class="n">aborted</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * do not reference the buffer (bp) here as we could race</span>
<span class="cm">	 * with it being freed after writing the unmount record to the</span>
<span class="cm">	 * log.</span>
<span class="cm">	 */</span>

<span class="p">}</span>	<span class="cm">/* xlog_iodone */</span>

<span class="cm">/*</span>
<span class="cm"> * Return size of each in-core log record buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * All machines get 8 x 32kB buffers by default, unless tuned otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * If the filesystem blocksize is too large, we may need to choose a</span>
<span class="cm"> * larger size since the directory code currently logs entire blocks.</span>
<span class="cm"> */</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_get_iclog_buffer_size</span><span class="p">(</span><span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
			   <span class="n">xlog_t</span>	<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xhdrs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logbufs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_bufs</span> <span class="o">=</span> <span class="n">XLOG_MAX_ICLOGS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_bufs</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logbufs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Buffer size passed in from mount system call.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logbsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_size</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logbsize</span><span class="p">;</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_size_log</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_size_log</span><span class="o">++</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_haslogv2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* # headers = size / 32k</span>
<span class="cm">			 * one header holds cycles from 32k of data</span>
<span class="cm">			 */</span>

			<span class="n">xhdrs</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logbsize</span> <span class="o">/</span> <span class="n">XLOG_HEADER_CYCLE_SIZE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logbsize</span> <span class="o">%</span> <span class="n">XLOG_HEADER_CYCLE_SIZE</span><span class="p">)</span>
				<span class="n">xhdrs</span><span class="o">++</span><span class="p">;</span>
			<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span> <span class="o">=</span> <span class="n">xhdrs</span> <span class="o">&lt;&lt;</span> <span class="n">BBSHIFT</span><span class="p">;</span>
			<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_heads</span> <span class="o">=</span> <span class="n">xhdrs</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logbsize</span> <span class="o">&lt;=</span> <span class="n">XLOG_BIG_RECORD_BSIZE</span><span class="p">);</span>
			<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span> <span class="o">=</span> <span class="n">BBSIZE</span><span class="p">;</span>
			<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_heads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* All machines use 32kB buffers by default. */</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_size</span> <span class="o">=</span> <span class="n">XLOG_BIG_RECORD_BSIZE</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_size_log</span> <span class="o">=</span> <span class="n">XLOG_BIG_RECORD_BSHIFT</span><span class="p">;</span>

	<span class="cm">/* the default log size is 16k or 32k which is one header sector */</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span> <span class="o">=</span> <span class="n">BBSIZE</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_heads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="cm">/* are we being asked to make the sizes selected above visible? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logbufs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logbufs</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_bufs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logbsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logbsize</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_size</span><span class="p">;</span>
<span class="p">}</span>	<span class="cm">/* xlog_get_iclog_buffer_size */</span>


<span class="cm">/*</span>
<span class="cm"> * This routine initializes some of the log structure for a given mount point.</span>
<span class="cm"> * Its primary purpose is to fill in enough, so recovery can occur.  However,</span>
<span class="cm"> * some other stuff may be filled in too.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="n">xlog_t</span> <span class="o">*</span>
<span class="nf">xlog_alloc_log</span><span class="p">(</span><span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	       <span class="n">xfs_buftarg_t</span>	<span class="o">*</span><span class="n">log_target</span><span class="p">,</span>
	       <span class="n">xfs_daddr_t</span>	<span class="n">blk_offset</span><span class="p">,</span>
	       <span class="kt">int</span>		<span class="n">num_bblks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">;</span>
	<span class="n">xlog_rec_header_t</span>	<span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="n">xlog_in_core_t</span>		<span class="o">**</span><span class="n">iclogp</span><span class="p">;</span>
	<span class="n">xlog_in_core_t</span>		<span class="o">*</span><span class="n">iclog</span><span class="p">,</span> <span class="o">*</span><span class="n">prev_iclog</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">log2_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">log</span> <span class="o">=</span> <span class="n">kmem_zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_t</span><span class="p">),</span> <span class="n">KM_MAYFAIL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">log</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;Log allocation failed: No memory!&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span>	   <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_targ</span>	   <span class="o">=</span> <span class="n">log_target</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logsize</span>     <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">num_bblks</span><span class="p">);</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBstart</span>  <span class="o">=</span> <span class="n">blk_offset</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span>   <span class="o">=</span> <span class="n">num_bblks</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_covered_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_COVER_IDLE</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flags</span>	   <span class="o">|=</span> <span class="n">XLOG_ACTIVE_RECOVERY</span><span class="p">;</span>

	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_prev_block</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* log-&gt;l_tail_lsn = 0x100000000LL; cycle = 1; current block = 0 */</span>
	<span class="n">xlog_assign_atomic_lsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_tail_lsn</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">xlog_assign_atomic_lsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_last_sync_lsn</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	    <span class="cm">/* 0 is bad since this is initial value */</span>

	<span class="n">xlog_grant_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">);</span>
	<span class="n">xlog_grant_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">EFSCORRUPTED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_hassector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span> <span class="p">{</span>
	        <span class="n">log2_size</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_logsectlog</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">log2_size</span> <span class="o">&lt;</span> <span class="n">BBSHIFT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;Log sector size too small (0x%x &lt; 0x%x)&quot;</span><span class="p">,</span>
				<span class="n">log2_size</span><span class="p">,</span> <span class="n">BBSHIFT</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_log</span><span class="p">;</span>
		<span class="p">}</span>

	        <span class="n">log2_size</span> <span class="o">-=</span> <span class="n">BBSHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">log2_size</span> <span class="o">&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sectbb_log</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;Log sector size too large (0x%x &gt; 0x%x)&quot;</span><span class="p">,</span>
				<span class="n">log2_size</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sectbb_log</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_log</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* for larger sector sizes, must have v2 or external log */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">log2_size</span> <span class="o">&amp;&amp;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBstart</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">xfs_sb_version_haslogv2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
		<span class="s">&quot;log sector size (0x%x) invalid for configuration.&quot;</span><span class="p">,</span>
				<span class="n">log2_size</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_log</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_sectBBsize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">log2_size</span><span class="p">;</span>

	<span class="n">xlog_get_iclog_buffer_size</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_alloc</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_size</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_log</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone</span> <span class="o">=</span> <span class="n">xlog_iodone</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_buf_islocked</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_xbuf</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flush_wait</span><span class="p">);</span>

	<span class="n">iclogp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The amount of memory to allocate for the iclog structure is</span>
<span class="cm">	 * rather funky due to the way the structure is defined.  It is</span>
<span class="cm">	 * done this way so that we can use different sizes for machines</span>
<span class="cm">	 * with different amounts of memory.  See the definition of</span>
<span class="cm">	 * xlog_in_core_t in xfs_log_priv.h for details.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_size</span> <span class="o">&gt;=</span> <span class="mi">4096</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_bufs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">iclogp</span> <span class="o">=</span> <span class="n">kmem_zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_in_core_t</span><span class="p">),</span> <span class="n">KM_MAYFAIL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">iclogp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free_iclog</span><span class="p">;</span>

		<span class="n">iclog</span> <span class="o">=</span> <span class="o">*</span><span class="n">iclogp</span><span class="p">;</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_prev</span> <span class="o">=</span> <span class="n">prev_iclog</span><span class="p">;</span>
		<span class="n">prev_iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="p">;</span>

		<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_get_uncached</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span><span class="p">,</span>
						<span class="n">BTOBB</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_size</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free_iclog</span><span class="p">;</span>

		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone</span> <span class="o">=</span> <span class="n">xlog_iodone</span><span class="p">;</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_bp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_data</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_bak</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_caddr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_rec_header_t</span><span class="p">));</span>
		<span class="n">head</span><span class="o">-&gt;</span><span class="n">h_magicno</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XLOG_HEADER_MAGIC_NUM</span><span class="p">);</span>
		<span class="n">head</span><span class="o">-&gt;</span><span class="n">h_version</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span>
			<span class="n">xfs_sb_version_haslogv2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">head</span><span class="o">-&gt;</span><span class="n">h_size</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_size</span><span class="p">);</span>
		<span class="cm">/* new fields */</span>
		<span class="n">head</span><span class="o">-&gt;</span><span class="n">h_fmt</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XLOG_FMT</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">h_fs_uuid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_uuid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uuid_t</span><span class="p">));</span>

		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_size</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span><span class="p">;</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_ACTIVE</span><span class="p">;</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_log</span> <span class="o">=</span> <span class="n">log</span><span class="p">;</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_refcnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback_lock</span><span class="p">);</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback_tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback</span><span class="p">);</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_datap</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_data</span> <span class="o">+</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span><span class="p">;</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_buf_islocked</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_bp</span><span class="p">));</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_force_wait</span><span class="p">);</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_write_wait</span><span class="p">);</span>

		<span class="n">iclogp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">iclogp</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>			<span class="cm">/* complete ring */</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="o">-&gt;</span><span class="n">ic_prev</span> <span class="o">=</span> <span class="n">prev_iclog</span><span class="p">;</span>	<span class="cm">/* re-write 1st prev ptr */</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_cil_init</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_iclog</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">log</span><span class="p">;</span>

<span class="nl">out_free_iclog:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span> <span class="n">iclog</span><span class="p">;</span> <span class="n">iclog</span> <span class="o">=</span> <span class="n">prev_iclog</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prev_iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_bp</span><span class="p">)</span>
			<span class="n">xfs_buf_free</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_bp</span><span class="p">);</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">iclog</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spinlock_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
	<span class="n">xfs_buf_free</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_xbuf</span><span class="p">);</span>
<span class="nl">out_free_log:</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>	<span class="cm">/* xlog_alloc_log */</span>


<span class="cm">/*</span>
<span class="cm"> * Write out the commit record of a transaction associated with the given</span>
<span class="cm"> * ticket.  Return the lsn of the commit record.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_commit_record</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">ticket</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">**</span><span class="n">iclog</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>		<span class="o">*</span><span class="n">commitlsnp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_log_iovec</span> <span class="n">reg</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">i_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">i_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">i_type</span> <span class="o">=</span> <span class="n">XLOG_REG_TYPE_COMMIT</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">lv_niovecs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">lv_iovecp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">ASSERT_ALWAYS</span><span class="p">(</span><span class="n">iclog</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_write</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">,</span> <span class="n">ticket</span><span class="p">,</span> <span class="n">commitlsnp</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span>
					<span class="n">XLOG_COMMIT_TRANS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">xfs_force_shutdown</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">SHUTDOWN_LOG_IO_ERROR</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Push on the buffer cache code if we ever use more than 75% of the on-disk</span>
<span class="cm"> * log space.  This code pushes on the lsn which would supposedly free up</span>
<span class="cm"> * the 25% which we want to leave free.  We may need to adopt a policy which</span>
<span class="cm"> * pushes on an lsn which is further along in the log once we reach the high</span>
<span class="cm"> * water mark.  In this manner, we would be creating a low water mark.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_grant_push_ail</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">need_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_lsn_t</span>	<span class="n">threshold_lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>	<span class="n">last_sync_lsn</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">free_blocks</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">free_bytes</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">threshold_block</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">threshold_cycle</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">free_threshold</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">BTOBB</span><span class="p">(</span><span class="n">need_bytes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">);</span>

	<span class="n">free_bytes</span> <span class="o">=</span> <span class="n">xlog_space_left</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">.</span><span class="n">grant</span><span class="p">);</span>
	<span class="n">free_blocks</span> <span class="o">=</span> <span class="n">BTOBBT</span><span class="p">(</span><span class="n">free_bytes</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the threshold for the minimum number of free blocks in the</span>
<span class="cm">	 * log to the maximum of what the caller needs, one quarter of the</span>
<span class="cm">	 * log, and 256 blocks.</span>
<span class="cm">	 */</span>
	<span class="n">free_threshold</span> <span class="o">=</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">need_bytes</span><span class="p">);</span>
	<span class="n">free_threshold</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">free_threshold</span><span class="p">,</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">free_threshold</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">free_threshold</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_blocks</span> <span class="o">&gt;=</span> <span class="n">free_threshold</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">xlog_crack_atomic_lsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_tail_lsn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threshold_cycle</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">threshold_block</span><span class="p">);</span>
	<span class="n">threshold_block</span> <span class="o">+=</span> <span class="n">free_threshold</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">threshold_block</span> <span class="o">&gt;=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">threshold_block</span> <span class="o">-=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">;</span>
		<span class="n">threshold_cycle</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">threshold_lsn</span> <span class="o">=</span> <span class="n">xlog_assign_lsn</span><span class="p">(</span><span class="n">threshold_cycle</span><span class="p">,</span>
					<span class="n">threshold_block</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t pass in an lsn greater than the lsn of the last</span>
<span class="cm">	 * log record known to be on disk. Use a snapshot of the last sync lsn</span>
<span class="cm">	 * so that it doesn&#39;t change between the compare and the set.</span>
<span class="cm">	 */</span>
	<span class="n">last_sync_lsn</span> <span class="o">=</span> <span class="n">atomic64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_last_sync_lsn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_LSN_CMP</span><span class="p">(</span><span class="n">threshold_lsn</span><span class="p">,</span> <span class="n">last_sync_lsn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">threshold_lsn</span> <span class="o">=</span> <span class="n">last_sync_lsn</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the transaction layer to kick the dirty buffers out to</span>
<span class="cm">	 * disk asynchronously. No point in trying to do this if</span>
<span class="cm">	 * the filesystem is shutting down.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XLOG_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">log</span><span class="p">))</span>
		<span class="n">xfs_ail_push</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_ailp</span><span class="p">,</span> <span class="n">threshold_lsn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The bdstrat callback function for log bufs. This gives us a central</span>
<span class="cm"> * place to trap bufs in case we get hit by a log I/O error and need to</span>
<span class="cm"> * shutdown. Actually, in practice, even when we didn&#39;t get a log error,</span>
<span class="cm"> * we transition the iclogs to IOERROR state *after* flushing all existing</span>
<span class="cm"> * iclogs to disk. This is because we don&#39;t want anymore new transactions to be</span>
<span class="cm"> * started or completed afterwards.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_bdstrat</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">*</span><span class="n">iclog</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_fspriv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_buf_ioerror</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">EIO</span><span class="p">);</span>
		<span class="n">xfs_buf_stale</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">xfs_buf_ioend</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * It would seem logical to return EIO here, but we rely on</span>
<span class="cm">		 * the log state machine to propagate I/O errors instead of</span>
<span class="cm">		 * doing it here.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_buf_iorequest</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush out the in-core log (iclog) to the on-disk log in an asynchronous </span>
<span class="cm"> * fashion.  Previously, we should have moved the current iclog</span>
<span class="cm"> * ptr in the log to point to the next available iclog.  This allows further</span>
<span class="cm"> * write to continue while this code syncs out an iclog ready to go.</span>
<span class="cm"> * Before an in-core log can be written out, the data section must be scanned</span>
<span class="cm"> * to save away the 1st word of each BBSIZE block into the header.  We replace</span>
<span class="cm"> * it with the current cycle count.  Each BBSIZE block is tagged with the</span>
<span class="cm"> * cycle count because there in an implicit assumption that drives will</span>
<span class="cm"> * guarantee that entire 512 byte blocks get written at once.  In other words,</span>
<span class="cm"> * we can&#39;t have part of a 512 byte block written and part not written.  By</span>
<span class="cm"> * tagging each block, we will know which blocks are valid when recovering</span>
<span class="cm"> * after an unclean shutdown.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is single threaded on the iclog.  No other thread can be in</span>
<span class="cm"> * this routine with the same iclog.  Changing contents of iclog can there-</span>
<span class="cm"> * fore be done without grabbing the state machine lock.  Updating the global</span>
<span class="cm"> * log will require grabbing the lock though.</span>
<span class="cm"> *</span>
<span class="cm"> * The entire log manager uses a logical block numbering scheme.  Only</span>
<span class="cm"> * log_sync (and then only bwrite()) know about the fact that the log may</span>
<span class="cm"> * not start with block zero on a given device.  The log block start offset</span>
<span class="cm"> * is added immediately before calling bwrite().</span>
<span class="cm"> */</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_sync</span><span class="p">(</span><span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	  <span class="n">xlog_in_core_t</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_caddr_t</span>	<span class="n">dptr</span><span class="p">;</span>		<span class="cm">/* pointer to byte sized element */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">count</span><span class="p">;</span>		<span class="cm">/* byte count of bwrite */</span>
	<span class="n">uint</span>		<span class="n">count_init</span><span class="p">;</span>	<span class="cm">/* initial count before roundup */</span>
	<span class="kt">int</span>		<span class="n">roundoff</span><span class="p">;</span>       <span class="cm">/* roundoff to BB or stripe */</span>
	<span class="kt">int</span>		<span class="n">split</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* split write into two regions */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">v2</span> <span class="o">=</span> <span class="n">xfs_sb_version_haslogv2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">);</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_log_writes</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_refcnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Add for LR header */</span>
	<span class="n">count_init</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span> <span class="o">+</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span><span class="p">;</span>

	<span class="cm">/* Round out the log write size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v2</span> <span class="o">&amp;&amp;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_logsunit</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we have a v2 stripe unit to use */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">XLOG_LSUNITTOB</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">XLOG_BTOLSUNIT</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">count_init</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">BTOBB</span><span class="p">(</span><span class="n">count_init</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">roundoff</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="n">count_init</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">roundoff</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">v2</span> <span class="o">&amp;&amp;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_logsunit</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> 
                <span class="n">roundoff</span> <span class="o">&lt;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_logsunit</span><span class="p">)</span>
		<span class="o">||</span> 
		<span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_logsunit</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> 
		 <span class="n">roundoff</span> <span class="o">&lt;</span> <span class="n">BBTOB</span><span class="p">(</span><span class="mi">1</span><span class="p">)));</span>

	<span class="cm">/* move grant heads by roundoff in sync */</span>
	<span class="n">xlog_grant_add_space</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">.</span><span class="n">grant</span><span class="p">,</span> <span class="n">roundoff</span><span class="p">);</span>
	<span class="n">xlog_grant_add_space</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">.</span><span class="n">grant</span><span class="p">,</span> <span class="n">roundoff</span><span class="p">);</span>

	<span class="cm">/* put cycle number in every block */</span>
	<span class="n">xlog_pack_data</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="n">roundoff</span><span class="p">);</span> 

	<span class="cm">/* real byte length */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_len</span> <span class="o">=</span>
			<span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span> <span class="o">+</span> <span class="n">roundoff</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_len</span> <span class="o">=</span>
			<span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_bp</span><span class="p">;</span>
	<span class="n">XFS_BUF_SET_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">BLOCK_LSN</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_lsn</span><span class="p">)));</span>

	<span class="n">XFS_STATS_ADD</span><span class="p">(</span><span class="n">xs_log_blocks</span><span class="p">,</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">count</span><span class="p">));</span>

	<span class="cm">/* Do we need to split this write into 2 parts? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_BUF_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">+</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">split</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="p">(</span><span class="n">BBTOB</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span> <span class="o">-</span> <span class="n">XFS_BUF_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span> <span class="o">-</span> <span class="n">XFS_BUF_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_bwritecnt</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* split into 2 writes */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_bwritecnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_length</span> <span class="o">=</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_fspriv</span> <span class="o">=</span> <span class="n">iclog</span><span class="p">;</span>
	<span class="n">XFS_BUF_ZEROFLAGS</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">XFS_BUF_ASYNC</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">XBF_SYNCIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_BARRIER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">XBF_FUA</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Flush the data device before flushing the log to make</span>
<span class="cm">		 * sure all meta data written back from the AIL actually made</span>
<span class="cm">		 * it to disk before stamping the new log tail LSN into the</span>
<span class="cm">		 * log buffer.  For an external log we need to issue the</span>
<span class="cm">		 * flush explicitly, and unfortunately synchronously here;</span>
<span class="cm">		 * for an internal log we can simply use the block layer</span>
<span class="cm">		 * state machine for preflushes.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span> <span class="o">!=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">)</span>
			<span class="n">xfs_blkdev_issue_flush</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">XBF_FLUSH</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_BUF_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_BUF_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">+</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">);</span>

	<span class="n">xlog_verify_iclog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">B_TRUE</span><span class="p">);</span>

	<span class="cm">/* account for log which doesn&#39;t start at block #0 */</span>
	<span class="n">XFS_BUF_SET_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_BUF_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">+</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBstart</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t call xfs_bwrite here. We do log-syncs even when the filesystem</span>
<span class="cm">	 * is shutting down.</span>
<span class="cm">	 */</span>
	<span class="n">XFS_BUF_WRITE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bdstrat</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_buf_ioerror_alert</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="s">&quot;xlog_sync&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">split</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_log</span><span class="o">-&gt;</span><span class="n">l_xbuf</span><span class="p">;</span>
		<span class="n">XFS_BUF_SET_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	     <span class="cm">/* logical 0 */</span>
		<span class="n">xfs_buf_associate_memory</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span> <span class="o">+</span> <span class="n">count</span><span class="p">,</span> <span class="n">split</span><span class="p">);</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_fspriv</span> <span class="o">=</span> <span class="n">iclog</span><span class="p">;</span>
		<span class="n">XFS_BUF_ZEROFLAGS</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">XFS_BUF_ASYNC</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">XBF_SYNCIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_BARRIER</span><span class="p">)</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">XBF_FUA</span><span class="p">;</span>
		<span class="n">dptr</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Bump the cycle numbers at the start of each block</span>
<span class="cm">		 * since this part of the buffer is at the start of</span>
<span class="cm">		 * a new cycle.  Watch out for the header magic number</span>
<span class="cm">		 * case, though.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">split</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">BBSIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">be32_add_cpu</span><span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">dptr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">dptr</span><span class="p">)</span> <span class="o">==</span> <span class="n">XLOG_HEADER_MAGIC_NUM</span><span class="p">)</span>
				<span class="n">be32_add_cpu</span><span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">dptr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">dptr</span> <span class="o">+=</span> <span class="n">BBSIZE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_BUF_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_BUF_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">+</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">);</span>

		<span class="cm">/* account for internal log which doesn&#39;t start at block #0 */</span>
		<span class="n">XFS_BUF_SET_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_BUF_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">+</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBstart</span><span class="p">);</span>
		<span class="n">XFS_BUF_WRITE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bdstrat</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_buf_ioerror_alert</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="s">&quot;xlog_sync (split)&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>	<span class="cm">/* xlog_sync */</span>


<span class="cm">/*</span>
<span class="cm"> * Deallocate a log structure</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_dealloc_log</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_in_core_t</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">,</span> <span class="o">*</span><span class="n">next_iclog</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

	<span class="n">xlog_cil_destroy</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * always need to ensure that the extra buffer does not point to memory</span>
<span class="cm">	 * owned by another log buffer before we free it.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_buf_set_empty</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_xbuf</span><span class="p">,</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_size</span><span class="p">));</span>
	<span class="n">xfs_buf_free</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_xbuf</span><span class="p">);</span>

	<span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_bufs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_buf_free</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_bp</span><span class="p">);</span>
		<span class="n">next_iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">iclog</span><span class="p">);</span>
		<span class="n">iclog</span> <span class="o">=</span> <span class="n">next_iclog</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spinlock_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>

	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_log</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
<span class="p">}</span>	<span class="cm">/* xlog_dealloc_log */</span>

<span class="cm">/*</span>
<span class="cm"> * Update counters atomically now that memcpy is done.</span>
<span class="cm"> */</span>
<span class="cm">/* ARGSUSED */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xlog_state_finish_copy</span><span class="p">(</span><span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
		       <span class="n">xlog_in_core_t</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">,</span>
		       <span class="kt">int</span>		<span class="n">record_cnt</span><span class="p">,</span>
		       <span class="kt">int</span>		<span class="n">copy_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>

	<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_num_logops</span><span class="p">,</span> <span class="n">record_cnt</span><span class="p">);</span>
	<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span> <span class="o">+=</span> <span class="n">copy_bytes</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
<span class="p">}</span>	<span class="cm">/* xlog_state_finish_copy */</span>




<span class="cm">/*</span>
<span class="cm"> * print out info relating to regions written which consume</span>
<span class="cm"> * the reservation</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xlog_print_tic_res</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">ticket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uint</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">ophdr_spc</span> <span class="o">=</span> <span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_res_num_ophdrs</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">);</span>

	<span class="cm">/* match with XLOG_REG_TYPE_* in xfs_log.h */</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">res_type_str</span><span class="p">[</span><span class="n">XLOG_REG_TYPE_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	    <span class="s">&quot;bformat&quot;</span><span class="p">,</span>
	    <span class="s">&quot;bchunk&quot;</span><span class="p">,</span>
	    <span class="s">&quot;efi_format&quot;</span><span class="p">,</span>
	    <span class="s">&quot;efd_format&quot;</span><span class="p">,</span>
	    <span class="s">&quot;iformat&quot;</span><span class="p">,</span>
	    <span class="s">&quot;icore&quot;</span><span class="p">,</span>
	    <span class="s">&quot;iext&quot;</span><span class="p">,</span>
	    <span class="s">&quot;ibroot&quot;</span><span class="p">,</span>
	    <span class="s">&quot;ilocal&quot;</span><span class="p">,</span>
	    <span class="s">&quot;iattr_ext&quot;</span><span class="p">,</span>
	    <span class="s">&quot;iattr_broot&quot;</span><span class="p">,</span>
	    <span class="s">&quot;iattr_local&quot;</span><span class="p">,</span>
	    <span class="s">&quot;qformat&quot;</span><span class="p">,</span>
	    <span class="s">&quot;dquot&quot;</span><span class="p">,</span>
	    <span class="s">&quot;quotaoff&quot;</span><span class="p">,</span>
	    <span class="s">&quot;LR header&quot;</span><span class="p">,</span>
	    <span class="s">&quot;unmount&quot;</span><span class="p">,</span>
	    <span class="s">&quot;commit&quot;</span><span class="p">,</span>
	    <span class="s">&quot;trans header&quot;</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">trans_type_str</span><span class="p">[</span><span class="n">XFS_TRANS_TYPE_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	    <span class="s">&quot;SETATTR_NOT_SIZE&quot;</span><span class="p">,</span>
	    <span class="s">&quot;SETATTR_SIZE&quot;</span><span class="p">,</span>
	    <span class="s">&quot;INACTIVE&quot;</span><span class="p">,</span>
	    <span class="s">&quot;CREATE&quot;</span><span class="p">,</span>
	    <span class="s">&quot;CREATE_TRUNC&quot;</span><span class="p">,</span>
	    <span class="s">&quot;TRUNCATE_FILE&quot;</span><span class="p">,</span>
	    <span class="s">&quot;REMOVE&quot;</span><span class="p">,</span>
	    <span class="s">&quot;LINK&quot;</span><span class="p">,</span>
	    <span class="s">&quot;RENAME&quot;</span><span class="p">,</span>
	    <span class="s">&quot;MKDIR&quot;</span><span class="p">,</span>
	    <span class="s">&quot;RMDIR&quot;</span><span class="p">,</span>
	    <span class="s">&quot;SYMLINK&quot;</span><span class="p">,</span>
	    <span class="s">&quot;SET_DMATTRS&quot;</span><span class="p">,</span>
	    <span class="s">&quot;GROWFS&quot;</span><span class="p">,</span>
	    <span class="s">&quot;STRAT_WRITE&quot;</span><span class="p">,</span>
	    <span class="s">&quot;DIOSTRAT&quot;</span><span class="p">,</span>
	    <span class="s">&quot;WRITE_SYNC&quot;</span><span class="p">,</span>
	    <span class="s">&quot;WRITEID&quot;</span><span class="p">,</span>
	    <span class="s">&quot;ADDAFORK&quot;</span><span class="p">,</span>
	    <span class="s">&quot;ATTRINVAL&quot;</span><span class="p">,</span>
	    <span class="s">&quot;ATRUNCATE&quot;</span><span class="p">,</span>
	    <span class="s">&quot;ATTR_SET&quot;</span><span class="p">,</span>
	    <span class="s">&quot;ATTR_RM&quot;</span><span class="p">,</span>
	    <span class="s">&quot;ATTR_FLAG&quot;</span><span class="p">,</span>
	    <span class="s">&quot;CLEAR_AGI_BUCKET&quot;</span><span class="p">,</span>
	    <span class="s">&quot;QM_SBCHANGE&quot;</span><span class="p">,</span>
	    <span class="s">&quot;DUMMY1&quot;</span><span class="p">,</span>
	    <span class="s">&quot;DUMMY2&quot;</span><span class="p">,</span>
	    <span class="s">&quot;QM_QUOTAOFF&quot;</span><span class="p">,</span>
	    <span class="s">&quot;QM_DQALLOC&quot;</span><span class="p">,</span>
	    <span class="s">&quot;QM_SETQLIM&quot;</span><span class="p">,</span>
	    <span class="s">&quot;QM_DQCLUSTER&quot;</span><span class="p">,</span>
	    <span class="s">&quot;QM_QINOCREATE&quot;</span><span class="p">,</span>
	    <span class="s">&quot;QM_QUOTAOFF_END&quot;</span><span class="p">,</span>
	    <span class="s">&quot;SB_UNIT&quot;</span><span class="p">,</span>
	    <span class="s">&quot;FSYNC_TS&quot;</span><span class="p">,</span>
	    <span class="s">&quot;GROWFSRT_ALLOC&quot;</span><span class="p">,</span>
	    <span class="s">&quot;GROWFSRT_ZERO&quot;</span><span class="p">,</span>
	    <span class="s">&quot;GROWFSRT_FREE&quot;</span><span class="p">,</span>
	    <span class="s">&quot;SWAPEXT&quot;</span>
	<span class="p">};</span>

	<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
		<span class="s">&quot;xlog_write: reservation summary:</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  trans type  = %s (%u)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  unit res    = %d bytes</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  current res = %d bytes</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  total reg   = %u bytes (o/flow = %u bytes)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  ophdrs      = %u (ophdr space = %u bytes)</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  ophdr + reg = %u bytes</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  num regions = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">((</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_trans_type</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span>
		  <span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_trans_type</span> <span class="o">&gt;</span> <span class="n">XFS_TRANS_TYPE_MAX</span><span class="p">)</span> <span class="o">?</span>
		  <span class="s">&quot;bad-trans-type&quot;</span> <span class="o">:</span> <span class="n">trans_type_str</span><span class="p">[</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_trans_type</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_trans_type</span><span class="p">,</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_unit_res</span><span class="p">,</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span><span class="p">,</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_res_arr_sum</span><span class="p">,</span> <span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_res_o_flow</span><span class="p">,</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_res_num_ophdrs</span><span class="p">,</span> <span class="n">ophdr_spc</span><span class="p">,</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_res_arr_sum</span> <span class="o">+</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_res_o_flow</span> <span class="o">+</span> <span class="n">ophdr_spc</span><span class="p">,</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_res_num</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_res_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uint</span> <span class="n">r_type</span> <span class="o">=</span> <span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_res_arr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_type</span><span class="p">;</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;region[%u]: %s - %u bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
			    <span class="p">((</span><span class="n">r_type</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">r_type</span> <span class="o">&gt;</span> <span class="n">XLOG_REG_TYPE_MAX</span><span class="p">)</span> <span class="o">?</span>
			    <span class="s">&quot;bad-rtype&quot;</span> <span class="o">:</span> <span class="n">res_type_str</span><span class="p">[</span><span class="n">r_type</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
			    <span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_res_arr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xfs_alert_tag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_PTAG_LOGRES</span><span class="p">,</span>
		<span class="s">&quot;xlog_write: reservation ran out. Need to up reservation&quot;</span><span class="p">);</span>
	<span class="n">xfs_force_shutdown</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">SHUTDOWN_CORRUPT_INCORE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the potential space needed by the log vector.  Each region gets</span>
<span class="cm"> * its own xlog_op_header_t and may need to be double word aligned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xlog_write_calc_vec_length</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">ticket</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">log_vector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">headers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="cm">/* acct for start rec of xact */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_TIC_INITED</span><span class="p">)</span>
		<span class="n">headers</span><span class="o">++</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">lv</span> <span class="o">=</span> <span class="n">log_vector</span><span class="p">;</span> <span class="n">lv</span><span class="p">;</span> <span class="n">lv</span> <span class="o">=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">headers</span> <span class="o">+=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_niovecs</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_niovecs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">xfs_log_iovec</span>	<span class="o">*</span><span class="n">vecp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_iovecp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="n">len</span> <span class="o">+=</span> <span class="n">vecp</span><span class="o">-&gt;</span><span class="n">i_len</span><span class="p">;</span>
			<span class="n">xlog_tic_add_region</span><span class="p">(</span><span class="n">ticket</span><span class="p">,</span> <span class="n">vecp</span><span class="o">-&gt;</span><span class="n">i_len</span><span class="p">,</span> <span class="n">vecp</span><span class="o">-&gt;</span><span class="n">i_type</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_res_num_ophdrs</span> <span class="o">+=</span> <span class="n">headers</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">headers</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xlog_op_header</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If first write for transaction, insert start record  We can&#39;t be trying to</span>
<span class="cm"> * commit if we are inited.  We can&#39;t have any &quot;partial_copy&quot; if we are inited.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xlog_write_start_rec</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog_op_header</span>	<span class="o">*</span><span class="n">ophdr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">ticket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_TIC_INITED</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_tid</span>	<span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>
	<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_clientid</span> <span class="o">=</span> <span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_clientid</span><span class="p">;</span>
	<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_flags</span> <span class="o">=</span> <span class="n">XLOG_START_TRANS</span><span class="p">;</span>
	<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_res2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XLOG_TIC_INITED</span><span class="p">;</span>

	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xlog_op_header</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">xlog_op_header_t</span> <span class="o">*</span>
<span class="nf">xlog_write_setup_ophdr</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_op_header</span>	<span class="o">*</span><span class="n">ophdr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">ticket</span><span class="p">,</span>
	<span class="n">uint</span>			<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_tid</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>
	<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_clientid</span> <span class="o">=</span> <span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_clientid</span><span class="p">;</span>
	<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_res2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* are we copying a commit or unmount record? */</span>
	<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ve seen logs corrupted with bad transaction client ids.  This</span>
<span class="cm">	 * makes sure that XFS doesn&#39;t generate them on.  Turn this into an EIO</span>
<span class="cm">	 * and shut down the filesystem.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_clientid</span><span class="p">)</span>  <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_TRANSACTION</span>:
	<span class="k">case</span> <span class="n">XFS_VOLUME</span>:
	<span class="k">case</span> <span class="n">XFS_LOG</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span>
			<span class="s">&quot;Bad XFS transaction clientid 0x%x in ticket 0x%p&quot;</span><span class="p">,</span>
			<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_clientid</span><span class="p">,</span> <span class="n">ticket</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ophdr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up the parameters of the region copy into the log. This has</span>
<span class="cm"> * to handle region write split across multiple log buffers - this</span>
<span class="cm"> * state is kept external to this function so that this code can</span>
<span class="cm"> * can be written in an obvious, self documenting manner.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xlog_write_setup_copy</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">ticket</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_op_header</span>	<span class="o">*</span><span class="n">ophdr</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">space_available</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">space_required</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">copy_off</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">copy_len</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">last_was_partial_copy</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">bytes_consumed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">still_to_copy</span><span class="p">;</span>

	<span class="n">still_to_copy</span> <span class="o">=</span> <span class="n">space_required</span> <span class="o">-</span> <span class="o">*</span><span class="n">bytes_consumed</span><span class="p">;</span>
	<span class="o">*</span><span class="n">copy_off</span> <span class="o">=</span> <span class="o">*</span><span class="n">bytes_consumed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">still_to_copy</span> <span class="o">&lt;=</span> <span class="n">space_available</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* write of region completes here */</span>
		<span class="o">*</span><span class="n">copy_len</span> <span class="o">=</span> <span class="n">still_to_copy</span><span class="p">;</span>
		<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_len</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="o">*</span><span class="n">copy_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">last_was_partial_copy</span><span class="p">)</span>
			<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">XLOG_END_TRANS</span><span class="o">|</span><span class="n">XLOG_WAS_CONT_TRANS</span><span class="p">);</span>
		<span class="o">*</span><span class="n">last_was_partial_copy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">bytes_consumed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* partial write of region, needs extra log op header reservation */</span>
	<span class="o">*</span><span class="n">copy_len</span> <span class="o">=</span> <span class="n">space_available</span><span class="p">;</span>
	<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_len</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="o">*</span><span class="n">copy_len</span><span class="p">);</span>
	<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_flags</span> <span class="o">|=</span> <span class="n">XLOG_CONTINUE_TRANS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">last_was_partial_copy</span><span class="p">)</span>
		<span class="n">ophdr</span><span class="o">-&gt;</span><span class="n">oh_flags</span> <span class="o">|=</span> <span class="n">XLOG_WAS_CONT_TRANS</span><span class="p">;</span>
	<span class="o">*</span><span class="n">bytes_consumed</span> <span class="o">+=</span> <span class="o">*</span><span class="n">copy_len</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">last_was_partial_copy</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* account for new log op header */</span>
	<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xlog_op_header</span><span class="p">);</span>
	<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_res_num_ophdrs</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xlog_op_header</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xlog_write_copy_finish</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">,</span>
	<span class="n">uint</span>			<span class="n">flags</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">record_cnt</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">data_cnt</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">partial_copy</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">partial_copy_len</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">log_offset</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">**</span><span class="n">commit_iclog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">partial_copy</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This iclog has already been marked WANT_SYNC by</span>
<span class="cm">		 * xlog_state_get_iclog_space.</span>
<span class="cm">		 */</span>
		<span class="n">xlog_state_finish_copy</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="o">*</span><span class="n">record_cnt</span><span class="p">,</span> <span class="o">*</span><span class="n">data_cnt</span><span class="p">);</span>
		<span class="o">*</span><span class="n">record_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">data_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">xlog_state_release_iclog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">partial_copy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">partial_copy_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_size</span> <span class="o">-</span> <span class="n">log_offset</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* no more space in this iclog - push it. */</span>
		<span class="n">xlog_state_finish_copy</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="o">*</span><span class="n">record_cnt</span><span class="p">,</span> <span class="o">*</span><span class="n">data_cnt</span><span class="p">);</span>
		<span class="o">*</span><span class="n">record_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">data_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="n">xlog_state_want_sync</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">commit_iclog</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">xlog_state_release_iclog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XLOG_COMMIT_TRANS</span><span class="p">);</span>
		<span class="o">*</span><span class="n">commit_iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write some region out to in-core log</span>
<span class="cm"> *</span>
<span class="cm"> * This will be called when writing externally provided regions or when</span>
<span class="cm"> * writing out a commit record for a given transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * General algorithm:</span>
<span class="cm"> *	1. Find total length of this write.  This may include adding to the</span>
<span class="cm"> *		lengths passed in.</span>
<span class="cm"> *	2. Check whether we violate the tickets reservation.</span>
<span class="cm"> *	3. While writing to this iclog</span>
<span class="cm"> *	    A. Reserve as much space in this iclog as can get</span>
<span class="cm"> *	    B. If this is first write, save away start lsn</span>
<span class="cm"> *	    C. While writing this region:</span>
<span class="cm"> *		1. If first write of transaction, write start record</span>
<span class="cm"> *		2. Write log operation header (header per region)</span>
<span class="cm"> *		3. Find out if we can fit entire region into this iclog</span>
<span class="cm"> *		4. Potentially, verify destination memcpy ptr</span>
<span class="cm"> *		5. Memcpy (partial) region</span>
<span class="cm"> *		6. If partial copy, release iclog; otherwise, continue</span>
<span class="cm"> *			copying more regions into current iclog</span>
<span class="cm"> *	4. Mark want sync bit (in simulation mode)</span>
<span class="cm"> *	5. Release iclog for potential flush to on-disk log.</span>
<span class="cm"> *</span>
<span class="cm"> * ERRORS:</span>
<span class="cm"> * 1.	Panic if reservation is overrun.  This should never happen since</span>
<span class="cm"> *	reservation amounts are generated internal to the filesystem.</span>
<span class="cm"> * NOTES:</span>
<span class="cm"> * 1. Tickets are single threaded data structures.</span>
<span class="cm"> * 2. The XLOG_END_TRANS &amp; XLOG_CONTINUE_TRANS flags are passed down to the</span>
<span class="cm"> *	syncing routine.  When a single log_write region needs to span</span>
<span class="cm"> *	multiple in-core logs, the XLOG_CONTINUE_TRANS bit should be set</span>
<span class="cm"> *	on all log operation writes which don&#39;t contain the end of the</span>
<span class="cm"> *	region.  The XLOG_END_TRANS bit is used for the in-core log</span>
<span class="cm"> *	operation which contains the end of the continued log_write region.</span>
<span class="cm"> * 3. When xlog_state_get_iclog_space() grabs the rest of the current iclog,</span>
<span class="cm"> *	we don&#39;t really know exactly how much space will be used.  As a result,</span>
<span class="cm"> *	we don&#39;t update ic_offset until the end when we know exactly how many</span>
<span class="cm"> *	bytes have been written out.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xlog_write</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">log_vector</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">ticket</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>		<span class="o">*</span><span class="n">start_lsn</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">**</span><span class="n">commit_iclog</span><span class="p">,</span>
	<span class="n">uint</span>			<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">*</span><span class="n">iclog</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_log_iovec</span>	<span class="o">*</span><span class="n">vecp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">lv</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">partial_copy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">partial_copy_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">contwr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">record_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">data_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="o">*</span><span class="n">start_lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">xlog_write_calc_vec_length</span><span class="p">(</span><span class="n">ticket</span><span class="p">,</span> <span class="n">log_vector</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Region headers and bytes are already accounted for.</span>
<span class="cm">	 * We only need to take into account start records and</span>
<span class="cm">	 * split regions in this function.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_TIC_INITED</span><span class="p">)</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Commit record headers need to be accounted for. These</span>
<span class="cm">	 * come in as separate writes so are easy to detect.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XLOG_COMMIT_TRANS</span> <span class="o">|</span> <span class="n">XLOG_UNMOUNT_TRANS</span><span class="p">))</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">xlog_print_tic_res</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">ticket</span><span class="p">);</span>

	<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lv</span> <span class="o">=</span> <span class="n">log_vector</span><span class="p">;</span>
	<span class="n">vecp</span> <span class="o">=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_iovecp</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lv</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_niovecs</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span>		<span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">log_offset</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_state_get_iclog_space</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iclog</span><span class="p">,</span> <span class="n">ticket</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">contwr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log_offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="n">log_offset</span> <span class="o">&lt;=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_datap</span> <span class="o">+</span> <span class="n">log_offset</span><span class="p">;</span>

		<span class="cm">/* start_lsn is the first lsn written to. That&#39;s all we need. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">start_lsn</span><span class="p">)</span>
			<span class="o">*</span><span class="n">start_lsn</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_lsn</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * This loop writes out as many regions as can fit in the amount</span>
<span class="cm">		 * of space which was allocated by xlog_state_get_iclog_space().</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">lv</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_niovecs</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">xfs_log_iovec</span>	<span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vecp</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">xlog_op_header</span>	<span class="o">*</span><span class="n">ophdr</span><span class="p">;</span>
			<span class="kt">int</span>			<span class="n">start_rec_copy</span><span class="p">;</span>
			<span class="kt">int</span>			<span class="n">copy_len</span><span class="p">;</span>
			<span class="kt">int</span>			<span class="n">copy_off</span><span class="p">;</span>

			<span class="n">ASSERT</span><span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">i_len</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__int32_t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__int32_t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">start_rec_copy</span> <span class="o">=</span> <span class="n">xlog_write_start_rec</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">ticket</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">start_rec_copy</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">record_cnt</span><span class="o">++</span><span class="p">;</span>
				<span class="n">xlog_write_adv_cnt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log_offset</span><span class="p">,</span>
						   <span class="n">start_rec_copy</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">ophdr</span> <span class="o">=</span> <span class="n">xlog_write_setup_ophdr</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ticket</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ophdr</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

			<span class="n">xlog_write_adv_cnt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log_offset</span><span class="p">,</span>
					   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xlog_op_header</span><span class="p">));</span>

			<span class="n">len</span> <span class="o">+=</span> <span class="n">xlog_write_setup_copy</span><span class="p">(</span><span class="n">ticket</span><span class="p">,</span> <span class="n">ophdr</span><span class="p">,</span>
						     <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_size</span><span class="o">-</span><span class="n">log_offset</span><span class="p">,</span>
						     <span class="n">reg</span><span class="o">-&gt;</span><span class="n">i_len</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">copy_off</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">copy_len</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">partial_copy</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">partial_copy_len</span><span class="p">);</span>
			<span class="n">xlog_verify_dest_ptr</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

			<span class="cm">/* copy region */</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">copy_len</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">i_addr</span> <span class="o">+</span> <span class="n">copy_off</span><span class="p">,</span> <span class="n">copy_len</span><span class="p">);</span>
			<span class="n">xlog_write_adv_cnt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log_offset</span><span class="p">,</span> <span class="n">copy_len</span><span class="p">);</span>

			<span class="n">copy_len</span> <span class="o">+=</span> <span class="n">start_rec_copy</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">);</span>
			<span class="n">record_cnt</span><span class="o">++</span><span class="p">;</span>
			<span class="n">data_cnt</span> <span class="o">+=</span> <span class="n">contwr</span> <span class="o">?</span> <span class="n">copy_len</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_write_copy_finish</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">record_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_cnt</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">partial_copy</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">partial_copy_len</span><span class="p">,</span>
						       <span class="n">log_offset</span><span class="p">,</span>
						       <span class="n">commit_iclog</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * if we had a partial copy, we need to get more iclog</span>
<span class="cm">			 * space but we don&#39;t want to increment the region</span>
<span class="cm">			 * index because there is still more is this region to</span>
<span class="cm">			 * write.</span>
<span class="cm">			 *</span>
<span class="cm">			 * If we completed writing this region, and we flushed</span>
<span class="cm">			 * the iclog (indicated by resetting of the record</span>
<span class="cm">			 * count), then we also need to get more log space. If</span>
<span class="cm">			 * this was the last record, though, we are done and</span>
<span class="cm">			 * can just return.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">partial_copy</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">index</span> <span class="o">==</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_niovecs</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lv</span> <span class="o">=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_next</span><span class="p">;</span>
				<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lv</span><span class="p">)</span>
					<span class="n">vecp</span> <span class="o">=</span> <span class="n">lv</span><span class="o">-&gt;</span><span class="n">lv_iovecp</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">record_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lv</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">xlog_state_finish_copy</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="n">record_cnt</span><span class="p">,</span> <span class="n">data_cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">commit_iclog</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">xlog_state_release_iclog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XLOG_COMMIT_TRANS</span><span class="p">);</span>
	<span class="o">*</span><span class="n">commit_iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *		State Machine functions</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************</span>
<span class="cm"> */</span>

<span class="cm">/* Clean iclogs starting from the head.  This ordering must be</span>
<span class="cm"> * maintained, so an iclog doesn&#39;t become ACTIVE beyond one that</span>
<span class="cm"> * is SYNCING.  This is also required to maintain the notion that we use</span>
<span class="cm"> * a ordered wait queue to hold off would be writers to the log when every</span>
<span class="cm"> * iclog is trying to sync to disk.</span>
<span class="cm"> *</span>
<span class="cm"> * State Change: DIRTY -&gt; ACTIVE</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_state_clean_log</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_in_core_t</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_DIRTY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span>	<span class="o">=</span> <span class="n">XLOG_STATE_ACTIVE</span><span class="p">;</span>
			<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the number of ops in this iclog indicate it just</span>
<span class="cm">			 * contains the dummy transaction, we can</span>
<span class="cm">			 * change state into IDLE (the second time around).</span>
<span class="cm">			 * Otherwise we should change the state into</span>
<span class="cm">			 * NEED a dummy.</span>
<span class="cm">			 * We don&#39;t need to cover the dummy.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">changed</span> <span class="o">&amp;&amp;</span>
			   <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_num_logops</span><span class="p">)</span> <span class="o">==</span>
			   		<span class="n">XLOG_COVER_OPS</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We have two dirty iclogs so start over</span>
<span class="cm">				 * This could also be num of ops indicates</span>
<span class="cm">				 * this is not the dummy going out.</span>
<span class="cm">				 */</span>
				<span class="n">changed</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_num_logops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_cycle_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_cycle_data</span><span class="p">));</span>
			<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_ACTIVE</span><span class="p">)</span>
			<span class="cm">/* do nothing */</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* stop cleaning */</span>
		<span class="n">iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iclog</span> <span class="o">!=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">);</span>

	<span class="cm">/* log is locked when we are called */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Change state for the dummy log recording.</span>
<span class="cm">	 * We usually go to NEED. But we go to NEED2 if the changed indicates</span>
<span class="cm">	 * we are done writing the dummy record.</span>
<span class="cm">	 * If we are done with the second dummy recored (DONE2), then</span>
<span class="cm">	 * we go to IDLE.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">changed</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_covered_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">XLOG_STATE_COVER_IDLE</span>:
		<span class="k">case</span> <span class="n">XLOG_STATE_COVER_NEED</span>:
		<span class="k">case</span> <span class="n">XLOG_STATE_COVER_NEED2</span>:
			<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_covered_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_COVER_NEED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">XLOG_STATE_COVER_DONE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">changed</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_covered_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_COVER_NEED2</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_covered_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_COVER_NEED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">XLOG_STATE_COVER_DONE2</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">changed</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_covered_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_COVER_IDLE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_covered_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_COVER_NEED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>	<span class="cm">/* xlog_state_clean_log */</span>

<span class="n">STATIC</span> <span class="n">xfs_lsn_t</span>
<span class="nf">xlog_get_lowest_lsn</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_in_core_t</span>  <span class="o">*</span><span class="n">lsn_log</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>	<span class="n">lowest_lsn</span><span class="p">,</span> <span class="n">lsn</span><span class="p">;</span>

	<span class="n">lsn_log</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
	<span class="n">lowest_lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lsn_log</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XLOG_STATE_ACTIVE</span><span class="o">|</span><span class="n">XLOG_STATE_DIRTY</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">lsn</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">lsn_log</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_lsn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">lsn</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lowest_lsn</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">XFS_LSN_CMP</span><span class="p">(</span><span class="n">lsn</span><span class="p">,</span> <span class="n">lowest_lsn</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lowest_lsn</span> <span class="o">=</span> <span class="n">lsn</span><span class="p">;</span>
		<span class="p">}</span>
	    <span class="p">}</span>
	    <span class="n">lsn_log</span> <span class="o">=</span> <span class="n">lsn_log</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">lsn_log</span> <span class="o">!=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lowest_lsn</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_state_do_callback</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">aborted</span><span class="p">,</span>
	<span class="n">xlog_in_core_t</span>	<span class="o">*</span><span class="n">ciclog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_in_core_t</span>	   <span class="o">*</span><span class="n">iclog</span><span class="p">;</span>
	<span class="n">xlog_in_core_t</span>	   <span class="o">*</span><span class="n">first_iclog</span><span class="p">;</span>	<span class="cm">/* used to know when we&#39;ve</span>
<span class="cm">						 * processed all iclogs once */</span>
	<span class="n">xfs_log_callback_t</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="o">*</span><span class="n">cb_next</span><span class="p">;</span>
	<span class="kt">int</span>		   <span class="n">flushcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>	   <span class="n">lowest_lsn</span><span class="p">;</span>
	<span class="kt">int</span>		   <span class="n">ioerrors</span><span class="p">;</span>	<span class="cm">/* counter: iclogs with errors */</span>
	<span class="kt">int</span>		   <span class="n">loopdidcallbacks</span><span class="p">;</span> <span class="cm">/* flag: inner loop did callbacks*/</span>
	<span class="kt">int</span>		   <span class="n">funcdidcallbacks</span><span class="p">;</span> <span class="cm">/* flag: function did callbacks */</span>
	<span class="kt">int</span>		   <span class="n">repeats</span><span class="p">;</span>	<span class="cm">/* for issuing console warnings if</span>
<span class="cm">					 * looping too many times */</span>
	<span class="kt">int</span>		   <span class="n">wake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
	<span class="n">first_iclog</span> <span class="o">=</span> <span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
	<span class="n">ioerrors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">funcdidcallbacks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">repeats</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Scan all iclogs starting with the one pointed to by the</span>
<span class="cm">		 * log.  Reset this starting point each time the log is</span>
<span class="cm">		 * unlocked (during callbacks).</span>
<span class="cm">		 *</span>
<span class="cm">		 * Keep looping through iclogs until one full pass is made</span>
<span class="cm">		 * without running any callbacks.</span>
<span class="cm">		 */</span>
		<span class="n">first_iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
		<span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
		<span class="n">loopdidcallbacks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">repeats</span><span class="o">++</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>

			<span class="cm">/* skip all iclogs in the ACTIVE &amp; DIRTY states */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span>
			    <span class="p">(</span><span class="n">XLOG_STATE_ACTIVE</span><span class="o">|</span><span class="n">XLOG_STATE_DIRTY</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Between marking a filesystem SHUTDOWN and stopping</span>
<span class="cm">			 * the log, we do flush all iclogs to disk (if there</span>
<span class="cm">			 * wasn&#39;t a log I/O error). So, we do want things to</span>
<span class="cm">			 * go smoothly in case of just a SHUTDOWN  w/o a</span>
<span class="cm">			 * LOG_IO_ERROR.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Can only perform callbacks in order.  Since</span>
<span class="cm">				 * this iclog is not in the DONE_SYNC/</span>
<span class="cm">				 * DO_CALLBACK state, we skip the rest and</span>
<span class="cm">				 * just try to clean up.  If we set our iclog</span>
<span class="cm">				 * to DO_CALLBACK, we will not process it when</span>
<span class="cm">				 * we retry since a previous iclog is in the</span>
<span class="cm">				 * CALLBACK and the state cannot change since</span>
<span class="cm">				 * we are holding the l_icloglock.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span>
					<span class="p">(</span><span class="n">XLOG_STATE_DONE_SYNC</span> <span class="o">|</span>
						 <span class="n">XLOG_STATE_DO_CALLBACK</span><span class="p">)))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">ciclog</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ciclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span>
							<span class="n">XLOG_STATE_DONE_SYNC</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">ciclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_DO_CALLBACK</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/*</span>
<span class="cm">				 * We now have an iclog that is in either the</span>
<span class="cm">				 * DO_CALLBACK or DONE_SYNC states. The other</span>
<span class="cm">				 * states (WANT_SYNC, SYNCING, or CALLBACK were</span>
<span class="cm">				 * caught by the above if and are going to</span>
<span class="cm">				 * clean (i.e. we aren&#39;t doing their callbacks)</span>
<span class="cm">				 * see the above if.</span>
<span class="cm">				 */</span>

				<span class="cm">/*</span>
<span class="cm">				 * We will do one more check here to see if we</span>
<span class="cm">				 * have chased our tail around.</span>
<span class="cm">				 */</span>

				<span class="n">lowest_lsn</span> <span class="o">=</span> <span class="n">xlog_get_lowest_lsn</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lowest_lsn</span> <span class="o">&amp;&amp;</span>
				    <span class="n">XFS_LSN_CMP</span><span class="p">(</span><span class="n">lowest_lsn</span><span class="p">,</span>
						<span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_lsn</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span> <span class="cm">/* Leave this iclog for</span>
<span class="cm">						   * another thread */</span>
				<span class="p">}</span>

				<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_CALLBACK</span><span class="p">;</span>


				<span class="cm">/*</span>
<span class="cm">				 * update the last_sync_lsn before we drop the</span>
<span class="cm">				 * icloglock to ensure we are the only one that</span>
<span class="cm">				 * can update it.</span>
<span class="cm">				 */</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_LSN_CMP</span><span class="p">(</span><span class="n">atomic64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_last_sync_lsn</span><span class="p">),</span>
					<span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_lsn</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">atomic64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_last_sync_lsn</span><span class="p">,</span>
					<span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_lsn</span><span class="p">));</span>

			<span class="p">}</span> <span class="k">else</span>
				<span class="n">ioerrors</span><span class="o">++</span><span class="p">;</span>

			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Keep processing entries in the callback list until</span>
<span class="cm">			 * we come around and it is empty.  We need to</span>
<span class="cm">			 * atomically see that the list is empty and change the</span>
<span class="cm">			 * state to DIRTY so that we don&#39;t miss any more</span>
<span class="cm">			 * callbacks being added.</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback_lock</span><span class="p">);</span>
			<span class="n">cb</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback_tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback</span><span class="p">);</span>
				<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback_lock</span><span class="p">);</span>

				<span class="cm">/* perform callbacks in the order given */</span>
				<span class="k">for</span> <span class="p">(;</span> <span class="n">cb</span><span class="p">;</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">cb_next</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">cb_next</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_next</span><span class="p">;</span>
					<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_func</span><span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_arg</span><span class="p">,</span> <span class="n">aborted</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback_lock</span><span class="p">);</span>
				<span class="n">cb</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">loopdidcallbacks</span><span class="o">++</span><span class="p">;</span>
			<span class="n">funcdidcallbacks</span><span class="o">++</span><span class="p">;</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">))</span>
				<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_DIRTY</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Transition from DIRTY to ACTIVE if applicable.</span>
<span class="cm">			 * NOP if STATE_IOERROR.</span>
<span class="cm">			 */</span>
			<span class="n">xlog_state_clean_log</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>

			<span class="cm">/* wake up threads waiting in xfs_log_force() */</span>
			<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_force_wait</span><span class="p">);</span>

			<span class="n">iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">first_iclog</span> <span class="o">!=</span> <span class="n">iclog</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">repeats</span> <span class="o">&gt;</span> <span class="mi">5000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">flushcnt</span> <span class="o">+=</span> <span class="n">repeats</span><span class="p">;</span>
			<span class="n">repeats</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span>
				<span class="s">&quot;%s: possible infinite loop (%d iterations)&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">flushcnt</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ioerrors</span> <span class="o">&amp;&amp;</span> <span class="n">loopdidcallbacks</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * make one last gasp attempt to see if iclogs are being left in</span>
<span class="cm">	 * limbo..</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">funcdidcallbacks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">first_iclog</span> <span class="o">=</span> <span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">!=</span> <span class="n">XLOG_STATE_DO_CALLBACK</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Terminate the loop if iclogs are found in states</span>
<span class="cm">			 * which will cause other threads to clean up iclogs.</span>
<span class="cm">			 *</span>
<span class="cm">			 * SYNCING - i/o completion will go through logs</span>
<span class="cm">			 * DONE_SYNC - interrupt thread should be waiting for</span>
<span class="cm">			 *              l_icloglock</span>
<span class="cm">			 * IOERROR - give up hope all ye who enter here</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_WANT_SYNC</span> <span class="o">||</span>
			    <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_SYNCING</span> <span class="o">||</span>
			    <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_DONE_SYNC</span> <span class="o">||</span>
			    <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_IOERROR</span> <span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">first_iclog</span> <span class="o">!=</span> <span class="n">iclog</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XLOG_STATE_ACTIVE</span><span class="o">|</span><span class="n">XLOG_STATE_IOERROR</span><span class="p">))</span>
		<span class="n">wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wake</span><span class="p">)</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flush_wait</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Finish transitioning this iclog to the dirty state.</span>
<span class="cm"> *</span>
<span class="cm"> * Make sure that we completely execute this routine only when this is</span>
<span class="cm"> * the last call to the iclog.  There is a good chance that iclog flushes,</span>
<span class="cm"> * when we reach the end of the physical log, get turned into 2 separate</span>
<span class="cm"> * calls to bwrite.  Hence, one iclog flush could generate two calls to this</span>
<span class="cm"> * routine.  By using the reference count bwritecnt, we guarantee that only</span>
<span class="cm"> * the second completion goes through.</span>
<span class="cm"> *</span>
<span class="cm"> * Callbacks could take time, so they are done outside the scope of the</span>
<span class="cm"> * global state machine log lock.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_state_done_syncing</span><span class="p">(</span>
	<span class="n">xlog_in_core_t</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">aborted</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_t</span>		   <span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_log</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_SYNCING</span> <span class="o">||</span>
	       <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_refcnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_bwritecnt</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_bwritecnt</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>


	<span class="cm">/*</span>
<span class="cm">	 * If we got an error, either on the first buffer, or in the case of</span>
<span class="cm">	 * split log writes, on the second, we mark ALL iclogs STATE_IOERROR,</span>
<span class="cm">	 * and none should ever be attempted to be written to disk</span>
<span class="cm">	 * again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">!=</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_bwritecnt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_DONE_SYNC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Someone could be sleeping prior to writing out the next</span>
<span class="cm">	 * iclog buffer, we wake them all, one will get to do the</span>
<span class="cm">	 * I/O, the others get to wait for the result.</span>
<span class="cm">	 */</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_write_wait</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
	<span class="n">xlog_state_do_callback</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">aborted</span><span class="p">,</span> <span class="n">iclog</span><span class="p">);</span>	<span class="cm">/* also cleans log */</span>
<span class="p">}</span>	<span class="cm">/* xlog_state_done_syncing */</span>


<span class="cm">/*</span>
<span class="cm"> * If the head of the in-core log ring is not (ACTIVE or DIRTY), then we must</span>
<span class="cm"> * sleep.  We wait on the flush queue on the head iclog as that should be</span>
<span class="cm"> * the first iclog to complete flushing. Hence if all iclogs are syncing,</span>
<span class="cm"> * we will wait here and all new writes will sleep until a sync completes.</span>
<span class="cm"> *</span>
<span class="cm"> * The in-core logs are used in a circular fashion. They are not used</span>
<span class="cm"> * out-of-order even when an iclog past the head is free.</span>
<span class="cm"> *</span>
<span class="cm"> * return:</span>
<span class="cm"> *	* log_offset where xlog_write() can start writing into the in-core</span>
<span class="cm"> *		log&#39;s data space.</span>
<span class="cm"> *	* in-core log pointer to which xlog_write() should write.</span>
<span class="cm"> *	* boolean indicating this is a continued write to an in-core log.</span>
<span class="cm"> *		If this is the last write, then the in-core log&#39;s offset field</span>
<span class="cm"> *		needs to be incremented, depending on the amount of data which</span>
<span class="cm"> *		is copied.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_state_get_iclog_space</span><span class="p">(</span><span class="n">xlog_t</span>	  <span class="o">*</span><span class="n">log</span><span class="p">,</span>
			   <span class="kt">int</span>		  <span class="n">len</span><span class="p">,</span>
			   <span class="n">xlog_in_core_t</span> <span class="o">**</span><span class="n">iclogp</span><span class="p">,</span>
			   <span class="n">xlog_ticket_t</span>  <span class="o">*</span><span class="n">ticket</span><span class="p">,</span>
			   <span class="kt">int</span>		  <span class="o">*</span><span class="n">continued_write</span><span class="p">,</span>
			   <span class="kt">int</span>		  <span class="o">*</span><span class="n">logoffsetp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		  <span class="n">log_offset</span><span class="p">;</span>
	<span class="n">xlog_rec_header_t</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="n">xlog_in_core_t</span>	  <span class="o">*</span><span class="n">iclog</span><span class="p">;</span>
	<span class="kt">int</span>		  <span class="n">error</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XLOG_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">log</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">!=</span> <span class="n">XLOG_STATE_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_log_noiclogs</span><span class="p">);</span>

		<span class="cm">/* Wait for log writes to have flushed */</span>
		<span class="n">xlog_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flush_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_refcnt</span><span class="p">);</span>	<span class="cm">/* prevents sync */</span>
	<span class="n">log_offset</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span><span class="p">;</span>

	<span class="cm">/* On the 1st write to an iclog, figure out lsn.  This works</span>
<span class="cm">	 * if iclogs marked XLOG_STATE_WANT_SYNC always write out what they are</span>
<span class="cm">	 * committing to.  If the offset is set, that&#39;s how many blocks</span>
<span class="cm">	 * must be written.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">log_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">-=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span><span class="p">;</span>
		<span class="n">xlog_tic_add_region</span><span class="p">(</span><span class="n">ticket</span><span class="p">,</span>
				    <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span><span class="p">,</span>
				    <span class="n">XLOG_REG_TYPE_LRHEADER</span><span class="p">);</span>
		<span class="n">head</span><span class="o">-&gt;</span><span class="n">h_cycle</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span><span class="p">);</span>
		<span class="n">head</span><span class="o">-&gt;</span><span class="n">h_lsn</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span>
			<span class="n">xlog_assign_lsn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_block</span><span class="p">));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_block</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If there is enough room to write everything, then do it.  Otherwise,</span>
<span class="cm">	 * claim the rest of the region and make sure the XLOG_STATE_WANT_SYNC</span>
<span class="cm">	 * bit is on, so this will get flushed out.  Don&#39;t update ic_offset</span>
<span class="cm">	 * until you know exactly how many bytes get copied.  Therefore, wait</span>
<span class="cm">	 * until later to update ic_offset.</span>
<span class="cm">	 *</span>
<span class="cm">	 * xlog_write() algorithm assumes that at least 2 xlog_op_header_t&#39;s</span>
<span class="cm">	 * can fit into remaining data section.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_size</span> <span class="o">-</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xlog_state_switch_iclogs</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_size</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If I&#39;m the only one writing to this iclog, sync it to disk.</span>
<span class="cm">		 * We need to do an atomic compare and decrement here to avoid</span>
<span class="cm">		 * racing with concurrent atomic_dec_and_lock() calls in</span>
<span class="cm">		 * xlog_state_release_iclog() when there is more than one</span>
<span class="cm">		 * reference to the iclog.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_refcnt</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* we are the only one */</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_state_release_iclog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do we have enough room to write the full amount in the remainder</span>
<span class="cm">	 * of this iclog?  Or must we continue a write on the next iclog and</span>
<span class="cm">	 * mark this iclog as completely taken?  In the case where we switch</span>
<span class="cm">	 * iclogs (to mark it taken), this particular iclog will release/sync</span>
<span class="cm">	 * to disk in xlog_write().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_size</span> <span class="o">-</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">continued_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">continued_write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">xlog_state_switch_iclogs</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">iclogp</span> <span class="o">=</span> <span class="n">iclog</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span> <span class="o">&lt;=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_size</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>

	<span class="o">*</span><span class="n">logoffsetp</span> <span class="o">=</span> <span class="n">log_offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>	<span class="cm">/* xlog_state_get_iclog_space */</span>

<span class="cm">/* The first cnt-1 times through here we don&#39;t need to</span>
<span class="cm"> * move the grant write head because the permanent</span>
<span class="cm"> * reservation has reserved cnt times the unit amount.</span>
<span class="cm"> * Release part of current permanent unit reservation and</span>
<span class="cm"> * reset current reservation to be one units worth.  Also</span>
<span class="cm"> * move grant reservation head forward.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_regrant_reserve_log_space</span><span class="p">(</span><span class="n">xlog_t</span>	     <span class="o">*</span><span class="n">log</span><span class="p">,</span>
			       <span class="n">xlog_ticket_t</span> <span class="o">*</span><span class="n">ticket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xfs_log_regrant_reserve_enter</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">ticket</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_cnt</span><span class="o">--</span><span class="p">;</span>

	<span class="n">xlog_grant_sub_space</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">.</span><span class="n">grant</span><span class="p">,</span>
					<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span><span class="p">);</span>
	<span class="n">xlog_grant_sub_space</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">.</span><span class="n">grant</span><span class="p">,</span>
					<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span><span class="p">);</span>
	<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">=</span> <span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_unit_res</span><span class="p">;</span>
	<span class="n">xlog_tic_reset_res</span><span class="p">(</span><span class="n">ticket</span><span class="p">);</span>

	<span class="n">trace_xfs_log_regrant_reserve_sub</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">ticket</span><span class="p">);</span>

	<span class="cm">/* just return if we still have some of the pre-reserved space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">xlog_grant_add_space</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">.</span><span class="n">grant</span><span class="p">,</span>
					<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_unit_res</span><span class="p">);</span>

	<span class="n">trace_xfs_log_regrant_reserve_exit</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">ticket</span><span class="p">);</span>

	<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span> <span class="o">=</span> <span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_unit_res</span><span class="p">;</span>
	<span class="n">xlog_tic_reset_res</span><span class="p">(</span><span class="n">ticket</span><span class="p">);</span>
<span class="p">}</span>	<span class="cm">/* xlog_regrant_reserve_log_space */</span>


<span class="cm">/*</span>
<span class="cm"> * Give back the space left from a reservation.</span>
<span class="cm"> *</span>
<span class="cm"> * All the information we need to make a correct determination of space left</span>
<span class="cm"> * is present.  For non-permanent reservations, things are quite easy.  The</span>
<span class="cm"> * count should have been decremented to zero.  We only need to deal with the</span>
<span class="cm"> * space remaining in the current reservation part of the ticket.  If the</span>
<span class="cm"> * ticket contains a permanent reservation, there may be left over space which</span>
<span class="cm"> * needs to be released.  A count of N means that N-1 refills of the current</span>
<span class="cm"> * reservation can be done before we need to ask for more space.  The first</span>
<span class="cm"> * one goes to fill up the first current reservation.  Once we run out of</span>
<span class="cm"> * space, the count will stay at zero and the only space remaining will be</span>
<span class="cm"> * in the current reservation field.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_ungrant_log_space</span><span class="p">(</span><span class="n">xlog_t</span>	     <span class="o">*</span><span class="n">log</span><span class="p">,</span>
		       <span class="n">xlog_ticket_t</span> <span class="o">*</span><span class="n">ticket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">bytes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_cnt</span><span class="o">--</span><span class="p">;</span>

	<span class="n">trace_xfs_log_ungrant_enter</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">ticket</span><span class="p">);</span>
	<span class="n">trace_xfs_log_ungrant_sub</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">ticket</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a permanent reservation ticket, we may be able to free</span>
<span class="cm">	 * up more space based on the remaining count.</span>
<span class="cm">	 */</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_curr_res</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_TIC_PERM_RESERV</span><span class="p">);</span>
		<span class="n">bytes</span> <span class="o">+=</span> <span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_unit_res</span><span class="o">*</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_cnt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xlog_grant_sub_space</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">.</span><span class="n">grant</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="n">xlog_grant_sub_space</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">.</span><span class="n">grant</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>

	<span class="n">trace_xfs_log_ungrant_exit</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">ticket</span><span class="p">);</span>

	<span class="n">xfs_log_space_wake</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush iclog to disk if this is the last reference to the given iclog and</span>
<span class="cm"> * the WANT_SYNC bit is set.</span>
<span class="cm"> *</span>
<span class="cm"> * When this function is entered, the iclog is not necessarily in the</span>
<span class="cm"> * WANT_SYNC state.  It may be sitting around waiting to get filled.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_state_release_iclog</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xlog_in_core_t</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">sync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* do we sync? */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_refcnt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_refcnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_ACTIVE</span> <span class="o">||</span>
	       <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_WANT_SYNC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_WANT_SYNC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* update tail before writing to iclog */</span>
		<span class="n">xfs_lsn_t</span> <span class="n">tail_lsn</span> <span class="o">=</span> <span class="n">xlog_assign_tail_lsn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">);</span>
		<span class="n">sync</span><span class="o">++</span><span class="p">;</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_SYNCING</span><span class="p">;</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_tail_lsn</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">tail_lsn</span><span class="p">);</span>
		<span class="n">xlog_verify_tail_lsn</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="n">tail_lsn</span><span class="p">);</span>
		<span class="cm">/* cycle incremented when incrementing curr_block */</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We let the log lock go, so it&#39;s possible that we hit a log I/O</span>
<span class="cm">	 * error or some other SHUTDOWN condition that marks the iclog</span>
<span class="cm">	 * as XLOG_STATE_IOERROR before the bwrite. However, we know that</span>
<span class="cm">	 * this iclog has consistent data, so we ignore IOERROR</span>
<span class="cm">	 * flags after this point.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">xlog_sync</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>	<span class="cm">/* xlog_state_release_iclog */</span>


<span class="cm">/*</span>
<span class="cm"> * This routine will mark the current iclog in the ring as WANT_SYNC</span>
<span class="cm"> * and move the current iclog pointer to the next iclog in the ring.</span>
<span class="cm"> * When this routine is called from xlog_state_get_iclog_space(), the</span>
<span class="cm"> * exact size of the iclog has not yet been determined.  All we know is</span>
<span class="cm"> * that every data block.  We have run out of space in this log record.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_state_switch_iclogs</span><span class="p">(</span><span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
			 <span class="n">xlog_in_core_t</span> <span class="o">*</span><span class="n">iclog</span><span class="p">,</span>
			 <span class="kt">int</span>		<span class="n">eventual_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_ACTIVE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eventual_size</span><span class="p">)</span>
		<span class="n">eventual_size</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span><span class="p">;</span>
	<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_WANT_SYNC</span><span class="p">;</span>
	<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_prev_block</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_prev_block</span><span class="p">);</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_prev_block</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_block</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_prev_cycle</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span><span class="p">;</span>

	<span class="cm">/* roll log?: ic_offset changed later */</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_block</span> <span class="o">+=</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">eventual_size</span><span class="p">)</span><span class="o">+</span><span class="n">BTOBB</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span><span class="p">);</span>

	<span class="cm">/* Round up to next log-sunit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_haslogv2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_logsunit</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__uint32_t</span> <span class="n">sunit_bb</span> <span class="o">=</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_logsunit</span><span class="p">);</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_block</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_block</span><span class="p">,</span> <span class="n">sunit_bb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_block</span> <span class="o">&gt;=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span> <span class="o">==</span> <span class="n">XLOG_HEADER_MAGIC_NUM</span><span class="p">)</span>
			<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span><span class="o">++</span><span class="p">;</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_block</span> <span class="o">-=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_block</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">iclog</span> <span class="o">==</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">);</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
<span class="p">}</span>	<span class="cm">/* xlog_state_switch_iclogs */</span>

<span class="cm">/*</span>
<span class="cm"> * Write out all data in the in-core log as of this exact moment in time.</span>
<span class="cm"> *</span>
<span class="cm"> * Data may be written to the in-core log during this call.  However,</span>
<span class="cm"> * we don&#39;t guarantee this data will be written out.  A change from past</span>
<span class="cm"> * implementation means this routine will *not* write out zero length LRs.</span>
<span class="cm"> *</span>
<span class="cm"> * Basically, we try and perform an intelligent scan of the in-core logs.</span>
<span class="cm"> * If we determine there is no flushable data, we just return.  There is no</span>
<span class="cm"> * flushable data if:</span>
<span class="cm"> *</span>
<span class="cm"> *	1. the current iclog is active and has no data; the previous iclog</span>
<span class="cm"> *		is in the active or dirty state.</span>
<span class="cm"> *	2. the current iclog is drity, and the previous iclog is in the</span>
<span class="cm"> *		active or dirty state.</span>
<span class="cm"> *</span>
<span class="cm"> * We may sleep if:</span>
<span class="cm"> *</span>
<span class="cm"> *	1. the current iclog is not in the active nor dirty state.</span>
<span class="cm"> *	2. the current iclog dirty, and the previous iclog is not in the</span>
<span class="cm"> *		active nor dirty state.</span>
<span class="cm"> *	3. the current iclog is active, and there is another thread writing</span>
<span class="cm"> *		to this particular iclog.</span>
<span class="cm"> *	4. a) the current iclog is active and has no other writers</span>
<span class="cm"> *	   b) when we return from flushing out this iclog, it is still</span>
<span class="cm"> *		not in the active nor dirty state.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">_xfs_log_force</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">uint</span>			<span class="n">flags</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">log_flushed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">lsn</span><span class="p">;</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_log_force</span><span class="p">);</span>

	<span class="n">xlog_cil_force</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>

	<span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If the head iclog is not active nor dirty, we just attach</span>
<span class="cm">	 * ourselves to the head and go to sleep.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_ACTIVE</span> <span class="o">||</span>
	    <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_DIRTY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the head is dirty or (active and empty), then</span>
<span class="cm">		 * we need to look at the previous iclog.  If the previous</span>
<span class="cm">		 * iclog is active or dirty we are done.  There is nothing</span>
<span class="cm">		 * to sync out.  Otherwise, we attach ourselves to the</span>
<span class="cm">		 * previous iclog and go to sleep.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_DIRTY</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_refcnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
		     <span class="o">&amp;&amp;</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_prev</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_ACTIVE</span> <span class="o">||</span>
			    <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_DIRTY</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">no_sleep</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">goto</span> <span class="n">maybe_sleep</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_refcnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* We are the only one with access to this</span>
<span class="cm">				 * iclog.  Flush it out now.  There should</span>
<span class="cm">				 * be a roundoff of zero to show that someone</span>
<span class="cm">				 * has already taken care of the roundoff from</span>
<span class="cm">				 * the previous sync.</span>
<span class="cm">				 */</span>
				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_refcnt</span><span class="p">);</span>
				<span class="n">lsn</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_lsn</span><span class="p">);</span>
				<span class="n">xlog_state_switch_iclogs</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">xlog_state_release_iclog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">log_flushed</span><span class="p">)</span>
					<span class="o">*</span><span class="n">log_flushed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_lsn</span><span class="p">)</span> <span class="o">==</span> <span class="n">lsn</span> <span class="o">&amp;&amp;</span>
				    <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">!=</span> <span class="n">XLOG_STATE_DIRTY</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">maybe_sleep</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="k">goto</span> <span class="n">no_sleep</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Someone else is writing to this iclog.</span>
<span class="cm">				 * Use its call to flush out the data.  However,</span>
<span class="cm">				 * the other thread may not force out this LR,</span>
<span class="cm">				 * so we mark it WANT_SYNC.</span>
<span class="cm">				 */</span>
				<span class="n">xlog_state_switch_iclogs</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">maybe_sleep</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* By the time we come around again, the iclog could&#39;ve been filled</span>
<span class="cm">	 * which would give it another lsn.  If we have a new lsn, just</span>
<span class="cm">	 * return because the relevant data has been flushed.</span>
<span class="cm">	 */</span>
<span class="nl">maybe_sleep:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_LOG_SYNC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We must check if we&#39;re shutting down here, before</span>
<span class="cm">		 * we wait, while we&#39;re holding the l_icloglock.</span>
<span class="cm">		 * Then we check again after waking up, in case our</span>
<span class="cm">		 * sleep was disturbed by a bad news.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_log_force_sleep</span><span class="p">);</span>
		<span class="n">xlog_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_force_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * No need to grab the log lock here since we&#39;re</span>
<span class="cm">		 * only deciding whether or not to return EIO</span>
<span class="cm">		 * and the memory read should be atomic.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">log_flushed</span><span class="p">)</span>
			<span class="o">*</span><span class="n">log_flushed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

<span class="nl">no_sleep:</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wrapper for _xfs_log_force(), to be used when caller doesn&#39;t care</span>
<span class="cm"> * about errors or whether the log was flushed or not. This is the normal</span>
<span class="cm"> * interface to use when trying to unpin items or move the log forward.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_log_force</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">uint</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">error</span><span class="p">;</span>

	<span class="n">trace_xfs_log_force</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">_xfs_log_force</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: error %d returned.&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Force the in-core log to disk for a specific LSN.</span>
<span class="cm"> *</span>
<span class="cm"> * Find in-core log with lsn.</span>
<span class="cm"> *	If it is in the DIRTY state, just return.</span>
<span class="cm"> *	If it is in the ACTIVE state, move the in-core log into the WANT_SYNC</span>
<span class="cm"> *		state and go to sleep or return.</span>
<span class="cm"> *	If it is in any other state, go to sleep or return.</span>
<span class="cm"> *</span>
<span class="cm"> * Synchronous forces are implemented with a signal variable. All callers</span>
<span class="cm"> * to force a given lsn to disk will wait on a the sv attached to the</span>
<span class="cm"> * specific in-core log.  When given in-core log finally completes its</span>
<span class="cm"> * write to disk, that thread will wake up all threads waiting on the</span>
<span class="cm"> * sv.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">_xfs_log_force_lsn</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">lsn</span><span class="p">,</span>
	<span class="n">uint</span>			<span class="n">flags</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">log_flushed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">already_slept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">lsn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_log_force</span><span class="p">);</span>

	<span class="n">lsn</span> <span class="o">=</span> <span class="n">xlog_cil_force_lsn</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">lsn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lsn</span> <span class="o">==</span> <span class="n">NULLCOMMITLSN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">try_again:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
	<span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_lsn</span><span class="p">)</span> <span class="o">!=</span> <span class="n">lsn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_DIRTY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We sleep here if we haven&#39;t already slept (e.g.</span>
<span class="cm">			 * this is the first time we&#39;ve looked at the correct</span>
<span class="cm">			 * iclog buf) and the buffer before us is going to</span>
<span class="cm">			 * be sync&#39;ed. The reason for this is that if we</span>
<span class="cm">			 * are doing sync transactions here, by waiting for</span>
<span class="cm">			 * the previous I/O to complete, we can allow a few</span>
<span class="cm">			 * more transactions into this iclog before we close</span>
<span class="cm">			 * it down.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Otherwise, we mark the buffer WANT_SYNC, and bump</span>
<span class="cm">			 * up the refcnt so we can release the log (which</span>
<span class="cm">			 * drops the ref count).  The state switch keeps new</span>
<span class="cm">			 * transaction commits from using this buffer.  When</span>
<span class="cm">			 * the current commits finish writing into the buffer,</span>
<span class="cm">			 * the refcount will drop to zero and the buffer will</span>
<span class="cm">			 * go out then.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">already_slept</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_prev</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span>
			     <span class="p">(</span><span class="n">XLOG_STATE_WANT_SYNC</span> <span class="o">|</span> <span class="n">XLOG_STATE_SYNCING</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">));</span>

				<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_log_force_sleep</span><span class="p">);</span>

				<span class="n">xlog_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_prev</span><span class="o">-&gt;</span><span class="n">ic_write_wait</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">log_flushed</span><span class="p">)</span>
					<span class="o">*</span><span class="n">log_flushed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">already_slept</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">try_again</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_refcnt</span><span class="p">);</span>
			<span class="n">xlog_state_switch_iclogs</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xlog_state_release_iclog</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">log_flushed</span><span class="p">)</span>
				<span class="o">*</span><span class="n">log_flushed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_LOG_SYNC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="cm">/* sleep */</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span>
		      <span class="p">(</span><span class="n">XLOG_STATE_ACTIVE</span> <span class="o">|</span> <span class="n">XLOG_STATE_DIRTY</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Don&#39;t wait on completion if we know that we&#39;ve</span>
<span class="cm">			 * gotten a log write error.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_log_force_sleep</span><span class="p">);</span>
			<span class="n">xlog_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_force_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * No need to grab the log lock here since we&#39;re</span>
<span class="cm">			 * only deciding whether or not to return EIO</span>
<span class="cm">			 * and the memory read should be atomic.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">log_flushed</span><span class="p">)</span>
				<span class="o">*</span><span class="n">log_flushed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* just return */</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iclog</span> <span class="o">!=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wrapper for _xfs_log_force_lsn(), to be used when caller doesn&#39;t care</span>
<span class="cm"> * about errors or whether the log was flushed or not. This is the normal</span>
<span class="cm"> * interface to use when trying to unpin items or move the log forward.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_log_force_lsn</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>	<span class="n">lsn</span><span class="p">,</span>
	<span class="n">uint</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">error</span><span class="p">;</span>

	<span class="n">trace_xfs_log_force</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">lsn</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">_xfs_log_force_lsn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">lsn</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: error %d returned.&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when we want to mark the current iclog as being ready to sync to</span>
<span class="cm"> * disk.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_state_want_sync</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">xlog_in_core_t</span> <span class="o">*</span><span class="n">iclog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">==</span> <span class="n">XLOG_STATE_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xlog_state_switch_iclogs</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span>
			<span class="p">(</span><span class="n">XLOG_STATE_WANT_SYNC</span><span class="o">|</span><span class="n">XLOG_STATE_IOERROR</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *		TICKET functions</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Free a used ticket when its refcount falls to zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_log_ticket_put</span><span class="p">(</span>
	<span class="n">xlog_ticket_t</span>	<span class="o">*</span><span class="n">ticket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_ref</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_ref</span><span class="p">))</span>
		<span class="n">kmem_zone_free</span><span class="p">(</span><span class="n">xfs_log_ticket_zone</span><span class="p">,</span> <span class="n">ticket</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">xlog_ticket_t</span> <span class="o">*</span>
<span class="nf">xfs_log_ticket_get</span><span class="p">(</span>
	<span class="n">xlog_ticket_t</span>	<span class="o">*</span><span class="n">ticket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_ref</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ticket</span><span class="o">-&gt;</span><span class="n">t_ref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ticket</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate and initialise a new log ticket.</span>
<span class="cm"> */</span>
<span class="n">xlog_ticket_t</span> <span class="o">*</span>
<span class="nf">xlog_ticket_alloc</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">unit_bytes</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">cnt</span><span class="p">,</span>
	<span class="kt">char</span>		<span class="n">client</span><span class="p">,</span>
	<span class="n">bool</span>		<span class="n">permanent</span><span class="p">,</span>
	<span class="n">xfs_km_flags_t</span>	<span class="n">alloc_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span> <span class="o">*</span><span class="n">tic</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">num_headers</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">iclog_space</span><span class="p">;</span>

	<span class="n">tic</span> <span class="o">=</span> <span class="n">kmem_zone_zalloc</span><span class="p">(</span><span class="n">xfs_log_ticket_zone</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tic</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Permanent reservations have up to &#39;cnt&#39;-1 active log operations</span>
<span class="cm">	 * in the log.  A unit in this case is the amount of space for one</span>
<span class="cm">	 * of these log operations.  Normal reservations have a cnt of 1</span>
<span class="cm">	 * and their unit amount is the total amount of space required.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The following lines of code account for non-transaction data</span>
<span class="cm">	 * which occupy space in the on-disk log.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Normal form of a transaction is:</span>
<span class="cm">	 * &lt;oph&gt;&lt;trans-hdr&gt;&lt;start-oph&gt;&lt;reg1-oph&gt;&lt;reg1&gt;&lt;reg2-oph&gt;...&lt;commit-oph&gt;</span>
<span class="cm">	 * and then there are LR hdrs, split-recs and roundoff at end of syncs.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need to account for all the leadup data and trailer data</span>
<span class="cm">	 * around the transaction data.</span>
<span class="cm">	 * And then we need to account for the worst case in terms of using</span>
<span class="cm">	 * more space.</span>
<span class="cm">	 * The worst case will happen if:</span>
<span class="cm">	 * - the placement of the transaction happens to be such that the</span>
<span class="cm">	 *   roundoff is at its maximum</span>
<span class="cm">	 * - the transaction data is synced before the commit record is synced</span>
<span class="cm">	 *   i.e. &lt;transaction-data&gt;&lt;roundoff&gt; | &lt;commit-rec&gt;&lt;roundoff&gt;</span>
<span class="cm">	 *   Therefore the commit record is in its own Log Record.</span>
<span class="cm">	 *   This can happen as the commit record is called with its</span>
<span class="cm">	 *   own region to xlog_write().</span>
<span class="cm">	 *   This then means that in the worst case, roundoff can happen for</span>
<span class="cm">	 *   the commit-rec as well.</span>
<span class="cm">	 *   The commit-rec is smaller than padding in this scenario and so it is</span>
<span class="cm">	 *   not added separately.</span>
<span class="cm">	 */</span>

	<span class="cm">/* for trans header */</span>
	<span class="n">unit_bytes</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">);</span>
	<span class="n">unit_bytes</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_trans_header_t</span><span class="p">);</span>

	<span class="cm">/* for start-rec */</span>
	<span class="n">unit_bytes</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * for LR headers - the space for data in an iclog is the size minus</span>
<span class="cm">	 * the space used for the headers. If we use the iclog size, then we</span>
<span class="cm">	 * undercalculate the number of headers required.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Furthermore - the addition of op headers for split-recs might</span>
<span class="cm">	 * increase the space required enough to require more log and op</span>
<span class="cm">	 * headers, so take that into account too.</span>
<span class="cm">	 *</span>
<span class="cm">	 * IMPORTANT: This reservation makes the assumption that if this</span>
<span class="cm">	 * transaction is the first in an iclog and hence has the LR headers</span>
<span class="cm">	 * accounted to it, then the remaining space in the iclog is</span>
<span class="cm">	 * exclusively for this transaction.  i.e. if the transaction is larger</span>
<span class="cm">	 * than the iclog, it will be the only thing in that iclog.</span>
<span class="cm">	 * Fundamentally, this means we must pass the entire log vector to</span>
<span class="cm">	 * xlog_write to guarantee this.</span>
<span class="cm">	 */</span>
	<span class="n">iclog_space</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_size</span> <span class="o">-</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span><span class="p">;</span>
	<span class="n">num_headers</span> <span class="o">=</span> <span class="n">howmany</span><span class="p">(</span><span class="n">unit_bytes</span><span class="p">,</span> <span class="n">iclog_space</span><span class="p">);</span>

	<span class="cm">/* for split-recs - ophdrs added when data split over LRs */</span>
	<span class="n">unit_bytes</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_headers</span><span class="p">;</span>

	<span class="cm">/* add extra header reservations if we overrun */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">num_headers</span> <span class="o">||</span>
	       <span class="n">howmany</span><span class="p">(</span><span class="n">unit_bytes</span><span class="p">,</span> <span class="n">iclog_space</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">num_headers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unit_bytes</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">);</span>
		<span class="n">num_headers</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">unit_bytes</span> <span class="o">+=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span> <span class="o">*</span> <span class="n">num_headers</span><span class="p">;</span>

	<span class="cm">/* for commit-rec LR header - note: padding will subsume the ophdr */</span>
	<span class="n">unit_bytes</span> <span class="o">+=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span><span class="p">;</span>

	<span class="cm">/* for roundoff padding for transaction data and one for commit record */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_haslogv2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_logsunit</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* log su roundoff */</span>
		<span class="n">unit_bytes</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_logsunit</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* BB roundoff */</span>
		<span class="n">unit_bytes</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">BBSIZE</span><span class="p">;</span>
        <span class="p">}</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_ref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_task</span>		<span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_queue</span><span class="p">);</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_unit_res</span>		<span class="o">=</span> <span class="n">unit_bytes</span><span class="p">;</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_curr_res</span>		<span class="o">=</span> <span class="n">unit_bytes</span><span class="p">;</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_cnt</span>		<span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_ocnt</span>		<span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_tid</span>		<span class="o">=</span> <span class="n">random32</span><span class="p">();</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_clientid</span>		<span class="o">=</span> <span class="n">client</span><span class="p">;</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_flags</span>		<span class="o">=</span> <span class="n">XLOG_TIC_INITED</span><span class="p">;</span>
	<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_trans_type</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">permanent</span><span class="p">)</span>
		<span class="n">tic</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">|=</span> <span class="n">XLOG_TIC_PERM_RESERV</span><span class="p">;</span>

	<span class="n">xlog_tic_reset_res</span><span class="p">(</span><span class="n">tic</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tic</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *		Log debug routines</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> */</span>
<span class="cp">#if defined(DEBUG)</span>
<span class="cm">/*</span>
<span class="cm"> * Make sure that the destination ptr is within the valid data region of</span>
<span class="cm"> * one of the iclogs.  This uses backup pointers stored in a different</span>
<span class="cm"> * part of the log in case we trash the log structure.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xlog_verify_dest_ptr</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">good_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_bufs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&gt;=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_bak</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ptr</span> <span class="o">&lt;=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_bak</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_size</span><span class="p">)</span>
			<span class="n">good_ptr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">good_ptr</span><span class="p">)</span>
		<span class="n">xfs_emerg</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: invalid ptr&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check to make sure the grant write head didn&#39;t just over lap the tail.  If</span>
<span class="cm"> * the cycles are the same, we can&#39;t be overlapping.  Otherwise, make sure that</span>
<span class="cm"> * the cycles differ by exactly one and check the byte count.</span>
<span class="cm"> *</span>
<span class="cm"> * This check is run unlocked, so can give false positives. Rather than assert</span>
<span class="cm"> * on failures, use a warn-once flag and a panic tag to allow the admin to</span>
<span class="cm"> * determine if they want to panic the machine when such an error occurs. For</span>
<span class="cm"> * debug kernels this will have the same effect as using an assert but, unlinke</span>
<span class="cm"> * an assert, it can be turned off at runtime.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_verify_grant_tail</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">tail_cycle</span><span class="p">,</span> <span class="n">tail_blocks</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">cycle</span><span class="p">,</span> <span class="n">space</span><span class="p">;</span>

	<span class="n">xlog_crack_grant_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">.</span><span class="n">grant</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cycle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">space</span><span class="p">);</span>
	<span class="n">xlog_crack_atomic_lsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_tail_lsn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail_cycle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail_blocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tail_cycle</span> <span class="o">!=</span> <span class="n">cycle</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cycle</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">tail_cycle</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_TAIL_WARN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_alert_tag</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">XFS_PTAG_LOGRES</span><span class="p">,</span>
				<span class="s">&quot;%s: cycle - 1 != tail_cycle&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flags</span> <span class="o">|=</span> <span class="n">XLOG_TAIL_WARN</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">&gt;</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">tail_blocks</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_TAIL_WARN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_alert_tag</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">XFS_PTAG_LOGRES</span><span class="p">,</span>
				<span class="s">&quot;%s: space &gt; BBTOB(tail_blocks)&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flags</span> <span class="o">|=</span> <span class="n">XLOG_TAIL_WARN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* check if it will fit */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_verify_tail_lsn</span><span class="p">(</span><span class="n">xlog_t</span>	    <span class="o">*</span><span class="n">log</span><span class="p">,</span>
		     <span class="n">xlog_in_core_t</span> <span class="o">*</span><span class="n">iclog</span><span class="p">,</span>
		     <span class="n">xfs_lsn_t</span>	    <span class="n">tail_lsn</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">blocks</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">CYCLE_LSN</span><span class="p">(</span><span class="n">tail_lsn</span><span class="p">)</span> <span class="o">==</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_prev_cycle</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">blocks</span> <span class="o">=</span>
	    <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span> <span class="o">-</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_prev_block</span> <span class="o">-</span> <span class="n">BLOCK_LSN</span><span class="p">(</span><span class="n">tail_lsn</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&lt;</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span><span class="p">)</span><span class="o">+</span><span class="n">BTOBB</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_hsize</span><span class="p">))</span>
		<span class="n">xfs_emerg</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: ran out of log space&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">CYCLE_LSN</span><span class="p">(</span><span class="n">tail_lsn</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_prev_cycle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BLOCK_LSN</span><span class="p">(</span><span class="n">tail_lsn</span><span class="p">)</span> <span class="o">==</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_prev_block</span><span class="p">)</span>
		<span class="n">xfs_emerg</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: tail wrapped&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">blocks</span> <span class="o">=</span> <span class="n">BLOCK_LSN</span><span class="p">(</span><span class="n">tail_lsn</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_prev_block</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&lt;</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">xfs_emerg</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: ran out of log space&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>	<span class="cm">/* xlog_verify_tail_lsn */</span>

<span class="cm">/*</span>
<span class="cm"> * Perform a number of checks on the iclog before writing to disk.</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Make sure the iclogs are still circular</span>
<span class="cm"> * 2. Make sure we have a good magic number</span>
<span class="cm"> * 3. Make sure we don&#39;t have magic numbers in the data</span>
<span class="cm"> * 4. Check fields of each log operation header for:</span>
<span class="cm"> *	A. Valid client identifier</span>
<span class="cm"> *	B. tid ptr value falls in valid ptr space (user space code)</span>
<span class="cm"> *	C. Length in log record header is correct according to the</span>
<span class="cm"> *		individual operation headers within record.</span>
<span class="cm"> * 5. When a bwrite will occur within 5 blocks of the front of the physical</span>
<span class="cm"> *	log, check the preceding blocks of the physical log to make sure all</span>
<span class="cm"> *	the cycle numbers agree with the current cycle number.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_verify_iclog</span><span class="p">(</span><span class="n">xlog_t</span>	 <span class="o">*</span><span class="n">log</span><span class="p">,</span>
		  <span class="n">xlog_in_core_t</span> <span class="o">*</span><span class="n">iclog</span><span class="p">,</span>
		  <span class="kt">int</span>		 <span class="n">count</span><span class="p">,</span>
		  <span class="n">boolean_t</span>	 <span class="n">syncing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_op_header_t</span>	<span class="o">*</span><span class="n">ophead</span><span class="p">;</span>
	<span class="n">xlog_in_core_t</span>		<span class="o">*</span><span class="n">icptr</span><span class="p">;</span>
	<span class="n">xlog_in_core_2_t</span>	<span class="o">*</span><span class="n">xhdr</span><span class="p">;</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">ptr</span><span class="p">;</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">base_ptr</span><span class="p">;</span>
	<span class="n">__psint_t</span>		<span class="n">field_offset</span><span class="p">;</span>
	<span class="n">__uint8_t</span>		<span class="n">clientid</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">len</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">op_len</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">idx</span><span class="p">;</span>

	<span class="cm">/* check validity of iclog pointers */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
	<span class="n">icptr</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_bufs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">xfs_emerg</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: invalid ptr&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">icptr</span> <span class="o">=</span> <span class="n">icptr</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icptr</span> <span class="o">!=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">)</span>
		<span class="n">xfs_emerg</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: corrupt iclog ring&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>

	<span class="cm">/* check log magic numbers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_magicno</span> <span class="o">!=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XLOG_HEADER_MAGIC_NUM</span><span class="p">))</span>
		<span class="n">xfs_emerg</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: invalid magic num&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_caddr_t</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">+=</span> <span class="n">BBSIZE</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">&lt;</span> <span class="p">((</span><span class="n">xfs_caddr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">)</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>
	     <span class="n">ptr</span> <span class="o">+=</span> <span class="n">BBSIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XLOG_HEADER_MAGIC_NUM</span><span class="p">))</span>
			<span class="n">xfs_emerg</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: unexpected magic num&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* check fields */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_num_logops</span><span class="p">);</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_datap</span><span class="p">;</span>
	<span class="n">base_ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">ophead</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlog_op_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
	<span class="n">xhdr</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_data</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ophead</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlog_op_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>

		<span class="cm">/* clientid is only 1 byte */</span>
		<span class="n">field_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">__psint_t</span><span class="p">)</span>
			       <span class="p">((</span><span class="n">xfs_caddr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ophead</span><span class="o">-&gt;</span><span class="n">oh_clientid</span><span class="p">)</span> <span class="o">-</span> <span class="n">base_ptr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">syncing</span> <span class="o">==</span> <span class="n">B_FALSE</span> <span class="o">||</span> <span class="p">(</span><span class="n">field_offset</span> <span class="o">&amp;</span> <span class="mh">0x1ff</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">clientid</span> <span class="o">=</span> <span class="n">ophead</span><span class="o">-&gt;</span><span class="n">oh_clientid</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">BTOBBT</span><span class="p">((</span><span class="n">xfs_caddr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ophead</span><span class="o">-&gt;</span><span class="n">oh_clientid</span><span class="p">)</span> <span class="o">-</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_datap</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">XLOG_HEADER_CYCLE_SIZE</span> <span class="o">/</span> <span class="n">BBSIZE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">j</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">/</span> <span class="p">(</span><span class="n">XLOG_HEADER_CYCLE_SIZE</span> <span class="o">/</span> <span class="n">BBSIZE</span><span class="p">);</span>
				<span class="n">k</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">%</span> <span class="p">(</span><span class="n">XLOG_HEADER_CYCLE_SIZE</span> <span class="o">/</span> <span class="n">BBSIZE</span><span class="p">);</span>
				<span class="n">clientid</span> <span class="o">=</span> <span class="n">xlog_get_client_id</span><span class="p">(</span>
					<span class="n">xhdr</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">hic_xheader</span><span class="p">.</span><span class="n">xh_cycle_data</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">clientid</span> <span class="o">=</span> <span class="n">xlog_get_client_id</span><span class="p">(</span>
					<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_cycle_data</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clientid</span> <span class="o">!=</span> <span class="n">XFS_TRANSACTION</span> <span class="o">&amp;&amp;</span> <span class="n">clientid</span> <span class="o">!=</span> <span class="n">XFS_LOG</span><span class="p">)</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span>
				<span class="s">&quot;%s: invalid clientid %d op 0x%p offset 0x%lx&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">clientid</span><span class="p">,</span> <span class="n">ophead</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">field_offset</span><span class="p">);</span>

		<span class="cm">/* check length */</span>
		<span class="n">field_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">__psint_t</span><span class="p">)</span>
			       <span class="p">((</span><span class="n">xfs_caddr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ophead</span><span class="o">-&gt;</span><span class="n">oh_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">base_ptr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">syncing</span> <span class="o">==</span> <span class="n">B_FALSE</span> <span class="o">||</span> <span class="p">(</span><span class="n">field_offset</span> <span class="o">&amp;</span> <span class="mh">0x1ff</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">op_len</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ophead</span><span class="o">-&gt;</span><span class="n">oh_len</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">BTOBBT</span><span class="p">((</span><span class="n">__psint_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ophead</span><span class="o">-&gt;</span><span class="n">oh_len</span> <span class="o">-</span>
				    <span class="p">(</span><span class="n">__psint_t</span><span class="p">)</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_datap</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">XLOG_HEADER_CYCLE_SIZE</span> <span class="o">/</span> <span class="n">BBSIZE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">j</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">/</span> <span class="p">(</span><span class="n">XLOG_HEADER_CYCLE_SIZE</span> <span class="o">/</span> <span class="n">BBSIZE</span><span class="p">);</span>
				<span class="n">k</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">%</span> <span class="p">(</span><span class="n">XLOG_HEADER_CYCLE_SIZE</span> <span class="o">/</span> <span class="n">BBSIZE</span><span class="p">);</span>
				<span class="n">op_len</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">xhdr</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">hic_xheader</span><span class="p">.</span><span class="n">xh_cycle_data</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">op_len</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_cycle_data</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">op_len</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>	<span class="cm">/* xlog_verify_iclog */</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Mark all iclogs IOERROR. l_icloglock is held by the caller.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_state_ioerror</span><span class="p">(</span>
	<span class="n">xlog_t</span>	<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_in_core_t</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">,</span> <span class="o">*</span><span class="n">ic</span><span class="p">;</span>

	<span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Mark all the incore logs IOERROR.</span>
<span class="cm">		 * From now on, no log flushes will result.</span>
<span class="cm">		 */</span>
		<span class="n">ic</span> <span class="o">=</span> <span class="n">iclog</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ic</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">=</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">;</span>
			<span class="n">ic</span> <span class="o">=</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ic</span> <span class="o">!=</span> <span class="n">iclog</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Return non-zero, if state transition has already happened.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called from xfs_force_shutdown, when we&#39;re forcibly</span>
<span class="cm"> * shutting down the filesystem, typically because of an IO error.</span>
<span class="cm"> * Our main objectives here are to make sure that:</span>
<span class="cm"> *	a. the filesystem gets marked &#39;SHUTDOWN&#39; for all interested</span>
<span class="cm"> *	   parties to find out, &#39;atomically&#39;.</span>
<span class="cm"> *	b. those who&#39;re sleeping on log reservations, pinned objects and</span>
<span class="cm"> *	    other resources get woken up, and be told the bad news.</span>
<span class="cm"> *	c. nothing new gets queued up after (a) and (b) are done.</span>
<span class="cm"> *	d. if !logerror, flush the iclogs to disk, then seal them off</span>
<span class="cm"> *	   for business.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: for delayed logging the !logerror case needs to flush the regions</span>
<span class="cm"> * held in memory out to the iclogs before flushing them to disk. This needs</span>
<span class="cm"> * to be done before the log is marked as shutdown, otherwise the flush to the</span>
<span class="cm"> * iclogs will fail.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_log_force_umount</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">logerror</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">retval</span><span class="p">;</span>

	<span class="n">log</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this happens during log recovery, don&#39;t worry about</span>
<span class="cm">	 * locking; the log isn&#39;t open for business yet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">log</span> <span class="o">||</span>
	    <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_ACTIVE_RECOVERY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">XFS_MOUNT_FS_SHUTDOWN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_bp</span><span class="p">)</span>
			<span class="n">XFS_BUF_DONE</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Somebody could&#39;ve already done the hard work for us.</span>
<span class="cm">	 * No need to get locks for this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">logerror</span> <span class="o">&amp;&amp;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">XLOG_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">log</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flush the in memory commit item list before marking the log as</span>
<span class="cm">	 * being shut down. We need to do it in this order to ensure all the</span>
<span class="cm">	 * completed transactions are flushed to disk with the xfs_log_force()</span>
<span class="cm">	 * call below.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">logerror</span><span class="p">)</span>
		<span class="n">xlog_cil_force</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * mark the filesystem and the as in a shutdown state and wake</span>
<span class="cm">	 * everybody up to tell them the bad news.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">XFS_MOUNT_FS_SHUTDOWN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_bp</span><span class="p">)</span>
		<span class="n">XFS_BUF_DONE</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_bp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This flag is sort of redundant because of the mount flag, but</span>
<span class="cm">	 * it&#39;s good to maintain the separation between the log and the rest</span>
<span class="cm">	 * of XFS.</span>
<span class="cm">	 */</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flags</span> <span class="o">|=</span> <span class="n">XLOG_IO_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we hit a log error, we want to mark all the iclogs IOERROR</span>
<span class="cm">	 * while we&#39;re still holding the loglock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">logerror</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">xlog_state_ioerror</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want anybody waiting for log reservations after this. That</span>
<span class="cm">	 * means we have to wake up everybody queued up on reserveq as well as</span>
<span class="cm">	 * writeq.  In addition, we make sure in xlog_{re}grant_log_space that</span>
<span class="cm">	 * we don&#39;t enqueue anything once the SHUTDOWN flag is set, and this</span>
<span class="cm">	 * action is protected by the grant locks.</span>
<span class="cm">	 */</span>
	<span class="n">xlog_grant_head_wake_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">);</span>
	<span class="n">xlog_grant_head_wake_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="o">-&gt;</span><span class="n">ic_state</span> <span class="o">&amp;</span> <span class="n">XLOG_STATE_IOERROR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">logerror</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Force the incore logs to disk before shutting the</span>
<span class="cm">		 * log down completely.</span>
<span class="cm">		 */</span>
		<span class="n">_xfs_log_force</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_LOG_SYNC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">xlog_state_ioerror</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Wake up everybody waiting on xfs_log_force.</span>
<span class="cm">	 * Callback all log item committed functions as if the</span>
<span class="cm">	 * log writes were completed.</span>
<span class="cm">	 */</span>
	<span class="n">xlog_state_do_callback</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">XFS_LI_ABORTED</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cp">#ifdef XFSERRORDEBUG</span>
	<span class="p">{</span>
		<span class="n">xlog_in_core_t</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
		<span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_callback</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iclog</span> <span class="o">!=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_icloglock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/* return non-zero if log IOERROR transition had already happened */</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_iclogs_empty</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_in_core_t</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">;</span>

	<span class="n">iclog</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* endianness does not matter here, zero is zero in</span>
<span class="cm">		 * any language.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_num_logops</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iclog</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iclog</span> <span class="o">!=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
