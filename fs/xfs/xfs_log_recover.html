<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_log_recover.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_log_recover.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2006 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_bit.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_inum.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_ialloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode_item.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_ialloc.h&quot;</span>
<span class="cp">#include &quot;xfs_log_priv.h&quot;</span>
<span class="cp">#include &quot;xfs_buf_item.h&quot;</span>
<span class="cp">#include &quot;xfs_log_recover.h&quot;</span>
<span class="cp">#include &quot;xfs_extfree_item.h&quot;</span>
<span class="cp">#include &quot;xfs_trans_priv.h&quot;</span>
<span class="cp">#include &quot;xfs_quota.h&quot;</span>
<span class="cp">#include &quot;xfs_utils.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>

<span class="n">STATIC</span> <span class="kt">int</span>	<span class="n">xlog_find_zeroed</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_daddr_t</span> <span class="o">*</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span>	<span class="n">xlog_clear_stale_blocks</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_lsn_t</span><span class="p">);</span>
<span class="cp">#if defined(DEBUG)</span>
<span class="n">STATIC</span> <span class="kt">void</span>	<span class="n">xlog_recover_check_summary</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define	xlog_recover_check_summary(log)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is used during recovery to record the buf log items which</span>
<span class="cm"> * have been canceled and should not be replayed.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfs_buf_cancel</span> <span class="p">{</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">bc_blkno</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">bc_len</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">bc_refcount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">bc_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Sector aligned buffer routines for buffer create/read/write/access</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Verify the given count of basic blocks is valid number of blocks</span>
<span class="cm"> * to specify for an operation involving the given XFS log buffer.</span>
<span class="cm"> * Returns nonzero if the count is valid, 0 otherwise.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xlog_buf_bbcount_valid</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">bbcount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bbcount</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bbcount</span> <span class="o">&lt;=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a buffer to hold log data.  The buffer needs to be able</span>
<span class="cm"> * to map to a range of nbblks basic blocks at any valid (basic</span>
<span class="cm"> * block) offset within the log.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="n">xfs_buf_t</span> <span class="o">*</span>
<span class="nf">xlog_get_bp</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">nbblks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xlog_buf_bbcount_valid</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">nbblks</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;Invalid block length (0x%x) for buffer&quot;</span><span class="p">,</span>
			<span class="n">nbblks</span><span class="p">);</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_HIGH</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We do log I/O in units of log sectors (a power-of-2</span>
<span class="cm">	 * multiple of the basic block size), so we round up the</span>
<span class="cm">	 * requested size to accommodate the basic blocks required</span>
<span class="cm">	 * for complete log sectors.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In addition, the buffer may be used for a non-sector-</span>
<span class="cm">	 * aligned block offset, in which case an I/O of the</span>
<span class="cm">	 * requested size could extend beyond the end of the</span>
<span class="cm">	 * buffer.  If the requested size is only 1 basic block it</span>
<span class="cm">	 * will never straddle a sector boundary, so this won&#39;t be</span>
<span class="cm">	 * an issue.  Nor will this be a problem if the log I/O is</span>
<span class="cm">	 * done in basic blocks (sector size 1).  But otherwise we</span>
<span class="cm">	 * extend the buffer by one extra log sector to ensure</span>
<span class="cm">	 * there&#39;s space to accommodate this possibility.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbblks</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_sectBBsize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">nbblks</span> <span class="o">+=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_sectBBsize</span><span class="p">;</span>
	<span class="n">nbblks</span> <span class="o">=</span> <span class="n">round_up</span><span class="p">(</span><span class="n">nbblks</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_sectBBsize</span><span class="p">);</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_get_uncached</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span><span class="p">,</span> <span class="n">nbblks</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="p">)</span>
		<span class="n">xfs_buf_unlock</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_put_bp</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_free</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the address of the start of the given block number&#39;s data</span>
<span class="cm"> * in a log buffer.  The buffer covers a log sector-aligned region.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="n">xfs_caddr_t</span>
<span class="nf">xlog_align</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">blk_no</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">nbblks</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">offset</span> <span class="o">=</span> <span class="n">blk_no</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">xfs_daddr_t</span><span class="p">)</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_sectBBsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">nbblks</span> <span class="o">&lt;=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">+</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * nbblks should be uint, but oh well.  Just want to catch that 32-bit length.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_bread_noalign</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">blk_no</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">nbblks</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xlog_buf_bbcount_valid</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">nbblks</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;Invalid block length (0x%x) for buffer&quot;</span><span class="p">,</span>
			<span class="n">nbblks</span><span class="p">);</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_HIGH</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EFSCORRUPTED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">blk_no</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">blk_no</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_sectBBsize</span><span class="p">);</span>
	<span class="n">nbblks</span> <span class="o">=</span> <span class="n">round_up</span><span class="p">(</span><span class="n">nbblks</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_sectBBsize</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">nbblks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">nbblks</span> <span class="o">&lt;=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">);</span>

	<span class="n">XFS_BUF_SET_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBstart</span> <span class="o">+</span> <span class="n">blk_no</span><span class="p">);</span>
	<span class="n">XFS_BUF_READ</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_length</span> <span class="o">=</span> <span class="n">nbblks</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">xfsbdstrat</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_buf_iowait</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">xfs_buf_ioerror_alert</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_bread</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">blk_no</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">nbblks</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="n">xfs_caddr_t</span>	<span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread_noalign</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">blk_no</span><span class="p">,</span> <span class="n">nbblks</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">xlog_align</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">blk_no</span><span class="p">,</span> <span class="n">nbblks</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read at an offset into the buffer. Returns with the buffer in it&#39;s original</span>
<span class="cm"> * state regardless of the result of the read.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_bread_offset</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">blk_no</span><span class="p">,</span>		<span class="cm">/* block to read from */</span>
	<span class="kt">int</span>		<span class="n">nbblks</span><span class="p">,</span>		<span class="cm">/* blocks to read */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="n">xfs_caddr_t</span>	<span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_caddr_t</span>	<span class="n">orig_offset</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">orig_len</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">,</span> <span class="n">error2</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_buf_associate_memory</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">nbblks</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread_noalign</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">blk_no</span><span class="p">,</span> <span class="n">nbblks</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* must reset buffer pointer even on error */</span>
	<span class="n">error2</span> <span class="o">=</span> <span class="n">xfs_buf_associate_memory</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">orig_offset</span><span class="p">,</span> <span class="n">orig_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write out the buffer at the given block for the given number of blocks.</span>
<span class="cm"> * The buffer is kept locked across the write and is returned locked.</span>
<span class="cm"> * This can only be used for synchronous log writes.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_bwrite</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">blk_no</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">nbblks</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xlog_buf_bbcount_valid</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">nbblks</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;Invalid block length (0x%x) for buffer&quot;</span><span class="p">,</span>
			<span class="n">nbblks</span><span class="p">);</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_HIGH</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EFSCORRUPTED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">blk_no</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">blk_no</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_sectBBsize</span><span class="p">);</span>
	<span class="n">nbblks</span> <span class="o">=</span> <span class="n">round_up</span><span class="p">(</span><span class="n">nbblks</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_sectBBsize</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">nbblks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">nbblks</span> <span class="o">&lt;=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">);</span>

	<span class="n">XFS_BUF_SET_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBstart</span> <span class="o">+</span> <span class="n">blk_no</span><span class="p">);</span>
	<span class="n">XFS_BUF_ZEROFLAGS</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_buf_hold</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_buf_lock</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_length</span> <span class="o">=</span> <span class="n">nbblks</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bwrite</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">xfs_buf_ioerror_alert</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cm">/*</span>
<span class="cm"> * dump debug superblock and log record information</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_header_check_dump</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xlog_rec_header_t</span>	<span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_debug</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s:  SB : uuid = %pU, fmt = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_uuid</span><span class="p">,</span> <span class="n">XLOG_FMT</span><span class="p">);</span>
	<span class="n">xfs_debug</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;    log : uuid = %pU, fmt = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">h_fs_uuid</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">h_fmt</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define xlog_header_check_dump(mp, head)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * check log record header for recovery</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_header_check_recover</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xlog_rec_header_t</span>	<span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">h_magicno</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XLOG_HEADER_MAGIC_NUM</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * IRIX doesn&#39;t write the h_fmt field and leaves it zeroed</span>
<span class="cm">	 * (XLOG_FMT_UNKNOWN). This stops us from trying to recover</span>
<span class="cm">	 * a dirty log created in IRIX.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">h_fmt</span> <span class="o">!=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XLOG_FMT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
	<span class="s">&quot;dirty log written in incompatible format - can&#39;t recover&quot;</span><span class="p">);</span>
		<span class="n">xlog_header_check_dump</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xlog_header_check_recover(1)&quot;</span><span class="p">,</span>
				 <span class="n">XFS_ERRLEVEL_HIGH</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">uuid_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_uuid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">h_fs_uuid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
	<span class="s">&quot;dirty log entry has mismatched uuid - can&#39;t recover&quot;</span><span class="p">);</span>
		<span class="n">xlog_header_check_dump</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xlog_header_check_recover(2)&quot;</span><span class="p">,</span>
				 <span class="n">XFS_ERRLEVEL_HIGH</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * read the head block of the log and check the header</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_header_check_mount</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xlog_rec_header_t</span>	<span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">h_magicno</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XLOG_HEADER_MAGIC_NUM</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uuid_is_nil</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">h_fs_uuid</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * IRIX doesn&#39;t write the h_fs_uuid or h_fmt fields. If</span>
<span class="cm">		 * h_fs_uuid is nil, we assume this log was last mounted</span>
<span class="cm">		 * by IRIX and continue.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;nil uuid in log - IRIX style log&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">uuid_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_uuid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">h_fs_uuid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;log has mismatched uuid - can&#39;t recover&quot;</span><span class="p">);</span>
		<span class="n">xlog_header_check_dump</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xlog_header_check_mount&quot;</span><span class="p">,</span>
				 <span class="n">XFS_ERRLEVEL_HIGH</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_recover_iodone</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re not going to bother about retrying</span>
<span class="cm">		 * this during recovery. One strike!</span>
<span class="cm">		 */</span>
		<span class="n">xfs_buf_ioerror_alert</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">xfs_force_shutdown</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_target</span><span class="o">-&gt;</span><span class="n">bt_mount</span><span class="p">,</span>
					<span class="n">SHUTDOWN_META_IO_ERROR</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">xfs_buf_ioend</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine finds (to an approximation) the first block in the physical</span>
<span class="cm"> * log which contains the given cycle.  It uses a binary search algorithm.</span>
<span class="cm"> * Note that the algorithm can not be perfect because the disk will not</span>
<span class="cm"> * necessarily be perfect.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_find_cycle_start</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">first_blk</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="o">*</span><span class="n">last_blk</span><span class="p">,</span>
	<span class="n">uint</span>		<span class="n">cycle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_caddr_t</span>	<span class="n">offset</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">mid_blk</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">end_blk</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">mid_cycle</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">end_blk</span> <span class="o">=</span> <span class="o">*</span><span class="n">last_blk</span><span class="p">;</span>
	<span class="n">mid_blk</span> <span class="o">=</span> <span class="n">BLK_AVG</span><span class="p">(</span><span class="n">first_blk</span><span class="p">,</span> <span class="n">end_blk</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mid_blk</span> <span class="o">!=</span> <span class="n">first_blk</span> <span class="o">&amp;&amp;</span> <span class="n">mid_blk</span> <span class="o">!=</span> <span class="n">end_blk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">mid_blk</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">mid_cycle</span> <span class="o">=</span> <span class="n">xlog_get_cycle</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mid_cycle</span> <span class="o">==</span> <span class="n">cycle</span><span class="p">)</span>
			<span class="n">end_blk</span> <span class="o">=</span> <span class="n">mid_blk</span><span class="p">;</span>   <span class="cm">/* last_half_cycle == mid_cycle */</span>
		<span class="k">else</span>
			<span class="n">first_blk</span> <span class="o">=</span> <span class="n">mid_blk</span><span class="p">;</span> <span class="cm">/* first_half_cycle == mid_cycle */</span>
		<span class="n">mid_blk</span> <span class="o">=</span> <span class="n">BLK_AVG</span><span class="p">(</span><span class="n">first_blk</span><span class="p">,</span> <span class="n">end_blk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">mid_blk</span> <span class="o">==</span> <span class="n">first_blk</span> <span class="o">&amp;&amp;</span> <span class="n">mid_blk</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">end_blk</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">mid_blk</span> <span class="o">==</span> <span class="n">end_blk</span> <span class="o">&amp;&amp;</span> <span class="n">mid_blk</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">first_blk</span><span class="p">));</span>

	<span class="o">*</span><span class="n">last_blk</span> <span class="o">=</span> <span class="n">end_blk</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check that a range of blocks does not contain stop_on_cycle_no.</span>
<span class="cm"> * Fill in *new_blk with the block offset where such a block is</span>
<span class="cm"> * found, or with -1 (an invalid block number) if there is no such</span>
<span class="cm"> * block in the range.  The scan needs to occur from front to back</span>
<span class="cm"> * and the pointer into the region must be updated since a later</span>
<span class="cm"> * routine will need to perform another test.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_find_verify_cycle</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">start_blk</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">nbblks</span><span class="p">,</span>
	<span class="n">uint</span>		<span class="n">stop_on_cycle_no</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="o">*</span><span class="n">new_blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">cycle</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">bufblks</span><span class="p">;</span>
	<span class="n">xfs_caddr_t</span>	<span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Greedily allocate a buffer big enough to handle the full</span>
<span class="cm">	 * range of basic blocks we&#39;ll be examining.  If that fails,</span>
<span class="cm">	 * try a smaller size.  We need to be able to read at least</span>
<span class="cm">	 * a log sector, or we&#39;re out of luck.</span>
<span class="cm">	 */</span>
	<span class="n">bufblks</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ffs</span><span class="p">(</span><span class="n">nbblks</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bufblks</span> <span class="o">&gt;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">)</span>
		<span class="n">bufblks</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bp</span> <span class="o">=</span> <span class="n">xlog_get_bp</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">bufblks</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">bufblks</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bufblks</span> <span class="o">&lt;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_sectBBsize</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start_blk</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">start_blk</span> <span class="o">+</span> <span class="n">nbblks</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">bufblks</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">bcount</span><span class="p">;</span>

		<span class="n">bcount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bufblks</span><span class="p">,</span> <span class="p">(</span><span class="n">start_blk</span> <span class="o">+</span> <span class="n">nbblks</span> <span class="o">-</span> <span class="n">i</span><span class="p">));</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bcount</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bcount</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cycle</span> <span class="o">=</span> <span class="n">xlog_get_cycle</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cycle</span> <span class="o">==</span> <span class="n">stop_on_cycle_no</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">new_blk</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">buf</span> <span class="o">+=</span> <span class="n">BBSIZE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">new_blk</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">xlog_put_bp</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Potentially backup over partial log record write.</span>
<span class="cm"> *</span>
<span class="cm"> * In the typical case, last_blk is the number of the block directly after</span>
<span class="cm"> * a good log record.  Therefore, we subtract one to get the block number</span>
<span class="cm"> * of the last block in the given buffer.  extra_bblks contains the number</span>
<span class="cm"> * of blocks we would have read on a previous read.  This happens when the</span>
<span class="cm"> * last log record is split over the end of the physical log.</span>
<span class="cm"> *</span>
<span class="cm"> * extra_bblks is the number of blocks potentially verified on a previous</span>
<span class="cm"> * call to this routine.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_find_verify_log_record</span><span class="p">(</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">start_blk</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="o">*</span><span class="n">last_blk</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">extra_bblks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">offset</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">xlog_rec_header_t</span>	<span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">smallmem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">num_blks</span> <span class="o">=</span> <span class="o">*</span><span class="n">last_blk</span> <span class="o">-</span> <span class="n">start_blk</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">xhdrs</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">start_blk</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">*</span><span class="n">last_blk</span> <span class="o">!=</span> <span class="n">start_blk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bp</span> <span class="o">=</span> <span class="n">xlog_get_bp</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">num_blks</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bp</span> <span class="o">=</span> <span class="n">xlog_get_bp</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">smallmem</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">start_blk</span><span class="p">,</span> <span class="n">num_blks</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="p">((</span><span class="n">num_blks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">BBSHIFT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">last_blk</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">start_blk</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* valid log record not found */</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span>
		<span class="s">&quot;Log inconsistent (didn&#39;t find previous header)&quot;</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">smallmem</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlog_rec_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">h_magicno</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XLOG_HEADER_MAGIC_NUM</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smallmem</span><span class="p">)</span>
			<span class="n">offset</span> <span class="o">-=</span> <span class="n">BBSIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We hit the beginning of the physical log &amp; still no header.  Return</span>
<span class="cm">	 * to caller.  If caller can handle a return of -1, then this routine</span>
<span class="cm">	 * will be called again for the end of the physical log.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have the final block of the good log (the first block</span>
<span class="cm">	 * of the log record _before_ the head. So we check the uuid.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_header_check_mount</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">head</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We may have found a log record header before we expected one.</span>
<span class="cm">	 * last_blk will be the 1st block # with a given cycle #.  We may end</span>
<span class="cm">	 * up reading an entire log record.  In this case, we don&#39;t want to</span>
<span class="cm">	 * reset last_blk.  Only when last_blk points in the middle of a log</span>
<span class="cm">	 * record do we update last_blk.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_haslogv2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">uint</span>	<span class="n">h_size</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">h_size</span><span class="p">);</span>

		<span class="n">xhdrs</span> <span class="o">=</span> <span class="n">h_size</span> <span class="o">/</span> <span class="n">XLOG_HEADER_CYCLE_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h_size</span> <span class="o">%</span> <span class="n">XLOG_HEADER_CYCLE_SIZE</span><span class="p">)</span>
			<span class="n">xhdrs</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xhdrs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">last_blk</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="n">extra_bblks</span> <span class="o">!=</span>
	    <span class="n">BTOBB</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">h_len</span><span class="p">))</span> <span class="o">+</span> <span class="n">xhdrs</span><span class="p">)</span>
		<span class="o">*</span><span class="n">last_blk</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">xlog_put_bp</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Head is defined to be the point of the log where the next log write</span>
<span class="cm"> * write could go.  This means that incomplete LR writes at the end are</span>
<span class="cm"> * eliminated when calculating the head.  We aren&#39;t guaranteed that previous</span>
<span class="cm"> * LR have complete transactions.  We only know that a cycle number of</span>
<span class="cm"> * current cycle number -1 won&#39;t be present in the log if we start writing</span>
<span class="cm"> * from our current block number.</span>
<span class="cm"> *</span>
<span class="cm"> * last_blk contains the block number of the first block with a given</span>
<span class="cm"> * cycle number.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: zero if normal, non-zero if error.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_find_head</span><span class="p">(</span>
	<span class="n">xlog_t</span> 		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="o">*</span><span class="n">return_head_blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_caddr_t</span>	<span class="n">offset</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">new_blk</span><span class="p">,</span> <span class="n">first_blk</span><span class="p">,</span> <span class="n">start_blk</span><span class="p">,</span> <span class="n">last_blk</span><span class="p">,</span> <span class="n">head_blk</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">num_scan_bblks</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">first_half_cycle</span><span class="p">,</span> <span class="n">last_half_cycle</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">stop_on_cycle</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">,</span> <span class="n">log_bbnum</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">;</span>

	<span class="cm">/* Is the end of the log device zeroed? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_find_zeroed</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_blk</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">return_head_blk</span> <span class="o">=</span> <span class="n">first_blk</span><span class="p">;</span>

		<span class="cm">/* Is the whole lot zeroed? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_blk</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Linux XFS shouldn&#39;t generate totally zeroed logs -</span>
<span class="cm">			 * mkfs etc write a dummy unmount record to a fresh</span>
<span class="cm">			 * log so we can store the uuid in there</span>
<span class="cm">			 */</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;totally zeroed log&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;empty log check failed&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">first_blk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/* get cycle # of 1st block */</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="n">xlog_get_bp</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>

	<span class="n">first_half_cycle</span> <span class="o">=</span> <span class="n">xlog_get_cycle</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>

	<span class="n">last_blk</span> <span class="o">=</span> <span class="n">head_blk</span> <span class="o">=</span> <span class="n">log_bbnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* get cycle # of last block */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">last_blk</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>

	<span class="n">last_half_cycle</span> <span class="o">=</span> <span class="n">xlog_get_cycle</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">last_half_cycle</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the 1st half cycle number is equal to the last half cycle number,</span>
<span class="cm">	 * then the entire log is stamped with the same cycle number.  In this</span>
<span class="cm">	 * case, head_blk can&#39;t be set to zero (which makes sense).  The below</span>
<span class="cm">	 * math doesn&#39;t work out properly with head_blk equal to zero.  Instead,</span>
<span class="cm">	 * we set it to log_bbnum which is an invalid block number, but this</span>
<span class="cm">	 * value makes the math correct.  If head_blk doesn&#39;t changed through</span>
<span class="cm">	 * all the tests below, *head_blk is set to zero at the very end rather</span>
<span class="cm">	 * than log_bbnum.  In a sense, log_bbnum and zero are the same block</span>
<span class="cm">	 * in a circular file.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_half_cycle</span> <span class="o">==</span> <span class="n">last_half_cycle</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In this case we believe that the entire log should have</span>
<span class="cm">		 * cycle number last_half_cycle.  We need to scan backwards</span>
<span class="cm">		 * from the end verifying that there are no holes still</span>
<span class="cm">		 * containing last_half_cycle - 1.  If we find such a hole,</span>
<span class="cm">		 * then the start of that hole will be the new head.  The</span>
<span class="cm">		 * simple case looks like</span>
<span class="cm">		 *        x | x ... | x - 1 | x</span>
<span class="cm">		 * Another case that fits this picture would be</span>
<span class="cm">		 *        x | x + 1 | x ... | x</span>
<span class="cm">		 * In this case the head really is somewhere at the end of the</span>
<span class="cm">		 * log, as one of the latest writes at the beginning was</span>
<span class="cm">		 * incomplete.</span>
<span class="cm">		 * One more case is</span>
<span class="cm">		 *        x | x + 1 | x ... | x - 1 | x</span>
<span class="cm">		 * This is really the combination of the above two cases, and</span>
<span class="cm">		 * the head has to end up at the start of the x-1 hole at the</span>
<span class="cm">		 * end of the log.</span>
<span class="cm">		 *</span>
<span class="cm">		 * In the 256k log case, we will read from the beginning to the</span>
<span class="cm">		 * end of the log and search for cycle numbers equal to x-1.</span>
<span class="cm">		 * We don&#39;t worry about the x+1 blocks that we encounter,</span>
<span class="cm">		 * because we know that they cannot be the head since the log</span>
<span class="cm">		 * started with x.</span>
<span class="cm">		 */</span>
		<span class="n">head_blk</span> <span class="o">=</span> <span class="n">log_bbnum</span><span class="p">;</span>
		<span class="n">stop_on_cycle</span> <span class="o">=</span> <span class="n">last_half_cycle</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In this case we want to find the first block with cycle</span>
<span class="cm">		 * number matching last_half_cycle.  We expect the log to be</span>
<span class="cm">		 * some variation on</span>
<span class="cm">		 *        x + 1 ... | x ... | x</span>
<span class="cm">		 * The first block with cycle number x (last_half_cycle) will</span>
<span class="cm">		 * be where the new head belongs.  First we do a binary search</span>
<span class="cm">		 * for the first occurrence of last_half_cycle.  The binary</span>
<span class="cm">		 * search may not be totally accurate, so then we scan back</span>
<span class="cm">		 * from there looking for occurrences of last_half_cycle before</span>
<span class="cm">		 * us.  If that backwards scan wraps around the beginning of</span>
<span class="cm">		 * the log, then we look for occurrences of last_half_cycle - 1</span>
<span class="cm">		 * at the end of the log.  The cases we&#39;re looking for look</span>
<span class="cm">		 * like</span>
<span class="cm">		 *                               v binary search stopped here</span>
<span class="cm">		 *        x + 1 ... | x | x + 1 | x ... | x</span>
<span class="cm">		 *                   ^ but we want to locate this spot</span>
<span class="cm">		 * or</span>
<span class="cm">		 *        &lt;---------&gt; less than scan distance</span>
<span class="cm">		 *        x + 1 ... | x ... | x - 1 | x</span>
<span class="cm">		 *                           ^ we want to locate this spot</span>
<span class="cm">		 */</span>
		<span class="n">stop_on_cycle</span> <span class="o">=</span> <span class="n">last_half_cycle</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_find_cycle_start</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">first_blk</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">head_blk</span><span class="p">,</span> <span class="n">last_half_cycle</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now validate the answer.  Scan back some number of maximum possible</span>
<span class="cm">	 * blocks and make sure each one has the expected cycle number.  The</span>
<span class="cm">	 * maximum is determined by the total possible amount of buffering</span>
<span class="cm">	 * in the in-core log.  The following number can be made tighter if</span>
<span class="cm">	 * we actually look at the block size of the filesystem.</span>
<span class="cm">	 */</span>
	<span class="n">num_scan_bblks</span> <span class="o">=</span> <span class="n">XLOG_TOTAL_REC_SHIFT</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head_blk</span> <span class="o">&gt;=</span> <span class="n">num_scan_bblks</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are guaranteed that the entire check can be performed</span>
<span class="cm">		 * in one buffer.</span>
<span class="cm">		 */</span>
		<span class="n">start_blk</span> <span class="o">=</span> <span class="n">head_blk</span> <span class="o">-</span> <span class="n">num_scan_bblks</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_find_verify_cycle</span><span class="p">(</span><span class="n">log</span><span class="p">,</span>
						<span class="n">start_blk</span><span class="p">,</span> <span class="n">num_scan_bblks</span><span class="p">,</span>
						<span class="n">stop_on_cycle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_blk</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_blk</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">head_blk</span> <span class="o">=</span> <span class="n">new_blk</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* need to read 2 parts of log */</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are going to scan backwards in the log in two parts.</span>
<span class="cm">		 * First we scan the physical end of the log.  In this part</span>
<span class="cm">		 * of the log, we are looking for blocks with cycle number</span>
<span class="cm">		 * last_half_cycle - 1.</span>
<span class="cm">		 * If we find one, then we know that the log starts there, as</span>
<span class="cm">		 * we&#39;ve found a hole that didn&#39;t get written in going around</span>
<span class="cm">		 * the end of the physical log.  The simple case for this is</span>
<span class="cm">		 *        x + 1 ... | x ... | x - 1 | x</span>
<span class="cm">		 *        &lt;---------&gt; less than scan distance</span>
<span class="cm">		 * If all of the blocks at the end of the log have cycle number</span>
<span class="cm">		 * last_half_cycle, then we check the blocks at the start of</span>
<span class="cm">		 * the log looking for occurrences of last_half_cycle.  If we</span>
<span class="cm">		 * find one, then our current estimate for the location of the</span>
<span class="cm">		 * first occurrence of last_half_cycle is wrong and we move</span>
<span class="cm">		 * back to the hole we&#39;ve found.  This case looks like</span>
<span class="cm">		 *        x + 1 ... | x | x + 1 | x ...</span>
<span class="cm">		 *                               ^ binary search stopped here</span>
<span class="cm">		 * Another case we need to handle that only occurs in 256k</span>
<span class="cm">		 * logs is</span>
<span class="cm">		 *        x + 1 ... | x ... | x+1 | x ...</span>
<span class="cm">		 *                   ^ binary search stops here</span>
<span class="cm">		 * In a 256k log, the scan at the end of the log will see the</span>
<span class="cm">		 * x + 1 blocks.  We need to skip past those since that is</span>
<span class="cm">		 * certainly not the head of the log.  By searching for</span>
<span class="cm">		 * last_half_cycle-1 we accomplish that.</span>
<span class="cm">		 */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">head_blk</span> <span class="o">&lt;=</span> <span class="n">INT_MAX</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">xfs_daddr_t</span><span class="p">)</span> <span class="n">num_scan_bblks</span> <span class="o">&gt;=</span> <span class="n">head_blk</span><span class="p">);</span>
		<span class="n">start_blk</span> <span class="o">=</span> <span class="n">log_bbnum</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_scan_bblks</span> <span class="o">-</span> <span class="n">head_blk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_find_verify_cycle</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">start_blk</span><span class="p">,</span>
					<span class="n">num_scan_bblks</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">head_blk</span><span class="p">,</span>
					<span class="p">(</span><span class="n">stop_on_cycle</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">new_blk</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_blk</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">head_blk</span> <span class="o">=</span> <span class="n">new_blk</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">validate_head</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Scan beginning of log now.  The last part of the physical</span>
<span class="cm">		 * log is good.  This scan needs to verify that it doesn&#39;t find</span>
<span class="cm">		 * the last_half_cycle.</span>
<span class="cm">		 */</span>
		<span class="n">start_blk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">head_blk</span> <span class="o">&lt;=</span> <span class="n">INT_MAX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_find_verify_cycle</span><span class="p">(</span><span class="n">log</span><span class="p">,</span>
					<span class="n">start_blk</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">head_blk</span><span class="p">,</span>
					<span class="n">stop_on_cycle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_blk</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_blk</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">head_blk</span> <span class="o">=</span> <span class="n">new_blk</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">validate_head:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now we need to make sure head_blk is not pointing to a block in</span>
<span class="cm">	 * the middle of a log record.</span>
<span class="cm">	 */</span>
	<span class="n">num_scan_bblks</span> <span class="o">=</span> <span class="n">XLOG_REC_SHIFT</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head_blk</span> <span class="o">&gt;=</span> <span class="n">num_scan_bblks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_blk</span> <span class="o">=</span> <span class="n">head_blk</span> <span class="o">-</span> <span class="n">num_scan_bblks</span><span class="p">;</span> <span class="cm">/* don&#39;t read head_blk */</span>

		<span class="cm">/* start ptr at last block ptr before head_blk */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_find_verify_log_record</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">start_blk</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">head_blk</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">start_blk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">head_blk</span> <span class="o">&lt;=</span> <span class="n">INT_MAX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_find_verify_log_record</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">start_blk</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">head_blk</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We hit the beginning of the log during our search */</span>
			<span class="n">start_blk</span> <span class="o">=</span> <span class="n">log_bbnum</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_scan_bblks</span> <span class="o">-</span> <span class="n">head_blk</span><span class="p">);</span>
			<span class="n">new_blk</span> <span class="o">=</span> <span class="n">log_bbnum</span><span class="p">;</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">start_blk</span> <span class="o">&lt;=</span> <span class="n">INT_MAX</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">xfs_daddr_t</span><span class="p">)</span> <span class="n">log_bbnum</span><span class="o">-</span><span class="n">start_blk</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">head_blk</span> <span class="o">&lt;=</span> <span class="n">INT_MAX</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_find_verify_log_record</span><span class="p">(</span><span class="n">log</span><span class="p">,</span>
							<span class="n">start_blk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_blk</span><span class="p">,</span>
							<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">head_blk</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_blk</span> <span class="o">!=</span> <span class="n">log_bbnum</span><span class="p">)</span>
				<span class="n">head_blk</span> <span class="o">=</span> <span class="n">new_blk</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xlog_put_bp</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head_blk</span> <span class="o">==</span> <span class="n">log_bbnum</span><span class="p">)</span>
		<span class="o">*</span><span class="n">return_head_blk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">return_head_blk</span> <span class="o">=</span> <span class="n">head_blk</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * When returning here, we have a good block number.  Bad block</span>
<span class="cm">	 * means that during a previous crash, we didn&#39;t have a clean break</span>
<span class="cm">	 * from cycle number N to cycle number N-1.  In this case, we need</span>
<span class="cm">	 * to find the first block with cycle number N-1.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">bp_err:</span>
	<span class="n">xlog_put_bp</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;failed to find log head&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the sync block number or the tail of the log.</span>
<span class="cm"> *</span>
<span class="cm"> * This will be the block number of the last record to have its</span>
<span class="cm"> * associated buffers synced to disk.  Every log record header has</span>
<span class="cm"> * a sync lsn embedded in it.  LSNs hold block numbers, so it is easy</span>
<span class="cm"> * to get a sync block number.  The only concern is to figure out which</span>
<span class="cm"> * log record header to believe.</span>
<span class="cm"> *</span>
<span class="cm"> * The following algorithm uses the log record header with the largest</span>
<span class="cm"> * lsn.  The entire log record does not need to be valid.  We only care</span>
<span class="cm"> * that the header is valid.</span>
<span class="cm"> *</span>
<span class="cm"> * We could speed up search by using current head_blk buffer, but it is not</span>
<span class="cm"> * available.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_find_tail</span><span class="p">(</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="o">*</span><span class="n">head_blk</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="o">*</span><span class="n">tail_blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_rec_header_t</span>	<span class="o">*</span><span class="n">rhead</span><span class="p">;</span>
	<span class="n">xlog_op_header_t</span>	<span class="o">*</span><span class="n">op_head</span><span class="p">;</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">offset</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">found</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">umount_data_blk</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">after_umount_blk</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">tail_lsn</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">hblks</span><span class="p">;</span>

	<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find previous log record</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_find_head</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">head_blk</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">xlog_get_bp</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">head_blk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>				<span class="cm">/* special case */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">xlog_get_cycle</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">tail_blk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* leave all other log inited values alone */</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search backwards looking for log record header block</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">*</span><span class="n">head_blk</span> <span class="o">&lt;</span> <span class="n">INT_MAX</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">head_blk</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">offset</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XLOG_HEADER_MAGIC_NUM</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we haven&#39;t found the log record header block, start looking</span>
<span class="cm">	 * again from the end of the physical log.  XXXmiken: There should be</span>
<span class="cm">	 * a check here to make sure we didn&#39;t search more than N blocks in</span>
<span class="cm">	 * the previous code.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">head_blk</span><span class="p">);</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">offset</span> <span class="o">==</span>
			    <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XLOG_HEADER_MAGIC_NUM</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: couldn&#39;t find sync record&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* find blk_no of tail of log */</span>
	<span class="n">rhead</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlog_rec_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">offset</span><span class="p">;</span>
	<span class="o">*</span><span class="n">tail_blk</span> <span class="o">=</span> <span class="n">BLOCK_LSN</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_tail_lsn</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset log values according to the state of the log when we</span>
<span class="cm">	 * crashed.  In the case where head_blk == 0, we bump curr_cycle</span>
<span class="cm">	 * one because the next write starts a new cycle rather than</span>
<span class="cm">	 * continuing the cycle of the last good log record.  At this</span>
<span class="cm">	 * point we have guaranteed that all partial log records have been</span>
<span class="cm">	 * accounted for.  Therefore, we know that the last good log record</span>
<span class="cm">	 * written was complete and ended exactly on the end boundary</span>
<span class="cm">	 * of the physical log.</span>
<span class="cm">	 */</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_prev_block</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_block</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">head_blk</span><span class="p">;</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_cycle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span><span class="o">++</span><span class="p">;</span>
	<span class="n">atomic64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_tail_lsn</span><span class="p">,</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_tail_lsn</span><span class="p">));</span>
	<span class="n">atomic64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_last_sync_lsn</span><span class="p">,</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_lsn</span><span class="p">));</span>
	<span class="n">xlog_assign_grant_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_reserve_head</span><span class="p">.</span><span class="n">grant</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span><span class="p">,</span>
					<span class="n">BBTOB</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_block</span><span class="p">));</span>
	<span class="n">xlog_assign_grant_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_write_head</span><span class="p">.</span><span class="n">grant</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span><span class="p">,</span>
					<span class="n">BBTOB</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_block</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look for unmount record.  If we find it, then we know there</span>
<span class="cm">	 * was a clean unmount.  Since &#39;i&#39; could be the last block in</span>
<span class="cm">	 * the physical log, we convert to a log block before comparing</span>
<span class="cm">	 * to the head_blk.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Save the current tail lsn to use to pass to</span>
<span class="cm">	 * xlog_clear_stale_blocks() below.  We won&#39;t want to clear the</span>
<span class="cm">	 * unmount record if there is one, so we pass the lsn of the</span>
<span class="cm">	 * unmount record rather than the block after it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_haslogv2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">h_size</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_size</span><span class="p">);</span>
		<span class="kt">int</span>	<span class="n">h_version</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_version</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">h_version</span> <span class="o">&amp;</span> <span class="n">XLOG_VERSION_2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">h_size</span> <span class="o">&gt;</span> <span class="n">XLOG_HEADER_CYCLE_SIZE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hblks</span> <span class="o">=</span> <span class="n">h_size</span> <span class="o">/</span> <span class="n">XLOG_HEADER_CYCLE_SIZE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">h_size</span> <span class="o">%</span> <span class="n">XLOG_HEADER_CYCLE_SIZE</span><span class="p">)</span>
				<span class="n">hblks</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hblks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hblks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">after_umount_blk</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">hblks</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span>
		<span class="n">BTOBB</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_len</span><span class="p">)))</span> <span class="o">%</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">;</span>
	<span class="n">tail_lsn</span> <span class="o">=</span> <span class="n">atomic64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_tail_lsn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">head_blk</span> <span class="o">==</span> <span class="n">after_umount_blk</span> <span class="o">&amp;&amp;</span>
	    <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_num_logops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">umount_data_blk</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">hblks</span><span class="p">)</span> <span class="o">%</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">umount_data_blk</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

		<span class="n">op_head</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlog_op_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">op_head</span><span class="o">-&gt;</span><span class="n">oh_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_UNMOUNT_TRANS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Set tail and last sync so that newly written</span>
<span class="cm">			 * log records will point recovery to after the</span>
<span class="cm">			 * current unmount record.</span>
<span class="cm">			 */</span>
			<span class="n">xlog_assign_atomic_lsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_tail_lsn</span><span class="p">,</span>
					<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span><span class="p">,</span> <span class="n">after_umount_blk</span><span class="p">);</span>
			<span class="n">xlog_assign_atomic_lsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_last_sync_lsn</span><span class="p">,</span>
					<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span><span class="p">,</span> <span class="n">after_umount_blk</span><span class="p">);</span>
			<span class="o">*</span><span class="n">tail_blk</span> <span class="o">=</span> <span class="n">after_umount_blk</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Note that the unmount was clean. If the unmount</span>
<span class="cm">			 * was not clean, we need to know this to rebuild the</span>
<span class="cm">			 * superblock counters from the perag headers if we</span>
<span class="cm">			 * have a filesystem using non-persistent counters.</span>
<span class="cm">			 */</span>
			<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">XFS_MOUNT_WAS_CLEAN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure that there are no blocks in front of the head</span>
<span class="cm">	 * with the same cycle number as the head.  This can happen</span>
<span class="cm">	 * because we allow multiple outstanding log writes concurrently,</span>
<span class="cm">	 * and the later writes might make it out before earlier ones.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We use the lsn from before modifying it so that we&#39;ll never</span>
<span class="cm">	 * overwrite the unmount record after a clean unmount.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Do this only if we are going to recover the filesystem</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: This used to say &quot;if (!readonly)&quot;</span>
<span class="cm">	 * However on Linux, we can &amp; do recover a read-only filesystem.</span>
<span class="cm">	 * We only skip recovery if NORECOVERY is specified on mount,</span>
<span class="cm">	 * in which case we would not be here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But... if the -device- itself is readonly, just skip this.</span>
<span class="cm">	 * We can&#39;t recover this device anyway, so it won&#39;t matter.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_readonly_buftarg</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_clear_stale_blocks</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tail_lsn</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">xlog_put_bp</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;failed to locate log tail&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Is the log zeroed at all?</span>
<span class="cm"> *</span>
<span class="cm"> * The last binary search should be changed to perform an X block read</span>
<span class="cm"> * once X becomes small enough.  You can then search linearly through</span>
<span class="cm"> * the X blocks.  This will cut down on the number of reads we need to do.</span>
<span class="cm"> *</span>
<span class="cm"> * If the log is partially zeroed, this routine will pass back the blkno</span>
<span class="cm"> * of the first block with cycle number 0.  It won&#39;t have a complete LR</span>
<span class="cm"> * preceding it.</span>
<span class="cm"> *</span>
<span class="cm"> * Return:</span>
<span class="cm"> *	0  =&gt; the log is completely written to</span>
<span class="cm"> *	-1 =&gt; use *blk_no as the first block of the log</span>
<span class="cm"> *	&gt;0 =&gt; error has occurred</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_find_zeroed</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="o">*</span><span class="n">blk_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_caddr_t</span>	<span class="n">offset</span><span class="p">;</span>
	<span class="n">uint</span>	        <span class="n">first_cycle</span><span class="p">,</span> <span class="n">last_cycle</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">new_blk</span><span class="p">,</span> <span class="n">last_blk</span><span class="p">,</span> <span class="n">start_blk</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span>     <span class="n">num_scan_bblks</span><span class="p">;</span>
	<span class="kt">int</span>	        <span class="n">error</span><span class="p">,</span> <span class="n">log_bbnum</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">;</span>

	<span class="o">*</span><span class="n">blk_no</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* check totally zeroed log */</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="n">xlog_get_bp</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>

	<span class="n">first_cycle</span> <span class="o">=</span> <span class="n">xlog_get_cycle</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_cycle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* completely zeroed log */</span>
		<span class="o">*</span><span class="n">blk_no</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xlog_put_bp</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check partially zeroed log */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">log_bbnum</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>

	<span class="n">last_cycle</span> <span class="o">=</span> <span class="n">xlog_get_cycle</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_cycle</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* log completely written to */</span>
		<span class="n">xlog_put_bp</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">first_cycle</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the cycle of the last block is zero, the cycle of</span>
<span class="cm">		 * the first block must be 1. If it&#39;s not, maybe we&#39;re</span>
<span class="cm">		 * not looking at a log... Bail out.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span>
			<span class="s">&quot;Log inconsistent or not a log (last==0, first!=1)&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* we have a partially zeroed log */</span>
	<span class="n">last_blk</span> <span class="o">=</span> <span class="n">log_bbnum</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_find_cycle_start</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_blk</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate the answer.  Because there is no way to guarantee that</span>
<span class="cm">	 * the entire log is made up of log records which are the same size,</span>
<span class="cm">	 * we scan over the defined maximum blocks.  At this point, the maximum</span>
<span class="cm">	 * is not chosen to mean anything special.   XXXmiken</span>
<span class="cm">	 */</span>
	<span class="n">num_scan_bblks</span> <span class="o">=</span> <span class="n">XLOG_TOTAL_REC_SHIFT</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">num_scan_bblks</span> <span class="o">&lt;=</span> <span class="n">INT_MAX</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_blk</span> <span class="o">&lt;</span> <span class="n">num_scan_bblks</span><span class="p">)</span>
		<span class="n">num_scan_bblks</span> <span class="o">=</span> <span class="n">last_blk</span><span class="p">;</span>
	<span class="n">start_blk</span> <span class="o">=</span> <span class="n">last_blk</span> <span class="o">-</span> <span class="n">num_scan_bblks</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We search for any instances of cycle number 0 that occur before</span>
<span class="cm">	 * our current estimate of the head.  What we&#39;re trying to detect is</span>
<span class="cm">	 *        1 ... | 0 | 1 | 0...</span>
<span class="cm">	 *                       ^ binary search ends here</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_find_verify_cycle</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">start_blk</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">num_scan_bblks</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_blk</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_blk</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">last_blk</span> <span class="o">=</span> <span class="n">new_blk</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Potentially backup over partial log record write.  We don&#39;t need</span>
<span class="cm">	 * to search the end of the log because we know it is zero.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_find_verify_log_record</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">start_blk</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">last_blk</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	    <span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
	    <span class="k">goto</span> <span class="n">bp_err</span><span class="p">;</span>

	<span class="o">*</span><span class="n">blk_no</span> <span class="o">=</span> <span class="n">last_blk</span><span class="p">;</span>
<span class="nl">bp_err:</span>
	<span class="n">xlog_put_bp</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These are simple subroutines used by xlog_clear_stale_blocks() below</span>
<span class="cm"> * to initialize a buffer full of empty log record headers and write</span>
<span class="cm"> * them into the log.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_add_record</span><span class="p">(</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">buf</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">cycle</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">block</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">tail_cycle</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">tail_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_rec_header_t</span>	<span class="o">*</span><span class="n">recp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlog_rec_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BBSIZE</span><span class="p">);</span>
	<span class="n">recp</span><span class="o">-&gt;</span><span class="n">h_magicno</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XLOG_HEADER_MAGIC_NUM</span><span class="p">);</span>
	<span class="n">recp</span><span class="o">-&gt;</span><span class="n">h_cycle</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">cycle</span><span class="p">);</span>
	<span class="n">recp</span><span class="o">-&gt;</span><span class="n">h_version</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span>
			<span class="n">xfs_sb_version_haslogv2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">recp</span><span class="o">-&gt;</span><span class="n">h_lsn</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">xlog_assign_lsn</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">block</span><span class="p">));</span>
	<span class="n">recp</span><span class="o">-&gt;</span><span class="n">h_tail_lsn</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">xlog_assign_lsn</span><span class="p">(</span><span class="n">tail_cycle</span><span class="p">,</span> <span class="n">tail_block</span><span class="p">));</span>
	<span class="n">recp</span><span class="o">-&gt;</span><span class="n">h_fmt</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XLOG_FMT</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recp</span><span class="o">-&gt;</span><span class="n">h_fs_uuid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_uuid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uuid_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_write_log_records</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">cycle</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">start_block</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">blocks</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">tail_cycle</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">tail_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_caddr_t</span>	<span class="n">offset</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">balign</span><span class="p">,</span> <span class="n">ealign</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">sectbb</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_sectBBsize</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">end_block</span> <span class="o">=</span> <span class="n">start_block</span> <span class="o">+</span> <span class="n">blocks</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">bufblks</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Greedily allocate a buffer big enough to handle the full</span>
<span class="cm">	 * range of basic blocks to be written.  If that fails, try</span>
<span class="cm">	 * a smaller size.  We need to be able to write at least a</span>
<span class="cm">	 * log sector, or we&#39;re out of luck.</span>
<span class="cm">	 */</span>
	<span class="n">bufblks</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ffs</span><span class="p">(</span><span class="n">blocks</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bufblks</span> <span class="o">&gt;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">)</span>
		<span class="n">bufblks</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bp</span> <span class="o">=</span> <span class="n">xlog_get_bp</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">bufblks</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">bufblks</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bufblks</span> <span class="o">&lt;</span> <span class="n">sectbb</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We may need to do a read at the start to fill in part of</span>
<span class="cm">	 * the buffer in the starting sector not covered by the first</span>
<span class="cm">	 * write below.</span>
<span class="cm">	 */</span>
	<span class="n">balign</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">start_block</span><span class="p">,</span> <span class="n">sectbb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">balign</span> <span class="o">!=</span> <span class="n">start_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread_noalign</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">start_block</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_put_bp</span><span class="p">;</span>

		<span class="n">j</span> <span class="o">=</span> <span class="n">start_block</span> <span class="o">-</span> <span class="n">balign</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start_block</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end_block</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">bufblks</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>		<span class="n">bcount</span><span class="p">,</span> <span class="n">endcount</span><span class="p">;</span>

		<span class="n">bcount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bufblks</span><span class="p">,</span> <span class="n">end_block</span> <span class="o">-</span> <span class="n">start_block</span><span class="p">);</span>
		<span class="n">endcount</span> <span class="o">=</span> <span class="n">bcount</span> <span class="o">-</span> <span class="n">j</span><span class="p">;</span>

		<span class="cm">/* We may need to do a read at the end to fill in part of</span>
<span class="cm">		 * the buffer in the final sector not covered by the write.</span>
<span class="cm">		 * If this is the same sector as the above read, skip it.</span>
<span class="cm">		 */</span>
		<span class="n">ealign</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">end_block</span><span class="p">,</span> <span class="n">sectbb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">start_block</span> <span class="o">+</span> <span class="n">endcount</span> <span class="o">&gt;</span> <span class="n">ealign</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">+</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">ealign</span> <span class="o">-</span> <span class="n">start_block</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread_offset</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">ealign</span><span class="p">,</span> <span class="n">sectbb</span><span class="p">,</span>
							<span class="n">bp</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="p">}</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">xlog_align</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">start_block</span><span class="p">,</span> <span class="n">endcount</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">endcount</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xlog_add_record</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">,</span>
					<span class="n">tail_cycle</span><span class="p">,</span> <span class="n">tail_block</span><span class="p">);</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">BBSIZE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bwrite</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">start_block</span><span class="p">,</span> <span class="n">endcount</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">start_block</span> <span class="o">+=</span> <span class="n">endcount</span><span class="p">;</span>
		<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">out_put_bp:</span>
	<span class="n">xlog_put_bp</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine is called to blow away any incomplete log writes out</span>
<span class="cm"> * in front of the log head.  We do this so that we won&#39;t become confused</span>
<span class="cm"> * if we come up, write only a little bit more, and then crash again.</span>
<span class="cm"> * If we leave the partial log records out there, this situation could</span>
<span class="cm"> * cause us to think those partial writes are valid blocks since they</span>
<span class="cm"> * have the current cycle number.  We get rid of them by overwriting them</span>
<span class="cm"> * with empty log records with the old cycle number rather than the</span>
<span class="cm"> * current one.</span>
<span class="cm"> *</span>
<span class="cm"> * The tail lsn is passed in rather than taken from</span>
<span class="cm"> * the log so that we will not write over the unmount record after a</span>
<span class="cm"> * clean unmount in a 512 block log.  Doing so would leave the log without</span>
<span class="cm"> * any valid log records in it until a new one was written.  If we crashed</span>
<span class="cm"> * during that time we would not be able to recover.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_clear_stale_blocks</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>	<span class="n">tail_lsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">tail_cycle</span><span class="p">,</span> <span class="n">head_cycle</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">tail_block</span><span class="p">,</span> <span class="n">head_block</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">tail_distance</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">distance</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">tail_cycle</span> <span class="o">=</span> <span class="n">CYCLE_LSN</span><span class="p">(</span><span class="n">tail_lsn</span><span class="p">);</span>
	<span class="n">tail_block</span> <span class="o">=</span> <span class="n">BLOCK_LSN</span><span class="p">(</span><span class="n">tail_lsn</span><span class="p">);</span>
	<span class="n">head_cycle</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_cycle</span><span class="p">;</span>
	<span class="n">head_block</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_curr_block</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Figure out the distance between the new head of the log</span>
<span class="cm">	 * and the tail.  We want to write over any blocks beyond the</span>
<span class="cm">	 * head that we may have written just before the crash, but</span>
<span class="cm">	 * we don&#39;t want to overwrite the tail of the log.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head_cycle</span> <span class="o">==</span> <span class="n">tail_cycle</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The tail is behind the head in the physical log,</span>
<span class="cm">		 * so the distance from the head to the tail is the</span>
<span class="cm">		 * distance from the head to the end of the log plus</span>
<span class="cm">		 * the distance from the beginning of the log to the</span>
<span class="cm">		 * tail.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">head_block</span> <span class="o">&lt;</span> <span class="n">tail_block</span> <span class="o">||</span> <span class="n">head_block</span> <span class="o">&gt;=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xlog_clear_stale_blocks(1)&quot;</span><span class="p">,</span>
					 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">tail_distance</span> <span class="o">=</span> <span class="n">tail_block</span> <span class="o">+</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span> <span class="o">-</span> <span class="n">head_block</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The head is behind the tail in the physical log,</span>
<span class="cm">		 * so the distance from the head to the tail is just</span>
<span class="cm">		 * the tail block minus the head block.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">head_block</span> <span class="o">&gt;=</span> <span class="n">tail_block</span> <span class="o">||</span> <span class="n">head_cycle</span> <span class="o">!=</span> <span class="p">(</span><span class="n">tail_cycle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))){</span>
			<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xlog_clear_stale_blocks(2)&quot;</span><span class="p">,</span>
					 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">tail_distance</span> <span class="o">=</span> <span class="n">tail_block</span> <span class="o">-</span> <span class="n">head_block</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the head is right up against the tail, we can&#39;t clear</span>
<span class="cm">	 * anything.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tail_distance</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">tail_distance</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">max_distance</span> <span class="o">=</span> <span class="n">XLOG_TOTAL_REC_SHIFT</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Take the smaller of the maximum amount of outstanding I/O</span>
<span class="cm">	 * we could have and the distance to the tail to clear out.</span>
<span class="cm">	 * We take the smaller so that we don&#39;t overwrite the tail and</span>
<span class="cm">	 * we don&#39;t waste all day writing from the head to the tail</span>
<span class="cm">	 * for no reason.</span>
<span class="cm">	 */</span>
	<span class="n">max_distance</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">max_distance</span><span class="p">,</span> <span class="n">tail_distance</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">head_block</span> <span class="o">+</span> <span class="n">max_distance</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can stomp all the blocks we need to without</span>
<span class="cm">		 * wrapping around the end of the log.  Just do it</span>
<span class="cm">		 * in a single write.  Use the cycle number of the</span>
<span class="cm">		 * current cycle minus one so that the log will look like:</span>
<span class="cm">		 *     n ... | n - 1 ...</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_write_log_records</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="p">(</span><span class="n">head_cycle</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
				<span class="n">head_block</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">tail_cycle</span><span class="p">,</span>
				<span class="n">tail_block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need to wrap around the end of the physical log in</span>
<span class="cm">		 * order to clear all the blocks.  Do it in two separate</span>
<span class="cm">		 * I/Os.  The first write should be from the head to the</span>
<span class="cm">		 * end of the physical log, and it should use the current</span>
<span class="cm">		 * cycle number minus one just like above.</span>
<span class="cm">		 */</span>
		<span class="n">distance</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span> <span class="o">-</span> <span class="n">head_block</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_write_log_records</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="p">(</span><span class="n">head_cycle</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
				<span class="n">head_block</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">tail_cycle</span><span class="p">,</span>
				<span class="n">tail_block</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Now write the blocks at the start of the physical log.</span>
<span class="cm">		 * This writes the remainder of the blocks we want to clear.</span>
<span class="cm">		 * It uses the current cycle number since we&#39;re now on the</span>
<span class="cm">		 * same cycle as the head so that we get:</span>
<span class="cm">		 *    n ... n ... | n - 1 ...</span>
<span class="cm">		 *    ^^^^^ blocks we&#39;re writing</span>
<span class="cm">		 */</span>
		<span class="n">distance</span> <span class="o">=</span> <span class="n">max_distance</span> <span class="o">-</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span> <span class="o">-</span> <span class="n">head_block</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_write_log_records</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">head_cycle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span>
				<span class="n">tail_cycle</span><span class="p">,</span> <span class="n">tail_block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *		Log recover routines</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> */</span>

<span class="n">STATIC</span> <span class="n">xlog_recover_t</span> <span class="o">*</span>
<span class="nf">xlog_recover_find_tid</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="o">*</span><span class="n">head</span><span class="p">,</span>
	<span class="n">xlog_tid_t</span>		<span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_recover_t</span>		<span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">r_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_log_tid</span> <span class="o">==</span> <span class="n">tid</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">trans</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_recover_new_tid</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="o">*</span><span class="n">head</span><span class="p">,</span>
	<span class="n">xlog_tid_t</span>		<span class="n">tid</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">lsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_recover_t</span>		<span class="o">*</span><span class="n">trans</span><span class="p">;</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">kmem_zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_recover_t</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_log_tid</span>   <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_lsn</span>	   <span class="o">=</span> <span class="n">lsn</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_itemq</span><span class="p">);</span>

	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_list</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_recover_add_item</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">;</span>

	<span class="n">item</span> <span class="o">=</span> <span class="n">kmem_zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_recover_item_t</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_list</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_add_to_cont_trans</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_recover</span>	<span class="o">*</span><span class="n">trans</span><span class="p">,</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">dp</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">ptr</span><span class="p">,</span> <span class="n">old_ptr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">old_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_itemq</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* finish copying rest of trans header */</span>
		<span class="n">xlog_recover_add_item</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_itemq</span><span class="p">);</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_caddr_t</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_theader</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_trans_header_t</span><span class="p">)</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span> <span class="cm">/* d, s, l */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* take the tail entry */</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_itemq</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">xlog_recover_item_t</span><span class="p">,</span> <span class="n">ri_list</span><span class="p">);</span>

	<span class="n">old_ptr</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">i_addr</span><span class="p">;</span>
	<span class="n">old_len</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">i_len</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">kmem_realloc</span><span class="p">(</span><span class="n">old_ptr</span><span class="p">,</span> <span class="n">len</span><span class="o">+</span><span class="n">old_len</span><span class="p">,</span> <span class="n">old_len</span><span class="p">,</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">[</span><span class="n">old_len</span><span class="p">],</span> <span class="n">dp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span> <span class="cm">/* d, s, l */</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">i_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">i_addr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">trace_xfs_log_recover_item_add_cont</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The next region to add is the start of a new region.  It could be</span>
<span class="cm"> * a whole region or it could be the first part of a new region.  Because</span>
<span class="cm"> * of this, the assumption here is that the type and size fields of all</span>
<span class="cm"> * format structures fit into the first 32 bits of the structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This works because all regions must be 32 bit aligned.  Therefore, we</span>
<span class="cm"> * either have both fields or we have neither field.  In the case we have</span>
<span class="cm"> * neither field, the data part of the region is zero length.  We only have</span>
<span class="cm"> * a log_op_header and can throw away the header since a new one will appear</span>
<span class="cm"> * later.  If we have at least 4 bytes, then we can determine how many regions</span>
<span class="cm"> * will appear in the current log item.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_add_to_trans</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_recover</span>	<span class="o">*</span><span class="n">trans</span><span class="p">,</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">dp</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_inode_log_format_t</span>	<span class="o">*</span><span class="n">in_f</span><span class="p">;</span>			<span class="cm">/* any will do */</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_itemq</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* we need to catch log corruptions here */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">uint</span> <span class="o">*</span><span class="p">)</span><span class="n">dp</span> <span class="o">!=</span> <span class="n">XFS_TRANS_HEADER_MAGIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: bad header magic number&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_trans_header_t</span><span class="p">))</span>
			<span class="n">xlog_recover_add_item</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_itemq</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_theader</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span> <span class="cm">/* d, s, l */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">in_f</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_inode_log_format_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>

	<span class="cm">/* take the tail entry */</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_itemq</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">xlog_recover_item_t</span><span class="p">,</span> <span class="n">ri_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_total</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	     <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_total</span> <span class="o">==</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* tail item is in use, get a new one */</span>
		<span class="n">xlog_recover_add_item</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_itemq</span><span class="p">);</span>
		<span class="n">item</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_itemq</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
					<span class="n">xlog_recover_item_t</span><span class="p">,</span> <span class="n">ri_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* first region to be added */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_size</span> <span class="o">&gt;</span> <span class="n">XLOG_MAX_REGIONS_IN_ITEM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span>
		<span class="s">&quot;bad number of regions (%d) in inode log format&quot;</span><span class="p">,</span>
				  <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_size</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_total</span> <span class="o">=</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_size</span><span class="p">;</span>
		<span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span> <span class="o">=</span>
			<span class="n">kmem_zalloc</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_total</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_log_iovec_t</span><span class="p">),</span>
				    <span class="n">KM_SLEEP</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_total</span> <span class="o">&gt;</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_cnt</span><span class="p">);</span>
	<span class="cm">/* Description region is ri_buf[0] */</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_cnt</span><span class="p">].</span><span class="n">i_addr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_cnt</span><span class="p">].</span><span class="n">i_len</span>  <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">trace_xfs_log_recover_item_add</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sort the log items in the transaction. Cancelled buffers need</span>
<span class="cm"> * to be put first so they are processed before any items that might</span>
<span class="cm"> * modify the buffers. If they are cancelled, then the modifications</span>
<span class="cm"> * don&#39;t need to be replayed.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_reorder_trans</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_recover</span>	<span class="o">*</span><span class="n">trans</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">pass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">sort_list</span><span class="p">);</span>

	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_itemq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sort_list</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sort_list</span><span class="p">,</span> <span class="n">ri_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_buf_log_format_t</span>	<span class="o">*</span><span class="n">buf_f</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">i_addr</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ITEM_TYPE</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">XFS_LI_BUF</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_flags</span> <span class="o">&amp;</span> <span class="n">XFS_BLF_CANCEL</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">trace_xfs_log_recover_item_reorder_head</span><span class="p">(</span><span class="n">log</span><span class="p">,</span>
							<span class="n">trans</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">pass</span><span class="p">);</span>
				<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_itemq</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="n">XFS_LI_INODE</span>:
		<span class="k">case</span> <span class="n">XFS_LI_DQUOT</span>:
		<span class="k">case</span> <span class="n">XFS_LI_QUOTAOFF</span>:
		<span class="k">case</span> <span class="n">XFS_LI_EFD</span>:
		<span class="k">case</span> <span class="n">XFS_LI_EFI</span>:
			<span class="n">trace_xfs_log_recover_item_reorder_tail</span><span class="p">(</span><span class="n">log</span><span class="p">,</span>
							<span class="n">trans</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">pass</span><span class="p">);</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_itemq</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span>
				<span class="s">&quot;%s: unrecognized type of log operation&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sort_list</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Build up the table of buf cancel records so that we don&#39;t replay</span>
<span class="cm"> * cancelled data in the second pass.  For buffer records that are</span>
<span class="cm"> * not cancel records, there is nothing to do here so we just return.</span>
<span class="cm"> *</span>
<span class="cm"> * If we get a cancel record which is already in the table, this indicates</span>
<span class="cm"> * that the buffer was cancelled multiple times.  In order to ensure</span>
<span class="cm"> * that during pass 2 we keep the record in the table until we reach its</span>
<span class="cm"> * last occurrence in the log, we keep a reference count in the cancel</span>
<span class="cm"> * record in the table to tell us how many times we expect to see this</span>
<span class="cm"> * record during the second pass.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_buffer_pass1</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_recover_item</span>	<span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_log_format_t</span>	<span class="o">*</span><span class="n">buf_f</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">i_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">bucket</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_buf_cancel</span>	<span class="o">*</span><span class="n">bcp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this isn&#39;t a cancel buffer item, then just return.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_flags</span> <span class="o">&amp;</span> <span class="n">XFS_BLF_CANCEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trace_xfs_log_recover_buf_not_cancel</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">buf_f</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Insert an xfs_buf_cancel record into the hash table of them.</span>
<span class="cm">	 * If there is already an identical record, bump its reference count.</span>
<span class="cm">	 */</span>
	<span class="n">bucket</span> <span class="o">=</span> <span class="n">XLOG_BUF_CANCEL_BUCKET</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_blkno</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bcp</span><span class="p">,</span> <span class="n">bucket</span><span class="p">,</span> <span class="n">bc_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">bc_blkno</span> <span class="o">==</span> <span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_blkno</span> <span class="o">&amp;&amp;</span>
		    <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">bc_len</span> <span class="o">==</span> <span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">bc_refcount</span><span class="o">++</span><span class="p">;</span>
			<span class="n">trace_xfs_log_recover_buf_cancel_ref_inc</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">buf_f</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">bcp</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_buf_cancel</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
	<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">bc_blkno</span> <span class="o">=</span> <span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_blkno</span><span class="p">;</span>
	<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">bc_len</span> <span class="o">=</span> <span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_len</span><span class="p">;</span>
	<span class="n">bcp</span><span class="o">-&gt;</span><span class="n">bc_refcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">bc_list</span><span class="p">,</span> <span class="n">bucket</span><span class="p">);</span>

	<span class="n">trace_xfs_log_recover_buf_cancel_add</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">buf_f</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check to see whether the buffer being recovered has a corresponding</span>
<span class="cm"> * entry in the buffer cancel record table.  If it does then return 1</span>
<span class="cm"> * so that it will be cancelled, otherwise return 0.  If the buffer is</span>
<span class="cm"> * actually a buffer cancel item (XFS_BLF_CANCEL is set), then decrement</span>
<span class="cm"> * the refcount on the entry in the table and remove it from the table</span>
<span class="cm"> * if this is the last reference.</span>
<span class="cm"> *</span>
<span class="cm"> * We remove the cancel record from the table when we encounter its</span>
<span class="cm"> * last occurrence in the log so that if the same buffer is re-used</span>
<span class="cm"> * again after its last cancellation we actually replay the changes</span>
<span class="cm"> * made at that point.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_check_buffer_cancelled</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">blkno</span><span class="p">,</span>
	<span class="n">uint</span>			<span class="n">len</span><span class="p">,</span>
	<span class="n">ushort</span>			<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">bucket</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_buf_cancel</span>	<span class="o">*</span><span class="n">bcp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_buf_cancel_table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * There is nothing in the table built in pass one,</span>
<span class="cm">		 * so this buffer must not be cancelled.</span>
<span class="cm">		 */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_BLF_CANCEL</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search for an entry in the  cancel table that matches our buffer.</span>
<span class="cm">	 */</span>
	<span class="n">bucket</span> <span class="o">=</span> <span class="n">XLOG_BUF_CANCEL_BUCKET</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">blkno</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bcp</span><span class="p">,</span> <span class="n">bucket</span><span class="p">,</span> <span class="n">bc_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">bc_blkno</span> <span class="o">==</span> <span class="n">blkno</span> <span class="o">&amp;&amp;</span> <span class="n">bcp</span><span class="o">-&gt;</span><span class="n">bc_len</span> <span class="o">==</span> <span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We didn&#39;t find a corresponding entry in the table, so return 0 so</span>
<span class="cm">	 * that the buffer is NOT cancelled.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_BLF_CANCEL</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ve go a match, so return 1 so that the recovery of this buffer</span>
<span class="cm">	 * is cancelled.  If this buffer is actually a buffer cancel log</span>
<span class="cm">	 * item, then decrement the refcount on the one in the table and</span>
<span class="cm">	 * remove it if this is the last reference.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_BLF_CANCEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">bc_refcount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcp</span><span class="o">-&gt;</span><span class="n">bc_list</span><span class="p">);</span>
			<span class="n">kmem_free</span><span class="p">(</span><span class="n">bcp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform recovery for a buffer full of inodes.  In these buffers, the only</span>
<span class="cm"> * data which should be recovered is that which corresponds to the</span>
<span class="cm"> * di_next_unlinked pointers in the on disk inode structures.  The rest of the</span>
<span class="cm"> * data for the inodes is always logged through the inodes themselves rather</span>
<span class="cm"> * than the inode buffer and is recovered in xlog_recover_inode_pass2().</span>
<span class="cm"> *</span>
<span class="cm"> * The only time when buffers full of inodes are fully recovered is when the</span>
<span class="cm"> * buffer is full of newly allocated inodes.  In this case the buffer will</span>
<span class="cm"> * not be marked as an inode buffer and so will be sent to</span>
<span class="cm"> * xlog_recover_do_reg_buffer() below during recovery.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_do_inode_buffer</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="n">xfs_buf_log_format_t</span>	<span class="o">*</span><span class="n">buf_f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">item_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nbits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">reg_buf_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">reg_buf_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">next_unlinked_offset</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">inodes_per_buf</span><span class="p">;</span>
	<span class="n">xfs_agino_t</span>		<span class="o">*</span><span class="n">logged_nextp</span><span class="p">;</span>
	<span class="n">xfs_agino_t</span>		<span class="o">*</span><span class="n">buffer_nextp</span><span class="p">;</span>

	<span class="n">trace_xfs_log_recover_buf_inode_buf</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">,</span> <span class="n">buf_f</span><span class="p">);</span>

	<span class="n">inodes_per_buf</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_length</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodelog</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inodes_per_buf</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next_unlinked_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodesize</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_dinode_t</span><span class="p">,</span> <span class="n">di_next_unlinked</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">next_unlinked_offset</span> <span class="o">&gt;=</span>
		       <span class="p">(</span><span class="n">reg_buf_offset</span> <span class="o">+</span> <span class="n">reg_buf_bytes</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The next di_next_unlinked field is beyond</span>
<span class="cm">			 * the current logged region.  Find the next</span>
<span class="cm">			 * logged region that contains or is beyond</span>
<span class="cm">			 * the current di_next_unlinked field.</span>
<span class="cm">			 */</span>
			<span class="n">bit</span> <span class="o">+=</span> <span class="n">nbits</span><span class="p">;</span>
			<span class="n">bit</span> <span class="o">=</span> <span class="n">xfs_next_bit</span><span class="p">(</span><span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_data_map</span><span class="p">,</span>
					   <span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_map_size</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * If there are no more logged regions in the</span>
<span class="cm">			 * buffer, then we&#39;re done.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">nbits</span> <span class="o">=</span> <span class="n">xfs_contig_bits</span><span class="p">(</span><span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_data_map</span><span class="p">,</span>
						<span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_map_size</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">nbits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">reg_buf_offset</span> <span class="o">=</span> <span class="n">bit</span> <span class="o">&lt;&lt;</span> <span class="n">XFS_BLF_SHIFT</span><span class="p">;</span>
			<span class="n">reg_buf_bytes</span> <span class="o">=</span> <span class="n">nbits</span> <span class="o">&lt;&lt;</span> <span class="n">XFS_BLF_SHIFT</span><span class="p">;</span>
			<span class="n">item_index</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the current logged region starts after the current</span>
<span class="cm">		 * di_next_unlinked field, then move on to the next</span>
<span class="cm">		 * di_next_unlinked field.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_unlinked_offset</span> <span class="o">&lt;</span> <span class="n">reg_buf_offset</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">item_index</span><span class="p">].</span><span class="n">i_addr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">((</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">item_index</span><span class="p">].</span><span class="n">i_len</span> <span class="o">%</span> <span class="n">XFS_BLF_CHUNK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">((</span><span class="n">reg_buf_offset</span> <span class="o">+</span> <span class="n">reg_buf_bytes</span><span class="p">)</span> <span class="o">&lt;=</span>
							<span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_length</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * The current logged region contains a copy of the</span>
<span class="cm">		 * current di_next_unlinked field.  Extract its value</span>
<span class="cm">		 * and copy it to the buffer copy.</span>
<span class="cm">		 */</span>
		<span class="n">logged_nextp</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">item_index</span><span class="p">].</span><span class="n">i_addr</span> <span class="o">+</span>
				<span class="n">next_unlinked_offset</span> <span class="o">-</span> <span class="n">reg_buf_offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">logged_nextp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
		<span class="s">&quot;Bad inode buffer log record (ptr = 0x%p, bp = 0x%p). &quot;</span>
		<span class="s">&quot;Trying to replay bad (0) inode di_next_unlinked field.&quot;</span><span class="p">,</span>
				<span class="n">item</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xlog_recover_do_inode_buf&quot;</span><span class="p">,</span>
					 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">buffer_nextp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_agino_t</span> <span class="o">*</span><span class="p">)</span><span class="n">xfs_buf_offset</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span>
					      <span class="n">next_unlinked_offset</span><span class="p">);</span>
		<span class="o">*</span><span class="n">buffer_nextp</span> <span class="o">=</span> <span class="o">*</span><span class="n">logged_nextp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform a &#39;normal&#39; buffer recovery.  Each logged region of the</span>
<span class="cm"> * buffer should be copied over the corresponding region in the</span>
<span class="cm"> * given buffer.  The bitmap in the buf log format structure indicates</span>
<span class="cm"> * where to place the logged data.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_recover_do_reg_buffer</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="n">xfs_buf_log_format_t</span>	<span class="o">*</span><span class="n">buf_f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">bit</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nbits</span><span class="p">;</span>
	<span class="kt">int</span>                     <span class="n">error</span><span class="p">;</span>

	<span class="n">trace_xfs_log_recover_buf_reg_buf</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">,</span> <span class="n">buf_f</span><span class="p">);</span>

	<span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* 0 is the buf format structure */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="n">xfs_next_bit</span><span class="p">(</span><span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_data_map</span><span class="p">,</span>
				   <span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_map_size</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">nbits</span> <span class="o">=</span> <span class="n">xfs_contig_bits</span><span class="p">(</span><span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_data_map</span><span class="p">,</span>
					<span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_map_size</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nbits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">i_addr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">i_len</span> <span class="o">%</span> <span class="n">XFS_BLF_CHUNK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_length</span><span class="p">)</span> <span class="o">&gt;=</span>
		       <span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="n">bit</span> <span class="o">&lt;&lt;</span> <span class="n">XFS_BLF_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nbits</span> <span class="o">&lt;&lt;</span> <span class="n">XFS_BLF_SHIFT</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do a sanity check if this is a dquot buffer. Just checking</span>
<span class="cm">		 * the first dquot in the buffer should do. XXXThis is</span>
<span class="cm">		 * probably a good thing to do for other buf types also.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_flags</span> <span class="o">&amp;</span>
		   <span class="p">(</span><span class="n">XFS_BLF_UDQUOT_BUF</span><span class="o">|</span><span class="n">XFS_BLF_PDQUOT_BUF</span><span class="o">|</span><span class="n">XFS_BLF_GDQUOT_BUF</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">i_addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
					<span class="s">&quot;XFS: NULL dquot in %s.&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">i_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_disk_dquot_t</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
					<span class="s">&quot;XFS: dquot too small (%d) in %s.&quot;</span><span class="p">,</span>
					<span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">i_len</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_dqcheck</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">i_addr</span><span class="p">,</span>
					       <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_QMOPT_DOWARN</span><span class="p">,</span>
					       <span class="s">&quot;dquot_buf_recover&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">xfs_buf_offset</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span>
			<span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="n">bit</span> <span class="o">&lt;&lt;</span> <span class="n">XFS_BLF_SHIFT</span><span class="p">),</span>	<span class="cm">/* dest */</span>
			<span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">i_addr</span><span class="p">,</span>		<span class="cm">/* source */</span>
			<span class="n">nbits</span><span class="o">&lt;&lt;</span><span class="n">XFS_BLF_SHIFT</span><span class="p">);</span>		<span class="cm">/* length */</span>
 <span class="nl">next:</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="n">bit</span> <span class="o">+=</span> <span class="n">nbits</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Shouldn&#39;t be any more regions */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_total</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do some primitive error checking on ondisk dquot data structures.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_qm_dqcheck</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_disk_dquot_t</span> <span class="o">*</span><span class="n">ddq</span><span class="p">,</span>
	<span class="n">xfs_dqid_t</span>	 <span class="n">id</span><span class="p">,</span>
	<span class="n">uint</span>		 <span class="n">type</span><span class="p">,</span>	  <span class="cm">/* used only when IO_dorepair is true */</span>
	<span class="n">uint</span>		 <span class="n">flags</span><span class="p">,</span>
	<span class="kt">char</span>		 <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_dqblk_t</span>	 <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dqblk_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ddq</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">errs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can encounter an uninitialized dquot buffer for 2 reasons:</span>
<span class="cm">	 * 1. If we crash while deleting the quotainode(s), and those blks got</span>
<span class="cm">	 *    used for user data. This is because we take the path of regular</span>
<span class="cm">	 *    file deletion; however, the size field of quotainodes is never</span>
<span class="cm">	 *    updated, so all the tricks that we play in itruncate_finish</span>
<span class="cm">	 *    don&#39;t quite matter.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 2. We don&#39;t play the quota buffers when there&#39;s a quotaoff logitem.</span>
<span class="cm">	 *    But the allocation will be replayed so we&#39;ll end up with an</span>
<span class="cm">	 *    uninitialized quota block.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is all fine; things are still consistent, and we haven&#39;t lost</span>
<span class="cm">	 * any quota information. Just don&#39;t complain about bad dquot blks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_magic</span> <span class="o">!=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DQUOT_MAGIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_QMOPT_DOWARN</span><span class="p">)</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
			<span class="s">&quot;%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x&quot;</span><span class="p">,</span>
			<span class="n">str</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_magic</span><span class="p">),</span> <span class="n">XFS_DQUOT_MAGIC</span><span class="p">);</span>
		<span class="n">errs</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_version</span> <span class="o">!=</span> <span class="n">XFS_DQUOT_VERSION</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_QMOPT_DOWARN</span><span class="p">)</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
			<span class="s">&quot;%s : XFS dquot ID 0x%x, version 0x%x != 0x%x&quot;</span><span class="p">,</span>
			<span class="n">str</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_version</span><span class="p">,</span> <span class="n">XFS_DQUOT_VERSION</span><span class="p">);</span>
		<span class="n">errs</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">!=</span> <span class="n">XFS_DQ_USER</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">!=</span> <span class="n">XFS_DQ_PROJ</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">!=</span> <span class="n">XFS_DQ_GROUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_QMOPT_DOWARN</span><span class="p">)</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
			<span class="s">&quot;%s : XFS dquot ID 0x%x, unknown flags 0x%x&quot;</span><span class="p">,</span>
			<span class="n">str</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_flags</span><span class="p">);</span>
		<span class="n">errs</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">id</span> <span class="o">!=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_QMOPT_DOWARN</span><span class="p">)</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
			<span class="s">&quot;%s : ondisk-dquot 0x%p, ID mismatch: &quot;</span>
			<span class="s">&quot;0x%x expected, found id 0x%x&quot;</span><span class="p">,</span>
			<span class="n">str</span><span class="p">,</span> <span class="n">ddq</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_id</span><span class="p">));</span>
		<span class="n">errs</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">errs</span> <span class="o">&amp;&amp;</span> <span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_blk_softlimit</span> <span class="o">&amp;&amp;</span>
		    <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_bcount</span><span class="p">)</span> <span class="o">&gt;</span>
				<span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_blk_softlimit</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_btimer</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_QMOPT_DOWARN</span><span class="p">)</span>
					<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
			<span class="s">&quot;%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED&quot;</span><span class="p">,</span>
					<span class="n">str</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_id</span><span class="p">),</span> <span class="n">ddq</span><span class="p">);</span>
				<span class="n">errs</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_ino_softlimit</span> <span class="o">&amp;&amp;</span>
		    <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_icount</span><span class="p">)</span> <span class="o">&gt;</span>
				<span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_ino_softlimit</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_itimer</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_QMOPT_DOWARN</span><span class="p">)</span>
					<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
			<span class="s">&quot;%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED&quot;</span><span class="p">,</span>
					<span class="n">str</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_id</span><span class="p">),</span> <span class="n">ddq</span><span class="p">);</span>
				<span class="n">errs</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_rtb_softlimit</span> <span class="o">&amp;&amp;</span>
		    <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_rtbcount</span><span class="p">)</span> <span class="o">&gt;</span>
				<span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_rtb_softlimit</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_rtbtimer</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_QMOPT_DOWARN</span><span class="p">)</span>
					<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
			<span class="s">&quot;%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED&quot;</span><span class="p">,</span>
					<span class="n">str</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ddq</span><span class="o">-&gt;</span><span class="n">d_id</span><span class="p">),</span> <span class="n">ddq</span><span class="p">);</span>
				<span class="n">errs</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">errs</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_QMOPT_DQREPAIR</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">errs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_QMOPT_DOWARN</span><span class="p">)</span>
		<span class="n">xfs_notice</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;Re-initializing dquot ID 0x%x&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Typically, a repair is only requested by quotacheck.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_QMOPT_DQREPAIR</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_dqblk_t</span><span class="p">));</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dd_diskdq</span><span class="p">.</span><span class="n">d_magic</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DQUOT_MAGIC</span><span class="p">);</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dd_diskdq</span><span class="p">.</span><span class="n">d_version</span> <span class="o">=</span> <span class="n">XFS_DQUOT_VERSION</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dd_diskdq</span><span class="p">.</span><span class="n">d_flags</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dd_diskdq</span><span class="p">.</span><span class="n">d_id</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">errs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform a dquot buffer recovery.</span>
<span class="cm"> * Simple algorithm: if we have found a QUOTAOFF logitem of the same type</span>
<span class="cm"> * (ie. USR or GRP), then just toss this buffer away; don&#39;t recover it.</span>
<span class="cm"> * Else, treat it as a regular buffer and do recovery.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_recover_do_dquot_buffer</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="n">xfs_buf_log_format_t</span>	<span class="o">*</span><span class="n">buf_f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uint</span>			<span class="n">type</span><span class="p">;</span>

	<span class="n">trace_xfs_log_recover_buf_dquot_buf</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">buf_f</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Filesystems are required to send in quota flags at mount time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_qflags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_flags</span> <span class="o">&amp;</span> <span class="n">XFS_BLF_UDQUOT_BUF</span><span class="p">)</span>
		<span class="n">type</span> <span class="o">|=</span> <span class="n">XFS_DQ_USER</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_flags</span> <span class="o">&amp;</span> <span class="n">XFS_BLF_PDQUOT_BUF</span><span class="p">)</span>
		<span class="n">type</span> <span class="o">|=</span> <span class="n">XFS_DQ_PROJ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_flags</span> <span class="o">&amp;</span> <span class="n">XFS_BLF_GDQUOT_BUF</span><span class="p">)</span>
		<span class="n">type</span> <span class="o">|=</span> <span class="n">XFS_DQ_GROUP</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * This type of quotas was turned off, so ignore this buffer</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_quotaoffs_flag</span> <span class="o">&amp;</span> <span class="n">type</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">xlog_recover_do_reg_buffer</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">buf_f</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine replays a modification made to a buffer at runtime.</span>
<span class="cm"> * There are actually two types of buffer, regular and inode, which</span>
<span class="cm"> * are handled differently.  Inode buffers are handled differently</span>
<span class="cm"> * in that we only recover a specific set of data from them, namely</span>
<span class="cm"> * the inode di_next_unlinked fields.  This is because all other inode</span>
<span class="cm"> * data is actually logged via inode records and any data we replay</span>
<span class="cm"> * here which overlaps that may be stale.</span>
<span class="cm"> *</span>
<span class="cm"> * When meta-data buffers are freed at run time we log a buffer item</span>
<span class="cm"> * with the XFS_BLF_CANCEL bit set to indicate that previous copies</span>
<span class="cm"> * of the buffer in the log should not be replayed at recovery time.</span>
<span class="cm"> * This is so that if the blocks covered by the buffer are reused for</span>
<span class="cm"> * file data before we crash we don&#39;t end up replaying old, freed</span>
<span class="cm"> * meta-data into a user&#39;s file.</span>
<span class="cm"> *</span>
<span class="cm"> * To handle the cancellation of buffer log items, we make two passes</span>
<span class="cm"> * over the log during recovery.  During the first we build a table of</span>
<span class="cm"> * those buffers which have been cancelled, and during the second we</span>
<span class="cm"> * only replay those buffers which do not have corresponding cancel</span>
<span class="cm"> * records in the table.  See xlog_recover_do_buffer_pass[1,2] above</span>
<span class="cm"> * for more details on the implementation of the table of cancel records.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_buffer_pass2</span><span class="p">(</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">buffer_list</span><span class="p">,</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_log_format_t</span>	<span class="o">*</span><span class="n">buf_f</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">i_addr</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">buf_flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In this pass we only want to recover all the buffers which have</span>
<span class="cm">	 * not been cancelled and are not cancellation buffers themselves.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xlog_check_buffer_cancelled</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_blkno</span><span class="p">,</span>
			<span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_len</span><span class="p">,</span> <span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trace_xfs_log_recover_buf_cancel</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">buf_f</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_xfs_log_recover_buf_recover</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">buf_f</span><span class="p">);</span>

	<span class="n">buf_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_flags</span> <span class="o">&amp;</span> <span class="n">XFS_BLF_INODE_BUF</span><span class="p">)</span>
		<span class="n">buf_flags</span> <span class="o">|=</span> <span class="n">XBF_UNMAPPED</span><span class="p">;</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_read</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span> <span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_blkno</span><span class="p">,</span> <span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_len</span><span class="p">,</span>
			  <span class="n">buf_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_buf_ioerror_alert</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="s">&quot;xlog_recover_do..(read#1)&quot;</span><span class="p">);</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_flags</span> <span class="o">&amp;</span> <span class="n">XFS_BLF_INODE_BUF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover_do_inode_buffer</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">buf_f</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buf_f</span><span class="o">-&gt;</span><span class="n">blf_flags</span> <span class="o">&amp;</span>
		  <span class="p">(</span><span class="n">XFS_BLF_UDQUOT_BUF</span><span class="o">|</span><span class="n">XFS_BLF_PDQUOT_BUF</span><span class="o">|</span><span class="n">XFS_BLF_GDQUOT_BUF</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xlog_recover_do_dquot_buffer</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">buf_f</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xlog_recover_do_reg_buffer</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">buf_f</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Perform delayed write on the buffer.  Asynchronous writes will be</span>
<span class="cm">	 * slower when taking into account all the buffers to be flushed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also make sure that only inode buffers with good sizes stay in</span>
<span class="cm">	 * the buffer cache.  The kernel moves inodes in buffers of 1 block</span>
<span class="cm">	 * or XFS_INODE_CLUSTER_SIZE bytes, whichever is bigger.  The inode</span>
<span class="cm">	 * buffers in the log can be a different size if the log was generated</span>
<span class="cm">	 * by an older kernel using unclustered inode buffers or a newer kernel</span>
<span class="cm">	 * running with a different inode cluster size.  Regardless, if the</span>
<span class="cm">	 * the inode buffer size isn&#39;t MAX(blocksize, XFS_INODE_CLUSTER_SIZE)</span>
<span class="cm">	 * for *our* value of XFS_INODE_CLUSTER_SIZE, then we need to keep</span>
<span class="cm">	 * the buffer out of the buffer cache so that the buffer won&#39;t</span>
<span class="cm">	 * overlap with future reads of those inodes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_DINODE_MAGIC</span> <span class="o">==</span>
	    <span class="n">be16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)</span><span class="n">xfs_buf_offset</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_length</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span><span class="p">,</span>
			<span class="p">(</span><span class="n">__uint32_t</span><span class="p">)</span><span class="n">XFS_INODE_CLUSTER_SIZE</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">xfs_buf_stale</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bwrite</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_target</span><span class="o">-&gt;</span><span class="n">bt_mount</span> <span class="o">==</span> <span class="n">mp</span><span class="p">);</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone</span> <span class="o">=</span> <span class="n">xlog_recover_iodone</span><span class="p">;</span>
		<span class="n">xfs_buf_delwri_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">buffer_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_inode_pass2</span><span class="p">(</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">buffer_list</span><span class="p">,</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_inode_log_format_t</span>	<span class="o">*</span><span class="n">in_f</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_dinode_t</span>		<span class="o">*</span><span class="n">dip</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">len</span><span class="p">;</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">src</span><span class="p">;</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">dest</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">attr_index</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">fields</span><span class="p">;</span>
	<span class="n">xfs_icdinode_t</span>		<span class="o">*</span><span class="n">dicp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">need_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">i_len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_inode_log_format_t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">in_f</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">i_addr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">in_f</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_inode_log_format_t</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
		<span class="n">need_free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inode_item_format_convert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">in_f</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Inode buffers can be freed, look out for it,</span>
<span class="cm">	 * and do not replay the inode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xlog_check_buffer_cancelled</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_blkno</span><span class="p">,</span>
					<span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">trace_xfs_log_recover_inode_cancel</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">in_f</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">trace_xfs_log_recover_inode_recover</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">in_f</span><span class="p">);</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_read</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_blkno</span><span class="p">,</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_buf_ioerror_alert</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="s">&quot;xlog_recover_do..(read#2)&quot;</span><span class="p">);</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_fields</span> <span class="o">&amp;</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>
	<span class="n">dip</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dinode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">xfs_buf_offset</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_boffset</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure the place we&#39;re flushing out to really looks</span>
<span class="cm">	 * like an inode!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_magic</span> <span class="o">!=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DINODE_MAGIC</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
	<span class="s">&quot;%s: Bad inode magic number, dip = 0x%p, dino bp = 0x%p, ino = %Ld&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_ino</span><span class="p">);</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xlog_recover_inode_pass2(1)&quot;</span><span class="p">,</span>
				 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">EFSCORRUPTED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dicp</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">i_addr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_magic</span> <span class="o">!=</span> <span class="n">XFS_DINODE_MAGIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
			<span class="s">&quot;%s: Bad inode log record, rec ptr 0x%p, ino %Ld&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_ino</span><span class="p">);</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xlog_recover_inode_pass2(2)&quot;</span><span class="p">,</span>
				 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">EFSCORRUPTED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Skip replay when the on disk inode is newer than the log one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_flushiter</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_flushiter</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Deal with the wrap case, DI_MAX_FLUSH is less</span>
<span class="cm">		 * than smaller numbers</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_flushiter</span><span class="p">)</span> <span class="o">==</span> <span class="n">DI_MAX_FLUSH</span> <span class="o">&amp;&amp;</span>
		    <span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_flushiter</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">DI_MAX_FLUSH</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* do nothing */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">trace_xfs_log_recover_inode_skip</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">in_f</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Take the opportunity to reset the flush iteration count */</span>
	<span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_flushiter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_mode</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_BTREE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xlog_recover_inode_pass2(3)&quot;</span><span class="p">,</span>
					 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">dicp</span><span class="p">);</span>
			<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
		<span class="s">&quot;%s: Bad regular inode log record, rec ptr 0x%p, &quot;</span>
		<span class="s">&quot;ino ptr = 0x%p, ino bp = 0x%p, ino %Ld&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_ino</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">EFSCORRUPTED</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_mode</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_BTREE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_LOCAL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xlog_recover_inode_pass2(4)&quot;</span><span class="p">,</span>
					     <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">dicp</span><span class="p">);</span>
			<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
		<span class="s">&quot;%s: Bad dir inode log record, rec ptr 0x%p, &quot;</span>
		<span class="s">&quot;ino ptr = 0x%p, ino bp = 0x%p, ino %Ld&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_ino</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">EFSCORRUPTED</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_nextents</span> <span class="o">+</span> <span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_anextents</span> <span class="o">&gt;</span> <span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_nblocks</span><span class="p">)){</span>
		<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xlog_recover_inode_pass2(5)&quot;</span><span class="p">,</span>
				     <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">dicp</span><span class="p">);</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
	<span class="s">&quot;%s: Bad inode log record, rec ptr 0x%p, dino ptr 0x%p, &quot;</span>
	<span class="s">&quot;dino bp 0x%p, ino %Ld, total extents = %d, nblocks = %Ld&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_ino</span><span class="p">,</span>
			<span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_nextents</span> <span class="o">+</span> <span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_anextents</span><span class="p">,</span>
			<span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_nblocks</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">EFSCORRUPTED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_forkoff</span> <span class="o">&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodesize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xlog_recover_inode_pass2(6)&quot;</span><span class="p">,</span>
				     <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">dicp</span><span class="p">);</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
	<span class="s">&quot;%s: Bad inode log record, rec ptr 0x%p, dino ptr 0x%p, &quot;</span>
	<span class="s">&quot;dino bp 0x%p, ino %Ld, forkoff 0x%x&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">item</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_ino</span><span class="p">,</span> <span class="n">dicp</span><span class="o">-&gt;</span><span class="n">di_forkoff</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">EFSCORRUPTED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">i_len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_icdinode</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xlog_recover_inode_pass2(7)&quot;</span><span class="p">,</span>
				     <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">dicp</span><span class="p">);</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
			<span class="s">&quot;%s: Bad inode log record length %d, rec ptr 0x%p&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">i_len</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">EFSCORRUPTED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The core is in in-core format */</span>
	<span class="n">xfs_dinode_to_disk</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">i_addr</span><span class="p">);</span>

	<span class="cm">/* the rest is in on-disk format */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">i_len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_icdinode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="n">xfs_caddr_t</span><span class="p">)</span> <span class="n">dip</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_icdinode</span><span class="p">),</span>
			<span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">i_addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_icdinode</span><span class="p">),</span>
			<span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">i_len</span>  <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_icdinode</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">fields</span> <span class="o">=</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_fields</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fields</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_ILOG_DEV</span> <span class="o">|</span> <span class="n">XFS_ILOG_UUID</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_ILOG_DEV</span>:
		<span class="n">xfs_dinode_put_rdev</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_u</span><span class="p">.</span><span class="n">ilfu_rdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_ILOG_UUID</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="n">XFS_DFORK_DPTR</span><span class="p">(</span><span class="n">dip</span><span class="p">),</span>
		       <span class="o">&amp;</span><span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_u</span><span class="p">.</span><span class="n">ilfu_uuid</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">uuid_t</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">write_inode_buffer</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">i_len</span><span class="p">;</span>
	<span class="n">src</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">i_addr</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_size</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_size</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">fields</span> <span class="o">&amp;</span> <span class="n">XFS_ILOG_AFORK</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fields</span> <span class="o">&amp;</span> <span class="n">XFS_ILOG_DFORK</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_dsize</span><span class="p">));</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">fields</span> <span class="o">&amp;</span> <span class="n">XFS_ILOG_DFORK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_ILOG_DDATA</span>:
	<span class="k">case</span> <span class="n">XFS_ILOG_DEXT</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="n">XFS_DFORK_DPTR</span><span class="p">(</span><span class="n">dip</span><span class="p">),</span> <span class="n">src</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">XFS_ILOG_DBROOT</span>:
		<span class="n">xfs_bmbt_to_bmdr</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xfs_btree_block</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">xfs_bmdr_block_t</span> <span class="o">*</span><span class="p">)</span><span class="n">XFS_DFORK_DPTR</span><span class="p">(</span><span class="n">dip</span><span class="p">),</span>
				 <span class="n">XFS_DFORK_DSIZE</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">mp</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/*</span>
<span class="cm">		 * There are no data fork flags set.</span>
<span class="cm">		 */</span>
		<span class="n">ASSERT</span><span class="p">((</span><span class="n">fields</span> <span class="o">&amp;</span> <span class="n">XFS_ILOG_DFORK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we logged any attribute data, recover it.  There may or</span>
<span class="cm">	 * may not have been any other non-core data logged in this</span>
<span class="cm">	 * transaction.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_fields</span> <span class="o">&amp;</span> <span class="n">XFS_ILOG_AFORK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_fields</span> <span class="o">&amp;</span> <span class="n">XFS_ILOG_DFORK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">attr_index</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">attr_index</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">attr_index</span><span class="p">].</span><span class="n">i_len</span><span class="p">;</span>
		<span class="n">src</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">attr_index</span><span class="p">].</span><span class="n">i_addr</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_asize</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">in_f</span><span class="o">-&gt;</span><span class="n">ilf_fields</span> <span class="o">&amp;</span> <span class="n">XFS_ILOG_AFORK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">XFS_ILOG_ADATA</span>:
		<span class="k">case</span> <span class="n">XFS_ILOG_AEXT</span>:
			<span class="n">dest</span> <span class="o">=</span> <span class="n">XFS_DFORK_APTR</span><span class="p">(</span><span class="n">dip</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">XFS_DFORK_ASIZE</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">mp</span><span class="p">));</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">XFS_ILOG_ABROOT</span>:
			<span class="n">dest</span> <span class="o">=</span> <span class="n">XFS_DFORK_APTR</span><span class="p">(</span><span class="n">dip</span><span class="p">);</span>
			<span class="n">xfs_bmbt_to_bmdr</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xfs_btree_block</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="p">,</span>
					 <span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_bmdr_block_t</span><span class="o">*</span><span class="p">)</span><span class="n">dest</span><span class="p">,</span>
					 <span class="n">XFS_DFORK_ASIZE</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">mp</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: Invalid flag&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">write_inode_buffer:</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_target</span><span class="o">-&gt;</span><span class="n">bt_mount</span> <span class="o">==</span> <span class="n">mp</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone</span> <span class="o">=</span> <span class="n">xlog_recover_iodone</span><span class="p">;</span>
	<span class="n">xfs_buf_delwri_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">buffer_list</span><span class="p">);</span>
	<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_free</span><span class="p">)</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">in_f</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Recover QUOTAOFF records. We simply make a note of it in the xlog_t</span>
<span class="cm"> * structure, so that we know not to do any dquot item or dquot buffer recovery,</span>
<span class="cm"> * of that type.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_quotaoff_pass1</span><span class="p">(</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_qoff_logformat_t</span>	<span class="o">*</span><span class="n">qoff_f</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">i_addr</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">qoff_f</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The logitem format&#39;s flag tells us if this was user quotaoff,</span>
<span class="cm">	 * group/project quotaoff or both.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qoff_f</span><span class="o">-&gt;</span><span class="n">qf_flags</span> <span class="o">&amp;</span> <span class="n">XFS_UQUOTA_ACCT</span><span class="p">)</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_quotaoffs_flag</span> <span class="o">|=</span> <span class="n">XFS_DQ_USER</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qoff_f</span><span class="o">-&gt;</span><span class="n">qf_flags</span> <span class="o">&amp;</span> <span class="n">XFS_PQUOTA_ACCT</span><span class="p">)</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_quotaoffs_flag</span> <span class="o">|=</span> <span class="n">XFS_DQ_PROJ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qoff_f</span><span class="o">-&gt;</span><span class="n">qf_flags</span> <span class="o">&amp;</span> <span class="n">XFS_GQUOTA_ACCT</span><span class="p">)</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_quotaoffs_flag</span> <span class="o">|=</span> <span class="n">XFS_DQ_GROUP</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Recover a dquot record</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_dquot_pass2</span><span class="p">(</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">buffer_list</span><span class="p">,</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_disk_dquot</span>	<span class="o">*</span><span class="n">ddq</span><span class="p">,</span> <span class="o">*</span><span class="n">recddq</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_dq_logformat_t</span>	<span class="o">*</span><span class="n">dq_f</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">type</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * Filesystems are required to send in quota flags at mount time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_qflags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">recddq</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">i_addr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">recddq</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_alert</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;NULL dquot in %s.&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">i_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_disk_dquot_t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_alert</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;dquot too small (%d) in %s.&quot;</span><span class="p">,</span>
			<span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">i_len</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This type of quotas was turned off, so ignore this record.</span>
<span class="cm">	 */</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">recddq</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_DQ_USER</span> <span class="o">|</span> <span class="n">XFS_DQ_PROJ</span> <span class="o">|</span> <span class="n">XFS_DQ_GROUP</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_quotaoffs_flag</span> <span class="o">&amp;</span> <span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point we know that quota was _not_ turned off.</span>
<span class="cm">	 * Since the mount flags are not indicating to us otherwise, this</span>
<span class="cm">	 * must mean that quota is on, and the dquot needs to be replayed.</span>
<span class="cm">	 * Remember that we may not have fully recovered the superblock yet,</span>
<span class="cm">	 * so we can&#39;t do the usual trick of looking at the SB quota bits.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The other possibility, of course, is that the quota subsystem was</span>
<span class="cm">	 * removed since the last mount - ENOSYS.</span>
<span class="cm">	 */</span>
	<span class="n">dq_f</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">i_addr</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dq_f</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_dqcheck</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">recddq</span><span class="p">,</span> <span class="n">dq_f</span><span class="o">-&gt;</span><span class="n">qlf_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_QMOPT_DOWARN</span><span class="p">,</span>
			   <span class="s">&quot;xlog_recover_dquot_pass2 (log copy)&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dq_f</span><span class="o">-&gt;</span><span class="n">qlf_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_read_buf</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span> <span class="n">dq_f</span><span class="o">-&gt;</span><span class="n">qlf_blkno</span><span class="p">,</span>
				   <span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">dq_f</span><span class="o">-&gt;</span><span class="n">qlf_len</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">ddq</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_disk_dquot_t</span> <span class="o">*</span><span class="p">)</span><span class="n">xfs_buf_offset</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">dq_f</span><span class="o">-&gt;</span><span class="n">qlf_boffset</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * At least the magic num portion should be on disk because this</span>
<span class="cm">	 * was among a chunk of dquots created earlier, and we did some</span>
<span class="cm">	 * minimal initialization then.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_dqcheck</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ddq</span><span class="p">,</span> <span class="n">dq_f</span><span class="o">-&gt;</span><span class="n">qlf_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_QMOPT_DOWARN</span><span class="p">,</span>
			   <span class="s">&quot;xlog_recover_dquot_pass2&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">ddq</span><span class="p">,</span> <span class="n">recddq</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">i_len</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dq_f</span><span class="o">-&gt;</span><span class="n">qlf_size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_target</span><span class="o">-&gt;</span><span class="n">bt_mount</span> <span class="o">==</span> <span class="n">mp</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone</span> <span class="o">=</span> <span class="n">xlog_recover_iodone</span><span class="p">;</span>
	<span class="n">xfs_buf_delwri_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">buffer_list</span><span class="p">);</span>
	<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine is called to create an in-core extent free intent</span>
<span class="cm"> * item from the efi format structure which was logged on disk.</span>
<span class="cm"> * It allocates an in-core efi, copies the extents from the format</span>
<span class="cm"> * structure into it, and adds the efi to the AIL with the given</span>
<span class="cm"> * LSN.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_efi_pass2</span><span class="p">(</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">lsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">;</span>
	<span class="n">xfs_efi_log_item_t</span>	<span class="o">*</span><span class="n">efip</span><span class="p">;</span>
	<span class="n">xfs_efi_log_format_t</span>	<span class="o">*</span><span class="n">efi_formatp</span><span class="p">;</span>

	<span class="n">efi_formatp</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">i_addr</span><span class="p">;</span>

	<span class="n">efip</span> <span class="o">=</span> <span class="n">xfs_efi_init</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">efi_formatp</span><span class="o">-&gt;</span><span class="n">efi_nextents</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_efi_copy_format</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
					 <span class="o">&amp;</span><span class="p">(</span><span class="n">efip</span><span class="o">-&gt;</span><span class="n">efi_format</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">xfs_efi_item_free</span><span class="p">(</span><span class="n">efip</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efip</span><span class="o">-&gt;</span><span class="n">efi_next_extent</span><span class="p">,</span> <span class="n">efi_formatp</span><span class="o">-&gt;</span><span class="n">efi_nextents</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * xfs_trans_ail_update() drops the AIL lock.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_ail_update</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_ailp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efip</span><span class="o">-&gt;</span><span class="n">efi_item</span><span class="p">,</span> <span class="n">lsn</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This routine is called when an efd format structure is found in</span>
<span class="cm"> * a committed transaction in the log.  It&#39;s purpose is to cancel</span>
<span class="cm"> * the corresponding efi if it was still in the log.  To do this</span>
<span class="cm"> * it searches the AIL for the efi with an id equal to that in the</span>
<span class="cm"> * efd format structure.  If we find it, we remove the efi from the</span>
<span class="cm"> * AIL and free it.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_efd_pass2</span><span class="p">(</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_efd_log_format_t</span>	<span class="o">*</span><span class="n">efd_formatp</span><span class="p">;</span>
	<span class="n">xfs_efi_log_item_t</span>	<span class="o">*</span><span class="n">efip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">xfs_log_item_t</span>		<span class="o">*</span><span class="n">lip</span><span class="p">;</span>
	<span class="n">__uint64_t</span>		<span class="n">efi_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_ail_cursor</span>	<span class="n">cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>		<span class="o">*</span><span class="n">ailp</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_ailp</span><span class="p">;</span>

	<span class="n">efd_formatp</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">i_addr</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">i_len</span> <span class="o">==</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_efd_log_format_32_t</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">((</span><span class="n">efd_formatp</span><span class="o">-&gt;</span><span class="n">efd_nextents</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_extent_32_t</span><span class="p">))))</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">i_len</span> <span class="o">==</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_efd_log_format_64_t</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">((</span><span class="n">efd_formatp</span><span class="o">-&gt;</span><span class="n">efd_nextents</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_extent_64_t</span><span class="p">)))));</span>
	<span class="n">efi_id</span> <span class="o">=</span> <span class="n">efd_formatp</span><span class="o">-&gt;</span><span class="n">efd_efi_id</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search for the efi with the id in the efd format structure</span>
<span class="cm">	 * in the AIL.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
	<span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_trans_ail_cursor_first</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lip</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_type</span> <span class="o">==</span> <span class="n">XFS_LI_EFI</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">efip</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_efi_log_item_t</span> <span class="o">*</span><span class="p">)</span><span class="n">lip</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">efip</span><span class="o">-&gt;</span><span class="n">efi_format</span><span class="p">.</span><span class="n">efi_id</span> <span class="o">==</span> <span class="n">efi_id</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * xfs_trans_ail_delete() drops the</span>
<span class="cm">				 * AIL lock.</span>
<span class="cm">				 */</span>
				<span class="n">xfs_trans_ail_delete</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="n">lip</span><span class="p">,</span>
						     <span class="n">SHUTDOWN_CORRUPT_INCORE</span><span class="p">);</span>
				<span class="n">xfs_efi_item_free</span><span class="p">(</span><span class="n">efip</span><span class="p">);</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_trans_ail_cursor_next</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xfs_trans_ail_cursor_done</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free up any resources allocated by the transaction</span>
<span class="cm"> *</span>
<span class="cm"> * Remember that EFIs, EFDs, and IUNLINKs are handled later.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_recover_free_trans</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog_recover</span>	<span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_itemq</span><span class="p">,</span> <span class="n">ri_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Free the regions in the item. */</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_list</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">kmem_free</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">i_addr</span><span class="p">);</span>
		<span class="cm">/* Free the item itself */</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ri_buf</span><span class="p">);</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Free the transaction recover structure */</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_commit_pass1</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_recover</span>		<span class="o">*</span><span class="n">trans</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_recover_item</span>	<span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xfs_log_recover_item_recover</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">XLOG_RECOVER_PASS1</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ITEM_TYPE</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_LI_BUF</span>:
		<span class="k">return</span> <span class="n">xlog_recover_buffer_pass1</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">XFS_LI_QUOTAOFF</span>:
		<span class="k">return</span> <span class="n">xlog_recover_quotaoff_pass1</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">XFS_LI_INODE</span>:
	<span class="k">case</span> <span class="n">XFS_LI_EFI</span>:
	<span class="k">case</span> <span class="n">XFS_LI_EFD</span>:
	<span class="k">case</span> <span class="n">XFS_LI_DQUOT</span>:
		<span class="cm">/* nothing to do in pass 1 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: invalid item type (%d)&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">ITEM_TYPE</span><span class="p">(</span><span class="n">item</span><span class="p">));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_commit_pass2</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_recover</span>		<span class="o">*</span><span class="n">trans</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="o">*</span><span class="n">buffer_list</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_recover_item</span>	<span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xfs_log_recover_item_recover</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">XLOG_RECOVER_PASS2</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ITEM_TYPE</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_LI_BUF</span>:
		<span class="k">return</span> <span class="n">xlog_recover_buffer_pass2</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">buffer_list</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">XFS_LI_INODE</span>:
		<span class="k">return</span> <span class="n">xlog_recover_inode_pass2</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">buffer_list</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">XFS_LI_EFI</span>:
		<span class="k">return</span> <span class="n">xlog_recover_efi_pass2</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_lsn</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">XFS_LI_EFD</span>:
		<span class="k">return</span> <span class="n">xlog_recover_efd_pass2</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">XFS_LI_DQUOT</span>:
		<span class="k">return</span> <span class="n">xlog_recover_dquot_pass2</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">buffer_list</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">XFS_LI_QUOTAOFF</span>:
		<span class="cm">/* nothing to do in pass2 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: invalid item type (%d)&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">ITEM_TYPE</span><span class="p">(</span><span class="n">item</span><span class="p">));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform the transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * If the transaction modifies a buffer or inode, do it now.  Otherwise,</span>
<span class="cm"> * EFIs and EFDs get queued up by adding entries into the AIL for them.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_commit_trans</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_recover</span>	<span class="o">*</span><span class="n">trans</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">pass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error2</span><span class="p">;</span>
	<span class="n">xlog_recover_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span>		<span class="p">(</span><span class="n">buffer_list</span><span class="p">);</span>

	<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_list</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover_reorder_trans</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">pass</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">r_itemq</span><span class="p">,</span> <span class="n">ri_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">pass</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">XLOG_RECOVER_PASS1</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover_commit_pass1</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XLOG_RECOVER_PASS2</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover_commit_pass2</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span>
							  <span class="o">&amp;</span><span class="n">buffer_list</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xlog_recover_free_trans</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">error2</span> <span class="o">=</span> <span class="n">xfs_buf_delwri_submit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span> <span class="o">?</span> <span class="n">error</span> <span class="o">:</span> <span class="n">error2</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_unmount_trans</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_recover</span>	<span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Do nothing now */</span>
	<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: Unmount LR&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There are two valid states of the r_state field.  0 indicates that the</span>
<span class="cm"> * transaction structure is in a normal state.  We have either seen the</span>
<span class="cm"> * start of the transaction or the last operation we added was not a partial</span>
<span class="cm"> * operation.  If the last operation we added to the transaction was a</span>
<span class="cm"> * partial operation, we need to mark r_state with XLOG_WAS_CONT_TRANS.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: skip LRs with 0 data length.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_process_data</span><span class="p">(</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="n">rhash</span><span class="p">[],</span>
	<span class="n">xlog_rec_header_t</span>	<span class="o">*</span><span class="n">rhead</span><span class="p">,</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">dp</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">pass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">lp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">num_logops</span><span class="p">;</span>
	<span class="n">xlog_op_header_t</span>	<span class="o">*</span><span class="n">ohead</span><span class="p">;</span>
	<span class="n">xlog_recover_t</span>		<span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">xlog_tid_t</span>		<span class="n">tid</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">hash</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">flags</span><span class="p">;</span>

	<span class="n">lp</span> <span class="o">=</span> <span class="n">dp</span> <span class="o">+</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_len</span><span class="p">);</span>
	<span class="n">num_logops</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_num_logops</span><span class="p">);</span>

	<span class="cm">/* check the log format matches our own - else we can&#39;t recover */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xlog_header_check_recover</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">rhead</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">));</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">dp</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">num_logops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">dp</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">lp</span><span class="p">);</span>
		<span class="n">ohead</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlog_op_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">dp</span><span class="p">;</span>
		<span class="n">dp</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xlog_op_header_t</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ohead</span><span class="o">-&gt;</span><span class="n">oh_clientid</span> <span class="o">!=</span> <span class="n">XFS_TRANSACTION</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ohead</span><span class="o">-&gt;</span><span class="n">oh_clientid</span> <span class="o">!=</span> <span class="n">XFS_LOG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: bad clientid 0x%x&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">ohead</span><span class="o">-&gt;</span><span class="n">oh_clientid</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">tid</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ohead</span><span class="o">-&gt;</span><span class="n">oh_tid</span><span class="p">);</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">XLOG_RHASH</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">xlog_recover_find_tid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhash</span><span class="p">[</span><span class="n">hash</span><span class="p">],</span> <span class="n">tid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trans</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>		   <span class="cm">/* not found; add new tid */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ohead</span><span class="o">-&gt;</span><span class="n">oh_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_START_TRANS</span><span class="p">)</span>
				<span class="n">xlog_recover_new_tid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhash</span><span class="p">[</span><span class="n">hash</span><span class="p">],</span> <span class="n">tid</span><span class="p">,</span>
					<span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_lsn</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dp</span> <span class="o">+</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ohead</span><span class="o">-&gt;</span><span class="n">oh_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: bad length 0x%x&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ohead</span><span class="o">-&gt;</span><span class="n">oh_len</span><span class="p">));</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">ohead</span><span class="o">-&gt;</span><span class="n">oh_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">XLOG_END_TRANS</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XLOG_WAS_CONT_TRANS</span><span class="p">)</span>
				<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XLOG_CONTINUE_TRANS</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">XLOG_COMMIT_TRANS</span>:
				<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover_commit_trans</span><span class="p">(</span><span class="n">log</span><span class="p">,</span>
								<span class="n">trans</span><span class="p">,</span> <span class="n">pass</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">XLOG_UNMOUNT_TRANS</span>:
				<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover_unmount_trans</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">trans</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">XLOG_WAS_CONT_TRANS</span>:
				<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover_add_to_cont_trans</span><span class="p">(</span><span class="n">log</span><span class="p">,</span>
						<span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span>
						<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ohead</span><span class="o">-&gt;</span><span class="n">oh_len</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">XLOG_START_TRANS</span>:
				<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: bad transaction&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">);</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">case</span> <span class="n">XLOG_CONTINUE_TRANS</span>:
				<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover_add_to_trans</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span>
						<span class="n">dp</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ohead</span><span class="o">-&gt;</span><span class="n">oh_len</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: bad flag 0x%x&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dp</span> <span class="o">+=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ohead</span><span class="o">-&gt;</span><span class="n">oh_len</span><span class="p">);</span>
		<span class="n">num_logops</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process an extent free intent item that was recovered from</span>
<span class="cm"> * the log.  We need to free the extents that it describes.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_process_efi</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_efi_log_item_t</span>	<span class="o">*</span><span class="n">efip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_efd_log_item_t</span>	<span class="o">*</span><span class="n">efdp</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_extent_t</span>		<span class="o">*</span><span class="n">extp</span><span class="p">;</span>
	<span class="n">xfs_fsblock_t</span>		<span class="n">startblock_fsb</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">XFS_EFI_RECOVERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efip</span><span class="o">-&gt;</span><span class="n">efi_flags</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * First check the validity of the extents described by the</span>
<span class="cm">	 * EFI.  If any are bad, then assume that all are bad and</span>
<span class="cm">	 * just toss the EFI.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">efip</span><span class="o">-&gt;</span><span class="n">efi_format</span><span class="p">.</span><span class="n">efi_nextents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">extp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">efip</span><span class="o">-&gt;</span><span class="n">efi_format</span><span class="p">.</span><span class="n">efi_extents</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">startblock_fsb</span> <span class="o">=</span> <span class="n">XFS_BB_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
				   <span class="n">XFS_FSB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">ext_start</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">startblock_fsb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">ext_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">startblock_fsb</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_dblocks</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">ext_len</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agblocks</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This will pull the EFI from the AIL and</span>
<span class="cm">			 * free the memory associated with it.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_efi_release</span><span class="p">(</span><span class="n">efip</span><span class="p">,</span> <span class="n">efip</span><span class="o">-&gt;</span><span class="n">efi_format</span><span class="p">.</span><span class="n">efi_nextents</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_ITRUNCATE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_error</span><span class="p">;</span>
	<span class="n">efdp</span> <span class="o">=</span> <span class="n">xfs_trans_get_efd</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">efip</span><span class="p">,</span> <span class="n">efip</span><span class="o">-&gt;</span><span class="n">efi_format</span><span class="p">.</span><span class="n">efi_nextents</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">efip</span><span class="o">-&gt;</span><span class="n">efi_format</span><span class="p">.</span><span class="n">efi_nextents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">extp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">efip</span><span class="o">-&gt;</span><span class="n">efi_format</span><span class="p">.</span><span class="n">efi_extents</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_free_extent</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">ext_start</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">ext_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">abort_error</span><span class="p">;</span>
		<span class="n">xfs_trans_log_efd_extent</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">efdp</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">ext_start</span><span class="p">,</span>
					 <span class="n">extp</span><span class="o">-&gt;</span><span class="n">ext_len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">XFS_EFI_RECOVERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efip</span><span class="o">-&gt;</span><span class="n">efi_flags</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">abort_error:</span>
	<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_ABORT</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When this is called, all of the EFIs which did not have</span>
<span class="cm"> * corresponding EFDs should be in the AIL.  What we do now</span>
<span class="cm"> * is free the extents associated with each one.</span>
<span class="cm"> *</span>
<span class="cm"> * Since we process the EFIs in normal transactions, they</span>
<span class="cm"> * will be removed at some point after the commit.  This prevents</span>
<span class="cm"> * us from just walking down the list processing each one.</span>
<span class="cm"> * We&#39;ll use a flag in the EFI to skip those that we&#39;ve already</span>
<span class="cm"> * processed and use the AIL iteration mechanism&#39;s generation</span>
<span class="cm"> * count to try to speed this up at least a bit.</span>
<span class="cm"> *</span>
<span class="cm"> * When we start, we know that the EFIs are the only things in</span>
<span class="cm"> * the AIL.  As we process them, however, other items are added</span>
<span class="cm"> * to the AIL.  Since everything added to the AIL must come after</span>
<span class="cm"> * everything already in the AIL, we stop processing as soon as</span>
<span class="cm"> * we see something other than an EFI in the AIL.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_recover_process_efis</span><span class="p">(</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_log_item_t</span>		<span class="o">*</span><span class="n">lip</span><span class="p">;</span>
	<span class="n">xfs_efi_log_item_t</span>	<span class="o">*</span><span class="n">efip</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_ail_cursor</span>	<span class="n">cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>		<span class="o">*</span><span class="n">ailp</span><span class="p">;</span>

	<span class="n">ailp</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_ailp</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
	<span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_trans_ail_cursor_first</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lip</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re done when we see something other than an EFI.</span>
<span class="cm">		 * There should be no EFIs left in the AIL now.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_type</span> <span class="o">!=</span> <span class="n">XFS_LI_EFI</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
			<span class="k">for</span> <span class="p">(;</span> <span class="n">lip</span><span class="p">;</span> <span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_trans_ail_cursor_next</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">))</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_type</span> <span class="o">!=</span> <span class="n">XFS_LI_EFI</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Skip EFIs that we&#39;ve already processed.</span>
<span class="cm">		 */</span>
		<span class="n">efip</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_efi_log_item_t</span> <span class="o">*</span><span class="p">)</span><span class="n">lip</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">XFS_EFI_RECOVERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">efip</span><span class="o">-&gt;</span><span class="n">efi_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_trans_ail_cursor_next</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover_process_efi</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">efip</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_trans_ail_cursor_next</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">xfs_trans_ail_cursor_done</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine performs a transaction to null out a bad inode pointer</span>
<span class="cm"> * in an agi unlinked inode hash bucket.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_recover_clear_agi_bucket</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">bucket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="n">xfs_agi_t</span>	<span class="o">*</span><span class="n">agi</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agibp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_CLEAR_AGI_BUCKET</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_CLEAR_AGI_BUCKET_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span>
				  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_abort</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_read_agi</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">agibp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_abort</span><span class="p">;</span>

	<span class="n">agi</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGI</span><span class="p">(</span><span class="n">agibp</span><span class="p">);</span>
	<span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_unlinked</span><span class="p">[</span><span class="n">bucket</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NULLAGINO</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">,</span> <span class="n">agi_unlinked</span><span class="p">)</span> <span class="o">+</span>
		 <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_agino_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">bucket</span><span class="p">);</span>
	<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agibp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_agino_t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">out_abort:</span>
	<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_ABORT</span><span class="p">);</span>
<span class="nl">out_error:</span>
	<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: failed to clear agi %d. Continuing.&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="n">xfs_agino_t</span>
<span class="nf">xlog_recover_process_one_iunlink</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>		<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_agnumber_t</span>			<span class="n">agno</span><span class="p">,</span>
	<span class="n">xfs_agino_t</span>			<span class="n">agino</span><span class="p">,</span>
	<span class="kt">int</span>				<span class="n">bucket</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>			<span class="o">*</span><span class="n">ibp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_dinode</span>		<span class="o">*</span><span class="n">dip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>		<span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="n">xfs_ino_t</span>			<span class="n">ino</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">error</span><span class="p">;</span>

	<span class="n">ino</span> <span class="o">=</span> <span class="n">XFS_AGINO_TO_INO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">agino</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iget</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the on disk inode to find the next inode in the bucket.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_itobp</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ibp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_iput</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* setup for the next pass */</span>
	<span class="n">agino</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_next_unlinked</span><span class="p">);</span>
	<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">ibp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prevent any DMAPI event from being sent when the reference on</span>
<span class="cm">	 * the inode is dropped.</span>
<span class="cm">	 */</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_dmevmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRELE</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">agino</span><span class="p">;</span>

 <span class="nl">fail_iput:</span>
	<span class="n">IRELE</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
 <span class="nl">fail:</span>
	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t read in the inode this bucket points to, or this inode</span>
<span class="cm">	 * is messed up.  Just ditch this bucket of inodes.  We will lose</span>
<span class="cm">	 * some inodes and space, but at least we won&#39;t hang.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Call xlog_recover_clear_agi_bucket() to perform a transaction to</span>
<span class="cm">	 * clear the inode pointer in the bucket.</span>
<span class="cm">	 */</span>
	<span class="n">xlog_recover_clear_agi_bucket</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">bucket</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NULLAGINO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xlog_iunlink_recover</span>
<span class="cm"> *</span>
<span class="cm"> * This is called during recovery to process any inodes which</span>
<span class="cm"> * we unlinked but not freed when the system crashed.  These</span>
<span class="cm"> * inodes will be on the lists in the AGI blocks.  What we do</span>
<span class="cm"> * here is scan all the AGIs and fully truncate and free any</span>
<span class="cm"> * inodes found on the lists.  Each inode is removed from the</span>
<span class="cm"> * lists when it has been fully truncated and is freed.  The</span>
<span class="cm"> * freeing of the inode and its removal from the list must be</span>
<span class="cm"> * atomic.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_recover_process_iunlinks</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">;</span>
	<span class="n">xfs_agi_t</span>	<span class="o">*</span><span class="n">agi</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agibp</span><span class="p">;</span>
	<span class="n">xfs_agino_t</span>	<span class="n">agino</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">bucket</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">mp_dmevmask</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prevent any DMAPI event from being sent while in this function.</span>
<span class="cm">	 */</span>
	<span class="n">mp_dmevmask</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dmevmask</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dmevmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">agno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">agno</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">;</span> <span class="n">agno</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Find the agi for this ag.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_read_agi</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">agibp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * AGI is b0rked. Don&#39;t process it.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We should probably mark the filesystem as corrupt</span>
<span class="cm">			 * after we&#39;ve recovered all the ag&#39;s we can....</span>
<span class="cm">			 */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Unlock the buffer so that it can be acquired in the normal</span>
<span class="cm">		 * course of the transaction to truncate and free each inode.</span>
<span class="cm">		 * Because we are not racing with anyone else here for the AGI</span>
<span class="cm">		 * buffer, we don&#39;t even need to hold it locked to read the</span>
<span class="cm">		 * initial unlinked bucket entries out of the buffer. We keep</span>
<span class="cm">		 * buffer reference though, so that it stays pinned in memory</span>
<span class="cm">		 * while we need the buffer.</span>
<span class="cm">		 */</span>
		<span class="n">agi</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGI</span><span class="p">(</span><span class="n">agibp</span><span class="p">);</span>
		<span class="n">xfs_buf_unlock</span><span class="p">(</span><span class="n">agibp</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">bucket</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bucket</span> <span class="o">&lt;</span> <span class="n">XFS_AGI_UNLINKED_BUCKETS</span><span class="p">;</span> <span class="n">bucket</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">agino</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_unlinked</span><span class="p">[</span><span class="n">bucket</span><span class="p">]);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">agino</span> <span class="o">!=</span> <span class="n">NULLAGINO</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">agino</span> <span class="o">=</span> <span class="n">xlog_recover_process_one_iunlink</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
							<span class="n">agno</span><span class="p">,</span> <span class="n">agino</span><span class="p">,</span> <span class="n">bucket</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">xfs_buf_rele</span><span class="p">(</span><span class="n">agibp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dmevmask</span> <span class="o">=</span> <span class="n">mp_dmevmask</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef DEBUG</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_pack_data_checksum</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xlog_in_core_t</span>	<span class="o">*</span><span class="n">iclog</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="o">*</span><span class="n">up</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">chksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">up</span> <span class="o">=</span> <span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_datap</span><span class="p">;</span>
	<span class="cm">/* divide length by 4 to get # words */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chksum</span> <span class="o">^=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">up</span><span class="p">);</span>
		<span class="n">up</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_chksum</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">chksum</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define xlog_pack_data_checksum(log, iclog, size)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Stamp cycle number in every block</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xlog_pack_data</span><span class="p">(</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xlog_in_core_t</span>		<span class="o">*</span><span class="n">iclog</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">roundoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">size</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_offset</span> <span class="o">+</span> <span class="n">roundoff</span><span class="p">;</span>
	<span class="n">__be32</span>			<span class="n">cycle_lsn</span><span class="p">;</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">dp</span><span class="p">;</span>

	<span class="n">xlog_pack_data_checksum</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">iclog</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">cycle_lsn</span> <span class="o">=</span> <span class="n">CYCLE_LSN_DISK</span><span class="p">(</span><span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_lsn</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_datap</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">XLOG_HEADER_CYCLE_SIZE</span> <span class="o">/</span> <span class="n">BBSIZE</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_header</span><span class="p">.</span><span class="n">h_cycle_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">dp</span><span class="p">;</span>
		<span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">dp</span> <span class="o">=</span> <span class="n">cycle_lsn</span><span class="p">;</span>
		<span class="n">dp</span> <span class="o">+=</span> <span class="n">BBSIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_haslogv2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xlog_in_core_2_t</span> <span class="o">*</span><span class="n">xhdr</span> <span class="o">=</span> <span class="n">iclog</span><span class="o">-&gt;</span><span class="n">ic_data</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="p">(</span><span class="n">XLOG_HEADER_CYCLE_SIZE</span> <span class="o">/</span> <span class="n">BBSIZE</span><span class="p">);</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="p">(</span><span class="n">XLOG_HEADER_CYCLE_SIZE</span> <span class="o">/</span> <span class="n">BBSIZE</span><span class="p">);</span>
			<span class="n">xhdr</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">hic_xheader</span><span class="p">.</span><span class="n">xh_cycle_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">dp</span><span class="p">;</span>
			<span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">dp</span> <span class="o">=</span> <span class="n">cycle_lsn</span><span class="p">;</span>
			<span class="n">dp</span> <span class="o">+=</span> <span class="n">BBSIZE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_iclog_heads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xhdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hic_xheader</span><span class="p">.</span><span class="n">xh_cycle</span> <span class="o">=</span> <span class="n">cycle_lsn</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xlog_unpack_data</span><span class="p">(</span>
	<span class="n">xlog_rec_header_t</span>	<span class="o">*</span><span class="n">rhead</span><span class="p">,</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">dp</span><span class="p">,</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_len</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		  <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">XLOG_HEADER_CYCLE_SIZE</span> <span class="o">/</span> <span class="n">BBSIZE</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">dp</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_cycle_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">dp</span> <span class="o">+=</span> <span class="n">BBSIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_haslogv2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xlog_in_core_2_t</span> <span class="o">*</span><span class="n">xhdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlog_in_core_2_t</span> <span class="o">*</span><span class="p">)</span><span class="n">rhead</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_len</span><span class="p">));</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="p">(</span><span class="n">XLOG_HEADER_CYCLE_SIZE</span> <span class="o">/</span> <span class="n">BBSIZE</span><span class="p">);</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="p">(</span><span class="n">XLOG_HEADER_CYCLE_SIZE</span> <span class="o">/</span> <span class="n">BBSIZE</span><span class="p">);</span>
			<span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">dp</span> <span class="o">=</span> <span class="n">xhdr</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">hic_xheader</span><span class="p">.</span><span class="n">xh_cycle_data</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
			<span class="n">dp</span> <span class="o">+=</span> <span class="n">BBSIZE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_valid_rec_header</span><span class="p">(</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xlog_rec_header_t</span>	<span class="o">*</span><span class="n">rhead</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">blkno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">hlen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_magicno</span> <span class="o">!=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XLOG_HEADER_MAGIC_NUM</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xlog_valid_rec_header(1)&quot;</span><span class="p">,</span>
				<span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_version</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_version</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">XLOG_VERSION_OKBITS</span><span class="p">)))))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;%s: unrecognised log version (%d).&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_version</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* LR body must have data or it wouldn&#39;t have been written */</span>
	<span class="n">hlen</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span> <span class="n">hlen</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">hlen</span> <span class="o">&gt;</span> <span class="n">INT_MAX</span> <span class="p">))</span> <span class="p">{</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xlog_valid_rec_header(2)&quot;</span><span class="p">,</span>
				<span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span> <span class="n">blkno</span> <span class="o">&gt;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span> <span class="o">||</span> <span class="n">blkno</span> <span class="o">&gt;</span> <span class="n">INT_MAX</span> <span class="p">))</span> <span class="p">{</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xlog_valid_rec_header(3)&quot;</span><span class="p">,</span>
				<span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read the log from tail to head and process the log records found.</span>
<span class="cm"> * Handle the two cases where the tail and head are in the same cycle</span>
<span class="cm"> * and where the active portion of the log wraps around the end of</span>
<span class="cm"> * the physical log separately.  The pass parameter is passed through</span>
<span class="cm"> * to the routines called to process the data and is not looked at</span>
<span class="cm"> * here.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_do_recovery_pass</span><span class="p">(</span>
	<span class="n">xlog_t</span>			<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">head_blk</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">tail_blk</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">pass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_rec_header_t</span>	<span class="o">*</span><span class="n">rhead</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">blk_no</span><span class="p">;</span>
	<span class="n">xfs_caddr_t</span>		<span class="n">offset</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">hbp</span><span class="p">,</span> <span class="o">*</span><span class="n">dbp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">h_size</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">bblks</span><span class="p">,</span> <span class="n">split_bblks</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">hblks</span><span class="p">,</span> <span class="n">split_hblks</span><span class="p">,</span> <span class="n">wrapped_hblks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="n">rhash</span><span class="p">[</span><span class="n">XLOG_RHASH_SIZE</span><span class="p">];</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">head_blk</span> <span class="o">!=</span> <span class="n">tail_blk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the header of the tail block and get the iclog buffer size from</span>
<span class="cm">	 * h_size.  Use this to tell how many sectors make up the log header.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_haslogv2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * When using variable length iclogs, read first sector of</span>
<span class="cm">		 * iclog header and extract the header size from it.  Get a</span>
<span class="cm">		 * new hbp that is the correct size.</span>
<span class="cm">		 */</span>
		<span class="n">hbp</span> <span class="o">=</span> <span class="n">xlog_get_bp</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hbp</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tail_blk</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bread_err1</span><span class="p">;</span>

		<span class="n">rhead</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlog_rec_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_valid_rec_header</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">rhead</span><span class="p">,</span> <span class="n">tail_blk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bread_err1</span><span class="p">;</span>
		<span class="n">h_size</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_version</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">XLOG_VERSION_2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">h_size</span> <span class="o">&gt;</span> <span class="n">XLOG_HEADER_CYCLE_SIZE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hblks</span> <span class="o">=</span> <span class="n">h_size</span> <span class="o">/</span> <span class="n">XLOG_HEADER_CYCLE_SIZE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">h_size</span> <span class="o">%</span> <span class="n">XLOG_HEADER_CYCLE_SIZE</span><span class="p">)</span>
				<span class="n">hblks</span><span class="o">++</span><span class="p">;</span>
			<span class="n">xlog_put_bp</span><span class="p">(</span><span class="n">hbp</span><span class="p">);</span>
			<span class="n">hbp</span> <span class="o">=</span> <span class="n">xlog_get_bp</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">hblks</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hblks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_sectBBsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">hblks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">hbp</span> <span class="o">=</span> <span class="n">xlog_get_bp</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">h_size</span> <span class="o">=</span> <span class="n">XLOG_BIG_RECORD_BSIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hbp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">dbp</span> <span class="o">=</span> <span class="n">xlog_get_bp</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">h_size</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xlog_put_bp</span><span class="p">(</span><span class="n">hbp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">rhash</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rhash</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tail_blk</span> <span class="o">&lt;=</span> <span class="n">head_blk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">blk_no</span> <span class="o">=</span> <span class="n">tail_blk</span><span class="p">;</span> <span class="n">blk_no</span> <span class="o">&lt;</span> <span class="n">head_blk</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">blk_no</span><span class="p">,</span> <span class="n">hblks</span><span class="p">,</span> <span class="n">hbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>

			<span class="n">rhead</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlog_rec_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_valid_rec_header</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">rhead</span><span class="p">,</span> <span class="n">blk_no</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>

			<span class="cm">/* blocks in data section */</span>
			<span class="n">bblks</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">BTOBB</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_len</span><span class="p">));</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">blk_no</span> <span class="o">+</span> <span class="n">hblks</span><span class="p">,</span> <span class="n">bblks</span><span class="p">,</span> <span class="n">dbp</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>

			<span class="n">xlog_unpack_data</span><span class="p">(</span><span class="n">rhead</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover_process_data</span><span class="p">(</span><span class="n">log</span><span class="p">,</span>
						<span class="n">rhash</span><span class="p">,</span> <span class="n">rhead</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">pass</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>
			<span class="n">blk_no</span> <span class="o">+=</span> <span class="n">bblks</span> <span class="o">+</span> <span class="n">hblks</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Perform recovery around the end of the physical log.</span>
<span class="cm">		 * When the head is not on the same cycle number as the tail,</span>
<span class="cm">		 * we can&#39;t do a sequential recovery as above.</span>
<span class="cm">		 */</span>
		<span class="n">blk_no</span> <span class="o">=</span> <span class="n">tail_blk</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">blk_no</span> <span class="o">&lt;</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Check for header wrapping around physical end-of-log</span>
<span class="cm">			 */</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">hbp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
			<span class="n">split_hblks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">wrapped_hblks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">blk_no</span> <span class="o">+</span> <span class="n">hblks</span> <span class="o">&lt;=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Read header in one read */</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">blk_no</span><span class="p">,</span> <span class="n">hblks</span><span class="p">,</span> <span class="n">hbp</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* This LR is split across physical log end */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">blk_no</span> <span class="o">!=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* some data before physical log end */</span>
					<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk_no</span> <span class="o">&lt;=</span> <span class="n">INT_MAX</span><span class="p">);</span>
					<span class="n">split_hblks</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">blk_no</span><span class="p">;</span>
					<span class="n">ASSERT</span><span class="p">(</span><span class="n">split_hblks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
					<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">blk_no</span><span class="p">,</span>
							   <span class="n">split_hblks</span><span class="p">,</span> <span class="n">hbp</span><span class="p">,</span>
							   <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * Note: this black magic still works with</span>
<span class="cm">				 * large sector sizes (non-512) only because:</span>
<span class="cm">				 * - we increased the buffer size originally</span>
<span class="cm">				 *   by 1 sector giving us enough extra space</span>
<span class="cm">				 *   for the second read;</span>
<span class="cm">				 * - the log start is guaranteed to be sector</span>
<span class="cm">				 *   aligned;</span>
<span class="cm">				 * - we read the log end (LR header start)</span>
<span class="cm">				 *   _first_, then the log start (LR header end)</span>
<span class="cm">				 *   - order is important.</span>
<span class="cm">				 */</span>
				<span class="n">wrapped_hblks</span> <span class="o">=</span> <span class="n">hblks</span> <span class="o">-</span> <span class="n">split_hblks</span><span class="p">;</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread_offset</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">wrapped_hblks</span><span class="p">,</span> <span class="n">hbp</span><span class="p">,</span>
						<span class="n">offset</span> <span class="o">+</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">split_hblks</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rhead</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlog_rec_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_valid_rec_header</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">rhead</span><span class="p">,</span>
						<span class="n">split_hblks</span> <span class="o">?</span> <span class="n">blk_no</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>

			<span class="n">bblks</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">BTOBB</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_len</span><span class="p">));</span>
			<span class="n">blk_no</span> <span class="o">+=</span> <span class="n">hblks</span><span class="p">;</span>

			<span class="cm">/* Read in data for log record */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">blk_no</span> <span class="o">+</span> <span class="n">bblks</span> <span class="o">&lt;=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">blk_no</span><span class="p">,</span> <span class="n">bblks</span><span class="p">,</span> <span class="n">dbp</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* This log record is split across the</span>
<span class="cm">				 * physical end of log */</span>
				<span class="n">offset</span> <span class="o">=</span> <span class="n">dbp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
				<span class="n">split_bblks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">blk_no</span> <span class="o">!=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* some data is before the physical</span>
<span class="cm">					 * end of log */</span>
					<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">wrapped_hblks</span><span class="p">);</span>
					<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk_no</span> <span class="o">&lt;=</span> <span class="n">INT_MAX</span><span class="p">);</span>
					<span class="n">split_bblks</span> <span class="o">=</span>
						<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">blk_no</span><span class="p">;</span>
					<span class="n">ASSERT</span><span class="p">(</span><span class="n">split_bblks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
					<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">blk_no</span><span class="p">,</span>
							<span class="n">split_bblks</span><span class="p">,</span> <span class="n">dbp</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * Note: this black magic still works with</span>
<span class="cm">				 * large sector sizes (non-512) only because:</span>
<span class="cm">				 * - we increased the buffer size originally</span>
<span class="cm">				 *   by 1 sector giving us enough extra space</span>
<span class="cm">				 *   for the second read;</span>
<span class="cm">				 * - the log start is guaranteed to be sector</span>
<span class="cm">				 *   aligned;</span>
<span class="cm">				 * - we read the log end (LR header start)</span>
<span class="cm">				 *   _first_, then the log start (LR header end)</span>
<span class="cm">				 *   - order is important.</span>
<span class="cm">				 */</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread_offset</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">bblks</span> <span class="o">-</span> <span class="n">split_bblks</span><span class="p">,</span> <span class="n">hbp</span><span class="p">,</span>
						<span class="n">offset</span> <span class="o">+</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">split_bblks</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">xlog_unpack_data</span><span class="p">(</span><span class="n">rhead</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover_process_data</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">rhash</span><span class="p">,</span>
							<span class="n">rhead</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">pass</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>
			<span class="n">blk_no</span> <span class="o">+=</span> <span class="n">bblks</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk_no</span> <span class="o">&gt;=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">);</span>
		<span class="n">blk_no</span> <span class="o">-=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_logBBsize</span><span class="p">;</span>

		<span class="cm">/* read first part of physical log */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">blk_no</span> <span class="o">&lt;</span> <span class="n">head_blk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">blk_no</span><span class="p">,</span> <span class="n">hblks</span><span class="p">,</span> <span class="n">hbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>

			<span class="n">rhead</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlog_rec_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_valid_rec_header</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">rhead</span><span class="p">,</span> <span class="n">blk_no</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>

			<span class="n">bblks</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">BTOBB</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rhead</span><span class="o">-&gt;</span><span class="n">h_len</span><span class="p">));</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_bread</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">blk_no</span><span class="o">+</span><span class="n">hblks</span><span class="p">,</span> <span class="n">bblks</span><span class="p">,</span> <span class="n">dbp</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>

			<span class="n">xlog_unpack_data</span><span class="p">(</span><span class="n">rhead</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover_process_data</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">rhash</span><span class="p">,</span>
							<span class="n">rhead</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">pass</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">bread_err2</span><span class="p">;</span>
			<span class="n">blk_no</span> <span class="o">+=</span> <span class="n">bblks</span> <span class="o">+</span> <span class="n">hblks</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">bread_err2:</span>
	<span class="n">xlog_put_bp</span><span class="p">(</span><span class="n">dbp</span><span class="p">);</span>
 <span class="nl">bread_err1:</span>
	<span class="n">xlog_put_bp</span><span class="p">(</span><span class="n">hbp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do the recovery of the log.  We actually do this in two phases.</span>
<span class="cm"> * The two passes are necessary in order to implement the function</span>
<span class="cm"> * of cancelling a record written into the log.  The first pass</span>
<span class="cm"> * determines those things which have been cancelled, and the</span>
<span class="cm"> * second pass replays log items normally except for those which</span>
<span class="cm"> * have been cancelled.  The handling of the replay and cancellations</span>
<span class="cm"> * takes place in the log item type specific routines.</span>
<span class="cm"> *</span>
<span class="cm"> * The table of items which have cancel records in the log is allocated</span>
<span class="cm"> * and freed at this level, since only here do we know when all of</span>
<span class="cm"> * the log recovery has been completed.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_do_log_recovery</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">head_blk</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">tail_blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">head_blk</span> <span class="o">!=</span> <span class="n">tail_blk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * First do a pass to find all of the cancelled buf log items.</span>
<span class="cm">	 * Store them in the buf_cancel_table for use in the second pass.</span>
<span class="cm">	 */</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_buf_cancel_table</span> <span class="o">=</span> <span class="n">kmem_zalloc</span><span class="p">(</span><span class="n">XLOG_BC_TABLE_SIZE</span> <span class="o">*</span>
						 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">),</span>
						 <span class="n">KM_SLEEP</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">XLOG_BC_TABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_buf_cancel_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_do_recovery_pass</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">head_blk</span><span class="p">,</span> <span class="n">tail_blk</span><span class="p">,</span>
				      <span class="n">XLOG_RECOVER_PASS1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_buf_cancel_table</span><span class="p">);</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_buf_cancel_table</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Then do a second pass to actually recover the items in the log.</span>
<span class="cm">	 * When it is complete free the table of buf cancel items.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_do_recovery_pass</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">head_blk</span><span class="p">,</span> <span class="n">tail_blk</span><span class="p">,</span>
				      <span class="n">XLOG_RECOVER_PASS2</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">XLOG_BC_TABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_buf_cancel_table</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* DEBUG */</span><span class="cp"></span>

	<span class="n">kmem_free</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_buf_cancel_table</span><span class="p">);</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_buf_cancel_table</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do the actual recovery</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xlog_do_recover</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">head_blk</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">tail_blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_sb_t</span>	<span class="o">*</span><span class="n">sbp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First replay the images in the log.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_do_log_recovery</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">head_blk</span><span class="p">,</span> <span class="n">tail_blk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If IO errors happened during recovery, bail out.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We now update the tail_lsn since much of the recovery has completed</span>
<span class="cm">	 * and there may be space available to use.  If there were no extent</span>
<span class="cm">	 * or iunlinks, we can free up the entire log and set the tail_lsn to</span>
<span class="cm">	 * be the last_sync_lsn.  This was set in xlog_find_tail to be the</span>
<span class="cm">	 * lsn of the last known good LR on disk.  If there are extent frees</span>
<span class="cm">	 * or iunlinks they will have some entries in the AIL; so we look at</span>
<span class="cm">	 * the AIL to determine how to set the tail_lsn.</span>
<span class="cm">	 */</span>
	<span class="n">xlog_assign_tail_lsn</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that we&#39;ve finished replaying all buffer and inode</span>
<span class="cm">	 * updates, re-read in the superblock.</span>
<span class="cm">	 */</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_getsb</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">XFS_BUF_UNDONE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">XFS_BUF_ISWRITE</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
	<span class="n">XFS_BUF_READ</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">XFS_BUF_UNASYNC</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">xfsbdstrat</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_buf_iowait</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_buf_ioerror_alert</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Convert superblock from on-disk format */</span>
	<span class="n">sbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">;</span>
	<span class="n">xfs_sb_from_disk</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">XFS_BUF_TO_SBP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_magicnum</span> <span class="o">==</span> <span class="n">XFS_SB_MAGIC</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_sb_good_version</span><span class="p">(</span><span class="n">sbp</span><span class="p">));</span>
	<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* We&#39;ve re-read the superblock so re-initialize per-cpu counters */</span>
	<span class="n">xfs_icsb_reinit_counters</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">);</span>

	<span class="n">xlog_recover_check_summary</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>

	<span class="cm">/* Normal transactions can now occur */</span>
	<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XLOG_ACTIVE_RECOVERY</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform recovery and re-initialize some log variables in xlog_find_tail.</span>
<span class="cm"> *</span>
<span class="cm"> * Return error or zero.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xlog_recover</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">head_blk</span><span class="p">,</span> <span class="n">tail_blk</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="cm">/* find the tail of the log */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xlog_find_tail</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head_blk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail_blk</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tail_blk</span> <span class="o">!=</span> <span class="n">head_blk</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* There used to be a comment here:</span>
<span class="cm">		 *</span>
<span class="cm">		 * disallow recovery on read-only mounts.  note -- mount</span>
<span class="cm">		 * checks for ENOSPC and turns it into an intelligent</span>
<span class="cm">		 * error message.</span>
<span class="cm">		 * ...but this is no longer true.  Now, unless you specify</span>
<span class="cm">		 * NORECOVERY (in which case this function would never be</span>
<span class="cm">		 * called), we just go ahead and recover.  We do this all</span>
<span class="cm">		 * under the vfs layer, so we can get away with it unless</span>
<span class="cm">		 * the device itself is read-only, in which case we fail.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dev_is_read_only</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;recovery&quot;</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">xfs_notice</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;Starting recovery (logdev: %s)&quot;</span><span class="p">,</span>
				<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_logname</span> <span class="o">?</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_logname</span>
						     <span class="o">:</span> <span class="s">&quot;internal&quot;</span><span class="p">);</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_do_recover</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">head_blk</span><span class="p">,</span> <span class="n">tail_blk</span><span class="p">);</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flags</span> <span class="o">|=</span> <span class="n">XLOG_RECOVERY_NEEDED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * In the first part of recovery we replay inodes and buffers and build</span>
<span class="cm"> * up the list of extent free items which need to be processed.  Here</span>
<span class="cm"> * we process the extent free items and clean up the on disk unlinked</span>
<span class="cm"> * inode lists.  This is separated from the first part of recovery so</span>
<span class="cm"> * that the root and real-time bitmap inodes can be read in from disk in</span>
<span class="cm"> * between the two stages.  This is necessary so that we can free space</span>
<span class="cm"> * in the real-time portion of the file system.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xlog_recover_finish</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now we&#39;re ready to do the transactions needed for the</span>
<span class="cm">	 * rest of recovery.  Start with completing all the extent</span>
<span class="cm">	 * free intent records and then process the unlinked inode</span>
<span class="cm">	 * lists.  At this point, we essentially run in normal mode</span>
<span class="cm">	 * except that we&#39;re still performing recovery actions</span>
<span class="cm">	 * rather than accepting new requests.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flags</span> <span class="o">&amp;</span> <span class="n">XLOG_RECOVERY_NEEDED</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">error</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xlog_recover_process_efis</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;Failed to recover EFIs&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Sync the log to get all the EFIs out of the AIL.</span>
<span class="cm">		 * This isn&#39;t absolutely necessary, but it helps in</span>
<span class="cm">		 * case the unlink transactions would have problems</span>
<span class="cm">		 * pushing the EFIs out of the way.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_log_force</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="n">XFS_LOG_SYNC</span><span class="p">);</span>

		<span class="n">xlog_recover_process_iunlinks</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>

		<span class="n">xlog_recover_check_summary</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>

		<span class="n">xfs_notice</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;Ending recovery (logdev: %s)&quot;</span><span class="p">,</span>
				<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_logname</span> <span class="o">?</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="o">-&gt;</span><span class="n">m_logname</span>
						     <span class="o">:</span> <span class="s">&quot;internal&quot;</span><span class="p">);</span>
		<span class="n">log</span><span class="o">-&gt;</span><span class="n">l_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XLOG_RECOVERY_NEEDED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xfs_info</span><span class="p">(</span><span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">,</span> <span class="s">&quot;Ending clean mount&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#if defined(DEBUG)</span>
<span class="cm">/*</span>
<span class="cm"> * Read all of the agf and agi counters and check that they</span>
<span class="cm"> * are consistent with the superblock counters.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xlog_recover_check_summary</span><span class="p">(</span>
	<span class="n">xlog_t</span>		<span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_agf_t</span>	<span class="o">*</span><span class="n">agfp</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agfbp</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agibp</span><span class="p">;</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">;</span>
	<span class="n">__uint64_t</span>	<span class="n">freeblks</span><span class="p">;</span>
	<span class="n">__uint64_t</span>	<span class="n">itotal</span><span class="p">;</span>
	<span class="n">__uint64_t</span>	<span class="n">ifree</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_mp</span><span class="p">;</span>

	<span class="n">freeblks</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
	<span class="n">itotal</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
	<span class="n">ifree</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">agno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">agno</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">;</span> <span class="n">agno</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_read_agf</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">agfbp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s agf read failed agno %d error %d&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">agfp</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGF</span><span class="p">(</span><span class="n">agfbp</span><span class="p">);</span>
			<span class="n">freeblks</span> <span class="o">+=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agfp</span><span class="o">-&gt;</span><span class="n">agf_freeblks</span><span class="p">)</span> <span class="o">+</span>
				    <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agfp</span><span class="o">-&gt;</span><span class="n">agf_flcount</span><span class="p">);</span>
			<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">agfbp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_read_agi</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">agibp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s agi read failed agno %d error %d&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">xfs_agi</span>	<span class="o">*</span><span class="n">agi</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGI</span><span class="p">(</span><span class="n">agibp</span><span class="p">);</span>

			<span class="n">itotal</span> <span class="o">+=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_count</span><span class="p">);</span>
			<span class="n">ifree</span> <span class="o">+=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_freecount</span><span class="p">);</span>
			<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">agibp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
