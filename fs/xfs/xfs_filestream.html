<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_filestream.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_filestream.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2006-2007 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_inum.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_utils.h&quot;</span>
<span class="cp">#include &quot;xfs_mru_cache.h&quot;</span>
<span class="cp">#include &quot;xfs_filestream.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>

<span class="cp">#ifdef XFS_FILESTREAMS_TRACE</span>

<span class="n">ktrace_t</span> <span class="o">*</span><span class="n">xfs_filestreams_trace_buf</span><span class="p">;</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_filestreams_trace</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>	<span class="cm">/* mount point */</span>
	<span class="kt">int</span>		<span class="n">type</span><span class="p">,</span>	<span class="cm">/* type of trace */</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">func</span><span class="p">,</span>	<span class="cm">/* source function */</span>
	<span class="kt">int</span>		<span class="n">line</span><span class="p">,</span>	<span class="cm">/* source line number */</span>
	<span class="n">__psunsigned_t</span>	<span class="n">arg0</span><span class="p">,</span>
	<span class="n">__psunsigned_t</span>	<span class="n">arg1</span><span class="p">,</span>
	<span class="n">__psunsigned_t</span>	<span class="n">arg2</span><span class="p">,</span>
	<span class="n">__psunsigned_t</span>	<span class="n">arg3</span><span class="p">,</span>
	<span class="n">__psunsigned_t</span>	<span class="n">arg4</span><span class="p">,</span>
	<span class="n">__psunsigned_t</span>	<span class="n">arg5</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktrace_enter</span><span class="p">(</span><span class="n">xfs_filestreams_trace_buf</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">__psint_t</span><span class="p">)(</span><span class="n">type</span> <span class="o">|</span> <span class="p">(</span><span class="n">line</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)),</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">func</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">__psunsigned_t</span><span class="p">)</span><span class="n">current_pid</span><span class="p">(),</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mp</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">__psunsigned_t</span><span class="p">)</span><span class="n">arg0</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">__psunsigned_t</span><span class="p">)</span><span class="n">arg1</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">__psunsigned_t</span><span class="p">)</span><span class="n">arg2</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">__psunsigned_t</span><span class="p">)</span><span class="n">arg3</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">__psunsigned_t</span><span class="p">)</span><span class="n">arg4</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">__psunsigned_t</span><span class="p">)</span><span class="n">arg5</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define TRACE0(mp,t)			TRACE6(mp,t,0,0,0,0,0,0)</span>
<span class="cp">#define TRACE1(mp,t,a0)			TRACE6(mp,t,a0,0,0,0,0,0)</span>
<span class="cp">#define TRACE2(mp,t,a0,a1)		TRACE6(mp,t,a0,a1,0,0,0,0)</span>
<span class="cp">#define TRACE3(mp,t,a0,a1,a2)		TRACE6(mp,t,a0,a1,a2,0,0,0)</span>
<span class="cp">#define TRACE4(mp,t,a0,a1,a2,a3)	TRACE6(mp,t,a0,a1,a2,a3,0,0)</span>
<span class="cp">#define TRACE5(mp,t,a0,a1,a2,a3,a4)	TRACE6(mp,t,a0,a1,a2,a3,a4,0)</span>
<span class="cp">#define TRACE6(mp,t,a0,a1,a2,a3,a4,a5) \</span>
<span class="cp">	xfs_filestreams_trace(mp, t, __func__, __LINE__, \</span>
<span class="cp">				(__psunsigned_t)a0, (__psunsigned_t)a1, \</span>
<span class="cp">				(__psunsigned_t)a2, (__psunsigned_t)a3, \</span>
<span class="cp">				(__psunsigned_t)a4, (__psunsigned_t)a5)</span>

<span class="cp">#define TRACE_AG_SCAN(mp, ag, ag2) \</span>
<span class="cp">		TRACE2(mp, XFS_FSTRM_KTRACE_AGSCAN, ag, ag2);</span>
<span class="cp">#define TRACE_AG_PICK1(mp, max_ag, maxfree) \</span>
<span class="cp">		TRACE2(mp, XFS_FSTRM_KTRACE_AGPICK1, max_ag, maxfree);</span>
<span class="cp">#define TRACE_AG_PICK2(mp, ag, ag2, cnt, free, scan, flag) \</span>
<span class="cp">		TRACE6(mp, XFS_FSTRM_KTRACE_AGPICK2, ag, ag2, \</span>
<span class="cp">			 cnt, free, scan, flag)</span>
<span class="cp">#define TRACE_UPDATE(mp, ip, ag, cnt, ag2, cnt2) \</span>
<span class="cp">		TRACE5(mp, XFS_FSTRM_KTRACE_UPDATE, ip, ag, cnt, ag2, cnt2)</span>
<span class="cp">#define TRACE_FREE(mp, ip, pip, ag, cnt) \</span>
<span class="cp">		TRACE4(mp, XFS_FSTRM_KTRACE_FREE, ip, pip, ag, cnt)</span>
<span class="cp">#define TRACE_LOOKUP(mp, ip, pip, ag, cnt) \</span>
<span class="cp">		TRACE4(mp, XFS_FSTRM_KTRACE_ITEM_LOOKUP, ip, pip, ag, cnt)</span>
<span class="cp">#define TRACE_ASSOCIATE(mp, ip, pip, ag, cnt) \</span>
<span class="cp">		TRACE4(mp, XFS_FSTRM_KTRACE_ASSOCIATE, ip, pip, ag, cnt)</span>
<span class="cp">#define TRACE_MOVEAG(mp, ip, pip, oag, ocnt, nag, ncnt) \</span>
<span class="cp">		TRACE6(mp, XFS_FSTRM_KTRACE_MOVEAG, ip, pip, oag, ocnt, nag, ncnt)</span>
<span class="cp">#define TRACE_ORPHAN(mp, ip, ag) \</span>
<span class="cp">		TRACE2(mp, XFS_FSTRM_KTRACE_ORPHAN, ip, ag);</span>


<span class="cp">#else</span>
<span class="cp">#define TRACE_AG_SCAN(mp, ag, ag2)</span>
<span class="cp">#define TRACE_AG_PICK1(mp, max_ag, maxfree)</span>
<span class="cp">#define TRACE_AG_PICK2(mp, ag, ag2, cnt, free, scan, flag)</span>
<span class="cp">#define TRACE_UPDATE(mp, ip, ag, cnt, ag2, cnt2)</span>
<span class="cp">#define TRACE_FREE(mp, ip, pip, ag, cnt)</span>
<span class="cp">#define TRACE_LOOKUP(mp, ip, pip, ag, cnt)</span>
<span class="cp">#define TRACE_ASSOCIATE(mp, ip, pip, ag, cnt)</span>
<span class="cp">#define TRACE_MOVEAG(mp, ip, pip, oag, ocnt, nag, ncnt)</span>
<span class="cp">#define TRACE_ORPHAN(mp, ip, ag)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">kmem_zone_t</span> <span class="o">*</span><span class="n">item_zone</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Structure for associating a file or a directory with an allocation group.</span>
<span class="cm"> * The parent directory pointer is only needed for files, but since there will</span>
<span class="cm"> * generally be vastly more files than directories in the cache, using the same</span>
<span class="cm"> * data structure simplifies the code with very little memory overhead.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">fstrm_item</span>
<span class="p">{</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">ag</span><span class="p">;</span>	<span class="cm">/* AG currently in use for the file/directory. */</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">;</span>	<span class="cm">/* inode self-pointer. */</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">pip</span><span class="p">;</span>	<span class="cm">/* Parent directory inode pointer. */</span>
<span class="p">}</span> <span class="n">fstrm_item_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Allocation group filestream associations are tracked with per-ag atomic</span>
<span class="cm"> * counters.  These counters allow _xfs_filestream_pick_ag() to tell whether a</span>
<span class="cm"> * particular AG already has active filestreams associated with it. The mount</span>
<span class="cm"> * point&#39;s m_peraglock is used to protect these counters from per-ag array</span>
<span class="cm"> * re-allocation during a growfs operation.  When xfs_growfs_data_private() is</span>
<span class="cm"> * about to reallocate the array, it calls xfs_filestream_flush() with the</span>
<span class="cm"> * m_peraglock held in write mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Since xfs_mru_cache_flush() guarantees that all the free functions for all</span>
<span class="cm"> * the cache elements have finished executing before it returns, it&#39;s safe for</span>
<span class="cm"> * the free functions to use the atomic counters without m_peraglock protection.</span>
<span class="cm"> * This allows the implementation of xfs_fstrm_free_func() to be agnostic about</span>
<span class="cm"> * whether it was called with the m_peraglock held in read mode, write mode or</span>
<span class="cm"> * not held at all.  The race condition this addresses is the following:</span>
<span class="cm"> *</span>
<span class="cm"> *  - The work queue scheduler fires and pulls a filestream directory cache</span>
<span class="cm"> *    element off the LRU end of the cache for deletion, then gets pre-empted.</span>
<span class="cm"> *  - A growfs operation grabs the m_peraglock in write mode, flushes all the</span>
<span class="cm"> *    remaining items from the cache and reallocates the mount point&#39;s per-ag</span>
<span class="cm"> *    array, resetting all the counters to zero.</span>
<span class="cm"> *  - The work queue thread resumes and calls the free function for the element</span>
<span class="cm"> *    it started cleaning up earlier.  In the process it decrements the</span>
<span class="cm"> *    filestreams counter for an AG that now has no references.</span>
<span class="cm"> *</span>
<span class="cm"> * With a shrinkfs feature, the above scenario could panic the system.</span>
<span class="cm"> *</span>
<span class="cm"> * All other uses of the following macros should be protected by either the</span>
<span class="cm"> * m_peraglock held in read mode, or the cache&#39;s internal locking exposed by the</span>
<span class="cm"> * interval between a call to xfs_mru_cache_lookup() and a call to</span>
<span class="cm"> * xfs_mru_cache_done().  In addition, the m_peraglock must be held in read mode</span>
<span class="cm"> * when new elements are added to the cache.</span>
<span class="cm"> *</span>
<span class="cm"> * Combined, these locking rules ensure that no associations will ever exist in</span>
<span class="cm"> * the cache that reference per-ag array elements that have since been</span>
<span class="cm"> * reallocated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xfs_filestream_peek_ag</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span> <span class="o">*</span><span class="n">pag</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">ret</span><span class="p">;</span>

	<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_fstrms</span><span class="p">);</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xfs_filestream_get_ag</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span> <span class="o">*</span><span class="n">pag</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">ret</span><span class="p">;</span>

	<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_fstrms</span><span class="p">);</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xfs_filestream_put_ag</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span> <span class="o">*</span><span class="n">pag</span><span class="p">;</span>

	<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_fstrms</span><span class="p">);</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scan the AGs starting at startag looking for an AG that isn&#39;t in use and has</span>
<span class="cm"> * at least minlen blocks free.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">_xfs_filestream_pick_ag</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">startag</span><span class="p">,</span>
	<span class="n">xfs_agnumber_t</span>	<span class="o">*</span><span class="n">agp</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">,</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">minlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">streams</span><span class="p">,</span> <span class="n">max_streams</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">err</span><span class="p">,</span> <span class="n">trylock</span><span class="p">,</span> <span class="n">nscan</span><span class="p">;</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">longest</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">minfree</span><span class="p">,</span> <span class="n">maxfree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">ag</span><span class="p">,</span> <span class="n">max_ag</span> <span class="o">=</span> <span class="n">NULLAGNUMBER</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span> <span class="o">*</span><span class="n">pag</span><span class="p">;</span>

	<span class="cm">/* 2% of an AG&#39;s blocks must be free for it to be chosen. */</span>
	<span class="n">minfree</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agblocks</span> <span class="o">/</span> <span class="mi">50</span><span class="p">;</span>

	<span class="n">ag</span> <span class="o">=</span> <span class="n">startag</span><span class="p">;</span>
	<span class="o">*</span><span class="n">agp</span> <span class="o">=</span> <span class="n">NULLAGNUMBER</span><span class="p">;</span>

	<span class="cm">/* For the first pass, don&#39;t sleep trying to init the per-AG. */</span>
	<span class="n">trylock</span> <span class="o">=</span> <span class="n">XFS_ALLOC_FLAG_TRYLOCK</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">nscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">nscan</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">);</span>
		<span class="n">TRACE_AG_SCAN</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_fstrms</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_init</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">xfs_alloc_pagf_init</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">trylock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">trylock</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Might fail sometimes during the 1st pass with trylock set. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_init</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next_ag</span><span class="p">;</span>

		<span class="cm">/* Keep track of the AG with the most free blocks. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_freeblks</span> <span class="o">&gt;</span> <span class="n">maxfree</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">maxfree</span> <span class="o">=</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_freeblks</span><span class="p">;</span>
			<span class="n">max_streams</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_fstrms</span><span class="p">);</span>
			<span class="n">max_ag</span> <span class="o">=</span> <span class="n">ag</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The AG reference count does two things: it enforces mutual</span>
<span class="cm">		 * exclusion when examining the suitability of an AG in this</span>
<span class="cm">		 * loop, and it guards against two filestreams being established</span>
<span class="cm">		 * in the same AG as each other.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfs_filestream_get_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_filestream_put_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next_ag</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">longest</span> <span class="o">=</span> <span class="n">xfs_alloc_longest_free_extent</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">pag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">minlen</span> <span class="o">&amp;&amp;</span> <span class="n">longest</span> <span class="o">&gt;=</span> <span class="n">minlen</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">(</span><span class="o">!</span><span class="n">minlen</span> <span class="o">&amp;&amp;</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_freeblks</span> <span class="o">&gt;=</span> <span class="n">minfree</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_metadata</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_PICK_USERDATA</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_PICK_LOWSPACE</span><span class="p">)))</span> <span class="p">{</span>

			<span class="cm">/* Break out, retaining the reference on the AG. */</span>
			<span class="n">free</span> <span class="o">=</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_freeblks</span><span class="p">;</span>
			<span class="n">streams</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_fstrms</span><span class="p">);</span>
			<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
			<span class="o">*</span><span class="n">agp</span> <span class="o">=</span> <span class="n">ag</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Drop the reference on this AG, it&#39;s not usable. */</span>
		<span class="n">xfs_filestream_put_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">);</span>
<span class="nl">next_ag:</span>
		<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
		<span class="cm">/* Move to the next AG, wrapping to AG 0 if necessary. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">ag</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">)</span>
			<span class="n">ag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* If a full pass of the AGs hasn&#39;t been done yet, continue. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ag</span> <span class="o">!=</span> <span class="n">startag</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Allow sleeping in xfs_alloc_pagf_init() on the 2nd pass. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trylock</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trylock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Finally, if lowspace wasn&#39;t set, set it for the 3rd pass. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_PICK_LOWSPACE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_PICK_LOWSPACE</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Take the AG with the most free space, regardless of whether</span>
<span class="cm">		 * it&#39;s already in use by another filestream.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_ag</span> <span class="o">!=</span> <span class="n">NULLAGNUMBER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_filestream_get_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">max_ag</span><span class="p">);</span>
			<span class="n">TRACE_AG_PICK1</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">max_ag</span><span class="p">,</span> <span class="n">maxfree</span><span class="p">);</span>
			<span class="n">streams</span> <span class="o">=</span> <span class="n">max_streams</span><span class="p">;</span>
			<span class="n">free</span> <span class="o">=</span> <span class="n">maxfree</span><span class="p">;</span>
			<span class="o">*</span><span class="n">agp</span> <span class="o">=</span> <span class="n">max_ag</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* take AG 0 if none matched */</span>
		<span class="n">TRACE_AG_PICK1</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">max_ag</span><span class="p">,</span> <span class="n">maxfree</span><span class="p">);</span>
		<span class="o">*</span><span class="n">agp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">TRACE_AG_PICK2</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">startag</span><span class="p">,</span> <span class="o">*</span><span class="n">agp</span><span class="p">,</span> <span class="n">streams</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">nscan</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the allocation group number for a file or a directory, updating inode</span>
<span class="cm"> * references and per-AG references as appropriate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">_xfs_filestream_update_ag</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">pip</span><span class="p">,</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">ag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_mru_cache_t</span>	<span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="n">fstrm_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">old_ag</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">old_pip</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Either ip is a regular file and pip is a directory, or ip is a</span>
<span class="cm">	 * directory and pip is NULL.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pip</span> <span class="o">&amp;&amp;</span>
	               <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">))</span> <span class="o">||</span>
	              <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pip</span><span class="p">)));</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">cache</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_filestream</span><span class="p">;</span>

	<span class="n">item</span> <span class="o">=</span> <span class="n">xfs_mru_cache_lookup</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">==</span> <span class="n">ip</span><span class="p">);</span>
		<span class="n">old_ag</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ag</span><span class="p">;</span>
		<span class="n">item</span><span class="o">-&gt;</span><span class="n">ag</span> <span class="o">=</span> <span class="n">ag</span><span class="p">;</span>
		<span class="n">old_pip</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">pip</span><span class="p">;</span>
		<span class="n">item</span><span class="o">-&gt;</span><span class="n">pip</span> <span class="o">=</span> <span class="n">pip</span><span class="p">;</span>
		<span class="n">xfs_mru_cache_done</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the AG has changed, drop the old ref and take a new one,</span>
<span class="cm">		 * effectively transferring the reference from old to new AG.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ag</span> <span class="o">!=</span> <span class="n">old_ag</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_filestream_put_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">old_ag</span><span class="p">);</span>
			<span class="n">xfs_filestream_get_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If ip is a file and its pip has changed, drop the old ref and</span>
<span class="cm">		 * take a new one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pip</span> <span class="o">&amp;&amp;</span> <span class="n">pip</span> <span class="o">!=</span> <span class="n">old_pip</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRELE</span><span class="p">(</span><span class="n">old_pip</span><span class="p">);</span>
			<span class="n">IHOLD</span><span class="p">(</span><span class="n">pip</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">TRACE_UPDATE</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">old_ag</span><span class="p">,</span> <span class="n">xfs_filestream_peek_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">old_ag</span><span class="p">),</span>
				<span class="n">ag</span><span class="p">,</span> <span class="n">xfs_filestream_peek_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">item</span> <span class="o">=</span> <span class="n">kmem_zone_zalloc</span><span class="p">(</span><span class="n">item_zone</span><span class="p">,</span> <span class="n">KM_MAYFAIL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">item</span><span class="o">-&gt;</span><span class="n">ag</span> <span class="o">=</span> <span class="n">ag</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">pip</span> <span class="o">=</span> <span class="n">pip</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">xfs_mru_cache_insert</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_zone_free</span><span class="p">(</span><span class="n">item_zone</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Take a reference on the AG. */</span>
	<span class="n">xfs_filestream_get_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take a reference on the inode itself regardless of whether it&#39;s a</span>
<span class="cm">	 * regular file or a directory.</span>
<span class="cm">	 */</span>
	<span class="n">IHOLD</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In the case of a regular file, take a reference on the parent inode</span>
<span class="cm">	 * as well to ensure it remains in-core.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pip</span><span class="p">)</span>
		<span class="n">IHOLD</span><span class="p">(</span><span class="n">pip</span><span class="p">);</span>

	<span class="n">TRACE_UPDATE</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">xfs_filestream_peek_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">),</span>
			<span class="n">ag</span><span class="p">,</span> <span class="n">xfs_filestream_peek_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* xfs_fstrm_free_func(): callback for freeing cached stream items. */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_fstrm_free_func</span><span class="p">(</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">ino</span><span class="p">,</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fstrm_item_t</span>	<span class="o">*</span><span class="n">item</span>  <span class="o">=</span> <span class="p">(</span><span class="n">fstrm_item_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">==</span> <span class="n">ino</span><span class="p">);</span>

	<span class="n">xfs_iflags_clear</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IFILESTREAM</span><span class="p">);</span>

	<span class="cm">/* Drop the reference taken on the AG when the item was added. */</span>
	<span class="n">xfs_filestream_put_ag</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ag</span><span class="p">);</span>

	<span class="n">TRACE_FREE</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">pip</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ag</span><span class="p">,</span>
		<span class="n">xfs_filestream_peek_ag</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ag</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * _xfs_filestream_update_ag() always takes a reference on the inode</span>
<span class="cm">	 * itself, whether it&#39;s a file or a directory.  Release it here.</span>
<span class="cm">	 * This can result in the inode being freed and so we must</span>
<span class="cm">	 * not hold any inode locks when freeing filesstreams objects</span>
<span class="cm">	 * otherwise we can deadlock here.</span>
<span class="cm">	 */</span>
	<span class="n">IRELE</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In the case of a regular file, _xfs_filestream_update_ag() also</span>
<span class="cm">	 * takes a ref on the parent inode to keep it in-core.  Release that</span>
<span class="cm">	 * too.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">pip</span><span class="p">)</span>
		<span class="n">IRELE</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">pip</span><span class="p">);</span>

	<span class="cm">/* Finally, free the memory allocated for the item. */</span>
	<span class="n">kmem_zone_free</span><span class="p">(</span><span class="n">item_zone</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_filestream_init() is called at xfs initialisation time to set up the</span>
<span class="cm"> * memory zone that will be used for filestream data structure allocation.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_filestream_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">item_zone</span> <span class="o">=</span> <span class="n">kmem_zone_init</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">fstrm_item_t</span><span class="p">),</span> <span class="s">&quot;fstrm_item&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item_zone</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_filestream_uninit() is called at xfs termination time to destroy the</span>
<span class="cm"> * memory zone that was used for filestream data structure allocation.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_filestream_uninit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_zone_destroy</span><span class="p">(</span><span class="n">item_zone</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_filestream_mount() is called when a file system is mounted with the</span>
<span class="cm"> * filestream option.  It is responsible for allocating the data structures</span>
<span class="cm"> * needed to track the new file system&#39;s file streams.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_filestream_mount</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">lifetime</span><span class="p">,</span> <span class="n">grp_count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The filestream timer tunable is currently fixed within the range of</span>
<span class="cm">	 * one second to four minutes, with five seconds being the default.  The</span>
<span class="cm">	 * group count is somewhat arbitrary, but it&#39;d be nice to adhere to the</span>
<span class="cm">	 * timer tunable to within about 10 percent.  This requires at least 10</span>
<span class="cm">	 * groups.</span>
<span class="cm">	 */</span>
	<span class="n">lifetime</span>  <span class="o">=</span> <span class="n">xfs_fstrm_centisecs</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">grp_count</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">xfs_mru_cache_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_filestream</span><span class="p">,</span> <span class="n">lifetime</span><span class="p">,</span> <span class="n">grp_count</span><span class="p">,</span>
	                     <span class="n">xfs_fstrm_free_func</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_filestream_unmount() is called when a file system that was mounted with</span>
<span class="cm"> * the filestream option is unmounted.  It drains the data structures created</span>
<span class="cm"> * to track the file system&#39;s file streams and frees all the memory that was</span>
<span class="cm"> * allocated.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_filestream_unmount</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mru_cache_destroy</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_filestream</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the AG of the filestream the file or directory belongs to, or</span>
<span class="cm"> * NULLAGNUMBER otherwise.</span>
<span class="cm"> */</span>
<span class="n">xfs_agnumber_t</span>
<span class="nf">xfs_filestream_lookup_ag</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mru_cache_t</span>	<span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="n">fstrm_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">ag</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">ref</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NULLAGNUMBER</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="o">-&gt;</span><span class="n">m_filestream</span><span class="p">;</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">xfs_mru_cache_lookup</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">TRACE_LOOKUP</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">NULLAGNUMBER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NULLAGNUMBER</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span> <span class="o">==</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
	<span class="n">ag</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ag</span><span class="p">;</span>
	<span class="n">ref</span> <span class="o">=</span> <span class="n">xfs_filestream_peek_ag</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">ag</span><span class="p">);</span>
	<span class="n">xfs_mru_cache_done</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>

	<span class="n">TRACE_LOOKUP</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">pip</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_filestream_associate() should only be called to associate a regular file</span>
<span class="cm"> * with its parent directory.  Calling it with a child directory isn&#39;t</span>
<span class="cm"> * appropriate because filestreams don&#39;t apply to entire directory hierarchies.</span>
<span class="cm"> * Creating a file in a child directory of an existing filestream directory</span>
<span class="cm"> * starts a new filestream with its own allocation group association.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns &lt; 0 on error, 0 if successful association occurred, &gt; 0 if</span>
<span class="cm"> * we failed to get an association because of locking issues.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_filestream_associate</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">pip</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_mru_cache_t</span>	<span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="n">fstrm_item_t</span>	<span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">ag</span><span class="p">,</span> <span class="n">rotorstep</span><span class="p">,</span> <span class="n">startag</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">cache</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_filestream</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have a problem, Houston.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Taking the iolock here violates inode locking order - we already</span>
<span class="cm">	 * hold the ilock. Hence if we block getting this lock we may never</span>
<span class="cm">	 * wake. Unfortunately, that means if we can&#39;t get the lock, we&#39;re</span>
<span class="cm">	 * screwed in terms of getting a stream association - we can&#39;t spin</span>
<span class="cm">	 * waiting for the lock because someone else is waiting on the lock we</span>
<span class="cm">	 * hold and we cannot drop that as we are in a transaction here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Lucky for us, this inversion is not a problem because it&#39;s a</span>
<span class="cm">	 * directory inode that we are trying to lock here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So, if we can&#39;t get the iolock without sleeping then just give up</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_ilock_nowait</span><span class="p">(</span><span class="n">pip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* If the parent directory is already in the cache, use its AG. */</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">xfs_mru_cache_lookup</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">==</span> <span class="n">pip</span><span class="p">);</span>
		<span class="n">ag</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">ag</span><span class="p">;</span>
		<span class="n">xfs_mru_cache_done</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>

		<span class="n">TRACE_LOOKUP</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">pip</span><span class="p">,</span> <span class="n">pip</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">xfs_filestream_peek_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">_xfs_filestream_update_ag</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">pip</span><span class="p">,</span> <span class="n">ag</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the starting AG using the rotor for inode32, otherwise</span>
<span class="cm">	 * use the directory inode&#39;s AG.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_32BITINODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rotorstep</span> <span class="o">=</span> <span class="n">xfs_rotorstep</span><span class="p">;</span>
		<span class="n">startag</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agfrotor</span> <span class="o">/</span> <span class="n">rotorstep</span><span class="p">)</span> <span class="o">%</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">;</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agfrotor</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agfrotor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span>
		                 <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span> <span class="o">*</span> <span class="n">rotorstep</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">startag</span> <span class="o">=</span> <span class="n">XFS_INO_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="cm">/* Pick a new AG for the parent inode starting at startag. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">_xfs_filestream_pick_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">startag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">ag</span> <span class="o">==</span> <span class="n">NULLAGNUMBER</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_did_pick</span><span class="p">;</span>

	<span class="cm">/* Associate the parent inode with the AG. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">_xfs_filestream_update_ag</span><span class="p">(</span><span class="n">pip</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_did_pick</span><span class="p">;</span>

	<span class="cm">/* Associate the file inode with the AG. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">_xfs_filestream_update_ag</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">pip</span><span class="p">,</span> <span class="n">ag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_did_pick</span><span class="p">;</span>

	<span class="n">TRACE_ASSOCIATE</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">pip</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">xfs_filestream_peek_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">));</span>

<span class="nl">exit_did_pick:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If _xfs_filestream_pick_ag() returned a valid AG, remove the</span>
<span class="cm">	 * reference it took on it, since the file and directory will have taken</span>
<span class="cm">	 * their own now if they were successfully cached.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ag</span> <span class="o">!=</span> <span class="n">NULLAGNUMBER</span><span class="p">)</span>
		<span class="n">xfs_filestream_put_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">);</span>

<span class="nl">exit:</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">pip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pick a new allocation group for the current file and its file stream.  This</span>
<span class="cm"> * function is called by xfs_bmap_filestreams() with the mount point&#39;s per-ag</span>
<span class="cm"> * lock held.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_filestream_new_ag</span><span class="p">(</span>
	<span class="n">xfs_bmalloca_t</span>	<span class="o">*</span><span class="n">ap</span><span class="p">,</span>
	<span class="n">xfs_agnumber_t</span>	<span class="o">*</span><span class="n">agp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="o">*</span><span class="n">pip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_mru_cache_t</span>	<span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">minlen</span><span class="p">;</span>
	<span class="n">fstrm_item_t</span>	<span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">ag</span> <span class="o">=</span> <span class="n">NULLAGNUMBER</span><span class="p">;</span>

	<span class="n">ip</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">cache</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_filestream</span><span class="p">;</span>
	<span class="n">minlen</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="o">*</span><span class="n">agp</span> <span class="o">=</span> <span class="n">NULLAGNUMBER</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look for the file in the cache, removing it if it&#39;s found.  Doing</span>
<span class="cm">	 * this allows it to be held across the dir lookup that follows.</span>
<span class="cm">	 */</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">xfs_mru_cache_remove</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span> <span class="o">==</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>

		<span class="cm">/* Save the file&#39;s parent inode and old AG number for later. */</span>
		<span class="n">pip</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">pip</span><span class="p">;</span>
		<span class="n">ag</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">ag</span><span class="p">;</span>

		<span class="cm">/* Look for the file&#39;s directory in the cache. */</span>
		<span class="n">dir</span> <span class="o">=</span> <span class="n">xfs_mru_cache_lookup</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">pip</span> <span class="o">==</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the directory has already moved on to a new AG,</span>
<span class="cm">			 * use that AG as the new AG for the file. Don&#39;t</span>
<span class="cm">			 * forget to twiddle the AG refcounts to match the</span>
<span class="cm">			 * movement.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">ag</span> <span class="o">!=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">ag</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_filestream_put_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">ag</span><span class="p">);</span>
				<span class="n">xfs_filestream_get_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">ag</span><span class="p">);</span>
				<span class="o">*</span><span class="n">agp</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">ag</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">ag</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">xfs_mru_cache_done</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Put the file back in the cache.  If this fails, the free</span>
<span class="cm">		 * function needs to be called to tidy up in the same way as if</span>
<span class="cm">		 * the item had simply expired from the cache.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">xfs_mru_cache_insert</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_fstrm_free_func</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the file&#39;s AG was moved to the directory&#39;s new AG, there&#39;s</span>
<span class="cm">		 * nothing more to be done.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">agp</span> <span class="o">!=</span> <span class="n">NULLAGNUMBER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">TRACE_MOVEAG</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">pip</span><span class="p">,</span>
					<span class="n">ag</span><span class="p">,</span> <span class="n">xfs_filestream_peek_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">),</span>
					<span class="o">*</span><span class="n">agp</span><span class="p">,</span> <span class="n">xfs_filestream_peek_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="o">*</span><span class="n">agp</span><span class="p">));</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the file&#39;s parent directory is known, take its iolock in exclusive</span>
<span class="cm">	 * mode to prevent two sibling files from racing each other to migrate</span>
<span class="cm">	 * themselves and their parent to different AGs.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that we lock the parent directory iolock inside the child</span>
<span class="cm">	 * iolock here.  That&#39;s fine as we never hold both parent and child</span>
<span class="cm">	 * iolock in any other place.  This is different from the ilock,</span>
<span class="cm">	 * which requires locking of the child after the parent for namespace</span>
<span class="cm">	 * operations.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pip</span><span class="p">)</span>
		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">pip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span> <span class="o">|</span> <span class="n">XFS_IOLOCK_PARENT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * A new AG needs to be found for the file.  If the file&#39;s parent</span>
<span class="cm">	 * directory is also known, it will be moved to the new AG as well to</span>
<span class="cm">	 * ensure that files created inside it in future use the new AG.</span>
<span class="cm">	 */</span>
	<span class="n">ag</span> <span class="o">=</span> <span class="p">(</span><span class="n">ag</span> <span class="o">==</span> <span class="n">NULLAGNUMBER</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="n">ag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">userdata</span> <span class="o">?</span> <span class="n">XFS_PICK_USERDATA</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
	        <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flist</span><span class="o">-&gt;</span><span class="n">xbf_low</span> <span class="o">?</span> <span class="n">XFS_PICK_LOWSPACE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">_xfs_filestream_pick_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">agp</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">minlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="o">*</span><span class="n">agp</span> <span class="o">==</span> <span class="n">NULLAGNUMBER</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the file wasn&#39;t found in the file cache, then its parent directory</span>
<span class="cm">	 * inode isn&#39;t known.  For this to have happened, the file must either</span>
<span class="cm">	 * be pre-existing, or it was created long enough ago that its cache</span>
<span class="cm">	 * entry has expired.  This isn&#39;t the sort of usage that the filestreams</span>
<span class="cm">	 * allocator is trying to optimise, so there&#39;s no point trying to track</span>
<span class="cm">	 * its new AG somehow in the filestream data structures.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">TRACE_ORPHAN</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">*</span><span class="n">agp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Associate the parent inode with the AG. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">_xfs_filestream_update_ag</span><span class="p">(</span><span class="n">pip</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">agp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="cm">/* Associate the file inode with the AG. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">_xfs_filestream_update_ag</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">pip</span><span class="p">,</span> <span class="o">*</span><span class="n">agp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">TRACE_MOVEAG</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">pip</span><span class="p">,</span> <span class="n">NULLAGNUMBER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="o">*</span><span class="n">agp</span><span class="p">,</span> <span class="n">xfs_filestream_peek_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="o">*</span><span class="n">agp</span><span class="p">));</span>

<span class="nl">exit:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If _xfs_filestream_pick_ag() returned a valid AG, remove the</span>
<span class="cm">	 * reference it took on it, since the file and directory will have taken</span>
<span class="cm">	 * their own now if they were successfully cached.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">agp</span> <span class="o">!=</span> <span class="n">NULLAGNUMBER</span><span class="p">)</span>
		<span class="n">xfs_filestream_put_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="o">*</span><span class="n">agp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">agp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pip</span><span class="p">)</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">pip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove an association between an inode and a filestream object.</span>
<span class="cm"> * Typically this is done on last close of an unlinked file.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_filestream_deassociate</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mru_cache_t</span>	<span class="o">*</span><span class="n">cache</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="o">-&gt;</span><span class="n">m_filestream</span><span class="p">;</span>

	<span class="n">xfs_mru_cache_delete</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
