<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_dir2_node.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_dir2_node.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_da_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap.h&quot;</span>
<span class="cp">#include &quot;xfs_dir2_format.h&quot;</span>
<span class="cp">#include &quot;xfs_dir2_priv.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Function declarations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">xfs_dir2_free_log_header</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xfs_dir2_leafn_add</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">xfs_dir2_leafn_check</span><span class="p">(</span><span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define	xfs_dir2_leafn_check(dp, bp)</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">xfs_dir2_leafn_moveents</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp_s</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">start_s</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp_d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_d</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">xfs_dir2_leafn_rebalance</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				     <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk1</span><span class="p">,</span>
				     <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk2</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xfs_dir2_leafn_remove</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">dblk</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="o">*</span><span class="n">rval</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xfs_dir2_node_addname_int</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
				     <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">fblk</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Log entries from a freespace block.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_dir2_free_log_bests</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>		<span class="cm">/* freespace buffer */</span>
	<span class="kt">int</span>			<span class="n">first</span><span class="p">,</span>		<span class="cm">/* first entry to log */</span>
	<span class="kt">int</span>			<span class="n">last</span><span class="p">)</span>		<span class="cm">/* last entry to log */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_free_t</span>		<span class="o">*</span><span class="n">free</span><span class="p">;</span>		<span class="cm">/* freespace structure */</span>

	<span class="n">free</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_FREE_MAGIC</span><span class="p">));</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
		<span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">free</span><span class="p">),</span>
		<span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">free</span> <span class="o">+</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Log header from a freespace block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xfs_dir2_free_log_header</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>		<span class="cm">/* freespace buffer */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_free_t</span>		<span class="o">*</span><span class="n">free</span><span class="p">;</span>		<span class="cm">/* freespace structure */</span>

	<span class="n">free</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_FREE_MAGIC</span><span class="p">));</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">free</span><span class="p">),</span>
		<span class="p">(</span><span class="n">uint</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_dir2_free_hdr_t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert a leaf-format directory to a node-format directory.</span>
<span class="cm"> * We need to change the magic number of the leaf block, and copy</span>
<span class="cm"> * the freespace table out of the leaf block into its own block.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_leaf_to_node</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">,</span>		<span class="cm">/* operation arguments */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">lbp</span><span class="p">)</span>		<span class="cm">/* leaf buffer */</span>
<span class="p">{</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">;</span>		<span class="cm">/* incore directory inode */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">fbp</span><span class="p">;</span>		<span class="cm">/* freespace buffer */</span>
	<span class="n">xfs_dir2_db_t</span>		<span class="n">fdb</span><span class="p">;</span>		<span class="cm">/* freespace block number */</span>
	<span class="n">xfs_dir2_free_t</span>		<span class="o">*</span><span class="n">free</span><span class="p">;</span>		<span class="cm">/* freespace structure */</span>
	<span class="n">__be16</span>			<span class="o">*</span><span class="n">from</span><span class="p">;</span>		<span class="cm">/* pointer to freespace entry */</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>		<span class="cm">/* leaf freespace index */</span>
	<span class="n">xfs_dir2_leaf_t</span>		<span class="o">*</span><span class="n">leaf</span><span class="p">;</span>		<span class="cm">/* leaf structure */</span>
	<span class="n">xfs_dir2_leaf_tail_t</span>	<span class="o">*</span><span class="n">ltp</span><span class="p">;</span>		<span class="cm">/* leaf tail structure */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>
	<span class="kt">int</span>			<span class="n">n</span><span class="p">;</span>		<span class="cm">/* count of live freespc ents */</span>
	<span class="n">xfs_dir2_data_off_t</span>	<span class="n">off</span><span class="p">;</span>		<span class="cm">/* freespace entry value */</span>
	<span class="n">__be16</span>			<span class="o">*</span><span class="n">to</span><span class="p">;</span>		<span class="cm">/* pointer to freespace entry */</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>		<span class="cm">/* transaction pointer */</span>

	<span class="n">trace_xfs_dir2_leaf_to_node</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Add a freespace block to the directory.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_grow_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">XFS_DIR2_FREE_SPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdb</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">fdb</span> <span class="o">==</span> <span class="n">XFS_DIR2_FREE_FIRSTDB</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the buffer for the new freespace block.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_get_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">xfs_dir2_db_to_da</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">fdb</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbp</span><span class="p">,</span>
			<span class="n">XFS_DATA_FORK</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">fbp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">free</span> <span class="o">=</span> <span class="n">fbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">lbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ltp</span> <span class="o">=</span> <span class="n">xfs_dir2_leaf_tail_p</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initialize the freespace block header.</span>
<span class="cm">	 */</span>
	<span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_FREE_MAGIC</span><span class="p">);</span>
	<span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstdb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ltp</span><span class="o">-&gt;</span><span class="n">bestcount</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">/</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblksize</span><span class="p">);</span>
	<span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nvalid</span> <span class="o">=</span> <span class="n">ltp</span><span class="o">-&gt;</span><span class="n">bestcount</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy freespace entries from the leaf block to the new block.</span>
<span class="cm">	 * Count active entries.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">from</span> <span class="o">=</span> <span class="n">xfs_dir2_leaf_bests_p</span><span class="p">(</span><span class="n">ltp</span><span class="p">),</span> <span class="n">to</span> <span class="o">=</span> <span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ltp</span><span class="o">-&gt;</span><span class="n">bestcount</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">from</span><span class="o">++</span><span class="p">,</span> <span class="n">to</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">off</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">from</span><span class="p">))</span> <span class="o">!=</span> <span class="n">NULLDATAOFF</span><span class="p">)</span>
			<span class="n">n</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">off</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nused</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Log everything.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_dir2_leaf_log_header</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">lbp</span><span class="p">);</span>
	<span class="n">xfs_dir2_free_log_header</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">fbp</span><span class="p">);</span>
	<span class="n">xfs_dir2_free_log_bests</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">fbp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nvalid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">fbp</span><span class="p">);</span>
	<span class="n">xfs_dir2_leafn_check</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">lbp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a leaf entry to a leaf block in a node-form directory.</span>
<span class="cm"> * The other work necessary is done from the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_dir2_leafn_add</span><span class="p">(</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>		<span class="cm">/* leaf buffer */</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">,</span>		<span class="cm">/* operation arguments */</span>
	<span class="kt">int</span>			<span class="n">index</span><span class="p">)</span>		<span class="cm">/* insertion pt for new entry */</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">compact</span><span class="p">;</span>	<span class="cm">/* compacting stale leaves */</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">;</span>		<span class="cm">/* incore directory inode */</span>
	<span class="kt">int</span>			<span class="n">highstale</span><span class="p">;</span>	<span class="cm">/* next stale entry */</span>
	<span class="n">xfs_dir2_leaf_t</span>		<span class="o">*</span><span class="n">leaf</span><span class="p">;</span>		<span class="cm">/* leaf structure */</span>
	<span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">lep</span><span class="p">;</span>		<span class="cm">/* leaf entry */</span>
	<span class="kt">int</span>			<span class="n">lfloghigh</span><span class="p">;</span>	<span class="cm">/* high leaf entry logging */</span>
	<span class="kt">int</span>			<span class="n">lfloglow</span><span class="p">;</span>	<span class="cm">/* low leaf entry logging */</span>
	<span class="kt">int</span>			<span class="n">lowstale</span><span class="p">;</span>	<span class="cm">/* previous stale entry */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>		<span class="cm">/* transaction pointer */</span>

	<span class="n">trace_xfs_dir2_leafn_add</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Quick check just to make sure we are not going to index</span>
<span class="cm">	 * into other peoples memory</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are already the maximum number of leaf entries in</span>
<span class="cm">	 * the block, if there are no stale entries it won&#39;t fit.</span>
<span class="cm">	 * Caller will do a split.  If there are stale entries we&#39;ll do</span>
<span class="cm">	 * a compact.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">==</span> <span class="n">xfs_dir2_max_leaf_ents</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSPC</span><span class="p">);</span>
		<span class="n">compact</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">compact</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">||</span>
	       <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_JUSTCHECK</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compact out all but one stale leaf entry.  Leaves behind</span>
<span class="cm">	 * the entry closest to index.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">compact</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_dir2_leaf_compact_x1</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lowstale</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">highstale</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">lfloglow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lfloghigh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set impossible logging indices for this case.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lfloglow</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
		<span class="n">lfloghigh</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Insert the new entry, log everything.</span>
<span class="cm">	 */</span>
	<span class="n">lep</span> <span class="o">=</span> <span class="n">xfs_dir2_leaf_find_entry</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">compact</span><span class="p">,</span> <span class="n">lowstale</span><span class="p">,</span>
				       <span class="n">highstale</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lfloglow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lfloghigh</span><span class="p">);</span>

	<span class="n">lep</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>
	<span class="n">lep</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">xfs_dir2_db_off_to_dataptr</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
				<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">));</span>
	<span class="n">xfs_dir2_leaf_log_header</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_dir2_leaf_log_ents</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">lfloglow</span><span class="p">,</span> <span class="n">lfloghigh</span><span class="p">);</span>
	<span class="n">xfs_dir2_leafn_check</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cm">/*</span>
<span class="cm"> * Check internal consistency of a leafn block.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="n">xfs_dir2_leafn_check</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">dp</span><span class="p">,</span>			<span class="cm">/* incore directory inode */</span>
	<span class="n">xfs_dabuf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>			<span class="cm">/* leaf buffer */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>			<span class="cm">/* leaf index */</span>
	<span class="n">xfs_dir2_leaf_t</span>	<span class="o">*</span><span class="n">leaf</span><span class="p">;</span>			<span class="cm">/* leaf structure */</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>			<span class="cm">/* filesystem mount point */</span>
	<span class="kt">int</span>		<span class="n">stale</span><span class="p">;</span>			<span class="cm">/* count of stale leaves */</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">xfs_dir2_max_leaf_ents</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">stale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;=</span>
			       <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">address</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_NULL_DATAPTR</span><span class="p">))</span>
			<span class="n">stale</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">)</span> <span class="o">==</span> <span class="n">stale</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* DEBUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Return the last hash value in the leaf.</span>
<span class="cm"> * Stale entries are ok.</span>
<span class="cm"> */</span>
<span class="n">xfs_dahash_t</span>					<span class="cm">/* hash value */</span>
<span class="n">xfs_dir2_leafn_lasthash</span><span class="p">(</span>
	<span class="n">xfs_dabuf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">,</span>			<span class="cm">/* leaf buffer */</span>
	<span class="kt">int</span>		<span class="o">*</span><span class="n">count</span><span class="p">)</span>			<span class="cm">/* count of entries in leaf */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_leaf_t</span>	<span class="o">*</span><span class="n">leaf</span><span class="p">;</span>			<span class="cm">/* leaf structure */</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up a leaf entry for space to add a name in a node-format leaf block.</span>
<span class="cm"> * The extrablk in state is a freespace block.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_dir2_leafn_lookup_for_addname</span><span class="p">(</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>		<span class="cm">/* leaf buffer */</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">,</span>		<span class="cm">/* operation arguments */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">indexp</span><span class="p">,</span>	<span class="cm">/* out: leaf entry index */</span>
	<span class="n">xfs_da_state_t</span>		<span class="o">*</span><span class="n">state</span><span class="p">)</span>		<span class="cm">/* state to fill in */</span>
<span class="p">{</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">curbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* current data/free buffer */</span>
	<span class="n">xfs_dir2_db_t</span>		<span class="n">curdb</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* current data block number */</span>
	<span class="n">xfs_dir2_db_t</span>		<span class="n">curfdb</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* current free block number */</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">;</span>		<span class="cm">/* incore directory inode */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="kt">int</span>			<span class="n">fi</span><span class="p">;</span>		<span class="cm">/* free entry index */</span>
	<span class="n">xfs_dir2_free_t</span>		<span class="o">*</span><span class="n">free</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* free block structure */</span>
	<span class="kt">int</span>			<span class="n">index</span><span class="p">;</span>		<span class="cm">/* leaf entry index */</span>
	<span class="n">xfs_dir2_leaf_t</span>		<span class="o">*</span><span class="n">leaf</span><span class="p">;</span>		<span class="cm">/* leaf structure */</span>
	<span class="kt">int</span>			<span class="n">length</span><span class="p">;</span>		<span class="cm">/* length of new data entry */</span>
	<span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">lep</span><span class="p">;</span>		<span class="cm">/* leaf entry */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>
	<span class="n">xfs_dir2_db_t</span>		<span class="n">newdb</span><span class="p">;</span>		<span class="cm">/* new data block number */</span>
	<span class="n">xfs_dir2_db_t</span>		<span class="n">newfdb</span><span class="p">;</span>		<span class="cm">/* new free block number */</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>		<span class="cm">/* transaction pointer */</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">));</span>
<span class="cp">#ifdef __KERNEL__</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">xfs_dir2_leafn_check</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Look up the hash value in the leaf entries.</span>
<span class="cm">	 */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">xfs_dir2_leaf_search_hash</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do we have a buffer coming in?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If so, it&#39;s a free block buffer, get the block number. */</span>
		<span class="n">curbp</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span><span class="p">;</span>
		<span class="n">curfdb</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">blkno</span><span class="p">;</span>
		<span class="n">free</span> <span class="o">=</span> <span class="n">curbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_FREE_MAGIC</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">xfs_dir2_data_entsize</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Loop over leaf entries with the right hash value.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">index</span><span class="p">];</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">lep</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">;</span>
				<span class="n">lep</span><span class="o">++</span><span class="p">,</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Skip stale leaf entries.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">lep</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">)</span> <span class="o">==</span> <span class="n">XFS_DIR2_NULL_DATAPTR</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Pull the data block number from the entry.</span>
<span class="cm">		 */</span>
		<span class="n">newdb</span> <span class="o">=</span> <span class="n">xfs_dir2_dataptr_to_db</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">lep</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * For addname, we&#39;re looking for a place to put the new entry.</span>
<span class="cm">		 * We want to use a data block with an entry of equal</span>
<span class="cm">		 * hash value to ours if there is one with room.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If this block isn&#39;t the data block we already have</span>
<span class="cm">		 * in hand, take a look at it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newdb</span> <span class="o">!=</span> <span class="n">curdb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curdb</span> <span class="o">=</span> <span class="n">newdb</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Convert the data block to the free block</span>
<span class="cm">			 * holding its freespace information.</span>
<span class="cm">			 */</span>
			<span class="n">newfdb</span> <span class="o">=</span> <span class="n">xfs_dir2_db_to_fdb</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">newdb</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If it&#39;s not the one we have in hand, read it in.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newfdb</span> <span class="o">!=</span> <span class="n">curfdb</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * If we had one before, drop it.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">curbp</span><span class="p">)</span>
					<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">curbp</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * Read the free block.</span>
<span class="cm">				 */</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span>
						<span class="n">xfs_dir2_db_to_da</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">newfdb</span><span class="p">),</span>
						<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curbp</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
				<span class="n">free</span> <span class="o">=</span> <span class="n">curbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">magic</span><span class="p">)</span> <span class="o">==</span>
					<span class="n">XFS_DIR2_FREE_MAGIC</span><span class="p">);</span>
				<span class="n">ASSERT</span><span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstdb</span><span class="p">)</span> <span class="o">%</span>
					<span class="n">xfs_dir2_free_max_bests</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstdb</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">curdb</span><span class="p">);</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">curdb</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstdb</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nvalid</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Get the index for our entry.</span>
<span class="cm">			 */</span>
			<span class="n">fi</span> <span class="o">=</span> <span class="n">xfs_dir2_db_to_fdindex</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">curdb</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If it has room, return it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">==</span>
			    <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">NULLDATAOFF</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_dir2_leafn_lookup_int&quot;</span><span class="p">,</span>
							<span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">curfdb</span> <span class="o">!=</span> <span class="n">newfdb</span><span class="p">)</span>
					<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">curbp</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">curfdb</span> <span class="o">=</span> <span class="n">newfdb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">fi</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Didn&#39;t find any space */</span>
	<span class="n">fi</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_OKNOENT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curbp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Giving back a free block. */</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span> <span class="o">=</span> <span class="n">curbp</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">fi</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">curfdb</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="n">XFS_DIR2_FREE_MAGIC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Return the index, that will be the insertion point.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">indexp</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOENT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up a leaf entry in a node-format leaf block.</span>
<span class="cm"> * The extrablk in state a data block.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_dir2_leafn_lookup_for_entry</span><span class="p">(</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>		<span class="cm">/* leaf buffer */</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">,</span>		<span class="cm">/* operation arguments */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">indexp</span><span class="p">,</span>	<span class="cm">/* out: leaf entry index */</span>
	<span class="n">xfs_da_state_t</span>		<span class="o">*</span><span class="n">state</span><span class="p">)</span>		<span class="cm">/* state to fill in */</span>
<span class="p">{</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">curbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* current data/free buffer */</span>
	<span class="n">xfs_dir2_db_t</span>		<span class="n">curdb</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* current data block number */</span>
	<span class="n">xfs_dir2_data_entry_t</span>	<span class="o">*</span><span class="n">dep</span><span class="p">;</span>		<span class="cm">/* data block entry */</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">;</span>		<span class="cm">/* incore directory inode */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="kt">int</span>			<span class="n">index</span><span class="p">;</span>		<span class="cm">/* leaf entry index */</span>
	<span class="n">xfs_dir2_leaf_t</span>		<span class="o">*</span><span class="n">leaf</span><span class="p">;</span>		<span class="cm">/* leaf structure */</span>
	<span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">lep</span><span class="p">;</span>		<span class="cm">/* leaf entry */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>
	<span class="n">xfs_dir2_db_t</span>		<span class="n">newdb</span><span class="p">;</span>		<span class="cm">/* new data block number */</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>		<span class="cm">/* transaction pointer */</span>
	<span class="k">enum</span> <span class="n">xfs_dacmp</span>		<span class="n">cmp</span><span class="p">;</span>		<span class="cm">/* comparison result */</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">));</span>
<span class="cp">#ifdef __KERNEL__</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">xfs_dir2_leafn_check</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Look up the hash value in the leaf entries.</span>
<span class="cm">	 */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">xfs_dir2_leaf_search_hash</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do we have a buffer coming in?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curbp</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span><span class="p">;</span>
		<span class="n">curdb</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">blkno</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Loop over leaf entries with the right hash value.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">index</span><span class="p">];</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">lep</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">;</span>
				<span class="n">lep</span><span class="o">++</span><span class="p">,</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Skip stale leaf entries.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">lep</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">)</span> <span class="o">==</span> <span class="n">XFS_DIR2_NULL_DATAPTR</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Pull the data block number from the entry.</span>
<span class="cm">		 */</span>
		<span class="n">newdb</span> <span class="o">=</span> <span class="n">xfs_dir2_dataptr_to_db</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">lep</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * Not adding a new entry, so we really want to find</span>
<span class="cm">		 * the name given to us.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If it&#39;s a different data block, go get it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newdb</span> <span class="o">!=</span> <span class="n">curdb</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we had a block before that we aren&#39;t saving</span>
<span class="cm">			 * for a CI name, drop it</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curbp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">cmpresult</span> <span class="o">==</span> <span class="n">XFS_CMP_DIFFERENT</span> <span class="o">||</span>
						<span class="n">curdb</span> <span class="o">!=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">blkno</span><span class="p">))</span>
				<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">curbp</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If needing the block that is saved with a CI match,</span>
<span class="cm">			 * use it otherwise read in the new data block.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">cmpresult</span> <span class="o">!=</span> <span class="n">XFS_CMP_DIFFERENT</span> <span class="o">&amp;&amp;</span>
					<span class="n">newdb</span> <span class="o">==</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">blkno</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span><span class="p">);</span>
				<span class="n">curbp</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span>
						<span class="n">xfs_dir2_db_to_da</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">newdb</span><span class="p">),</span>
						<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curbp</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">xfs_dir2_data_check</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">curbp</span><span class="p">);</span>
			<span class="n">curdb</span> <span class="o">=</span> <span class="n">newdb</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Point to the data entry.</span>
<span class="cm">		 */</span>
		<span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_entry_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">curbp</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span>
			<span class="n">xfs_dir2_dataptr_to_off</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">lep</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">)));</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compare the entry and if it&#39;s an exact match, return</span>
<span class="cm">		 * EEXIST immediately. If it&#39;s the first case-insensitive</span>
<span class="cm">		 * match, store the block &amp; inode number and continue looking.</span>
<span class="cm">		 */</span>
		<span class="n">cmp</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirnameops</span><span class="o">-&gt;</span><span class="n">compname</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">dep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">!=</span> <span class="n">XFS_CMP_DIFFERENT</span> <span class="o">&amp;&amp;</span> <span class="n">cmp</span> <span class="o">!=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">cmpresult</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If there is a CI match block, drop it */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">cmpresult</span> <span class="o">!=</span> <span class="n">XFS_CMP_DIFFERENT</span> <span class="o">&amp;&amp;</span>
						<span class="n">curdb</span> <span class="o">!=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">blkno</span><span class="p">)</span>
				<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">cmpresult</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">;</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">inumber</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">dep</span><span class="o">-&gt;</span><span class="n">inumber</span><span class="p">);</span>
			<span class="o">*</span><span class="n">indexp</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span> <span class="o">=</span> <span class="n">curbp</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">curdb</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dep</span> <span class="o">-</span>
							<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">curbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="n">XFS_DIR2_DATA_MAGIC</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="n">XFS_CMP_EXACT</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EEXIST</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">||</span>
					<span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_OKNOENT</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curbp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">cmpresult</span> <span class="o">==</span> <span class="n">XFS_CMP_DIFFERENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Giving back last used data block. */</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span> <span class="o">=</span> <span class="n">curbp</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">curdb</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="n">XFS_DIR2_DATA_MAGIC</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* If the curbp is not the CI match block, drop it */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span> <span class="o">!=</span> <span class="n">curbp</span><span class="p">)</span>
				<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">curbp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">indexp</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOENT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up a leaf entry in a node-format leaf block.</span>
<span class="cm"> * If this is an addname then the extrablk in state is a freespace block,</span>
<span class="cm"> * otherwise it&#39;s a data block.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xfs_dir2_leafn_lookup_int</span><span class="p">(</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>		<span class="cm">/* leaf buffer */</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">,</span>		<span class="cm">/* operation arguments */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">indexp</span><span class="p">,</span>	<span class="cm">/* out: leaf entry index */</span>
	<span class="n">xfs_da_state_t</span>		<span class="o">*</span><span class="n">state</span><span class="p">)</span>		<span class="cm">/* state to fill in */</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_ADDNAME</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">xfs_dir2_leafn_lookup_for_addname</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">indexp</span><span class="p">,</span>
							<span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">xfs_dir2_leafn_lookup_for_entry</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">indexp</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move count leaf entries from source to destination leaf.</span>
<span class="cm"> * Log entries and headers.  Stale entries are preserved.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="n">xfs_dir2_leafn_moveents</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>	<span class="o">*</span><span class="n">args</span><span class="p">,</span>			<span class="cm">/* operation arguments */</span>
	<span class="n">xfs_dabuf_t</span>	<span class="o">*</span><span class="n">bp_s</span><span class="p">,</span>			<span class="cm">/* source leaf buffer */</span>
	<span class="kt">int</span>		<span class="n">start_s</span><span class="p">,</span>		<span class="cm">/* source leaf index */</span>
	<span class="n">xfs_dabuf_t</span>	<span class="o">*</span><span class="n">bp_d</span><span class="p">,</span>			<span class="cm">/* destination leaf buffer */</span>
	<span class="kt">int</span>		<span class="n">start_d</span><span class="p">,</span>		<span class="cm">/* destination leaf index */</span>
	<span class="kt">int</span>		<span class="n">count</span><span class="p">)</span>			<span class="cm">/* count of leaves to copy */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_leaf_t</span>	<span class="o">*</span><span class="n">leaf_d</span><span class="p">;</span>		<span class="cm">/* destination leaf structure */</span>
	<span class="n">xfs_dir2_leaf_t</span>	<span class="o">*</span><span class="n">leaf_s</span><span class="p">;</span>		<span class="cm">/* source leaf structure */</span>
	<span class="kt">int</span>		<span class="n">stale</span><span class="p">;</span>			<span class="cm">/* count stale leaves copied */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>			<span class="cm">/* transaction pointer */</span>

	<span class="n">trace_xfs_dir2_leafn_moveents</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">start_s</span><span class="p">,</span> <span class="n">start_d</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Silently return if nothing to do.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">leaf_s</span> <span class="o">=</span> <span class="n">bp_s</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">leaf_d</span> <span class="o">=</span> <span class="n">bp_d</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the destination index is not the end of the current</span>
<span class="cm">	 * destination leaf entries, open up a hole in the destination</span>
<span class="cm">	 * to hold the new entries.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_d</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf_d</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf_d</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">start_d</span> <span class="o">+</span> <span class="n">count</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">leaf_d</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">start_d</span><span class="p">],</span>
			<span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf_d</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">start_d</span><span class="p">)</span> <span class="o">*</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_dir2_leaf_entry_t</span><span class="p">));</span>
		<span class="n">xfs_dir2_leaf_log_ents</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp_d</span><span class="p">,</span> <span class="n">start_d</span> <span class="o">+</span> <span class="n">count</span><span class="p">,</span>
			<span class="n">count</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf_d</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the source has stale leaves, count the ones in the copy range</span>
<span class="cm">	 * so we can update the header correctly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>			<span class="cm">/* temp leaf index */</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start_s</span><span class="p">,</span> <span class="n">stale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">start_s</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">address</span> <span class="o">==</span>
			    <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_NULL_DATAPTR</span><span class="p">))</span>
				<span class="n">stale</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">stale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy the leaf entries from source to destination.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf_d</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">start_d</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">start_s</span><span class="p">],</span>
		<span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_dir2_leaf_entry_t</span><span class="p">));</span>
	<span class="n">xfs_dir2_leaf_log_ents</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp_d</span><span class="p">,</span> <span class="n">start_d</span><span class="p">,</span> <span class="n">start_d</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there are source entries after the ones we copied,</span>
<span class="cm">	 * delete the ones we copied by sliding the next ones down.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_s</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">start_s</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">start_s</span> <span class="o">+</span> <span class="n">count</span><span class="p">],</span>
			<span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_dir2_leaf_entry_t</span><span class="p">));</span>
		<span class="n">xfs_dir2_leaf_log_ents</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp_s</span><span class="p">,</span> <span class="n">start_s</span><span class="p">,</span> <span class="n">start_s</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Update the headers and log them.</span>
<span class="cm">	 */</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">count</span><span class="p">));</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">stale</span><span class="p">));</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf_d</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf_d</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">,</span> <span class="n">stale</span><span class="p">);</span>
	<span class="n">xfs_dir2_leaf_log_header</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp_s</span><span class="p">);</span>
	<span class="n">xfs_dir2_leaf_log_header</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp_d</span><span class="p">);</span>
	<span class="n">xfs_dir2_leafn_check</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">bp_s</span><span class="p">);</span>
	<span class="n">xfs_dir2_leafn_check</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">bp_d</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine the sort order of two leaf blocks.</span>
<span class="cm"> * Returns 1 if both are valid and leaf2 should be before leaf1, else 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* sort order */</span>
<span class="n">xfs_dir2_leafn_order</span><span class="p">(</span>
	<span class="n">xfs_dabuf_t</span>	<span class="o">*</span><span class="n">leaf1_bp</span><span class="p">,</span>		<span class="cm">/* leaf1 buffer */</span>
	<span class="n">xfs_dabuf_t</span>	<span class="o">*</span><span class="n">leaf2_bp</span><span class="p">)</span>		<span class="cm">/* leaf2 buffer */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_leaf_t</span>	<span class="o">*</span><span class="n">leaf1</span><span class="p">;</span>			<span class="cm">/* leaf1 structure */</span>
	<span class="n">xfs_dir2_leaf_t</span>	<span class="o">*</span><span class="n">leaf2</span><span class="p">;</span>			<span class="cm">/* leaf2 structure */</span>

	<span class="n">leaf1</span> <span class="o">=</span> <span class="n">leaf1_bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">leaf2</span> <span class="o">=</span> <span class="n">leaf2_bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span>
	     <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Rebalance leaf entries between two leaf blocks.</span>
<span class="cm"> * This is actually only called when the second block is new,</span>
<span class="cm"> * though the code deals with the general case.</span>
<span class="cm"> * A new entry will be inserted in one of the blocks, and that</span>
<span class="cm"> * entry is taken into account when balancing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="n">xfs_dir2_leafn_rebalance</span><span class="p">(</span>
	<span class="n">xfs_da_state_t</span>		<span class="o">*</span><span class="n">state</span><span class="p">,</span>		<span class="cm">/* btree cursor */</span>
	<span class="n">xfs_da_state_blk_t</span>	<span class="o">*</span><span class="n">blk1</span><span class="p">,</span>		<span class="cm">/* first btree block */</span>
	<span class="n">xfs_da_state_blk_t</span>	<span class="o">*</span><span class="n">blk2</span><span class="p">)</span>		<span class="cm">/* second btree block */</span>
<span class="p">{</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">;</span>		<span class="cm">/* operation arguments */</span>
	<span class="kt">int</span>			<span class="n">count</span><span class="p">;</span>		<span class="cm">/* count (&amp; direction) leaves */</span>
	<span class="kt">int</span>			<span class="n">isleft</span><span class="p">;</span>		<span class="cm">/* new goes in left leaf */</span>
	<span class="n">xfs_dir2_leaf_t</span>		<span class="o">*</span><span class="n">leaf1</span><span class="p">;</span>		<span class="cm">/* first leaf structure */</span>
	<span class="n">xfs_dir2_leaf_t</span>		<span class="o">*</span><span class="n">leaf2</span><span class="p">;</span>		<span class="cm">/* second leaf structure */</span>
	<span class="kt">int</span>			<span class="n">mid</span><span class="p">;</span>		<span class="cm">/* midpoint leaf index */</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="kt">int</span>			<span class="n">oldstale</span><span class="p">;</span>	<span class="cm">/* old count of stale leaves */</span>
<span class="cp">#endif</span>
	<span class="kt">int</span>			<span class="n">oldsum</span><span class="p">;</span>		<span class="cm">/* old total leaf count */</span>
	<span class="kt">int</span>			<span class="n">swap</span><span class="p">;</span>		<span class="cm">/* swapped leaf blocks */</span>

	<span class="n">args</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the block order is wrong, swap the arguments.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">swap</span> <span class="o">=</span> <span class="n">xfs_dir2_leafn_order</span><span class="p">(</span><span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_da_state_blk_t</span>	<span class="o">*</span><span class="n">tmp</span><span class="p">;</span>	<span class="cm">/* temp for block swap */</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">blk1</span><span class="p">;</span>
		<span class="n">blk1</span> <span class="o">=</span> <span class="n">blk2</span><span class="p">;</span>
		<span class="n">blk2</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">leaf1</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">leaf2</span> <span class="o">=</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">oldsum</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">oldstale</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">)</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">mid</span> <span class="o">=</span> <span class="n">oldsum</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the old leaf count was odd then the new one will be even,</span>
<span class="cm">	 * so we need to divide the new count evenly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldsum</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_dahash_t</span>	<span class="n">midhash</span><span class="p">;</span>	<span class="cm">/* middle entry hash value */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&gt;=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span>
			<span class="n">midhash</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">mid</span> <span class="o">-</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)].</span><span class="n">hashval</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">midhash</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
		<span class="n">isleft</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">&lt;=</span> <span class="n">midhash</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the old count is even then the new count is odd, so there&#39;s</span>
<span class="cm">	 * no preferred side for the new entry.</span>
<span class="cm">	 * Pick the left one.</span>
<span class="cm">	 */</span>
	<span class="k">else</span>
		<span class="n">isleft</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Calculate moved entry count.  Positive means left-to-right,</span>
<span class="cm">	 * negative means right-to-left.  Then move the entries.</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">mid</span> <span class="o">+</span> <span class="p">(</span><span class="n">isleft</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">xfs_dir2_leafn_moveents</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
			<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">count</span><span class="p">,</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">xfs_dir2_leafn_moveents</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
			<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">),</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">==</span> <span class="n">oldsum</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">)</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">)</span> <span class="o">==</span> <span class="n">oldstale</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Mark whether we&#39;re inserting into the old or new leaf.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span> <span class="o">=</span> <span class="n">swap</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span> <span class="o">=</span> <span class="o">!</span><span class="n">swap</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span> <span class="o">=</span>
			<span class="n">swap</span> <span class="o">^</span> <span class="p">(</span><span class="n">blk1</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Adjust the expected index for insertion.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span><span class="p">)</span>
		<span class="n">blk2</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">-</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finally sanity check just to make sure we are not returning a</span>
<span class="cm">	 * negative index</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">blk2</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">blk2</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xfs_alert</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
	<span class="s">&quot;%s: picked the wrong leaf? reverting original leaf: blk1-&gt;index %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove an entry from a node directory.</span>
<span class="cm"> * This removes the leaf entry and the data entry,</span>
<span class="cm"> * and updates the free block if necessary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_dir2_leafn_remove</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">,</span>		<span class="cm">/* operation arguments */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>		<span class="cm">/* leaf buffer */</span>
	<span class="kt">int</span>			<span class="n">index</span><span class="p">,</span>		<span class="cm">/* leaf entry index */</span>
	<span class="n">xfs_da_state_blk_t</span>	<span class="o">*</span><span class="n">dblk</span><span class="p">,</span>		<span class="cm">/* data block */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">rval</span><span class="p">)</span>		<span class="cm">/* resulting block needs join */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_data_hdr_t</span>	<span class="o">*</span><span class="n">hdr</span><span class="p">;</span>		<span class="cm">/* data block header */</span>
	<span class="n">xfs_dir2_db_t</span>		<span class="n">db</span><span class="p">;</span>		<span class="cm">/* data block number */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">dbp</span><span class="p">;</span>		<span class="cm">/* data block buffer */</span>
	<span class="n">xfs_dir2_data_entry_t</span>	<span class="o">*</span><span class="n">dep</span><span class="p">;</span>		<span class="cm">/* data block entry */</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">;</span>		<span class="cm">/* incore directory inode */</span>
	<span class="n">xfs_dir2_leaf_t</span>		<span class="o">*</span><span class="n">leaf</span><span class="p">;</span>		<span class="cm">/* leaf structure */</span>
	<span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">lep</span><span class="p">;</span>		<span class="cm">/* leaf entry */</span>
	<span class="kt">int</span>			<span class="n">longest</span><span class="p">;</span>	<span class="cm">/* longest data free entry */</span>
	<span class="kt">int</span>			<span class="n">off</span><span class="p">;</span>		<span class="cm">/* data block entry offset */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>
	<span class="kt">int</span>			<span class="n">needlog</span><span class="p">;</span>	<span class="cm">/* need to log data header */</span>
	<span class="kt">int</span>			<span class="n">needscan</span><span class="p">;</span>	<span class="cm">/* need to rescan data frees */</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>		<span class="cm">/* transaction pointer */</span>

	<span class="n">trace_xfs_dir2_leafn_remove</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Point to the entry we&#39;re removing.</span>
<span class="cm">	 */</span>
	<span class="n">lep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * Extract the data block and offset from the entry.</span>
<span class="cm">	 */</span>
	<span class="n">db</span> <span class="o">=</span> <span class="n">xfs_dir2_dataptr_to_db</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">lep</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dblk</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">==</span> <span class="n">db</span><span class="p">);</span>
	<span class="n">off</span> <span class="o">=</span> <span class="n">xfs_dir2_dataptr_to_off</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">lep</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dblk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">off</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Kill the leaf entry by marking it stale.</span>
<span class="cm">	 * Log the leaf block changes.</span>
<span class="cm">	 */</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_dir2_leaf_log_header</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">lep</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_NULL_DATAPTR</span><span class="p">);</span>
	<span class="n">xfs_dir2_leaf_log_ents</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make the data entry free.  Keep track of the longest freespace</span>
<span class="cm">	 * in the data block in case it changes.</span>
<span class="cm">	 */</span>
	<span class="n">dbp</span> <span class="o">=</span> <span class="n">dblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="n">dbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_entry_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">off</span><span class="p">);</span>
	<span class="n">longest</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bestfree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">);</span>
	<span class="n">needlog</span> <span class="o">=</span> <span class="n">needscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_dir2_data_make_free</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dbp</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span>
		<span class="n">xfs_dir2_data_entsize</span><span class="p">(</span><span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">needlog</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needscan</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Rescan the data block freespaces for bestfree.</span>
<span class="cm">	 * Log the data block header if needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needscan</span><span class="p">)</span>
		<span class="n">xfs_dir2_data_freescan</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needlog</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needlog</span><span class="p">)</span>
		<span class="n">xfs_dir2_data_log_header</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dbp</span><span class="p">);</span>
	<span class="n">xfs_dir2_data_check</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">dbp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the longest data block freespace changes, need to update</span>
<span class="cm">	 * the corresponding freeblock entry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">longest</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bestfree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
		<span class="n">xfs_dabuf_t</span>	<span class="o">*</span><span class="n">fbp</span><span class="p">;</span>		<span class="cm">/* freeblock buffer */</span>
		<span class="n">xfs_dir2_db_t</span>	<span class="n">fdb</span><span class="p">;</span>		<span class="cm">/* freeblock block number */</span>
		<span class="kt">int</span>		<span class="n">findex</span><span class="p">;</span>		<span class="cm">/* index in freeblock entries */</span>
		<span class="n">xfs_dir2_free_t</span>	<span class="o">*</span><span class="n">free</span><span class="p">;</span>		<span class="cm">/* freeblock structure */</span>
		<span class="kt">int</span>		<span class="n">logfree</span><span class="p">;</span>	<span class="cm">/* need to log free entry */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Convert the data block number to a free block,</span>
<span class="cm">		 * read in the free block.</span>
<span class="cm">		 */</span>
		<span class="n">fdb</span> <span class="o">=</span> <span class="n">xfs_dir2_db_to_fdb</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">db</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">xfs_dir2_db_to_da</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">fdb</span><span class="p">),</span>
				<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbp</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">free</span> <span class="o">=</span> <span class="n">fbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_FREE_MAGIC</span><span class="p">));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstdb</span><span class="p">)</span> <span class="o">==</span>
		       <span class="n">xfs_dir2_free_max_bests</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">*</span>
		       <span class="p">(</span><span class="n">fdb</span> <span class="o">-</span> <span class="n">XFS_DIR2_FREE_FIRSTDB</span><span class="p">(</span><span class="n">mp</span><span class="p">)));</span>
		<span class="cm">/*</span>
<span class="cm">		 * Calculate which entry we need to fix.</span>
<span class="cm">		 */</span>
		<span class="n">findex</span> <span class="o">=</span> <span class="n">xfs_dir2_db_to_fdindex</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">db</span><span class="p">);</span>
		<span class="n">longest</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bestfree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the data block is now empty we can get rid of it</span>
<span class="cm">		 * (usually).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">longest</span> <span class="o">==</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblksize</span> <span class="o">-</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Try to punch out the data block.</span>
<span class="cm">			 */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_shrink_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">dbp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dblk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">hdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * We can get ENOSPC if there&#39;s no space reservation.</span>
<span class="cm">			 * In this case just drop the buffer and some one else</span>
<span class="cm">			 * will eventually get rid of the empty block.</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">dbp</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we got rid of the data block, we can eliminate that entry</span>
<span class="cm">		 * in the free block.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * One less used entry in the free table.</span>
<span class="cm">			 */</span>
			<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nused</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">xfs_dir2_free_log_header</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">fbp</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If this was the last entry in the table, we can</span>
<span class="cm">			 * trim the table size back.  There might be other</span>
<span class="cm">			 * entries at the end referring to non-existent</span>
<span class="cm">			 * data blocks, get those too.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">findex</span> <span class="o">==</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nvalid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>		<span class="cm">/* free entry index */</span>

				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">findex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				     <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				     <span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">NULLDATAOFF</span><span class="p">);</span>
				     <span class="n">i</span><span class="o">--</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nvalid</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">logfree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Not the last entry, just punch it out.</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">findex</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">NULLDATAOFF</span><span class="p">);</span>
				<span class="n">logfree</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * If there are no useful entries left in the block,</span>
<span class="cm">			 * get rid of the block if we can.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nused</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_shrink_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fdb</span><span class="p">,</span> <span class="n">fbp</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">fbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="n">logfree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">ENOSPC</span> <span class="o">||</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">total</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * It&#39;s possible to get ENOSPC if there is no</span>
<span class="cm">				 * space reservation.  In this case some one</span>
<span class="cm">				 * else will eventually get rid of this block.</span>
<span class="cm">				 */</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Data block is not empty, just set the free entry to</span>
<span class="cm">		 * the new value.</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">findex</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">longest</span><span class="p">);</span>
			<span class="n">logfree</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Log the free entry that changed, unless we got rid of it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">logfree</span><span class="p">)</span>
			<span class="n">xfs_dir2_free_log_bests</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">fbp</span><span class="p">,</span> <span class="n">findex</span><span class="p">,</span> <span class="n">findex</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Drop the buffer if we still have it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fbp</span><span class="p">)</span>
			<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">fbp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xfs_dir2_leafn_check</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Return indication of whether this leaf block is empty enough</span>
<span class="cm">	 * to justify trying to join it with a neighbor.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">rval</span> <span class="o">=</span>
		<span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">)</span> <span class="o">+</span>
		 <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
		 <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">)))</span> <span class="o">&lt;</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dir_magicpct</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Split the leaf entries in the old block into old and new blocks.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_leafn_split</span><span class="p">(</span>
	<span class="n">xfs_da_state_t</span>		<span class="o">*</span><span class="n">state</span><span class="p">,</span>		<span class="cm">/* btree cursor */</span>
	<span class="n">xfs_da_state_blk_t</span>	<span class="o">*</span><span class="n">oldblk</span><span class="p">,</span>	<span class="cm">/* original block */</span>
	<span class="n">xfs_da_state_blk_t</span>	<span class="o">*</span><span class="n">newblk</span><span class="p">)</span>	<span class="cm">/* newly created block */</span>
<span class="p">{</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">;</span>		<span class="cm">/* operation arguments */</span>
	<span class="n">xfs_dablk_t</span>		<span class="n">blkno</span><span class="p">;</span>		<span class="cm">/* new leaf block number */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate space for a new leaf node.</span>
<span class="cm">	 */</span>
	<span class="n">args</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_grow_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initialize the new leaf block.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_leaf_init</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">xfs_dir2_da_to_db</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">),</span>
		<span class="o">&amp;</span><span class="n">newblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">newblk</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="n">newblk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Rebalance the entries across the two leaves, link the new</span>
<span class="cm">	 * block into the leaves.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_dir2_leafn_rebalance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">oldblk</span><span class="p">,</span> <span class="n">newblk</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_blk_link</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">oldblk</span><span class="p">,</span> <span class="n">newblk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Insert the new entry in the correct block.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_leafn_add</span><span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_leafn_add</span><span class="p">(</span><span class="n">newblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">newblk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Update last hashval in each block since we added the name.</span>
<span class="cm">	 */</span>
	<span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">xfs_dir2_leafn_lasthash</span><span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">newblk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">xfs_dir2_leafn_lasthash</span><span class="p">(</span><span class="n">newblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">xfs_dir2_leafn_check</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_dir2_leafn_check</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">newblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check a leaf block and its neighbors to see if the block should be</span>
<span class="cm"> * collapsed into one or the other neighbor.  Always keep the block</span>
<span class="cm"> * with the smaller block number.</span>
<span class="cm"> * If the current block is over 50% full, don&#39;t try to join it, return 0.</span>
<span class="cm"> * If the block is empty, fill in the state structure and return 2.</span>
<span class="cm"> * If it can be collapsed, fill in the state structure and return 1.</span>
<span class="cm"> * If nothing can be done, return 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_leafn_toosmall</span><span class="p">(</span>
	<span class="n">xfs_da_state_t</span>		<span class="o">*</span><span class="n">state</span><span class="p">,</span>		<span class="cm">/* btree cursor */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">action</span><span class="p">)</span>	<span class="cm">/* resulting action to take */</span>
<span class="p">{</span>
	<span class="n">xfs_da_state_blk_t</span>	<span class="o">*</span><span class="n">blk</span><span class="p">;</span>		<span class="cm">/* leaf block */</span>
	<span class="n">xfs_dablk_t</span>		<span class="n">blkno</span><span class="p">;</span>		<span class="cm">/* leaf block number */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* leaf buffer */</span>
	<span class="kt">int</span>			<span class="n">bytes</span><span class="p">;</span>		<span class="cm">/* bytes in use */</span>
	<span class="kt">int</span>			<span class="n">count</span><span class="p">;</span>		<span class="cm">/* leaf live entry count */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="kt">int</span>			<span class="n">forward</span><span class="p">;</span>	<span class="cm">/* sibling block direction */</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>		<span class="cm">/* sibling counter */</span>
	<span class="n">xfs_da_blkinfo_t</span>	<span class="o">*</span><span class="n">info</span><span class="p">;</span>		<span class="cm">/* leaf block header */</span>
	<span class="n">xfs_dir2_leaf_t</span>		<span class="o">*</span><span class="n">leaf</span><span class="p">;</span>		<span class="cm">/* leaf structure */</span>
	<span class="kt">int</span>			<span class="n">rval</span><span class="p">;</span>		<span class="cm">/* result from path_shift */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for the degenerate case of the block being over 50% full.</span>
<span class="cm">	 * If so, it&#39;s not worth even looking to see if we might be able</span>
<span class="cm">	 * to coalesce with a sibling.</span>
<span class="cm">	 */</span>
	<span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">));</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_leaf_t</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">);</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Blk over 50%, don&#39;t try to join.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check for the degenerate case of the block being empty.</span>
<span class="cm">	 * If the block is empty, we&#39;ll simply delete it, no need to</span>
<span class="cm">	 * coalesce it with a sibling block.  We choose (arbitrarily)</span>
<span class="cm">	 * to merge with the forward block unless it is NULL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make altpath point to the block we want to keep and</span>
<span class="cm">		 * path point to the block we want to drop (this one).</span>
<span class="cm">		 */</span>
		<span class="n">forward</span> <span class="o">=</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">forw</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">));</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_path_shift</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="n">rval</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Examine each sibling block to see if we can coalesce with</span>
<span class="cm">	 * at least 25% free space to spare.  We need to figure out</span>
<span class="cm">	 * whether to merge with the forward or the backward block.</span>
<span class="cm">	 * We prefer coalescing with the lower numbered sibling so as</span>
<span class="cm">	 * to shrink a directory over time.</span>
<span class="cm">	 */</span>
	<span class="n">forward</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">forward</span> <span class="o">=</span> <span class="o">!</span><span class="n">forward</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blkno</span> <span class="o">=</span> <span class="n">forward</span> <span class="o">?</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">)</span> <span class="o">:</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Read the sibling leaf block.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span>
		    <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span>
			    <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Count bytes in the two blocks combined.</span>
<span class="cm">		 */</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_leaf_t</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">);</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">-</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">));</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">);</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">count</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Fits with at least 25% to spare.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Didn&#39;t like either block, give up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Done with the sibling leaf block here, drop the dabuf</span>
<span class="cm">	 * so path_shift can get it.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make altpath point to the block we want to keep (the lower</span>
<span class="cm">	 * numbered block) and path point to the block we want to drop.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">&lt;</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_path_shift</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_path_shift</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="n">rval</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move all the leaf entries from drop_blk to save_blk.</span>
<span class="cm"> * This is done as part of a join operation.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="n">xfs_dir2_leafn_unbalance</span><span class="p">(</span>
	<span class="n">xfs_da_state_t</span>		<span class="o">*</span><span class="n">state</span><span class="p">,</span>		<span class="cm">/* cursor */</span>
	<span class="n">xfs_da_state_blk_t</span>	<span class="o">*</span><span class="n">drop_blk</span><span class="p">,</span>	<span class="cm">/* dead block */</span>
	<span class="n">xfs_da_state_blk_t</span>	<span class="o">*</span><span class="n">save_blk</span><span class="p">)</span>	<span class="cm">/* surviving block */</span>
<span class="p">{</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">;</span>		<span class="cm">/* operation arguments */</span>
	<span class="n">xfs_dir2_leaf_t</span>		<span class="o">*</span><span class="n">drop_leaf</span><span class="p">;</span>	<span class="cm">/* dead leaf structure */</span>
	<span class="n">xfs_dir2_leaf_t</span>		<span class="o">*</span><span class="n">save_leaf</span><span class="p">;</span>	<span class="cm">/* surviving leaf structure */</span>

	<span class="n">args</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">);</span>
	<span class="n">drop_leaf</span> <span class="o">=</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">save_leaf</span> <span class="o">=</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">drop_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">save_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there are any stale leaf entries, take this opportunity</span>
<span class="cm">	 * to purge them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drop_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">)</span>
		<span class="n">xfs_dir2_leaf_compact</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">save_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">)</span>
		<span class="n">xfs_dir2_leaf_compact</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Move the entries from drop to the appropriate end of save.</span>
<span class="cm">	 */</span>
	<span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">drop_leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_dir2_leafn_order</span><span class="p">(</span><span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">))</span>
		<span class="n">xfs_dir2_leafn_moveents</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">xfs_dir2_leafn_moveents</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
			<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">save_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">),</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">));</span>
	<span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">save_leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">save_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
	<span class="n">xfs_dir2_leafn_check</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Top-level node form directory addname routine.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_node_addname</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">)</span>		<span class="cm">/* operation arguments */</span>
<span class="p">{</span>
	<span class="n">xfs_da_state_blk_t</span>	<span class="o">*</span><span class="n">blk</span><span class="p">;</span>		<span class="cm">/* leaf block for insert */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="kt">int</span>			<span class="n">rval</span><span class="p">;</span>		<span class="cm">/* sub-return value */</span>
	<span class="n">xfs_da_state_t</span>		<span class="o">*</span><span class="n">state</span><span class="p">;</span>		<span class="cm">/* btree cursor */</span>

	<span class="n">trace_xfs_dir2_node_addname</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate and initialize the state (btree cursor).</span>
<span class="cm">	 */</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">xfs_da_state_alloc</span><span class="p">();</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblksize</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">node_ents</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dir_node_ents</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Look up the name.  We&#39;re not supposed to find it, but</span>
<span class="cm">	 * this gives us the insertion point.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_node_lookup_int</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">!=</span> <span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Add the data entry to a data block.</span>
<span class="cm">	 * Extravalid is set to a freeblock found by lookup.</span>
<span class="cm">	 */</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">xfs_dir2_node_addname_int</span><span class="p">(</span><span class="n">args</span><span class="p">,</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Add the new leaf entry.</span>
<span class="cm">	 */</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">xfs_dir2_leafn_add</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * It worked, fix the hash values up the btree.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_JUSTCHECK</span><span class="p">))</span>
			<span class="n">xfs_da_fixhashpath</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * It didn&#39;t work, we need to split the leaf block.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">rval</span> <span class="o">==</span> <span class="n">ENOSPC</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Split the leaf block and insert the new entry.</span>
<span class="cm">		 */</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="n">xfs_da_split</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="n">xfs_da_state_free</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add the data entry for a node-format directory name addition.</span>
<span class="cm"> * The leaf entry is added in xfs_dir2_leafn_add.</span>
<span class="cm"> * We may enter with a freespace block that the lookup found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_dir2_node_addname_int</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">,</span>		<span class="cm">/* operation arguments */</span>
	<span class="n">xfs_da_state_blk_t</span>	<span class="o">*</span><span class="n">fblk</span><span class="p">)</span>		<span class="cm">/* optional freespace block */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_data_hdr_t</span>	<span class="o">*</span><span class="n">hdr</span><span class="p">;</span>		<span class="cm">/* data block header */</span>
	<span class="n">xfs_dir2_db_t</span>		<span class="n">dbno</span><span class="p">;</span>		<span class="cm">/* data block number */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">dbp</span><span class="p">;</span>		<span class="cm">/* data block buffer */</span>
	<span class="n">xfs_dir2_data_entry_t</span>	<span class="o">*</span><span class="n">dep</span><span class="p">;</span>		<span class="cm">/* data entry pointer */</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">;</span>		<span class="cm">/* incore directory inode */</span>
	<span class="n">xfs_dir2_data_unused_t</span>	<span class="o">*</span><span class="n">dup</span><span class="p">;</span>		<span class="cm">/* data unused entry pointer */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="n">xfs_dir2_db_t</span>		<span class="n">fbno</span><span class="p">;</span>		<span class="cm">/* freespace block number */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">fbp</span><span class="p">;</span>		<span class="cm">/* freespace buffer */</span>
	<span class="kt">int</span>			<span class="n">findex</span><span class="p">;</span>		<span class="cm">/* freespace entry index */</span>
	<span class="n">xfs_dir2_free_t</span>		<span class="o">*</span><span class="n">free</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* freespace block structure */</span>
	<span class="n">xfs_dir2_db_t</span>		<span class="n">ifbno</span><span class="p">;</span>		<span class="cm">/* initial freespace block no */</span>
	<span class="n">xfs_dir2_db_t</span>		<span class="n">lastfbno</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>	<span class="cm">/* highest freespace block no */</span>
	<span class="kt">int</span>			<span class="n">length</span><span class="p">;</span>		<span class="cm">/* length of the new entry */</span>
	<span class="kt">int</span>			<span class="n">logfree</span><span class="p">;</span>	<span class="cm">/* need to log free entry */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>
	<span class="kt">int</span>			<span class="n">needlog</span><span class="p">;</span>	<span class="cm">/* need to log data header */</span>
	<span class="kt">int</span>			<span class="n">needscan</span><span class="p">;</span>	<span class="cm">/* need to rescan data frees */</span>
	<span class="n">__be16</span>			<span class="o">*</span><span class="n">tagp</span><span class="p">;</span>		<span class="cm">/* data entry tag pointer */</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>		<span class="cm">/* transaction pointer */</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">xfs_dir2_data_entsize</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we came in with a freespace block that means that lookup</span>
<span class="cm">	 * found an entry with our hash value.  This is the freespace</span>
<span class="cm">	 * block for that data entry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fblk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fbp</span> <span class="o">=</span> <span class="n">fblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Remember initial freespace block number.</span>
<span class="cm">		 */</span>
		<span class="n">ifbno</span> <span class="o">=</span> <span class="n">fblk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">;</span>
		<span class="n">free</span> <span class="o">=</span> <span class="n">fbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_FREE_MAGIC</span><span class="p">));</span>
		<span class="n">findex</span> <span class="o">=</span> <span class="n">fblk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * This means the free entry showed that the data block had</span>
<span class="cm">		 * space for our entry, so we remembered it.</span>
<span class="cm">		 * Use that data block.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">findex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">findex</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nvalid</span><span class="p">));</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">findex</span><span class="p">])</span> <span class="o">!=</span> <span class="n">NULLDATAOFF</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">findex</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">);</span>
			<span class="n">dbno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstdb</span><span class="p">)</span> <span class="o">+</span> <span class="n">findex</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * The data block looked at didn&#39;t have enough room.</span>
<span class="cm">		 * We&#39;ll start at the beginning of the freespace entries.</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">dbno</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">findex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Didn&#39;t come in with a freespace block, so don&#39;t have a data block.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ifbno</span> <span class="o">=</span> <span class="n">dbno</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">fbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">findex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t have a data block yet, we&#39;re going to scan the</span>
<span class="cm">	 * freespace blocks looking for one.  Figure out what the</span>
<span class="cm">	 * highest freespace block number is.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dbno</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_fileoff_t</span>	<span class="n">fo</span><span class="p">;</span>		<span class="cm">/* freespace block number */</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_last_offset</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fo</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">lastfbno</span> <span class="o">=</span> <span class="n">xfs_dir2_da_to_db</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_dablk_t</span><span class="p">)</span><span class="n">fo</span><span class="p">);</span>
		<span class="n">fbno</span> <span class="o">=</span> <span class="n">ifbno</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * While we haven&#39;t identified a data block, search the freeblock</span>
<span class="cm">	 * data for a good data block.  If we find a null freeblock entry,</span>
<span class="cm">	 * indicating a hole in the data blocks, remember that.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dbno</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we don&#39;t have a freeblock in hand, get the next one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fbp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Happens the first time through unless lookup gave</span>
<span class="cm">			 * us a freespace block to start with.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">fbno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">fbno</span> <span class="o">=</span> <span class="n">XFS_DIR2_FREE_FIRSTDB</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If it&#39;s ifbno we already looked at it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fbno</span> <span class="o">==</span> <span class="n">ifbno</span><span class="p">)</span>
				<span class="n">fbno</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * If it&#39;s off the end we&#39;re done.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fbno</span> <span class="o">&gt;=</span> <span class="n">lastfbno</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Read the block.  There can be holes in the</span>
<span class="cm">			 * freespace blocks, so this might not succeed.</span>
<span class="cm">			 * This should be really rare, so there&#39;s no reason</span>
<span class="cm">			 * to avoid it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span>
					<span class="n">xfs_dir2_db_to_da</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">fbno</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbp</span><span class="p">,</span>
					<span class="n">XFS_DATA_FORK</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fbp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">free</span> <span class="o">=</span> <span class="n">fbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_FREE_MAGIC</span><span class="p">));</span>
			<span class="n">findex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Look at the current free entry.  Is it good enough?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">findex</span><span class="p">])</span> <span class="o">!=</span> <span class="n">NULLDATAOFF</span> <span class="o">&amp;&amp;</span>
		    <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">findex</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">)</span>
			<span class="n">dbno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstdb</span><span class="p">)</span> <span class="o">+</span> <span class="n">findex</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Are we done with the freeblock?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">findex</span> <span class="o">==</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nvalid</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Drop the block.</span>
<span class="cm">				 */</span>
				<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">fbp</span><span class="p">);</span>
				<span class="n">fbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">fblk</span> <span class="o">&amp;&amp;</span> <span class="n">fblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">)</span>
					<span class="n">fblk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t have a data block, we need to allocate one and make</span>
<span class="cm">	 * the freespace entries refer to it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dbno</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Not allowed to allocate, return failure.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_JUSTCHECK</span><span class="p">)</span> <span class="o">||</span>
							<span class="n">args</span><span class="o">-&gt;</span><span class="n">total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Drop the freespace buffer unless it came from our</span>
<span class="cm">			 * caller.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">fblk</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">fblk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fbp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">fbp</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSPC</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allocate and initialize the new data block.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_grow_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span>
							 <span class="n">XFS_DIR2_DATA_SPACE</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">dbno</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_data_init</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">dbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbp</span><span class="p">))))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Drop the freespace buffer unless it came from our</span>
<span class="cm">			 * caller.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">fblk</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">fblk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fbp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">fbp</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If (somehow) we have a freespace block, get rid of it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fbp</span><span class="p">)</span>
			<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">fbp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fblk</span> <span class="o">&amp;&amp;</span> <span class="n">fblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">)</span>
			<span class="n">fblk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get the freespace block corresponding to the data block</span>
<span class="cm">		 * that was just allocated.</span>
<span class="cm">		 */</span>
		<span class="n">fbno</span> <span class="o">=</span> <span class="n">xfs_dir2_db_to_fdb</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">dbno</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span>
				<span class="n">xfs_dir2_db_to_da</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">fbno</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbp</span><span class="p">,</span>
				<span class="n">XFS_DATA_FORK</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">dbp</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
  		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there wasn&#39;t a freespace block, the read will</span>
<span class="cm">		 * return a NULL fbp.  Allocate and initialize a new one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">fbp</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_grow_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">XFS_DIR2_FREE_SPACE</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">fbno</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">xfs_dir2_db_to_fdb</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">dbno</span><span class="p">)</span> <span class="o">!=</span> <span class="n">fbno</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
			<span class="s">&quot;%s: dir ino %llu needed freesp block %lld for</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;  data block %lld, got %lld ifbno %llu lastfbno %d&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">xfs_dir2_db_to_fdb</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">dbno</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dbno</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">fbno</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ifbno</span><span class="p">,</span> <span class="n">lastfbno</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">fblk</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
				<span class="s">&quot; fblk 0x%p blkno %llu index %d magic 0x%x&quot;</span><span class="p">,</span>
						<span class="n">fblk</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">fblk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span>
						<span class="n">fblk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
						<span class="n">fblk</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot; ... fblk is NULL&quot;</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_dir2_node_addname_int&quot;</span><span class="p">,</span>
						 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Get a buffer for the new block.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_get_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span>
						   <span class="n">xfs_dir2_db_to_da</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">fbno</span><span class="p">),</span>
						   <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbp</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">fbp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Initialize the new block to be empty, and remember</span>
<span class="cm">			 * its first slot as our empty slot.</span>
<span class="cm">			 */</span>
			<span class="n">free</span> <span class="o">=</span> <span class="n">fbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_FREE_MAGIC</span><span class="p">);</span>
			<span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstdb</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span>
				<span class="p">(</span><span class="n">fbno</span> <span class="o">-</span> <span class="n">XFS_DIR2_FREE_FIRSTDB</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="o">*</span>
				<span class="n">xfs_dir2_free_max_bests</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
			<span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nvalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nused</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">free</span> <span class="o">=</span> <span class="n">fbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_FREE_MAGIC</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set the freespace block index from the data block number.</span>
<span class="cm">		 */</span>
		<span class="n">findex</span> <span class="o">=</span> <span class="n">xfs_dir2_db_to_fdindex</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">dbno</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it&#39;s after the end of the current entries in the</span>
<span class="cm">		 * freespace block, extend that table.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">findex</span> <span class="o">&gt;=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nvalid</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">findex</span> <span class="o">&lt;</span> <span class="n">xfs_dir2_free_max_bests</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
			<span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nvalid</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">findex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Tag new entry so nused will go up.</span>
<span class="cm">			 */</span>
			<span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">findex</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">NULLDATAOFF</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this entry was for an empty data block</span>
<span class="cm">		 * (this should always be true) then update the header.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">findex</span><span class="p">]</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">NULLDATAOFF</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nused</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">xfs_dir2_free_log_header</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">fbp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update the real value in the table.</span>
<span class="cm">		 * We haven&#39;t allocated the data entry yet so this will</span>
<span class="cm">		 * change again.</span>
<span class="cm">		 */</span>
		<span class="n">hdr</span> <span class="o">=</span> <span class="n">dbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">findex</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bestfree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
		<span class="n">logfree</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We had a data block so we don&#39;t have to make a new one.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If just checking, we succeeded.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_JUSTCHECK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">fblk</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">fblk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fbp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">fbp</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Read the data block in.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span>
		    <span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">xfs_dir2_db_to_da</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">dbno</span><span class="p">),</span>
				<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbp</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">fblk</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">fblk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fbp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">fbp</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hdr</span> <span class="o">=</span> <span class="n">dbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">logfree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bestfree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Point to the existing unused space.</span>
<span class="cm">	 */</span>
	<span class="n">dup</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_unused_t</span> <span class="o">*</span><span class="p">)</span>
	      <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bestfree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">offset</span><span class="p">));</span>
	<span class="n">needscan</span> <span class="o">=</span> <span class="n">needlog</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Mark the first part of the unused space, inuse for us.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_dir2_data_use_free</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dbp</span><span class="p">,</span> <span class="n">dup</span><span class="p">,</span>
		<span class="p">(</span><span class="n">xfs_dir2_data_aoff_t</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dup</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">),</span> <span class="n">length</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">needlog</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needscan</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fill in the new entry and log it.</span>
<span class="cm">	 */</span>
	<span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_entry_t</span> <span class="o">*</span><span class="p">)</span><span class="n">dup</span><span class="p">;</span>
	<span class="n">dep</span><span class="o">-&gt;</span><span class="n">inumber</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">inumber</span><span class="p">);</span>
	<span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
	<span class="n">tagp</span> <span class="o">=</span> <span class="n">xfs_dir2_data_entry_tag_p</span><span class="p">(</span><span class="n">dep</span><span class="p">);</span>
	<span class="o">*</span><span class="n">tagp</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dep</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>
	<span class="n">xfs_dir2_data_log_entry</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dbp</span><span class="p">,</span> <span class="n">dep</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Rescan the block for bestfree if needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needscan</span><span class="p">)</span>
		<span class="n">xfs_dir2_data_freescan</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needlog</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Log the data block header if needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needlog</span><span class="p">)</span>
		<span class="n">xfs_dir2_data_log_header</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dbp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the freespace entry is now wrong, update it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">findex</span><span class="p">])</span> <span class="o">!=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bestfree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free</span><span class="o">-&gt;</span><span class="n">bests</span><span class="p">[</span><span class="n">findex</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bestfree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">;</span>
		<span class="n">logfree</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Log the freespace entry if needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">logfree</span><span class="p">)</span>
		<span class="n">xfs_dir2_free_log_bests</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">fbp</span><span class="p">,</span> <span class="n">findex</span><span class="p">,</span> <span class="n">findex</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the caller didn&#39;t hand us the freespace block, drop it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fblk</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">fblk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fbp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">fbp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Return the data block and offset in args, then drop the data block.</span>
<span class="cm">	 */</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dablk_t</span><span class="p">)</span><span class="n">dbno</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">tagp</span><span class="p">);</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">dbp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lookup an entry in a node-format directory.</span>
<span class="cm"> * All the real work happens in xfs_da_node_lookup_int.</span>
<span class="cm"> * The only real output is the inode number of the entry.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_node_lookup</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>	<span class="o">*</span><span class="n">args</span><span class="p">)</span>			<span class="cm">/* operation arguments */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>			<span class="cm">/* error return value */</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>			<span class="cm">/* btree level */</span>
	<span class="kt">int</span>		<span class="n">rval</span><span class="p">;</span>			<span class="cm">/* operation return value */</span>
	<span class="n">xfs_da_state_t</span>	<span class="o">*</span><span class="n">state</span><span class="p">;</span>			<span class="cm">/* btree cursor */</span>

	<span class="n">trace_xfs_dir2_node_lookup</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate and initialize the btree cursor.</span>
<span class="cm">	 */</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">xfs_da_state_alloc</span><span class="p">();</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblksize</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">node_ents</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dir_node_ents</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fill in the path to the entry in the cursor.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_node_lookup_int</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">==</span> <span class="n">ENOENT</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">cmpresult</span> <span class="o">==</span> <span class="n">XFS_CMP_CASE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If a CI match, dup the actual name and return EEXIST */</span>
		<span class="n">xfs_dir2_data_entry_t</span>	<span class="o">*</span><span class="n">dep</span><span class="p">;</span>

		<span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_entry_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span><span class="o">-&gt;</span>
						<span class="n">data</span> <span class="o">+</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="n">xfs_dir_cilookup_result</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">dep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Release the btree blocks and leaf block.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Release the data block if we have it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_da_state_free</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove an entry from a node-format directory.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_node_removename</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">)</span>		<span class="cm">/* operation arguments */</span>
<span class="p">{</span>
	<span class="n">xfs_da_state_blk_t</span>	<span class="o">*</span><span class="n">blk</span><span class="p">;</span>		<span class="cm">/* leaf block */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="kt">int</span>			<span class="n">rval</span><span class="p">;</span>		<span class="cm">/* operation return value */</span>
	<span class="n">xfs_da_state_t</span>		<span class="o">*</span><span class="n">state</span><span class="p">;</span>		<span class="cm">/* btree cursor */</span>

	<span class="n">trace_xfs_dir2_node_removename</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate and initialize the btree cursor.</span>
<span class="cm">	 */</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">xfs_da_state_alloc</span><span class="p">();</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblksize</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">node_ents</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dir_node_ents</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Look up the entry we&#39;re deleting, set up the cursor.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_node_lookup_int</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Didn&#39;t find it, upper layer screwed up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">!=</span> <span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_da_state_free</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Remove the leaf and data entries.</span>
<span class="cm">	 * Extrablk refers to the data block.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_leafn_remove</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fix the hash values up the btree.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_da_fixhashpath</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we need to join leaf blocks, do it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_join</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If no errors so far, try conversion to leaf format.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_node_to_leaf</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="n">xfs_da_state_free</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Replace an entry&#39;s inode number in a node-format directory.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_node_replace</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">)</span>		<span class="cm">/* operation arguments */</span>
<span class="p">{</span>
	<span class="n">xfs_da_state_blk_t</span>	<span class="o">*</span><span class="n">blk</span><span class="p">;</span>		<span class="cm">/* leaf block */</span>
	<span class="n">xfs_dir2_data_hdr_t</span>	<span class="o">*</span><span class="n">hdr</span><span class="p">;</span>		<span class="cm">/* data block header */</span>
	<span class="n">xfs_dir2_data_entry_t</span>	<span class="o">*</span><span class="n">dep</span><span class="p">;</span>		<span class="cm">/* data entry changed */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>		<span class="cm">/* btree level */</span>
	<span class="n">xfs_ino_t</span>		<span class="n">inum</span><span class="p">;</span>		<span class="cm">/* new inode number */</span>
	<span class="n">xfs_dir2_leaf_t</span>		<span class="o">*</span><span class="n">leaf</span><span class="p">;</span>		<span class="cm">/* leaf structure */</span>
	<span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">lep</span><span class="p">;</span>		<span class="cm">/* leaf entry being changed */</span>
	<span class="kt">int</span>			<span class="n">rval</span><span class="p">;</span>		<span class="cm">/* internal return value */</span>
	<span class="n">xfs_da_state_t</span>		<span class="o">*</span><span class="n">state</span><span class="p">;</span>		<span class="cm">/* btree cursor */</span>

	<span class="n">trace_xfs_dir2_node_replace</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate and initialize the btree cursor.</span>
<span class="cm">	 */</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">xfs_da_state_alloc</span><span class="p">();</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblksize</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">node_ents</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dir_node_ents</span><span class="p">;</span>
	<span class="n">inum</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">inumber</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Lookup the entry to change in the btree.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_node_lookup_int</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * It should be found, since the vnodeops layer has looked it up</span>
<span class="cm">	 * and locked it.  But paranoia is good.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">==</span> <span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Find the leaf entry.</span>
<span class="cm">		 */</span>
		<span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">);</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">lep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Point to the data entry.</span>
<span class="cm">		 */</span>
		<span class="n">hdr</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_DATA_MAGIC</span><span class="p">));</span>
		<span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_entry_t</span> <span class="o">*</span><span class="p">)</span>
		      <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span>
		       <span class="n">xfs_dir2_dataptr_to_off</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">lep</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">)));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">inum</span> <span class="o">!=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">dep</span><span class="o">-&gt;</span><span class="n">inumber</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * Fill in the new inode number and log the entry.</span>
<span class="cm">		 */</span>
		<span class="n">dep</span><span class="o">-&gt;</span><span class="n">inumber</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">inum</span><span class="p">);</span>
		<span class="n">xfs_dir2_data_log_entry</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span><span class="p">,</span> <span class="n">dep</span><span class="p">);</span>
		<span class="n">rval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Didn&#39;t find it, and we&#39;re holding a data block.  Drop it.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Release all the buffers in the cursor.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_da_state_free</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Trim off a trailing empty freespace block.</span>
<span class="cm"> * Return (in rvalp) 1 if we did it, 0 if not.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_node_trim_free</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">,</span>		<span class="cm">/* operation arguments */</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">fo</span><span class="p">,</span>		<span class="cm">/* free block number */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">rvalp</span><span class="p">)</span>		<span class="cm">/* out: did something */</span>
<span class="p">{</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* freespace buffer */</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">;</span>		<span class="cm">/* incore directory inode */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return code */</span>
	<span class="n">xfs_dir2_free_t</span>		<span class="o">*</span><span class="n">free</span><span class="p">;</span>		<span class="cm">/* freespace structure */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>		<span class="cm">/* transaction pointer */</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read the freespace block.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_dablk_t</span><span class="p">)</span><span class="n">fo</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span>
			<span class="n">XFS_DATA_FORK</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * There can be holes in freespace.  If fo is a hole, there&#39;s</span>
<span class="cm">	 * nothing to do.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">free</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_FREE_MAGIC</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there are used entries, there&#39;s nothing to do.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nused</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="o">*</span><span class="n">rvalp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Blow the block away.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span>
	    <span class="n">xfs_dir2_shrink_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">xfs_dir2_da_to_db</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_dablk_t</span><span class="p">)</span><span class="n">fo</span><span class="p">),</span>
		    <span class="n">bp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Can&#39;t fail with ENOSPC since that only happens with no</span>
<span class="cm">		 * space reservation, when breaking up an extent into two</span>
<span class="cm">		 * pieces.  This is the last block of an extent.</span>
<span class="cm">		 */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">ENOSPC</span><span class="p">);</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Return that we succeeded.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">rvalp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
