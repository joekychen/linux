<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_dir2_block.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_dir2_block.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2003,2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_da_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode_item.h&quot;</span>
<span class="cp">#include &quot;xfs_dir2.h&quot;</span>
<span class="cp">#include &quot;xfs_dir2_format.h&quot;</span>
<span class="cp">#include &quot;xfs_dir2_priv.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Local function prototypes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">xfs_dir2_block_log_leaf</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">last</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">xfs_dir2_block_log_tail</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xfs_dir2_block_lookup_int</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">**</span><span class="n">bpp</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="o">*</span><span class="n">entno</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xfs_dir2_block_sort</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>

<span class="k">static</span> <span class="n">xfs_dahash_t</span> <span class="n">xfs_dir_hash_dot</span><span class="p">,</span> <span class="n">xfs_dir_hash_dotdot</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * One-time startup routine called from xfs_init().</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_dir_startup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_dir_hash_dot</span> <span class="o">=</span> <span class="n">xfs_da_hashname</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_dir_hash_dotdot</span> <span class="o">=</span> <span class="n">xfs_da_hashname</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;..&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add an entry to a block directory.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_block_addname</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">)</span>		<span class="cm">/* directory op arguments */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_data_free_t</span>	<span class="o">*</span><span class="n">bf</span><span class="p">;</span>		<span class="cm">/* bestfree table in block */</span>
	<span class="n">xfs_dir2_data_hdr_t</span>	<span class="o">*</span><span class="n">hdr</span><span class="p">;</span>		<span class="cm">/* block header */</span>
	<span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">blp</span><span class="p">;</span>		<span class="cm">/* block leaf entries */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* buffer for block */</span>
	<span class="n">xfs_dir2_block_tail_t</span>	<span class="o">*</span><span class="n">btp</span><span class="p">;</span>		<span class="cm">/* block tail */</span>
	<span class="kt">int</span>			<span class="n">compact</span><span class="p">;</span>	<span class="cm">/* need to compact leaf ents */</span>
	<span class="n">xfs_dir2_data_entry_t</span>	<span class="o">*</span><span class="n">dep</span><span class="p">;</span>		<span class="cm">/* block data entry */</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">;</span>		<span class="cm">/* directory inode */</span>
	<span class="n">xfs_dir2_data_unused_t</span>	<span class="o">*</span><span class="n">dup</span><span class="p">;</span>		<span class="cm">/* block unused entry */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="n">xfs_dir2_data_unused_t</span>	<span class="o">*</span><span class="n">enddup</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* unused at end of data */</span>
	<span class="n">xfs_dahash_t</span>		<span class="n">hash</span><span class="p">;</span>		<span class="cm">/* hash value of found entry */</span>
	<span class="kt">int</span>			<span class="n">high</span><span class="p">;</span>		<span class="cm">/* high index for binary srch */</span>
	<span class="kt">int</span>			<span class="n">highstale</span><span class="p">;</span>	<span class="cm">/* high stale index */</span>
	<span class="kt">int</span>			<span class="n">lfloghigh</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>	<span class="cm">/* last final leaf to log */</span>
	<span class="kt">int</span>			<span class="n">lfloglow</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>	<span class="cm">/* first final leaf to log */</span>
	<span class="kt">int</span>			<span class="n">len</span><span class="p">;</span>		<span class="cm">/* length of the new entry */</span>
	<span class="kt">int</span>			<span class="n">low</span><span class="p">;</span>		<span class="cm">/* low index for binary srch */</span>
	<span class="kt">int</span>			<span class="n">lowstale</span><span class="p">;</span>	<span class="cm">/* low stale index */</span>
	<span class="kt">int</span>			<span class="n">mid</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>		<span class="cm">/* midpoint for binary srch */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>
	<span class="kt">int</span>			<span class="n">needlog</span><span class="p">;</span>	<span class="cm">/* need to log header */</span>
	<span class="kt">int</span>			<span class="n">needscan</span><span class="p">;</span>	<span class="cm">/* need to rescan freespace */</span>
	<span class="n">__be16</span>			<span class="o">*</span><span class="n">tagp</span><span class="p">;</span>		<span class="cm">/* pointer to tag value */</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>		<span class="cm">/* transaction structure */</span>

	<span class="n">trace_xfs_dir2_block_addname</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read the (one and only) directory block into dabuf bp.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span>
	    <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirdatablk</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check the magic number, corrupted if wrong.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_BLOCK_MAGIC</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_dir2_block_addname&quot;</span><span class="p">,</span>
				     <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">xfs_dir2_data_entsize</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set up pointers to parts of the block.</span>
<span class="cm">	 */</span>
	<span class="n">bf</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bestfree</span><span class="p">;</span>
	<span class="n">btp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_tail_p</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="n">blp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_leaf_p</span><span class="p">(</span><span class="n">btp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * No stale entries?  Need space for entry and new leaf.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Tag just before the first leaf entry.</span>
<span class="cm">		 */</span>
		<span class="n">tagp</span> <span class="o">=</span> <span class="p">(</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)</span><span class="n">blp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Data object just before the first leaf entry.</span>
<span class="cm">		 */</span>
		<span class="n">enddup</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_unused_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">tagp</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it&#39;s not free then can&#39;t do this add without cleaning up:</span>
<span class="cm">		 * the space before the first leaf entry needs to be free so it</span>
<span class="cm">		 * can be expanded to hold the pointer to the new entry.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">enddup</span><span class="o">-&gt;</span><span class="n">freetag</span><span class="p">)</span> <span class="o">!=</span> <span class="n">XFS_DIR2_DATA_FREE_TAG</span><span class="p">)</span>
			<span class="n">dup</span> <span class="o">=</span> <span class="n">enddup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check out the biggest freespace and see if it&#39;s the same one.</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">dup</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_unused_t</span> <span class="o">*</span><span class="p">)</span>
			      <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">bf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">offset</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dup</span> <span class="o">==</span> <span class="n">enddup</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * It is the biggest freespace, is it too small</span>
<span class="cm">				 * to hold the new leaf too?</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dup</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">+</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">blp</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * Yes, we use the second-largest</span>
<span class="cm">					 * entry instead if it works.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">bf</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">length</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span>
						<span class="n">dup</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_unused_t</span> <span class="o">*</span><span class="p">)</span>
						      <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span>
						       <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">bf</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">offset</span><span class="p">));</span>
					<span class="k">else</span>
						<span class="n">dup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Not the same free entry,</span>
<span class="cm">				 * just check its length.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dup</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">compact</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there are stale entries we&#39;ll use one for the leaf.</span>
<span class="cm">	 * Is the biggest entry enough to avoid compaction?</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">bf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dup</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_unused_t</span> <span class="o">*</span><span class="p">)</span>
		      <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">bf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">offset</span><span class="p">));</span>
		<span class="n">compact</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Will need to compact to make this work.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Tag just before the first leaf entry.</span>
<span class="cm">		 */</span>
		<span class="n">tagp</span> <span class="o">=</span> <span class="p">(</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)</span><span class="n">blp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Data object just before the first leaf entry.</span>
<span class="cm">		 */</span>
		<span class="n">dup</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_unused_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">tagp</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it&#39;s not free then the data will go where the</span>
<span class="cm">		 * leaf data starts now, if it works at all.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dup</span><span class="o">-&gt;</span><span class="n">freetag</span><span class="p">)</span> <span class="o">==</span> <span class="n">XFS_DIR2_DATA_FREE_TAG</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dup</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
			    <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">blp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">dup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">blp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">dup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dup</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_unused_t</span> <span class="o">*</span><span class="p">)</span><span class="n">blp</span><span class="p">;</span>
		<span class="n">compact</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this isn&#39;t a real add, we&#39;re done with the buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_JUSTCHECK</span><span class="p">)</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t have space for the new entry &amp; leaf ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dup</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Not trying to actually do anything, or don&#39;t have</span>
<span class="cm">		 * a space reservation: return no-space.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_JUSTCHECK</span><span class="p">)</span> <span class="o">||</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSPC</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Convert to the next larger format.</span>
<span class="cm">		 * Then add the new entry in that format.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_block_to_leaf</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">xfs_dir2_leaf_addname</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Just checking, and it would work, so say so.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_JUSTCHECK</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">needlog</span> <span class="o">=</span> <span class="n">needscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If need to compact the leaf entries, do it now.</span>
<span class="cm">	 * Leave the highest-numbered stale entry stale.</span>
<span class="cm">	 * XXX should be the one closest to mid but mid is not yet computed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">compact</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">fromidx</span><span class="p">;</span>		<span class="cm">/* source leaf index */</span>
		<span class="kt">int</span>	<span class="n">toidx</span><span class="p">;</span>			<span class="cm">/* target leaf index */</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">fromidx</span> <span class="o">=</span> <span class="n">toidx</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">highstale</span> <span class="o">=</span> <span class="n">lfloghigh</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		     <span class="n">fromidx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">fromidx</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">blp</span><span class="p">[</span><span class="n">fromidx</span><span class="p">].</span><span class="n">address</span> <span class="o">==</span>
			    <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_NULL_DATAPTR</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">highstale</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
					<span class="n">highstale</span> <span class="o">=</span> <span class="n">toidx</span><span class="p">;</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">lfloghigh</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
						<span class="n">lfloghigh</span> <span class="o">=</span> <span class="n">toidx</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fromidx</span> <span class="o">&lt;</span> <span class="n">toidx</span><span class="p">)</span>
				<span class="n">blp</span><span class="p">[</span><span class="n">toidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">blp</span><span class="p">[</span><span class="n">fromidx</span><span class="p">];</span>
			<span class="n">toidx</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lfloglow</span> <span class="o">=</span> <span class="n">toidx</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">lfloghigh</span> <span class="o">-=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">xfs_dir2_data_make_free</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
			<span class="p">(</span><span class="n">xfs_dir2_data_aoff_t</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">blp</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">),</span>
			<span class="p">(</span><span class="n">xfs_dir2_data_aoff_t</span><span class="p">)((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">blp</span><span class="p">)),</span>
			<span class="o">&amp;</span><span class="n">needlog</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needscan</span><span class="p">);</span>
		<span class="n">blp</span> <span class="o">+=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we now need to rebuild the bestfree map, do so.</span>
<span class="cm">		 * This needs to happen before the next call to use_free.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">needscan</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_dir2_data_freescan</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needlog</span><span class="p">);</span>
			<span class="n">needscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set leaf logging boundaries to impossible state.</span>
<span class="cm">	 * For the no-stale case they&#39;re set explicitly.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lfloglow</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
		<span class="n">lfloghigh</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Find the slot that&#39;s first lower than our hash value, -1 if none.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">hash</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">blp</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">hashval</span><span class="p">))</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span>
			<span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">blp</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mid</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * No stale entries, will use enddup space to hold new leaf.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Mark the space needed for the new leaf entry, now in use.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_dir2_data_use_free</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">enddup</span><span class="p">,</span>
			<span class="p">(</span><span class="n">xfs_dir2_data_aoff_t</span><span class="p">)</span>
			<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">enddup</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">enddup</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">-</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">blp</span><span class="p">)),</span>
			<span class="p">(</span><span class="n">xfs_dir2_data_aoff_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">blp</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">needlog</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needscan</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update the tail (entry count).</span>
<span class="cm">		 */</span>
		<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we now need to rebuild the bestfree map, do so.</span>
<span class="cm">		 * This needs to happen before the next call to use_free.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">needscan</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_dir2_data_freescan</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needlog</span><span class="p">);</span>
			<span class="n">needscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Adjust pointer to the first leaf entry, we&#39;re about to move</span>
<span class="cm">		 * the table up one to open up space for the new leaf entry.</span>
<span class="cm">		 * Then adjust our index to match.</span>
<span class="cm">		 */</span>
		<span class="n">blp</span><span class="o">--</span><span class="p">;</span>
		<span class="n">mid</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mid</span><span class="p">)</span>
			<span class="n">memmove</span><span class="p">(</span><span class="n">blp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mid</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">blp</span><span class="p">));</span>
		<span class="n">lfloglow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lfloghigh</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Use a stale leaf for our new entry.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">lowstale</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
		     <span class="n">lowstale</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="n">blp</span><span class="p">[</span><span class="n">lowstale</span><span class="p">].</span><span class="n">address</span> <span class="o">!=</span>
			<span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_NULL_DATAPTR</span><span class="p">);</span>
		     <span class="n">lowstale</span><span class="o">--</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">highstale</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		     <span class="n">highstale</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">blp</span><span class="p">[</span><span class="n">highstale</span><span class="p">].</span><span class="n">address</span> <span class="o">!=</span>
			<span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_NULL_DATAPTR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">lowstale</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">lowstale</span> <span class="o">&gt;</span> <span class="n">highstale</span> <span class="o">-</span> <span class="n">mid</span><span class="p">);</span>
		     <span class="n">highstale</span><span class="o">++</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Move entries toward the low-numbered stale entry.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lowstale</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">highstale</span> <span class="o">==</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">||</span>
		     <span class="n">mid</span> <span class="o">-</span> <span class="n">lowstale</span> <span class="o">&lt;=</span> <span class="n">highstale</span> <span class="o">-</span> <span class="n">mid</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">-</span> <span class="n">lowstale</span><span class="p">)</span>
				<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blp</span><span class="p">[</span><span class="n">lowstale</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">blp</span><span class="p">[</span><span class="n">lowstale</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
					<span class="p">(</span><span class="n">mid</span> <span class="o">-</span> <span class="n">lowstale</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">blp</span><span class="p">));</span>
			<span class="n">lfloglow</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">lowstale</span><span class="p">,</span> <span class="n">lfloglow</span><span class="p">);</span>
			<span class="n">lfloghigh</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">lfloghigh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Move entries toward the high-numbered stale entry.</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">highstale</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">));</span>
			<span class="n">mid</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">highstale</span> <span class="o">-</span> <span class="n">mid</span><span class="p">)</span>
				<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blp</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">blp</span><span class="p">[</span><span class="n">mid</span><span class="p">],</span>
					<span class="p">(</span><span class="n">highstale</span> <span class="o">-</span> <span class="n">mid</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">blp</span><span class="p">));</span>
			<span class="n">lfloglow</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">lfloglow</span><span class="p">);</span>
			<span class="n">lfloghigh</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">highstale</span><span class="p">,</span> <span class="n">lfloghigh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Point to the new data entry.</span>
<span class="cm">	 */</span>
	<span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_entry_t</span> <span class="o">*</span><span class="p">)</span><span class="n">dup</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fill in the leaf entry.</span>
<span class="cm">	 */</span>
	<span class="n">blp</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>
	<span class="n">blp</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">xfs_dir2_byte_to_dataptr</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dep</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">));</span>
	<span class="n">xfs_dir2_block_log_leaf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">lfloglow</span><span class="p">,</span> <span class="n">lfloghigh</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Mark space for the data entry used.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_dir2_data_use_free</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">dup</span><span class="p">,</span>
		<span class="p">(</span><span class="n">xfs_dir2_data_aoff_t</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dup</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">),</span>
		<span class="p">(</span><span class="n">xfs_dir2_data_aoff_t</span><span class="p">)</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needlog</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needscan</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Create the new data entry.</span>
<span class="cm">	 */</span>
	<span class="n">dep</span><span class="o">-&gt;</span><span class="n">inumber</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">inumber</span><span class="p">);</span>
	<span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
	<span class="n">tagp</span> <span class="o">=</span> <span class="n">xfs_dir2_data_entry_tag_p</span><span class="p">(</span><span class="n">dep</span><span class="p">);</span>
	<span class="o">*</span><span class="n">tagp</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dep</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clean up the bestfree array and log the header, tail, and entry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needscan</span><span class="p">)</span>
		<span class="n">xfs_dir2_data_freescan</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needlog</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needlog</span><span class="p">)</span>
		<span class="n">xfs_dir2_data_log_header</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_dir2_block_log_tail</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_dir2_data_log_entry</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">dep</span><span class="p">);</span>
	<span class="n">xfs_dir2_data_check</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Readdir for block directories.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_block_getdents</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">,</span>		<span class="cm">/* incore inode */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">dirent</span><span class="p">,</span>
	<span class="n">xfs_off_t</span>		<span class="o">*</span><span class="n">offset</span><span class="p">,</span>
	<span class="n">filldir_t</span>		<span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_data_hdr_t</span>	<span class="o">*</span><span class="n">hdr</span><span class="p">;</span>		<span class="cm">/* block header */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* buffer for block */</span>
	<span class="n">xfs_dir2_block_tail_t</span>	<span class="o">*</span><span class="n">btp</span><span class="p">;</span>		<span class="cm">/* block tail */</span>
	<span class="n">xfs_dir2_data_entry_t</span>	<span class="o">*</span><span class="n">dep</span><span class="p">;</span>		<span class="cm">/* block data entry */</span>
	<span class="n">xfs_dir2_data_unused_t</span>	<span class="o">*</span><span class="n">dup</span><span class="p">;</span>		<span class="cm">/* block unused entry */</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">endptr</span><span class="p">;</span>	<span class="cm">/* end of the data entries */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">ptr</span><span class="p">;</span>		<span class="cm">/* current data entry */</span>
	<span class="kt">int</span>			<span class="n">wantoff</span><span class="p">;</span>	<span class="cm">/* starting block offset */</span>
	<span class="n">xfs_off_t</span>		<span class="n">cook</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the block number in the offset is out of range, we&#39;re done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_dir2_dataptr_to_db</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirdatablk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Can&#39;t read the block, give up, else get dabuf in bp.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirdatablk</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Extract the byte offset we start at from the seek pointer.</span>
<span class="cm">	 * We&#39;ll skip entries before this.</span>
<span class="cm">	 */</span>
	<span class="n">wantoff</span> <span class="o">=</span> <span class="n">xfs_dir2_dataptr_to_off</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="o">*</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">xfs_dir2_data_check</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set up values for the loop.</span>
<span class="cm">	 */</span>
	<span class="n">btp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_tail_p</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">hdr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">endptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">xfs_dir2_block_leaf_p</span><span class="p">(</span><span class="n">btp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Loop over the data portion of the block.</span>
<span class="cm">	 * Each object is a real entry (dep) or an unused one (dup).</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">endptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dup</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_unused_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Unused, skip it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dup</span><span class="o">-&gt;</span><span class="n">freetag</span><span class="p">)</span> <span class="o">==</span> <span class="n">XFS_DIR2_DATA_FREE_TAG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ptr</span> <span class="o">+=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dup</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_entry_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Bump pointer for the next iteration.</span>
<span class="cm">		 */</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">xfs_dir2_data_entsize</span><span class="p">(</span><span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The entry is before the desired starting point, skip it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dep</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">&lt;</span> <span class="n">wantoff</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cook</span> <span class="o">=</span> <span class="n">xfs_dir2_db_off_to_dataptr</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirdatablk</span><span class="p">,</span>
					    <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dep</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If it didn&#39;t fit, set the final offset to here &amp; return.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span>
			    <span class="n">cook</span> <span class="o">&amp;</span> <span class="mh">0x7fffffff</span><span class="p">,</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">dep</span><span class="o">-&gt;</span><span class="n">inumber</span><span class="p">),</span>
			    <span class="n">DT_UNKNOWN</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">cook</span> <span class="o">&amp;</span> <span class="mh">0x7fffffff</span><span class="p">;</span>
			<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reached the end of the block.</span>
<span class="cm">	 * Set the offset to a non-existent block 1 and return.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">xfs_dir2_db_off_to_dataptr</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirdatablk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="mh">0x7fffffff</span><span class="p">;</span>
	<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Log leaf entries from the block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="n">xfs_dir2_block_log_leaf</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction structure */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>		<span class="cm">/* block buffer */</span>
	<span class="kt">int</span>			<span class="n">first</span><span class="p">,</span>		<span class="cm">/* index of first logged leaf */</span>
	<span class="kt">int</span>			<span class="n">last</span><span class="p">)</span>		<span class="cm">/* index of last logged leaf */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_data_hdr_t</span>	<span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">blp</span><span class="p">;</span>
	<span class="n">xfs_dir2_block_tail_t</span>	<span class="o">*</span><span class="n">btp</span><span class="p">;</span>

	<span class="n">btp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_tail_p</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="n">blp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_leaf_p</span><span class="p">(</span><span class="n">btp</span><span class="p">);</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">blp</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">),</span>
		<span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">blp</span><span class="p">[</span><span class="n">last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Log the block tail.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="n">xfs_dir2_block_log_tail</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction structure */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>		<span class="cm">/* block buffer */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_data_hdr_t</span>	<span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">xfs_dir2_block_tail_t</span>	<span class="o">*</span><span class="n">btp</span><span class="p">;</span>

	<span class="n">btp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_tail_p</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">btp</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">),</span>
		<span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">btp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up an entry in the block.  This is the external routine,</span>
<span class="cm"> * xfs_dir2_block_lookup_int does the real work.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_block_lookup</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">)</span>		<span class="cm">/* dir lookup arguments */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_data_hdr_t</span>	<span class="o">*</span><span class="n">hdr</span><span class="p">;</span>		<span class="cm">/* block header */</span>
	<span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">blp</span><span class="p">;</span>		<span class="cm">/* block leaf entries */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* block buffer */</span>
	<span class="n">xfs_dir2_block_tail_t</span>	<span class="o">*</span><span class="n">btp</span><span class="p">;</span>		<span class="cm">/* block tail */</span>
	<span class="n">xfs_dir2_data_entry_t</span>	<span class="o">*</span><span class="n">dep</span><span class="p">;</span>		<span class="cm">/* block data entry */</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">;</span>		<span class="cm">/* incore inode */</span>
	<span class="kt">int</span>			<span class="n">ent</span><span class="p">;</span>		<span class="cm">/* entry index */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>

	<span class="n">trace_xfs_dir2_block_lookup</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the buffer, look up the entry.</span>
<span class="cm">	 * If not found (ENOENT) then return, have no buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_block_lookup_int</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">xfs_dir2_data_check</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">btp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_tail_p</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="n">blp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_leaf_p</span><span class="p">(</span><span class="n">btp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the offset from the leaf entry, to point to the data.</span>
<span class="cm">	 */</span>
	<span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_entry_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span>
		<span class="n">xfs_dir2_dataptr_to_off</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">blp</span><span class="p">[</span><span class="n">ent</span><span class="p">].</span><span class="n">address</span><span class="p">)));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fill in inode number, CI name if appropriate, release the block.</span>
<span class="cm">	 */</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">inumber</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">dep</span><span class="o">-&gt;</span><span class="n">inumber</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir_cilookup_result</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">dep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
	<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Internal block lookup routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_dir2_block_lookup_int</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">,</span>		<span class="cm">/* dir lookup arguments */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">**</span><span class="n">bpp</span><span class="p">,</span>		<span class="cm">/* returned block buffer */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">entno</span><span class="p">)</span>		<span class="cm">/* returned entry number */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_dataptr_t</span>	<span class="n">addr</span><span class="p">;</span>		<span class="cm">/* data entry address */</span>
	<span class="n">xfs_dir2_data_hdr_t</span>	<span class="o">*</span><span class="n">hdr</span><span class="p">;</span>		<span class="cm">/* block header */</span>
	<span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">blp</span><span class="p">;</span>		<span class="cm">/* block leaf entries */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* block buffer */</span>
	<span class="n">xfs_dir2_block_tail_t</span>	<span class="o">*</span><span class="n">btp</span><span class="p">;</span>		<span class="cm">/* block tail */</span>
	<span class="n">xfs_dir2_data_entry_t</span>	<span class="o">*</span><span class="n">dep</span><span class="p">;</span>		<span class="cm">/* block data entry */</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">;</span>		<span class="cm">/* incore inode */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="n">xfs_dahash_t</span>		<span class="n">hash</span><span class="p">;</span>		<span class="cm">/* found hash value */</span>
	<span class="kt">int</span>			<span class="n">high</span><span class="p">;</span>		<span class="cm">/* binary search high index */</span>
	<span class="kt">int</span>			<span class="n">low</span><span class="p">;</span>		<span class="cm">/* binary search low index */</span>
	<span class="kt">int</span>			<span class="n">mid</span><span class="p">;</span>		<span class="cm">/* binary search current idx */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>		<span class="cm">/* transaction pointer */</span>
	<span class="k">enum</span> <span class="n">xfs_dacmp</span>		<span class="n">cmp</span><span class="p">;</span>		<span class="cm">/* comparison result */</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read the buffer, return error if we can&#39;t get it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span>
	    <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirdatablk</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">xfs_dir2_data_check</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">btp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_tail_p</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="n">blp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_leaf_p</span><span class="p">(</span><span class="n">btp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Loop doing a binary search for our hash value.</span>
<span class="cm">	 * Find our entry, ENOENT if it&#39;s not there.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">);</span>
		<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">hash</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">blp</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">hashval</span><span class="p">))</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span>
			<span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">&gt;</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_OKNOENT</span><span class="p">);</span>
			<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOENT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Back up to the first one with the right hash value.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">blp</span><span class="p">[</span><span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mid</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now loop forward through all the entries with the</span>
<span class="cm">	 * right hash value looking for our name.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">blp</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">address</span><span class="p">))</span> <span class="o">==</span> <span class="n">XFS_DIR2_NULL_DATAPTR</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get pointer to the entry from the leaf.</span>
<span class="cm">		 */</span>
		<span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_entry_t</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">xfs_dir2_dataptr_to_off</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">addr</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compare name and if it&#39;s an exact match, return the index</span>
<span class="cm">		 * and buffer. If it&#39;s the first case-insensitive match, store</span>
<span class="cm">		 * the index and buffer and continue looking for an exact match.</span>
<span class="cm">		 */</span>
		<span class="n">cmp</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirnameops</span><span class="o">-&gt;</span><span class="n">compname</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">dep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">!=</span> <span class="n">XFS_CMP_DIFFERENT</span> <span class="o">&amp;&amp;</span> <span class="n">cmp</span> <span class="o">!=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">cmpresult</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">cmpresult</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">;</span>
			<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
			<span class="o">*</span><span class="n">entno</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="n">XFS_CMP_EXACT</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">mid</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">blp</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">==</span> <span class="n">hash</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_OKNOENT</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Here, we can only be doing a lookup (not a rename or replace).</span>
<span class="cm">	 * If a case-insensitive match was found earlier, return success.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">cmpresult</span> <span class="o">==</span> <span class="n">XFS_CMP_CASE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * No match, release the buffer and return ENOENT.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOENT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove an entry from a block format directory.</span>
<span class="cm"> * If that makes the block small enough to fit in shortform, transform it.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_block_removename</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">)</span>		<span class="cm">/* directory operation args */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_data_hdr_t</span>	<span class="o">*</span><span class="n">hdr</span><span class="p">;</span>		<span class="cm">/* block header */</span>
	<span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">blp</span><span class="p">;</span>		<span class="cm">/* block leaf pointer */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* block buffer */</span>
	<span class="n">xfs_dir2_block_tail_t</span>	<span class="o">*</span><span class="n">btp</span><span class="p">;</span>		<span class="cm">/* block tail */</span>
	<span class="n">xfs_dir2_data_entry_t</span>	<span class="o">*</span><span class="n">dep</span><span class="p">;</span>		<span class="cm">/* block data entry */</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">;</span>		<span class="cm">/* incore inode */</span>
	<span class="kt">int</span>			<span class="n">ent</span><span class="p">;</span>		<span class="cm">/* block leaf entry index */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>
	<span class="kt">int</span>			<span class="n">needlog</span><span class="p">;</span>	<span class="cm">/* need to log block header */</span>
	<span class="kt">int</span>			<span class="n">needscan</span><span class="p">;</span>	<span class="cm">/* need to fixup bestfree */</span>
	<span class="n">xfs_dir2_sf_hdr_t</span>	<span class="n">sfh</span><span class="p">;</span>		<span class="cm">/* shortform header */</span>
	<span class="kt">int</span>			<span class="n">size</span><span class="p">;</span>		<span class="cm">/* shortform size */</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>		<span class="cm">/* transaction pointer */</span>

	<span class="n">trace_xfs_dir2_block_removename</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look up the entry in the block.  Gets the buffer and entry index.</span>
<span class="cm">	 * It will always be there, the vnodeops level does a lookup first.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_block_lookup_int</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">btp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_tail_p</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="n">blp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_leaf_p</span><span class="p">(</span><span class="n">btp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Point to the data entry using the leaf entry.</span>
<span class="cm">	 */</span>
	<span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_entry_t</span> <span class="o">*</span><span class="p">)</span>
	      <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">xfs_dir2_dataptr_to_off</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">blp</span><span class="p">[</span><span class="n">ent</span><span class="p">].</span><span class="n">address</span><span class="p">)));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Mark the data entry&#39;s space free.</span>
<span class="cm">	 */</span>
	<span class="n">needlog</span> <span class="o">=</span> <span class="n">needscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_dir2_data_make_free</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
		<span class="p">(</span><span class="n">xfs_dir2_data_aoff_t</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dep</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">),</span>
		<span class="n">xfs_dir2_data_entsize</span><span class="p">(</span><span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">needlog</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needscan</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fix up the block tail.</span>
<span class="cm">	 */</span>
	<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_dir2_block_log_tail</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Remove the leaf entry by marking it stale.</span>
<span class="cm">	 */</span>
	<span class="n">blp</span><span class="p">[</span><span class="n">ent</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_NULL_DATAPTR</span><span class="p">);</span>
	<span class="n">xfs_dir2_block_log_leaf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fix up bestfree, log the header if necessary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needscan</span><span class="p">)</span>
		<span class="n">xfs_dir2_data_freescan</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needlog</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needlog</span><span class="p">)</span>
		<span class="n">xfs_dir2_data_log_header</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_dir2_data_check</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * See if the size as a shortform is good enough.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">xfs_dir2_block_sfsize</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sfh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">XFS_IFORK_DSIZE</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If it works, do the conversion.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">xfs_dir2_block_to_sf</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sfh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Replace an entry in a V2 block directory.</span>
<span class="cm"> * Change the inode number to the new value.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_block_replace</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">)</span>		<span class="cm">/* directory operation args */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_data_hdr_t</span>	<span class="o">*</span><span class="n">hdr</span><span class="p">;</span>		<span class="cm">/* block header */</span>
	<span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">blp</span><span class="p">;</span>		<span class="cm">/* block leaf entries */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* block buffer */</span>
	<span class="n">xfs_dir2_block_tail_t</span>	<span class="o">*</span><span class="n">btp</span><span class="p">;</span>		<span class="cm">/* block tail */</span>
	<span class="n">xfs_dir2_data_entry_t</span>	<span class="o">*</span><span class="n">dep</span><span class="p">;</span>		<span class="cm">/* block data entry */</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">;</span>		<span class="cm">/* incore inode */</span>
	<span class="kt">int</span>			<span class="n">ent</span><span class="p">;</span>		<span class="cm">/* leaf entry index */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>

	<span class="n">trace_xfs_dir2_block_replace</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lookup the entry in the directory.  Get buffer and entry index.</span>
<span class="cm">	 * This will always succeed since the caller has already done a lookup.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_block_lookup_int</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">btp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_tail_p</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="n">blp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_leaf_p</span><span class="p">(</span><span class="n">btp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Point to the data entry we need to change.</span>
<span class="cm">	 */</span>
	<span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_entry_t</span> <span class="o">*</span><span class="p">)</span>
	      <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">xfs_dir2_dataptr_to_off</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">blp</span><span class="p">[</span><span class="n">ent</span><span class="p">].</span><span class="n">address</span><span class="p">)));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">dep</span><span class="o">-&gt;</span><span class="n">inumber</span><span class="p">)</span> <span class="o">!=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">inumber</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Change the inode number to the new value.</span>
<span class="cm">	 */</span>
	<span class="n">dep</span><span class="o">-&gt;</span><span class="n">inumber</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">inumber</span><span class="p">);</span>
	<span class="n">xfs_dir2_data_log_entry</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">dep</span><span class="p">);</span>
	<span class="n">xfs_dir2_data_check</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Qsort comparison routine for the block leaf entries.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>					<span class="cm">/* sort order */</span>
<span class="n">xfs_dir2_block_sort</span><span class="p">(</span>
	<span class="k">const</span> <span class="kt">void</span>			<span class="o">*</span><span class="n">a</span><span class="p">,</span>	<span class="cm">/* first leaf entry */</span>
	<span class="k">const</span> <span class="kt">void</span>			<span class="o">*</span><span class="n">b</span><span class="p">)</span>	<span class="cm">/* second leaf entry */</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">la</span><span class="p">;</span>	<span class="cm">/* first leaf entry */</span>
	<span class="k">const</span> <span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">lb</span><span class="p">;</span>	<span class="cm">/* second leaf entry */</span>

	<span class="n">la</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">lb</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">la</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">lb</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">la</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">lb</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert a V2 leaf directory to a V2 block directory if possible.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_leaf_to_block</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">,</span>		<span class="cm">/* operation arguments */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">lbp</span><span class="p">,</span>		<span class="cm">/* leaf buffer */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">dbp</span><span class="p">)</span>		<span class="cm">/* data buffer */</span>
<span class="p">{</span>
	<span class="n">__be16</span>			<span class="o">*</span><span class="n">bestsp</span><span class="p">;</span>	<span class="cm">/* leaf bests table */</span>
	<span class="n">xfs_dir2_data_hdr_t</span>	<span class="o">*</span><span class="n">hdr</span><span class="p">;</span>		<span class="cm">/* block header */</span>
	<span class="n">xfs_dir2_block_tail_t</span>	<span class="o">*</span><span class="n">btp</span><span class="p">;</span>		<span class="cm">/* block tail */</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">;</span>		<span class="cm">/* incore directory inode */</span>
	<span class="n">xfs_dir2_data_unused_t</span>	<span class="o">*</span><span class="n">dup</span><span class="p">;</span>		<span class="cm">/* unused data entry */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="kt">int</span>			<span class="n">from</span><span class="p">;</span>		<span class="cm">/* leaf from index */</span>
	<span class="n">xfs_dir2_leaf_t</span>		<span class="o">*</span><span class="n">leaf</span><span class="p">;</span>		<span class="cm">/* leaf structure */</span>
	<span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">lep</span><span class="p">;</span>		<span class="cm">/* leaf entry */</span>
	<span class="n">xfs_dir2_leaf_tail_t</span>	<span class="o">*</span><span class="n">ltp</span><span class="p">;</span>		<span class="cm">/* leaf tail structure */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* file system mount point */</span>
	<span class="kt">int</span>			<span class="n">needlog</span><span class="p">;</span>	<span class="cm">/* need to log data header */</span>
	<span class="kt">int</span>			<span class="n">needscan</span><span class="p">;</span>	<span class="cm">/* need to scan for bestfree */</span>
	<span class="n">xfs_dir2_sf_hdr_t</span>	<span class="n">sfh</span><span class="p">;</span>		<span class="cm">/* shortform header */</span>
	<span class="kt">int</span>			<span class="n">size</span><span class="p">;</span>		<span class="cm">/* bytes used */</span>
	<span class="n">__be16</span>			<span class="o">*</span><span class="n">tagp</span><span class="p">;</span>		<span class="cm">/* end of entry (tag) */</span>
	<span class="kt">int</span>			<span class="n">to</span><span class="p">;</span>		<span class="cm">/* block/leaf to index */</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>		<span class="cm">/* transaction pointer */</span>

	<span class="n">trace_xfs_dir2_leaf_to_block</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">lbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAF1_MAGIC</span><span class="p">));</span>
	<span class="n">ltp</span> <span class="o">=</span> <span class="n">xfs_dir2_leaf_tail_p</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there are data blocks other than the first one, take this</span>
<span class="cm">	 * opportunity to remove trailing empty data blocks that may have</span>
<span class="cm">	 * been left behind during no-space-reservation operations.</span>
<span class="cm">	 * These will show up in the leaf bests table.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblksize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bestsp</span> <span class="o">=</span> <span class="n">xfs_dir2_leaf_bests_p</span><span class="p">(</span><span class="n">ltp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">bestsp</span><span class="p">[</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ltp</span><span class="o">-&gt;</span><span class="n">bestcount</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">==</span>
		    <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblksize</span> <span class="o">-</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span>
			    <span class="n">xfs_dir2_leaf_trim_data</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">lbp</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">xfs_dir2_db_t</span><span class="p">)(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ltp</span><span class="o">-&gt;</span><span class="n">bestcount</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read the data block if we don&#39;t already have it, give up if it fails.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dbp</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirdatablk</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbp</span><span class="p">,</span>
		    <span class="n">XFS_DATA_FORK</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="n">dbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_DATA_MAGIC</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Size of the &quot;leaf&quot; area in the block.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_dir2_block_tail_t</span><span class="p">)</span> <span class="o">+</span>
	       <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lep</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Look at the last data entry.</span>
<span class="cm">	 */</span>
	<span class="n">tagp</span> <span class="o">=</span> <span class="p">(</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblksize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dup</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_unused_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">tagp</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * If it&#39;s not free or is too short we can&#39;t do it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dup</span><span class="o">-&gt;</span><span class="n">freetag</span><span class="p">)</span> <span class="o">!=</span> <span class="n">XFS_DIR2_DATA_FREE_TAG</span> <span class="o">||</span>
	    <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dup</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Start converting it to block form.</span>
<span class="cm">	 */</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_BLOCK_MAGIC</span><span class="p">);</span>
	<span class="n">needlog</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">needscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Use up the space at the end of the block (blp/btp).</span>
<span class="cm">	 */</span>
	<span class="n">xfs_dir2_data_use_free</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dbp</span><span class="p">,</span> <span class="n">dup</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblksize</span> <span class="o">-</span> <span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">needlog</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needscan</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initialize the block tail.</span>
<span class="cm">	 */</span>
	<span class="n">btp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_tail_p</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">stale</span><span class="p">));</span>
	<span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_dir2_block_log_tail</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dbp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initialize the block leaf area.  We compact out stale entries.</span>
<span class="cm">	 */</span>
	<span class="n">lep</span> <span class="o">=</span> <span class="n">xfs_dir2_block_leaf_p</span><span class="p">(</span><span class="n">btp</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">from</span> <span class="o">=</span> <span class="n">to</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">from</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span> <span class="n">from</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">from</span><span class="p">].</span><span class="n">address</span> <span class="o">==</span>
		    <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_NULL_DATAPTR</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">lep</span><span class="p">[</span><span class="n">to</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">from</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">to</span> <span class="o">==</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">));</span>
	<span class="n">xfs_dir2_block_log_leaf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dbp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Scan the bestfree if we need it and log the data block header.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needscan</span><span class="p">)</span>
		<span class="n">xfs_dir2_data_freescan</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needlog</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needlog</span><span class="p">)</span>
		<span class="n">xfs_dir2_data_log_header</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dbp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Pitch the old leaf block.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_shrink_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirleafblk</span><span class="p">,</span> <span class="n">lbp</span><span class="p">);</span>
	<span class="n">lbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now see if the resulting block can be shrunken to shortform.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">xfs_dir2_block_sfsize</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sfh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">XFS_IFORK_DSIZE</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">xfs_dir2_block_to_sf</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">dbp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sfh</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lbp</span><span class="p">)</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">lbp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dbp</span><span class="p">)</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">dbp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert the shortform directory to block form.</span>
<span class="cm"> */</span>
<span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_dir2_sf_to_block</span><span class="p">(</span>
	<span class="n">xfs_da_args_t</span>		<span class="o">*</span><span class="n">args</span><span class="p">)</span>		<span class="cm">/* operation arguments */</span>
<span class="p">{</span>
	<span class="n">xfs_dir2_db_t</span>		<span class="n">blkno</span><span class="p">;</span>		<span class="cm">/* dir-relative block # (0) */</span>
	<span class="n">xfs_dir2_data_hdr_t</span>	<span class="o">*</span><span class="n">hdr</span><span class="p">;</span>		<span class="cm">/* block header */</span>
	<span class="n">xfs_dir2_leaf_entry_t</span>	<span class="o">*</span><span class="n">blp</span><span class="p">;</span>		<span class="cm">/* block leaf entries */</span>
	<span class="n">xfs_dabuf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>		<span class="cm">/* block buffer */</span>
	<span class="n">xfs_dir2_block_tail_t</span>	<span class="o">*</span><span class="n">btp</span><span class="p">;</span>		<span class="cm">/* block tail pointer */</span>
	<span class="n">xfs_dir2_data_entry_t</span>	<span class="o">*</span><span class="n">dep</span><span class="p">;</span>		<span class="cm">/* data entry pointer */</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">;</span>		<span class="cm">/* incore directory inode */</span>
	<span class="kt">int</span>			<span class="n">dummy</span><span class="p">;</span>		<span class="cm">/* trash */</span>
	<span class="n">xfs_dir2_data_unused_t</span>	<span class="o">*</span><span class="n">dup</span><span class="p">;</span>		<span class="cm">/* unused entry pointer */</span>
	<span class="kt">int</span>			<span class="n">endoffset</span><span class="p">;</span>	<span class="cm">/* end of data objects */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>		<span class="cm">/* index */</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* filesystem mount point */</span>
	<span class="kt">int</span>			<span class="n">needlog</span><span class="p">;</span>	<span class="cm">/* need to log block header */</span>
	<span class="kt">int</span>			<span class="n">needscan</span><span class="p">;</span>	<span class="cm">/* need to scan block freespc */</span>
	<span class="kt">int</span>			<span class="n">newoffset</span><span class="p">;</span>	<span class="cm">/* offset from current entry */</span>
	<span class="kt">int</span>			<span class="n">offset</span><span class="p">;</span>		<span class="cm">/* target block offset */</span>
	<span class="n">xfs_dir2_sf_entry_t</span>	<span class="o">*</span><span class="n">sfep</span><span class="p">;</span>		<span class="cm">/* sf entry pointer */</span>
	<span class="n">xfs_dir2_sf_hdr_t</span>	<span class="o">*</span><span class="n">oldsfp</span><span class="p">;</span>	<span class="cm">/* old shortform header  */</span>
	<span class="n">xfs_dir2_sf_hdr_t</span>	<span class="o">*</span><span class="n">sfp</span><span class="p">;</span>		<span class="cm">/* shortform header  */</span>
	<span class="n">__be16</span>			<span class="o">*</span><span class="n">tagp</span><span class="p">;</span>		<span class="cm">/* end of data entry */</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>		<span class="cm">/* transaction pointer */</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>		<span class="n">name</span><span class="p">;</span>

	<span class="n">trace_xfs_dir2_sf_to_block</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFINLINE</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Bomb out if the shortform directory is way too short.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">&lt;</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_dir2_sf_hdr_t</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">oldsfp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_sf_hdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_bytes</span> <span class="o">==</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">&gt;=</span> <span class="n">xfs_dir2_sf_hdr_size</span><span class="p">(</span><span class="n">oldsfp</span><span class="o">-&gt;</span><span class="n">i8count</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the directory into a temporary buffer.</span>
<span class="cm">	 * Then pitch the incore inode data so we can make extents.</span>
<span class="cm">	 */</span>
	<span class="n">sfp</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_bytes</span><span class="p">,</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">oldsfp</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_bytes</span><span class="p">);</span>

	<span class="n">xfs_idata_realloc</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="o">-</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_bytes</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add block 0 to the inode.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_grow_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">XFS_DIR2_DATA_SPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">sfp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initialize the data block.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_data_init</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">sfp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_BLOCK_MAGIC</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Compute size of block &quot;tail&quot; area.</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">btp</span><span class="p">)</span> <span class="o">+</span>
	    <span class="p">(</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_dir2_leaf_entry_t</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The whole thing is initialized to free by the init routine.</span>
<span class="cm">	 * Say we&#39;re using the leaf and tail area.</span>
<span class="cm">	 */</span>
	<span class="n">dup</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_unused_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">hdr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">needlog</span> <span class="o">=</span> <span class="n">needscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_dir2_data_use_free</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">dup</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblksize</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needlog</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">needscan</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">needscan</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fill in the tail.</span>
<span class="cm">	 */</span>
	<span class="n">btp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_tail_p</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/* ., .. */</span>
	<span class="n">btp</span><span class="o">-&gt;</span><span class="n">stale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">blp</span> <span class="o">=</span> <span class="n">xfs_dir2_block_leaf_p</span><span class="p">(</span><span class="n">btp</span><span class="p">);</span>
	<span class="n">endoffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">blp</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Remove the freespace, we&#39;ll manage it.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_dir2_data_use_free</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">dup</span><span class="p">,</span>
		<span class="p">(</span><span class="n">xfs_dir2_data_aoff_t</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dup</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">),</span>
		<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dup</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">needlog</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">needscan</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Create entry for .</span>
<span class="cm">	 */</span>
	<span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_entry_t</span> <span class="o">*</span><span class="p">)</span>
	      <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">XFS_DIR2_DATA_DOT_OFFSET</span><span class="p">);</span>
	<span class="n">dep</span><span class="o">-&gt;</span><span class="n">inumber</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;.&#39;</span><span class="p">;</span>
	<span class="n">tagp</span> <span class="o">=</span> <span class="n">xfs_dir2_data_entry_tag_p</span><span class="p">(</span><span class="n">dep</span><span class="p">);</span>
	<span class="o">*</span><span class="n">tagp</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dep</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>
	<span class="n">xfs_dir2_data_log_entry</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">dep</span><span class="p">);</span>
	<span class="n">blp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">xfs_dir_hash_dot</span><span class="p">);</span>
	<span class="n">blp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">xfs_dir2_byte_to_dataptr</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dep</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Create entry for ..</span>
<span class="cm">	 */</span>
	<span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_entry_t</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">XFS_DIR2_DATA_DOTDOT_OFFSET</span><span class="p">);</span>
	<span class="n">dep</span><span class="o">-&gt;</span><span class="n">inumber</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">xfs_dir2_sf_get_parent_ino</span><span class="p">(</span><span class="n">sfp</span><span class="p">));</span>
	<span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">dep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;.&#39;</span><span class="p">;</span>
	<span class="n">tagp</span> <span class="o">=</span> <span class="n">xfs_dir2_data_entry_tag_p</span><span class="p">(</span><span class="n">dep</span><span class="p">);</span>
	<span class="o">*</span><span class="n">tagp</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dep</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>
	<span class="n">xfs_dir2_data_log_entry</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">dep</span><span class="p">);</span>
	<span class="n">blp</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">xfs_dir_hash_dotdot</span><span class="p">);</span>
	<span class="n">blp</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">xfs_dir2_byte_to_dataptr</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dep</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">));</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">XFS_DIR2_DATA_FIRST_OFFSET</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Loop over existing entries, stuff them in.</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
		<span class="n">sfep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sfep</span> <span class="o">=</span> <span class="n">xfs_dir2_sf_firstentry</span><span class="p">(</span><span class="n">sfp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Need to preserve the existing offset values in the sf directory.</span>
<span class="cm">	 * Insert holes (unused entries) where necessary.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">endoffset</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * sfep is null when we reach the end of the list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sfep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">newoffset</span> <span class="o">=</span> <span class="n">endoffset</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">newoffset</span> <span class="o">=</span> <span class="n">xfs_dir2_sf_get_offset</span><span class="p">(</span><span class="n">sfep</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * There should be a hole here, make one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">newoffset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dup</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_unused_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
			<span class="n">dup</span><span class="o">-&gt;</span><span class="n">freetag</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_DATA_FREE_TAG</span><span class="p">);</span>
			<span class="n">dup</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">newoffset</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
			<span class="o">*</span><span class="n">xfs_dir2_data_unused_tag_p</span><span class="p">(</span><span class="n">dup</span><span class="p">)</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span>
				<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dup</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">));</span>
			<span class="n">xfs_dir2_data_log_unused</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">dup</span><span class="p">);</span>
			<span class="n">xfs_dir2_data_freeinsert</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="n">dup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">);</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dup</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Copy a real entry.</span>
<span class="cm">		 */</span>
		<span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_data_entry_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">newoffset</span><span class="p">);</span>
		<span class="n">dep</span><span class="o">-&gt;</span><span class="n">inumber</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">xfs_dir2_sfe_get_ino</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">sfep</span><span class="p">));</span>
		<span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">sfep</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sfep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dep</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
		<span class="n">tagp</span> <span class="o">=</span> <span class="n">xfs_dir2_data_entry_tag_p</span><span class="p">(</span><span class="n">dep</span><span class="p">);</span>
		<span class="o">*</span><span class="n">tagp</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dep</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>
		<span class="n">xfs_dir2_data_log_entry</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">dep</span><span class="p">);</span>
		<span class="n">name</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">sfep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">name</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">sfep</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
		<span class="n">blp</span><span class="p">[</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirnameops</span><span class="o">-&gt;</span>
							<span class="n">hashname</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">));</span>
		<span class="n">blp</span><span class="p">[</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">xfs_dir2_byte_to_dataptr</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
						 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dep</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">));</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">tagp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">==</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">sfep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">sfep</span> <span class="o">=</span> <span class="n">xfs_dir2_sf_nextentry</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">sfep</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Done with the temporary buffer */</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">sfp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Sort the leaf entries by hash value.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_sort</span><span class="p">(</span><span class="n">blp</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">blp</span><span class="p">),</span> <span class="n">xfs_dir2_block_sort</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Log the leaf entry area and tail.</span>
<span class="cm">	 * Already logged the header in data_init, ignore needlog.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">needscan</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">xfs_dir2_block_log_leaf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_dir2_block_log_tail</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_dir2_data_check</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
