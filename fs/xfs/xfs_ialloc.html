<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_ialloc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_ialloc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2002,2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_bit.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_inum.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_ialloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_ialloc.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_rtalloc.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap.h&quot;</span>


<span class="cm">/*</span>
<span class="cm"> * Allocation group level functions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xfs_ialloc_cluster_alignment</span><span class="p">(</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_hasalign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inoalignmt</span> <span class="o">&gt;=</span>
	     <span class="n">XFS_B_TO_FSBT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_INODE_CLUSTER_SIZE</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inoalignmt</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lookup a record by ino in the btree given by cur.</span>
<span class="cm"> */</span>
<span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_inobt_lookup</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_btree_cur</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>	<span class="cm">/* btree cursor */</span>
	<span class="n">xfs_agino_t</span>		<span class="n">ino</span><span class="p">,</span>	<span class="cm">/* starting inode of chunk */</span>
	<span class="n">xfs_lookup_t</span>		<span class="n">dir</span><span class="p">,</span>	<span class="cm">/* &lt;=, &gt;=, == */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">stat</span><span class="p">)</span>	<span class="cm">/* success/failure */</span>
<span class="p">{</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bc_rec</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">ir_startino</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bc_rec</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">ir_freecount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bc_rec</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">ir_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">xfs_btree_lookup</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the record referred to by cur to the value given.</span>
<span class="cm"> * This either works (return 0) or gets an EFSCORRUPTED error.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error */</span>
<span class="n">xfs_inobt_update</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_btree_cur</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>	<span class="cm">/* btree cursor */</span>
	<span class="n">xfs_inobt_rec_incore_t</span>	<span class="o">*</span><span class="n">irec</span><span class="p">)</span>	<span class="cm">/* btree record */</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">xfs_btree_rec</span>	<span class="n">rec</span><span class="p">;</span>

	<span class="n">rec</span><span class="p">.</span><span class="n">inobt</span><span class="p">.</span><span class="n">ir_startino</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">irec</span><span class="o">-&gt;</span><span class="n">ir_startino</span><span class="p">);</span>
	<span class="n">rec</span><span class="p">.</span><span class="n">inobt</span><span class="p">.</span><span class="n">ir_freecount</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">irec</span><span class="o">-&gt;</span><span class="n">ir_freecount</span><span class="p">);</span>
	<span class="n">rec</span><span class="p">.</span><span class="n">inobt</span><span class="p">.</span><span class="n">ir_free</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">irec</span><span class="o">-&gt;</span><span class="n">ir_free</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">xfs_btree_update</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the data from the pointed-to record.</span>
<span class="cm"> */</span>
<span class="kt">int</span>					<span class="cm">/* error */</span>
<span class="n">xfs_inobt_get_rec</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_btree_cur</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>	<span class="cm">/* btree cursor */</span>
	<span class="n">xfs_inobt_rec_incore_t</span>	<span class="o">*</span><span class="n">irec</span><span class="p">,</span>	<span class="cm">/* btree record */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">stat</span><span class="p">)</span>	<span class="cm">/* output: success/failure */</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">xfs_btree_rec</span>	<span class="o">*</span><span class="n">rec</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_get_rec</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">stat</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irec</span><span class="o">-&gt;</span><span class="n">ir_startino</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">inobt</span><span class="p">.</span><span class="n">ir_startino</span><span class="p">);</span>
		<span class="n">irec</span><span class="o">-&gt;</span><span class="n">ir_freecount</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">inobt</span><span class="p">.</span><span class="n">ir_freecount</span><span class="p">);</span>
		<span class="n">irec</span><span class="o">-&gt;</span><span class="n">ir_free</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">inobt</span><span class="p">.</span><span class="n">ir_free</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Verify that the number of free inodes in the AGI is correct.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef DEBUG</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_check_agi_freecount</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_btree_cur</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_agi</span>		<span class="o">*</span><span class="n">agi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">bc_nlevels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_inobt_rec_incore_t</span> <span class="n">rec</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">freecount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_lookup</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_LOOKUP_GE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_get_rec</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">freecount</span> <span class="o">+=</span> <span class="n">rec</span><span class="p">.</span><span class="n">ir_freecount</span><span class="p">;</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_increment</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">bc_mp</span><span class="p">))</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">freecount</span> <span class="o">==</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_freecount</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define xfs_check_agi_freecount(cur, agi)	0</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Initialise a new set of inodes.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_ialloc_inode_init</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>
	<span class="n">xfs_agnumber_t</span>		<span class="n">agno</span><span class="p">,</span>
	<span class="n">xfs_agblock_t</span>		<span class="n">agbno</span><span class="p">,</span>
	<span class="n">xfs_agblock_t</span>		<span class="n">length</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">gen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">fbuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_dinode</span>	<span class="o">*</span><span class="n">free</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">blks_per_cluster</span><span class="p">,</span> <span class="n">nbufs</span><span class="p">,</span> <span class="n">ninodes</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">version</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">d</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Loop over the new block(s), filling in the inodes.</span>
<span class="cm">	 * For small block sizes, manipulate the inodes in buffers</span>
<span class="cm">	 * which are multiples of the blocks size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span> <span class="o">&gt;=</span> <span class="n">XFS_INODE_CLUSTER_SIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">blks_per_cluster</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">nbufs</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">ninodes</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inopblock</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">blks_per_cluster</span> <span class="o">=</span> <span class="n">XFS_INODE_CLUSTER_SIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">/</span>
				   <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span><span class="p">;</span>
		<span class="n">nbufs</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">blks_per_cluster</span><span class="p">;</span>
		<span class="n">ninodes</span> <span class="o">=</span> <span class="n">blks_per_cluster</span> <span class="o">*</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inopblock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Figure out what version number to use in the inodes we create.</span>
<span class="cm">	 * If the superblock version has caught up to the one that supports</span>
<span class="cm">	 * the new inode format, then use the new inode version.  Otherwise</span>
<span class="cm">	 * use the old version so that old kernels will continue to be</span>
<span class="cm">	 * able to use the file system.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_hasnlink</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span>
		<span class="n">version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nbufs</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get the block.</span>
<span class="cm">		 */</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">XFS_AGB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">agbno</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">blks_per_cluster</span><span class="p">));</span>
		<span class="n">fbuf</span> <span class="o">=</span> <span class="n">xfs_trans_get_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span>
					 <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_bsize</span> <span class="o">*</span> <span class="n">blks_per_cluster</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fbuf</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Initialize all inodes in this buffer and then log them.</span>
<span class="cm">		 *</span>
<span class="cm">		 * XXX: It would be much better if we had just one transaction</span>
<span class="cm">		 *	to log a whole cluster of inodes instead of all the</span>
<span class="cm">		 *	individual transactions causing a lot of log traffic.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_buf_zero</span><span class="p">(</span><span class="n">fbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ninodes</span> <span class="o">&lt;&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodelog</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ninodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span>	<span class="n">ioffset</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodelog</span><span class="p">;</span>
			<span class="n">uint</span>	<span class="n">isize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_dinode</span><span class="p">);</span>

			<span class="n">free</span> <span class="o">=</span> <span class="n">xfs_make_iptr</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">fbuf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">free</span><span class="o">-&gt;</span><span class="n">di_magic</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DINODE_MAGIC</span><span class="p">);</span>
			<span class="n">free</span><span class="o">-&gt;</span><span class="n">di_version</span> <span class="o">=</span> <span class="n">version</span><span class="p">;</span>
			<span class="n">free</span><span class="o">-&gt;</span><span class="n">di_gen</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
			<span class="n">free</span><span class="o">-&gt;</span><span class="n">di_next_unlinked</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NULLAGINO</span><span class="p">);</span>
			<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">fbuf</span><span class="p">,</span> <span class="n">ioffset</span><span class="p">,</span> <span class="n">ioffset</span> <span class="o">+</span> <span class="n">isize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">xfs_trans_inode_alloc_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">fbuf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate new inodes in the allocation group specified by agbp.</span>
<span class="cm"> * Return 0 for success, else error code.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>				<span class="cm">/* error code or 0 */</span>
<span class="n">xfs_ialloc_ag_alloc</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agbp</span><span class="p">,</span>		<span class="cm">/* alloc group buffer */</span>
	<span class="kt">int</span>		<span class="o">*</span><span class="n">alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_agi_t</span>	<span class="o">*</span><span class="n">agi</span><span class="p">;</span>		<span class="cm">/* allocation group header */</span>
	<span class="n">xfs_alloc_arg_t</span>	<span class="n">args</span><span class="p">;</span>		<span class="cm">/* allocation argument structure */</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">cur</span><span class="p">;</span>		<span class="cm">/* inode btree cursor */</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_agino_t</span>	<span class="n">newino</span><span class="p">;</span>		<span class="cm">/* new first inode&#39;s number */</span>
	<span class="n">xfs_agino_t</span>	<span class="n">newlen</span><span class="p">;</span>		<span class="cm">/* new number of inodes */</span>
	<span class="n">xfs_agino_t</span>	<span class="n">thisino</span><span class="p">;</span>	<span class="cm">/* current inode number, for loop */</span>
	<span class="kt">int</span>		<span class="n">isaligned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* inode allocation at stripe unit */</span>
					<span class="cm">/* boundary */</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span> <span class="o">*</span><span class="n">pag</span><span class="p">;</span>

	<span class="n">args</span><span class="p">.</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tp</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">mp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Locking will ensure that we don&#39;t have two callers in here</span>
<span class="cm">	 * at one time.</span>
<span class="cm">	 */</span>
	<span class="n">newlen</span> <span class="o">=</span> <span class="n">XFS_IALLOC_INODES</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxicount</span> <span class="o">&amp;&amp;</span>
	    <span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_icount</span> <span class="o">+</span> <span class="n">newlen</span> <span class="o">&gt;</span> <span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxicount</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSPC</span><span class="p">);</span>
	<span class="n">args</span><span class="p">.</span><span class="n">minlen</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">maxlen</span> <span class="o">=</span> <span class="n">XFS_IALLOC_BLOCKS</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * First try to allocate inodes contiguous with the last-allocated</span>
<span class="cm">	 * chunk of inodes.  If the filesystem is striped, this will fill</span>
<span class="cm">	 * an entire stripe unit with inodes.</span>
<span class="cm"> 	 */</span>
	<span class="n">agi</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGI</span><span class="p">(</span><span class="n">agbp</span><span class="p">);</span>
	<span class="n">newino</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_newino</span><span class="p">);</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_seqno</span><span class="p">);</span>
	<span class="n">args</span><span class="p">.</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">XFS_AGINO_TO_AGBNO</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="p">,</span> <span class="n">newino</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">XFS_IALLOC_BLOCKS</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">newino</span> <span class="o">!=</span> <span class="n">NULLAGINO</span> <span class="o">&amp;&amp;</span>
		  <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">agbno</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_length</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">args</span><span class="p">.</span><span class="n">fsbno</span> <span class="o">=</span> <span class="n">XFS_AGB_TO_FSB</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">agbno</span><span class="p">);</span>
		<span class="n">args</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">XFS_ALLOCTYPE_THIS_BNO</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">total</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">wasdel</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">isfl</span> <span class="o">=</span>
			<span class="n">args</span><span class="p">.</span><span class="n">userdata</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">minalignslop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">prod</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need to take into account alignment here to ensure that</span>
<span class="cm">		 * we don&#39;t modify the free list if we fail to have an exact</span>
<span class="cm">		 * block. If we don&#39;t have an exact match, and every oher</span>
<span class="cm">		 * attempt allocation attempt fails, we&#39;ll end up cancelling</span>
<span class="cm">		 * a dirty transaction and shutting down.</span>
<span class="cm">		 *</span>
<span class="cm">		 * For an exact allocation, alignment must be 1,</span>
<span class="cm">		 * however we need to take cluster alignment into account when</span>
<span class="cm">		 * fixing up the freelist. Use the minalignslop field to</span>
<span class="cm">		 * indicate that extra blocks might be required for alignment,</span>
<span class="cm">		 * but not to use them in the actual exact allocation.</span>
<span class="cm">		 */</span>
		<span class="n">args</span><span class="p">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">minalignslop</span> <span class="o">=</span> <span class="n">xfs_ialloc_cluster_alignment</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Allow space for the inode btree to split. */</span>
		<span class="n">args</span><span class="p">.</span><span class="n">minleft</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_in_maxlevels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_vextent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">args</span><span class="p">.</span><span class="n">fsbno</span> <span class="o">=</span> <span class="n">NULLFSBLOCK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">fsbno</span> <span class="o">==</span> <span class="n">NULLFSBLOCK</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set the alignment for the allocation.</span>
<span class="cm">		 * If stripe alignment is turned on then align at stripe unit</span>
<span class="cm">		 * boundary.</span>
<span class="cm">		 * If the cluster size is smaller than a filesystem block</span>
<span class="cm">		 * then we&#39;re doing I/O for inodes in filesystem block size</span>
<span class="cm">		 * pieces, so don&#39;t need alignment anyway.</span>
<span class="cm">		 */</span>
		<span class="n">isaligned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sinoalign</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_NOALIGN</span><span class="p">));</span>
			<span class="n">args</span><span class="p">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span><span class="p">;</span>
			<span class="n">isaligned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">args</span><span class="p">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="n">xfs_ialloc_cluster_alignment</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Need to figure out where to allocate the inode blocks.</span>
<span class="cm">		 * Ideally they should be spaced out through the a.g.</span>
<span class="cm">		 * For now, just allocate blocks up front.</span>
<span class="cm">		 */</span>
		<span class="n">args</span><span class="p">.</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_root</span><span class="p">);</span>
		<span class="n">args</span><span class="p">.</span><span class="n">fsbno</span> <span class="o">=</span> <span class="n">XFS_AGB_TO_FSB</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">agbno</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allocate a fixed-size extent of inodes.</span>
<span class="cm">		 */</span>
		<span class="n">args</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">XFS_ALLOCTYPE_NEAR_BNO</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">total</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">wasdel</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">isfl</span> <span class="o">=</span>
			<span class="n">args</span><span class="p">.</span><span class="n">userdata</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">minalignslop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">prod</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allow space for the inode btree to split.</span>
<span class="cm">		 */</span>
		<span class="n">args</span><span class="p">.</span><span class="n">minleft</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_in_maxlevels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_vextent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If stripe alignment is turned on, then try again with cluster</span>
<span class="cm">	 * alignment.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isaligned</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="p">.</span><span class="n">fsbno</span> <span class="o">==</span> <span class="n">NULLFSBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">args</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">XFS_ALLOCTYPE_NEAR_BNO</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">agbno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_root</span><span class="p">);</span>
		<span class="n">args</span><span class="p">.</span><span class="n">fsbno</span> <span class="o">=</span> <span class="n">XFS_AGB_TO_FSB</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">agbno</span><span class="p">);</span>
		<span class="n">args</span><span class="p">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="n">xfs_ialloc_cluster_alignment</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_vextent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">fsbno</span> <span class="o">==</span> <span class="n">NULLFSBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">len</span> <span class="o">==</span> <span class="n">args</span><span class="p">.</span><span class="n">minlen</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stamp and write the inode buffers.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Seed the new inode cluster with a random generation number. This</span>
<span class="cm">	 * prevents short-term reuse of generation numbers if a chunk is</span>
<span class="cm">	 * freed and then immediately reallocated. We use random numbers</span>
<span class="cm">	 * rather than a linear progression to prevent the next generation</span>
<span class="cm">	 * number from being easily guessable.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ialloc_inode_init</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">agbno</span><span class="p">,</span>
			<span class="n">args</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">random32</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Convert the results.</span>
<span class="cm">	 */</span>
	<span class="n">newino</span> <span class="o">=</span> <span class="n">XFS_OFFBNO_TO_AGINO</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">agbno</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_count</span><span class="p">,</span> <span class="n">newlen</span><span class="p">);</span>
	<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_freecount</span><span class="p">,</span> <span class="n">newlen</span><span class="p">);</span>
	<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
	<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_freecount</span> <span class="o">+=</span> <span class="n">newlen</span><span class="p">;</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_newino</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">newino</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Insert records describing the new inode chunk into the btree.</span>
<span class="cm">	 */</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="n">xfs_inobt_init_cursor</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">thisino</span> <span class="o">=</span> <span class="n">newino</span><span class="p">;</span>
	     <span class="n">thisino</span> <span class="o">&lt;</span> <span class="n">newino</span> <span class="o">+</span> <span class="n">newlen</span><span class="p">;</span>
	     <span class="n">thisino</span> <span class="o">+=</span> <span class="n">XFS_INODES_PER_CHUNK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bc_rec</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">ir_startino</span> <span class="o">=</span> <span class="n">thisino</span><span class="p">;</span>
		<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bc_rec</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">ir_freecount</span> <span class="o">=</span> <span class="n">XFS_INODES_PER_CHUNK</span><span class="p">;</span>
		<span class="n">cur</span><span class="o">-&gt;</span><span class="n">bc_rec</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">ir_free</span> <span class="o">=</span> <span class="n">XFS_INOBT_ALL_FREE</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_lookup</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">XFS_LOOKUP_EQ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">XFS_BTREE_ERROR</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_insert</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">XFS_BTREE_ERROR</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Log allocation group header fields</span>
<span class="cm">	 */</span>
	<span class="n">xfs_ialloc_log_agi</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span>
		<span class="n">XFS_AGI_COUNT</span> <span class="o">|</span> <span class="n">XFS_AGI_FREECOUNT</span> <span class="o">|</span> <span class="n">XFS_AGI_NEWINO</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Modify/log superblock values for inode count and inode free count.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_ICOUNT</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">newlen</span><span class="p">);</span>
	<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_IFREE</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">newlen</span><span class="p">);</span>
	<span class="o">*</span><span class="n">alloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="n">xfs_agnumber_t</span>
<span class="n">xfs_ialloc_next_ag</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agirotor_lock</span><span class="p">);</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agirotor</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agirotor</span> <span class="o">==</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxagi</span><span class="p">)</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agirotor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agirotor_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">agno</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Select an allocation group to look for a free inode in, based on the parent</span>
<span class="cm"> * inode and then mode.  Return the allocation group buffer.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="n">xfs_buf_t</span> <span class="o">*</span>			<span class="cm">/* allocation group buffer */</span>
<span class="n">xfs_ialloc_ag_select</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_ino_t</span>	<span class="n">parent</span><span class="p">,</span>		<span class="cm">/* parent directory inode number */</span>
	<span class="n">umode_t</span>		<span class="n">mode</span><span class="p">,</span>		<span class="cm">/* bits set to indicate file type */</span>
	<span class="kt">int</span>		<span class="n">okalloc</span><span class="p">)</span>	<span class="cm">/* ok to allocate more space */</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agbp</span><span class="p">;</span>		<span class="cm">/* allocation group header buffer */</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agcount</span><span class="p">;</span>	<span class="cm">/* number of ag&#39;s in the filesystem */</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">;</span>		<span class="cm">/* current ag number */</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* alloc buffer locking flags */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">ineed</span><span class="p">;</span>		<span class="cm">/* blocks needed for inode allocation */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">longest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* longest extent available */</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* mount point structure */</span>
	<span class="kt">int</span>		<span class="n">needspace</span><span class="p">;</span>	<span class="cm">/* file mode implies space allocated */</span>
	<span class="n">xfs_perag_t</span>	<span class="o">*</span><span class="n">pag</span><span class="p">;</span>		<span class="cm">/* per allocation group data */</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">pagno</span><span class="p">;</span>		<span class="cm">/* parent (starting) ag number */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Files of these types need at least one block if length &gt; 0</span>
<span class="cm">	 * (and they won&#39;t fit in the inode, but that&#39;s hard to figure out).</span>
<span class="cm">	 */</span>
	<span class="n">needspace</span> <span class="o">=</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">mode</span><span class="p">);</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>
	<span class="n">agcount</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxagi</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="n">pagno</span> <span class="o">=</span> <span class="n">xfs_ialloc_next_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pagno</span> <span class="o">=</span> <span class="n">XFS_INO_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pagno</span> <span class="o">&gt;=</span> <span class="n">agcount</span><span class="p">)</span>
			<span class="n">pagno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">pagno</span> <span class="o">&lt;</span> <span class="n">agcount</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Loop through allocation groups, looking for one with a little</span>
<span class="cm">	 * free space in it.  Note we don&#39;t look for free inodes, exactly.</span>
<span class="cm">	 * Instead, we include whether there is a need to allocate inodes</span>
<span class="cm">	 * to mean that blocks must be allocated for them,</span>
<span class="cm">	 * if none are currently free.</span>
<span class="cm">	 */</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">pagno</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">XFS_ALLOC_FLAG_TRYLOCK</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_init</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xfs_ialloc_read_agi</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">agbp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">agbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">nextag</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">agbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_inodeok</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_ialloc_next_ag</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">unlock_nextag</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Is there enough free space for the file plus a block</span>
<span class="cm">		 * of inodes (if we need to allocate some)?</span>
<span class="cm">		 */</span>
		<span class="n">ineed</span> <span class="o">=</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_freecount</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">XFS_IALLOC_BLOCKS</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ineed</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_init</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">agbp</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
			    <span class="n">xfs_ialloc_read_agi</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">agbp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">agbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">nextag</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">xfs_alloc_pagf_init</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ineed</span> <span class="o">||</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_init</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ineed</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">longest</span> <span class="o">=</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_longest</span><span class="p">))</span>
				<span class="n">longest</span> <span class="o">=</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_flcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ineed</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_freeblks</span> <span class="o">&gt;=</span> <span class="n">needspace</span> <span class="o">+</span> <span class="n">ineed</span> <span class="o">&amp;&amp;</span>
			     <span class="n">longest</span> <span class="o">&gt;=</span> <span class="n">ineed</span> <span class="o">&amp;&amp;</span>
			     <span class="n">okalloc</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">agbp</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
				    <span class="n">xfs_ialloc_read_agi</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">agbp</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">agbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">nextag</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">agbp</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="nl">unlock_nextag:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">agbp</span><span class="p">)</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">);</span>
<span class="nl">nextag:</span>
		<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * No point in iterating over the rest, if we&#39;re shutting</span>
<span class="cm">		 * down.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">agno</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">agno</span> <span class="o">&gt;=</span> <span class="n">agcount</span><span class="p">)</span>
			<span class="n">agno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">agno</span> <span class="o">==</span> <span class="n">pagno</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to retrieve the next record to the left/right from the current one.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_ialloc_next_rec</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_btree_cur</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>
	<span class="n">xfs_inobt_rec_incore_t</span>	<span class="o">*</span><span class="n">rec</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">done</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">left</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>                     <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_decrement</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_increment</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="o">*</span><span class="n">done</span> <span class="o">=</span> <span class="o">!</span><span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_get_rec</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_ialloc_get_rec</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_btree_cur</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>
	<span class="n">xfs_agino_t</span>		<span class="n">agino</span><span class="p">,</span>
	<span class="n">xfs_inobt_rec_incore_t</span>	<span class="o">*</span><span class="n">rec</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">done</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">left</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>                     <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_lookup</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">agino</span><span class="p">,</span> <span class="n">XFS_LOOKUP_EQ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="o">*</span><span class="n">done</span> <span class="o">=</span> <span class="o">!</span><span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_get_rec</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_RETURN</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Visible inode allocation functions.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * Find a free (set) bit in the inode bitmask.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">xfs_ialloc_find_free</span><span class="p">(</span><span class="n">xfs_inofree_t</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfs_lowbit64</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate an inode on disk.</span>
<span class="cm"> * Mode is used to tell whether the new inode will need space, and whether</span>
<span class="cm"> * it is a directory.</span>
<span class="cm"> *</span>
<span class="cm"> * The arguments IO_agbp and alloc_done are defined to work within</span>
<span class="cm"> * the constraint of one allocation per transaction.</span>
<span class="cm"> * xfs_dialloc() is designed to be called twice if it has to do an</span>
<span class="cm"> * allocation to make more free inodes.  On the first call,</span>
<span class="cm"> * IO_agbp should be set to NULL. If an inode is available,</span>
<span class="cm"> * i.e., xfs_dialloc() did not need to do an allocation, an inode</span>
<span class="cm"> * number is returned.  In this case, IO_agbp would be set to the</span>
<span class="cm"> * current ag_buf and alloc_done set to false.</span>
<span class="cm"> * If an allocation needed to be done, xfs_dialloc would return</span>
<span class="cm"> * the current ag_buf in IO_agbp and set alloc_done to true.</span>
<span class="cm"> * The caller should then commit the current transaction, allocate a new</span>
<span class="cm"> * transaction, and call xfs_dialloc() again, passing in the previous</span>
<span class="cm"> * value of IO_agbp.  IO_agbp should be held across the transactions.</span>
<span class="cm"> * Since the agbp is locked across the two calls, the second call is</span>
<span class="cm"> * guaranteed to have a free inode available.</span>
<span class="cm"> *</span>
<span class="cm"> * Once we successfully pick an inode its number is returned and the</span>
<span class="cm"> * on-disk data structures are updated.  The inode itself is not read</span>
<span class="cm"> * in, since doing so would break ordering constraints with xfs_reclaim.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xfs_dialloc</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_ino_t</span>	<span class="n">parent</span><span class="p">,</span>		<span class="cm">/* parent inode (directory) */</span>
	<span class="n">umode_t</span>		<span class="n">mode</span><span class="p">,</span>		<span class="cm">/* mode bits for new inode */</span>
	<span class="kt">int</span>		<span class="n">okalloc</span><span class="p">,</span>	<span class="cm">/* ok to allocate more space */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">IO_agbp</span><span class="p">,</span>	<span class="cm">/* in/out ag header&#39;s buffer */</span>
	<span class="n">boolean_t</span>	<span class="o">*</span><span class="n">alloc_done</span><span class="p">,</span>	<span class="cm">/* true if we needed to replenish</span>
<span class="cm">					   inode freelist */</span>
	<span class="n">xfs_ino_t</span>	<span class="o">*</span><span class="n">inop</span><span class="p">)</span>		<span class="cm">/* inode number allocated */</span>
<span class="p">{</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agcount</span><span class="p">;</span>	<span class="cm">/* number of allocation groups */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agbp</span><span class="p">;</span>		<span class="cm">/* allocation group header&#39;s buffer */</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">;</span>		<span class="cm">/* allocation group number */</span>
	<span class="n">xfs_agi_t</span>	<span class="o">*</span><span class="n">agi</span><span class="p">;</span>		<span class="cm">/* allocation group header structure */</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">cur</span><span class="p">;</span>		<span class="cm">/* inode allocation btree cursor */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>		<span class="cm">/* error return value */</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>		<span class="cm">/* result code */</span>
	<span class="kt">int</span>		<span class="n">ialloced</span><span class="p">;</span>	<span class="cm">/* inode allocation status */</span>
	<span class="kt">int</span>		<span class="n">noroom</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* no space for inode blk allocation */</span>
	<span class="n">xfs_ino_t</span>	<span class="n">ino</span><span class="p">;</span>		<span class="cm">/* fs-relative inode to be returned */</span>
	<span class="cm">/* REFERENCED */</span>
	<span class="kt">int</span>		<span class="n">j</span><span class="p">;</span>		<span class="cm">/* result code */</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>		<span class="cm">/* file system mount structure */</span>
	<span class="kt">int</span>		<span class="n">offset</span><span class="p">;</span>		<span class="cm">/* index of inode in chunk */</span>
	<span class="n">xfs_agino_t</span>	<span class="n">pagino</span><span class="p">;</span>		<span class="cm">/* parent&#39;s AG relative inode # */</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">pagno</span><span class="p">;</span>		<span class="cm">/* parent&#39;s AG number */</span>
	<span class="n">xfs_inobt_rec_incore_t</span> <span class="n">rec</span><span class="p">;</span>	<span class="cm">/* inode allocation record */</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">tagno</span><span class="p">;</span>		<span class="cm">/* testing allocation group number */</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">tcur</span><span class="p">;</span>		<span class="cm">/* temp cursor */</span>
	<span class="n">xfs_inobt_rec_incore_t</span> <span class="n">trec</span><span class="p">;</span>	<span class="cm">/* temp inode allocation record */</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span> <span class="o">*</span><span class="n">pag</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">IO_agbp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We do not have an agbp, so select an initial allocation</span>
<span class="cm">		 * group for inode allocation.</span>
<span class="cm">		 */</span>
		<span class="n">agbp</span> <span class="o">=</span> <span class="n">xfs_ialloc_ag_select</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">okalloc</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Couldn&#39;t find an allocation group satisfying the</span>
<span class="cm">		 * criteria, give up.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">agbp</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">inop</span> <span class="o">=</span> <span class="n">NULLFSINO</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">agi</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGI</span><span class="p">(</span><span class="n">agbp</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_magicnum</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_AGI_MAGIC</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Continue where we left off before.  In this case, we</span>
<span class="cm">		 * know that the allocation group has free inodes.</span>
<span class="cm">		 */</span>
		<span class="n">agbp</span> <span class="o">=</span> <span class="o">*</span><span class="n">IO_agbp</span><span class="p">;</span>
		<span class="n">agi</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGI</span><span class="p">(</span><span class="n">agbp</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_magicnum</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_AGI_MAGIC</span><span class="p">));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_freecount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>
	<span class="n">agcount</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">;</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_seqno</span><span class="p">);</span>
	<span class="n">tagno</span> <span class="o">=</span> <span class="n">agno</span><span class="p">;</span>
	<span class="n">pagno</span> <span class="o">=</span> <span class="n">XFS_INO_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="n">pagino</span> <span class="o">=</span> <span class="n">XFS_INO_TO_AGINO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have already hit the ceiling of inode blocks then clear</span>
<span class="cm">	 * okalloc so we scan all available agi structures for a free</span>
<span class="cm">	 * inode.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxicount</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_icount</span> <span class="o">+</span> <span class="n">XFS_IALLOC_INODES</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxicount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">noroom</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">okalloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Loop until we find an allocation group that either has free inodes</span>
<span class="cm">	 * or in which we can allocate some inodes.  Iterate through the</span>
<span class="cm">	 * allocation groups upward, wrapping at the end.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">alloc_done</span> <span class="o">=</span> <span class="n">B_FALSE</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_freecount</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t do anything if we&#39;re not supposed to allocate</span>
<span class="cm">		 * any blocks, just go on to the next ag.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">okalloc</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Try to allocate some new inodes in the allocation</span>
<span class="cm">			 * group.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ialloc_ag_alloc</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ialloced</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
					<span class="o">*</span><span class="n">inop</span> <span class="o">=</span> <span class="n">NULLFSINO</span><span class="p">;</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ialloced</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We successfully allocated some inodes, return</span>
<span class="cm">				 * the current context to the caller so that it</span>
<span class="cm">				 * can commit the current transaction and call</span>
<span class="cm">				 * us again where we left off.</span>
<span class="cm">				 */</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_freecount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
				<span class="o">*</span><span class="n">alloc_done</span> <span class="o">=</span> <span class="n">B_TRUE</span><span class="p">;</span>
				<span class="o">*</span><span class="n">IO_agbp</span> <span class="o">=</span> <span class="n">agbp</span><span class="p">;</span>
				<span class="o">*</span><span class="n">inop</span> <span class="o">=</span> <span class="n">NULLFSINO</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it failed, give up on this ag.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Go on to the next ag: get its ag header.</span>
<span class="cm">		 */</span>
<span class="nl">nextag:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">tagno</span> <span class="o">==</span> <span class="n">agcount</span><span class="p">)</span>
			<span class="n">tagno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tagno</span> <span class="o">==</span> <span class="n">agno</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">inop</span> <span class="o">=</span> <span class="n">NULLFSINO</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">noroom</span> <span class="o">?</span> <span class="n">ENOSPC</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tagno</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_inodeok</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">nextag</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ialloc_read_agi</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">tagno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">agbp</span><span class="p">);</span>
		<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nextag</span><span class="p">;</span>
		<span class="n">agi</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGI</span><span class="p">(</span><span class="n">agbp</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_magicnum</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_AGI_MAGIC</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Here with an allocation group that has a free inode.</span>
<span class="cm">	 * Reset agno since we may have chosen a new ag in the</span>
<span class="cm">	 * loop above.</span>
<span class="cm">	 */</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">tagno</span><span class="p">;</span>
	<span class="o">*</span><span class="n">IO_agbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>

 <span class="nl">restart_pagno:</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="n">xfs_inobt_init_cursor</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_seqno</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * If pagino is 0 (this is the root inode allocation) use newino.</span>
<span class="cm">	 * This must work because we&#39;ve just allocated some.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pagino</span><span class="p">)</span>
		<span class="n">pagino</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_newino</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_check_agi_freecount</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">agi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If in the same AG as the parent, try to get near the parent.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pagno</span> <span class="o">==</span> <span class="n">agno</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>		<span class="n">doneleft</span><span class="p">;</span>	<span class="cm">/* done, to the left */</span>
		<span class="kt">int</span>		<span class="n">doneright</span><span class="p">;</span>	<span class="cm">/* done, to the right */</span>
		<span class="kt">int</span>		<span class="n">searchdistance</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_lookup</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">pagino</span><span class="p">,</span> <span class="n">XFS_LOOKUP_LE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_get_rec</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">j</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rec</span><span class="p">.</span><span class="n">ir_freecount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Found a free inode in the same chunk</span>
<span class="cm">			 * as the parent, done.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">alloc_inode</span><span class="p">;</span>
		<span class="p">}</span>


		<span class="cm">/*</span>
<span class="cm">		 * In the same AG as parent, but parent&#39;s chunk is full.</span>
<span class="cm">		 */</span>

		<span class="cm">/* duplicate the cursor, search left &amp; right simultaneously */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_dup_cursor</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcur</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Skip to last blocks looked up if same parent inode.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pagino</span> <span class="o">!=</span> <span class="n">NULLAGINO</span> <span class="o">&amp;&amp;</span>
		    <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_pagino</span> <span class="o">==</span> <span class="n">pagino</span> <span class="o">&amp;&amp;</span>
		    <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_leftrec</span> <span class="o">!=</span> <span class="n">NULLAGINO</span> <span class="o">&amp;&amp;</span>
		    <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_rightrec</span> <span class="o">!=</span> <span class="n">NULLAGINO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ialloc_get_rec</span><span class="p">(</span><span class="n">tcur</span><span class="p">,</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_leftrec</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">trec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doneleft</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>

			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ialloc_get_rec</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_rightrec</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doneright</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* search left with tcur, back up 1 record */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ialloc_next_rec</span><span class="p">(</span><span class="n">tcur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doneleft</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>

			<span class="cm">/* search right with cur, go forward 1 record. */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ialloc_next_rec</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doneright</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Loop until we find an inode chunk with a free inode.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">doneleft</span> <span class="o">||</span> <span class="o">!</span><span class="n">doneright</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span>	<span class="n">useleft</span><span class="p">;</span>  <span class="cm">/* using left inode chunk this time */</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">searchdistance</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Not in range - save last search</span>
<span class="cm">				 * location and allocate a new inode</span>
<span class="cm">				 */</span>
				<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">tcur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
				<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_leftrec</span> <span class="o">=</span> <span class="n">trec</span><span class="p">.</span><span class="n">ir_startino</span><span class="p">;</span>
				<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_rightrec</span> <span class="o">=</span> <span class="n">rec</span><span class="p">.</span><span class="n">ir_startino</span><span class="p">;</span>
				<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_pagino</span> <span class="o">=</span> <span class="n">pagino</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">newino</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* figure out the closer block if both are valid. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">doneleft</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">doneright</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">useleft</span> <span class="o">=</span> <span class="n">pagino</span> <span class="o">-</span>
				 <span class="p">(</span><span class="n">trec</span><span class="p">.</span><span class="n">ir_startino</span> <span class="o">+</span> <span class="n">XFS_INODES_PER_CHUNK</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span>
				  <span class="n">rec</span><span class="p">.</span><span class="n">ir_startino</span> <span class="o">-</span> <span class="n">pagino</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">useleft</span> <span class="o">=</span> <span class="o">!</span><span class="n">doneleft</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* free inodes to the left? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">useleft</span> <span class="o">&amp;&amp;</span> <span class="n">trec</span><span class="p">.</span><span class="n">ir_freecount</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rec</span> <span class="o">=</span> <span class="n">trec</span><span class="p">;</span>
				<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
				<span class="n">cur</span> <span class="o">=</span> <span class="n">tcur</span><span class="p">;</span>

				<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_leftrec</span> <span class="o">=</span> <span class="n">trec</span><span class="p">.</span><span class="n">ir_startino</span><span class="p">;</span>
				<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_rightrec</span> <span class="o">=</span> <span class="n">rec</span><span class="p">.</span><span class="n">ir_startino</span><span class="p">;</span>
				<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_pagino</span> <span class="o">=</span> <span class="n">pagino</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">alloc_inode</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* free inodes to the right? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">useleft</span> <span class="o">&amp;&amp;</span> <span class="n">rec</span><span class="p">.</span><span class="n">ir_freecount</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">tcur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>

				<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_leftrec</span> <span class="o">=</span> <span class="n">trec</span><span class="p">.</span><span class="n">ir_startino</span><span class="p">;</span>
				<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_rightrec</span> <span class="o">=</span> <span class="n">rec</span><span class="p">.</span><span class="n">ir_startino</span><span class="p">;</span>
				<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_pagino</span> <span class="o">=</span> <span class="n">pagino</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">alloc_inode</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* get next record to check */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">useleft</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ialloc_next_rec</span><span class="p">(</span><span class="n">tcur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trec</span><span class="p">,</span>
								 <span class="o">&amp;</span><span class="n">doneleft</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ialloc_next_rec</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">,</span>
								 <span class="o">&amp;</span><span class="n">doneright</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We&#39;ve reached the end of the btree. because</span>
<span class="cm">		 * we are only searching a small chunk of the</span>
<span class="cm">		 * btree each search, there is obviously free</span>
<span class="cm">		 * inodes closer to the parent inode than we</span>
<span class="cm">		 * are now. restart the search again.</span>
<span class="cm">		 */</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_pagino</span> <span class="o">=</span> <span class="n">NULLAGINO</span><span class="p">;</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_leftrec</span> <span class="o">=</span> <span class="n">NULLAGINO</span><span class="p">;</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagl_rightrec</span> <span class="o">=</span> <span class="n">NULLAGINO</span><span class="p">;</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">tcur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
		<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart_pagno</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * In a different AG from the parent.</span>
<span class="cm">	 * See if the most recently allocated block has any free.</span>
<span class="cm">	 */</span>
<span class="nl">newino:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_newino</span> <span class="o">!=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NULLAGINO</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_lookup</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_newino</span><span class="p">),</span>
					 <span class="n">XFS_LOOKUP_EQ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_get_rec</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">j</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">rec</span><span class="p">.</span><span class="n">ir_freecount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * The last chunk allocated in the group</span>
<span class="cm">				 * still has a free inode.</span>
<span class="cm">				 */</span>
				<span class="k">goto</span> <span class="n">alloc_inode</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * None left in the last group, search the whole AG</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_lookup</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_LOOKUP_GE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_get_rec</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rec</span><span class="p">.</span><span class="n">ir_freecount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_increment</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">alloc_inode:</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">xfs_ialloc_find_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rec</span><span class="p">.</span><span class="n">ir_free</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">XFS_INODES_PER_CHUNK</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">XFS_AGINO_TO_OFFSET</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">rec</span><span class="p">.</span><span class="n">ir_startino</span><span class="p">)</span> <span class="o">%</span>
				   <span class="n">XFS_INODES_PER_CHUNK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">XFS_AGINO_TO_INO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">rec</span><span class="p">.</span><span class="n">ir_startino</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">rec</span><span class="p">.</span><span class="n">ir_free</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XFS_INOBT_MASK</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">rec</span><span class="p">.</span><span class="n">ir_freecount</span><span class="o">--</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_update</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_freecount</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_ialloc_log_agi</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">XFS_AGI_FREECOUNT</span><span class="p">);</span>
	<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_freecount</span><span class="o">--</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_check_agi_freecount</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">agi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>

	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_IFREE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="o">*</span><span class="n">inop</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error1:</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">tcur</span><span class="p">,</span> <span class="n">XFS_BTREE_ERROR</span><span class="p">);</span>
<span class="nl">error0:</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">XFS_BTREE_ERROR</span><span class="p">);</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free disk inode.  Carefully avoids touching the incore inode, all</span>
<span class="cm"> * manipulations incore are the caller&#39;s responsibility.</span>
<span class="cm"> * The on-disk inode is not changed by this operation, only the</span>
<span class="cm"> * btree (free inode mask) is changed.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xfs_difree</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_ino_t</span>	<span class="n">inode</span><span class="p">,</span>		<span class="cm">/* inode to be freed */</span>
	<span class="n">xfs_bmap_free_t</span>	<span class="o">*</span><span class="n">flist</span><span class="p">,</span>		<span class="cm">/* extents to free */</span>
	<span class="kt">int</span>		<span class="o">*</span><span class="n">delete</span><span class="p">,</span>	<span class="cm">/* set if inode cluster was deleted */</span>
	<span class="n">xfs_ino_t</span>	<span class="o">*</span><span class="n">first_ino</span><span class="p">)</span>	<span class="cm">/* first inode in deleted cluster */</span>
<span class="p">{</span>
	<span class="cm">/* REFERENCED */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">agbno</span><span class="p">;</span>	<span class="cm">/* block number containing inode */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agbp</span><span class="p">;</span>	<span class="cm">/* buffer containing allocation group header */</span>
	<span class="n">xfs_agino_t</span>	<span class="n">agino</span><span class="p">;</span>	<span class="cm">/* inode number relative to allocation group */</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">;</span>	<span class="cm">/* allocation group number */</span>
	<span class="n">xfs_agi_t</span>	<span class="o">*</span><span class="n">agi</span><span class="p">;</span>	<span class="cm">/* allocation group header */</span>
	<span class="n">xfs_btree_cur_t</span>	<span class="o">*</span><span class="n">cur</span><span class="p">;</span>	<span class="cm">/* inode btree cursor */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>	<span class="cm">/* error return value */</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>	<span class="cm">/* result code */</span>
	<span class="kt">int</span>		<span class="n">ilen</span><span class="p">;</span>	<span class="cm">/* inodes in an inode cluster */</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>	<span class="cm">/* mount structure for filesystem */</span>
	<span class="kt">int</span>		<span class="n">off</span><span class="p">;</span>	<span class="cm">/* offset of inode in inode chunk */</span>
	<span class="n">xfs_inobt_rec_incore_t</span> <span class="n">rec</span><span class="p">;</span>	<span class="cm">/* btree record */</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span> <span class="o">*</span><span class="n">pag</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Break up inode number into its components.</span>
<span class="cm">	 */</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">XFS_INO_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">agno</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">)</span>  <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: agno &gt;= mp-&gt;m_sb.sb_agcount (%d &gt;= %d).&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">agino</span> <span class="o">=</span> <span class="n">XFS_INO_TO_AGINO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">!=</span> <span class="n">XFS_AGINO_TO_INO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">agino</span><span class="p">))</span>  <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: inode != XFS_AGINO_TO_INO() (%llu != %llu).&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">inode</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">XFS_AGINO_TO_INO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">agino</span><span class="p">));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">agbno</span> <span class="o">=</span> <span class="n">XFS_AGINO_TO_AGBNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">agbno</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agblocks</span><span class="p">)</span>  <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: agbno &gt;= mp-&gt;m_sb.sb_agblocks (%d &gt;= %d).&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">agbno</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agblocks</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the allocation group header.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ialloc_read_agi</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">agbp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: xfs_ialloc_read_agi() returned error %d.&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">agi</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGI</span><span class="p">(</span><span class="n">agbp</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_magicnum</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_AGI_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">agbno</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_length</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initialize the cursor.</span>
<span class="cm">	 */</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="n">xfs_inobt_init_cursor</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_check_agi_freecount</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">agi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look for the entry describing this inode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_lookup</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">agino</span><span class="p">,</span> <span class="n">XFS_LOOKUP_LE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: xfs_inobt_lookup() returned error %d.&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_get_rec</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: xfs_inobt_get_rec() returned error %d.&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">XFS_WANT_CORRUPTED_GOTO</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">error0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the offset in the inode chunk.</span>
<span class="cm">	 */</span>
	<span class="n">off</span> <span class="o">=</span> <span class="n">agino</span> <span class="o">-</span> <span class="n">rec</span><span class="p">.</span><span class="n">ir_startino</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">off</span> <span class="o">&lt;</span> <span class="n">XFS_INODES_PER_CHUNK</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rec</span><span class="p">.</span><span class="n">ir_free</span> <span class="o">&amp;</span> <span class="n">XFS_INOBT_MASK</span><span class="p">(</span><span class="n">off</span><span class="p">)));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Mark the inode free &amp; increment the count.</span>
<span class="cm">	 */</span>
	<span class="n">rec</span><span class="p">.</span><span class="n">ir_free</span> <span class="o">|=</span> <span class="n">XFS_INOBT_MASK</span><span class="p">(</span><span class="n">off</span><span class="p">);</span>
	<span class="n">rec</span><span class="p">.</span><span class="n">ir_freecount</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When an inode cluster is free, it becomes eligible for removal</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_IKEEP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">rec</span><span class="p">.</span><span class="n">ir_freecount</span> <span class="o">==</span> <span class="n">XFS_IALLOC_INODES</span><span class="p">(</span><span class="n">mp</span><span class="p">)))</span> <span class="p">{</span>

		<span class="o">*</span><span class="n">delete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">first_ino</span> <span class="o">=</span> <span class="n">XFS_AGINO_TO_INO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">rec</span><span class="p">.</span><span class="n">ir_startino</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Remove the inode cluster from the AGI B+Tree, adjust the</span>
<span class="cm">		 * AGI and Superblock inode counts, and mark the disk space</span>
<span class="cm">		 * to be freed when the transaction is committed.</span>
<span class="cm">		 */</span>
		<span class="n">ilen</span> <span class="o">=</span> <span class="n">XFS_IALLOC_INODES</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_count</span><span class="p">,</span> <span class="o">-</span><span class="n">ilen</span><span class="p">);</span>
		<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_freecount</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">ilen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">xfs_ialloc_log_agi</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">XFS_AGI_COUNT</span> <span class="o">|</span> <span class="n">XFS_AGI_FREECOUNT</span><span class="p">);</span>
		<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_freecount</span> <span class="o">-=</span> <span class="n">ilen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
		<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_ICOUNT</span><span class="p">,</span> <span class="o">-</span><span class="n">ilen</span><span class="p">);</span>
		<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_IFREE</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">ilen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_btree_delete</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: xfs_btree_delete returned error %d.&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">xfs_bmap_add_free</span><span class="p">(</span><span class="n">XFS_AGB_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
				<span class="n">agno</span><span class="p">,</span> <span class="n">XFS_INO_TO_AGBNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span><span class="n">rec</span><span class="p">.</span><span class="n">ir_startino</span><span class="p">)),</span>
				<span class="n">XFS_IALLOC_BLOCKS</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="n">flist</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">delete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_update</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: xfs_inobt_update returned error %d.&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* </span>
<span class="cm">		 * Change the inode free counts and log the ag/sb changes.</span>
<span class="cm">		 */</span>
		<span class="n">be32_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_freecount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">xfs_ialloc_log_agi</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">XFS_AGI_FREECOUNT</span><span class="p">);</span>
		<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_freecount</span><span class="o">++</span><span class="p">;</span>
		<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
		<span class="n">xfs_trans_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_IFREE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_check_agi_freecount</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">agi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>

	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error0:</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">XFS_BTREE_ERROR</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_imap_lookup</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>
	<span class="n">xfs_agnumber_t</span>		<span class="n">agno</span><span class="p">,</span>
	<span class="n">xfs_agino_t</span>		<span class="n">agino</span><span class="p">,</span>
	<span class="n">xfs_agblock_t</span>		<span class="n">agbno</span><span class="p">,</span>
	<span class="n">xfs_agblock_t</span>		<span class="o">*</span><span class="n">chunk_agbno</span><span class="p">,</span>
	<span class="n">xfs_agblock_t</span>		<span class="o">*</span><span class="n">offset_agbno</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_inobt_rec_incore</span> <span class="n">rec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_btree_cur</span>	<span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">agbp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ialloc_read_agi</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">agbp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
			<span class="s">&quot;%s: xfs_ialloc_read_agi() returned error %d, agno %d&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lookup the inode record for the given agino. If the record cannot be</span>
<span class="cm">	 * found, then it&#39;s an invalid inode number and we should abort. Once</span>
<span class="cm">	 * we have a record, we need to ensure it contains the inode number</span>
<span class="cm">	 * we are looking up.</span>
<span class="cm">	 */</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="n">xfs_inobt_init_cursor</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_lookup</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">agino</span><span class="p">,</span> <span class="n">XFS_LOOKUP_LE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inobt_get_rec</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agbp</span><span class="p">);</span>
	<span class="n">xfs_btree_del_cursor</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">XFS_BTREE_NOERROR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* check that the returned record contains the required inode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rec</span><span class="p">.</span><span class="n">ir_startino</span> <span class="o">&gt;</span> <span class="n">agino</span> <span class="o">||</span>
	    <span class="n">rec</span><span class="p">.</span><span class="n">ir_startino</span> <span class="o">+</span> <span class="n">XFS_IALLOC_INODES</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">agino</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* for untrusted inodes check it is allocated first */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_IGET_UNTRUSTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">rec</span><span class="p">.</span><span class="n">ir_free</span> <span class="o">&amp;</span> <span class="n">XFS_INOBT_MASK</span><span class="p">(</span><span class="n">agino</span> <span class="o">-</span> <span class="n">rec</span><span class="p">.</span><span class="n">ir_startino</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">EINVAL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">chunk_agbno</span> <span class="o">=</span> <span class="n">XFS_AGINO_TO_AGBNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">rec</span><span class="p">.</span><span class="n">ir_startino</span><span class="p">);</span>
	<span class="o">*</span><span class="n">offset_agbno</span> <span class="o">=</span> <span class="n">agbno</span> <span class="o">-</span> <span class="o">*</span><span class="n">chunk_agbno</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the location of the inode in imap, for mapping it into a buffer.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xfs_imap</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	 <span class="o">*</span><span class="n">mp</span><span class="p">,</span>	<span class="cm">/* file system mount structure */</span>
	<span class="n">xfs_trans_t</span>	 <span class="o">*</span><span class="n">tp</span><span class="p">,</span>	<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_ino_t</span>	<span class="n">ino</span><span class="p">,</span>	<span class="cm">/* inode to locate */</span>
	<span class="k">struct</span> <span class="n">xfs_imap</span>	<span class="o">*</span><span class="n">imap</span><span class="p">,</span>	<span class="cm">/* location map structure */</span>
	<span class="n">uint</span>		<span class="n">flags</span><span class="p">)</span>	<span class="cm">/* flags for inode btree lookup */</span>
<span class="p">{</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">agbno</span><span class="p">;</span>	<span class="cm">/* block number of inode in the alloc group */</span>
	<span class="n">xfs_agino_t</span>	<span class="n">agino</span><span class="p">;</span>	<span class="cm">/* inode number within alloc group */</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">;</span>	<span class="cm">/* allocation group number */</span>
	<span class="kt">int</span>		<span class="n">blks_per_cluster</span><span class="p">;</span> <span class="cm">/* num blocks per inode cluster */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">chunk_agbno</span><span class="p">;</span>	<span class="cm">/* first block in inode chunk */</span>
	<span class="n">xfs_agblock_t</span>	<span class="n">cluster_agbno</span><span class="p">;</span>	<span class="cm">/* first block in inode cluster */</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>	<span class="cm">/* error code */</span>
	<span class="kt">int</span>		<span class="n">offset</span><span class="p">;</span>	<span class="cm">/* index of inode in its buffer */</span>
	<span class="kt">int</span>		<span class="n">offset_agbno</span><span class="p">;</span>	<span class="cm">/* blks from chunk start to inode */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ino</span> <span class="o">!=</span> <span class="n">NULLFSINO</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Split up the inode number into its parts.</span>
<span class="cm">	 */</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">XFS_INO_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="n">agino</span> <span class="o">=</span> <span class="n">XFS_INO_TO_AGINO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="n">agbno</span> <span class="o">=</span> <span class="n">XFS_AGINO_TO_AGBNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">agno</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span> <span class="o">||</span> <span class="n">agbno</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agblocks</span> <span class="o">||</span>
	    <span class="n">ino</span> <span class="o">!=</span> <span class="n">XFS_AGINO_TO_INO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">agino</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t output diagnostic information for untrusted inodes</span>
<span class="cm">		 * as they can be invalid without implying corruption.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_IGET_UNTRUSTED</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">agno</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
				<span class="s">&quot;%s: agno (%d) &gt;= mp-&gt;m_sb.sb_agcount (%d)&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">agbno</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agblocks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
		<span class="s">&quot;%s: agbno (0x%llx) &gt;= mp-&gt;m_sb.sb_agblocks (0x%lx)&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">agbno</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agblocks</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">!=</span> <span class="n">XFS_AGINO_TO_INO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">agino</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
		<span class="s">&quot;%s: ino (0x%llx) != XFS_AGINO_TO_INO() (0x%llx)&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span>
				<span class="n">XFS_AGINO_TO_INO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">agino</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">xfs_stack_trace</span><span class="p">();</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">blks_per_cluster</span> <span class="o">=</span> <span class="n">XFS_INODE_CLUSTER_SIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocklog</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For bulkstat and handle lookups, we have an untrusted inode number</span>
<span class="cm">	 * that we have to verify is valid. We cannot do this just by reading</span>
<span class="cm">	 * the inode buffer as it may have been unlinked and removed leaving</span>
<span class="cm">	 * inodes in stale state on disk. Hence we have to do a btree lookup</span>
<span class="cm">	 * in all cases where an untrusted inode number is passed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_IGET_UNTRUSTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_imap_lookup</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">agino</span><span class="p">,</span> <span class="n">agbno</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">chunk_agbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset_agbno</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_map</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the inode cluster size is the same as the blocksize or</span>
<span class="cm">	 * smaller we get to the buffer by simple arithmetics.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_INODE_CLUSTER_SIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">XFS_INO_TO_OFFSET</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inopblock</span><span class="p">);</span>

		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_blkno</span> <span class="o">=</span> <span class="n">XFS_AGB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">agbno</span><span class="p">);</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_len</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_boffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodelog</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the inode chunks are aligned then use simple maths to</span>
<span class="cm">	 * find the location. Otherwise we have to do a btree</span>
<span class="cm">	 * lookup to find the location.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inoalign_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset_agbno</span> <span class="o">=</span> <span class="n">agbno</span> <span class="o">&amp;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inoalign_mask</span><span class="p">;</span>
		<span class="n">chunk_agbno</span> <span class="o">=</span> <span class="n">agbno</span> <span class="o">-</span> <span class="n">offset_agbno</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_imap_lookup</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">agino</span><span class="p">,</span> <span class="n">agbno</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">chunk_agbno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset_agbno</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_map:</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">agbno</span> <span class="o">&gt;=</span> <span class="n">chunk_agbno</span><span class="p">);</span>
	<span class="n">cluster_agbno</span> <span class="o">=</span> <span class="n">chunk_agbno</span> <span class="o">+</span>
		<span class="p">((</span><span class="n">offset_agbno</span> <span class="o">/</span> <span class="n">blks_per_cluster</span><span class="p">)</span> <span class="o">*</span> <span class="n">blks_per_cluster</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">agbno</span> <span class="o">-</span> <span class="n">cluster_agbno</span><span class="p">)</span> <span class="o">*</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inopblock</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">XFS_INO_TO_OFFSET</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>

	<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_blkno</span> <span class="o">=</span> <span class="n">XFS_AGB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">cluster_agbno</span><span class="p">);</span>
	<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_len</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">blks_per_cluster</span><span class="p">);</span>
	<span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_boffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">ushort</span><span class="p">)(</span><span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodelog</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the inode number maps to a block outside the bounds</span>
<span class="cm">	 * of the file system then return NULL rather than calling</span>
<span class="cm">	 * read_buf and panicing when we get an error from the</span>
<span class="cm">	 * driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_blkno</span> <span class="o">+</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_len</span><span class="p">)</span> <span class="o">&gt;</span>
	    <span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_dblocks</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
	<span class="s">&quot;%s: (im_blkno (0x%llx) + im_len (0x%llx)) &gt; sb_dblocks (0x%llx)&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_blkno</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_len</span><span class="p">,</span>
			<span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_dblocks</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compute and fill in value of m_in_maxlevels.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="n">xfs_ialloc_compute_maxlevels</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>		<span class="cm">/* file system mount structure */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">level</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">maxblocks</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">maxleafents</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">minleafrecs</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">minnoderecs</span><span class="p">;</span>

	<span class="n">maxleafents</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="n">XFS_INO_AGINO_BITS</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
		<span class="n">XFS_INODES_PER_CHUNK_LOG</span><span class="p">;</span>
	<span class="n">minleafrecs</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_alloc_mnr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">minnoderecs</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_alloc_mnr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">maxblocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxleafents</span> <span class="o">+</span> <span class="n">minleafrecs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">minleafrecs</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">maxblocks</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span>
		<span class="n">maxblocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxblocks</span> <span class="o">+</span> <span class="n">minnoderecs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">minnoderecs</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_in_maxlevels</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Log specified fields for the ag hdr (inode section)</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="n">xfs_ialloc_log_agi</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">,</span>		<span class="cm">/* allocation group header buffer */</span>
	<span class="kt">int</span>		<span class="n">fields</span><span class="p">)</span>		<span class="cm">/* bitmask of fields to log */</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">first</span><span class="p">;</span>		<span class="cm">/* first byte number */</span>
	<span class="kt">int</span>			<span class="n">last</span><span class="p">;</span>		<span class="cm">/* last byte number */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">short</span>	<span class="n">offsets</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>	<span class="cm">/* field starting offsets */</span>
					<span class="cm">/* keep in sync with bit definitions */</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">,</span> <span class="n">agi_magicnum</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">,</span> <span class="n">agi_versionnum</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">,</span> <span class="n">agi_seqno</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">,</span> <span class="n">agi_length</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">,</span> <span class="n">agi_count</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">,</span> <span class="n">agi_root</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">,</span> <span class="n">agi_level</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">,</span> <span class="n">agi_freecount</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">,</span> <span class="n">agi_newino</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">,</span> <span class="n">agi_dirino</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">,</span> <span class="n">agi_unlinked</span><span class="p">),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">)</span>
	<span class="p">};</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">xfs_agi_t</span>		<span class="o">*</span><span class="n">agi</span><span class="p">;</span>	<span class="cm">/* allocation group header */</span>

	<span class="n">agi</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGI</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_magicnum</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_AGI_MAGIC</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Compute byte offsets for the first and last fields.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_btree_offsets</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">XFS_AGI_NUM_BITS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Log the allocation group inode header buffer.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="n">xfs_check_agi_unlinked</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_agi</span>		<span class="o">*</span><span class="n">agi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">XFS_AGI_UNLINKED_BUCKETS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_unlinked</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define xfs_check_agi_unlinked(agi)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Read in the allocation group header (inode allocation section)</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xfs_read_agi</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>	<span class="cm">/* file system mount structure */</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>	<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_agnumber_t</span>		<span class="n">agno</span><span class="p">,</span>	<span class="cm">/* allocation group number */</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">**</span><span class="n">bpp</span><span class="p">)</span>	<span class="cm">/* allocation group hdr buf */</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_agi</span>		<span class="o">*</span><span class="n">agi</span><span class="p">;</span>	<span class="cm">/* allocation group header */</span>
	<span class="kt">int</span>			<span class="n">agi_ok</span><span class="p">;</span>	<span class="cm">/* agi is consistent */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">agno</span> <span class="o">!=</span> <span class="n">NULLAGNUMBER</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_read_buf</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span>
			<span class="n">XFS_AG_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">XFS_AGI_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">)),</span>
			<span class="n">XFS_FSS_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bpp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">xfs_buf_geterror</span><span class="p">(</span><span class="o">*</span><span class="n">bpp</span><span class="p">));</span>
	<span class="n">agi</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGI</span><span class="p">(</span><span class="o">*</span><span class="n">bpp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate the magic number of the agi block.</span>
<span class="cm">	 */</span>
	<span class="n">agi_ok</span> <span class="o">=</span> <span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_magicnum</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_AGI_MAGIC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">XFS_AGI_GOOD_VERSION</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_versionnum</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_seqno</span><span class="p">)</span> <span class="o">==</span> <span class="n">agno</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">XFS_TEST_ERROR</span><span class="p">(</span><span class="o">!</span><span class="n">agi_ok</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">XFS_ERRTAG_IALLOC_READ_AGI</span><span class="p">,</span>
			<span class="n">XFS_RANDOM_IALLOC_READ_AGI</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_read_agi&quot;</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
				     <span class="n">mp</span><span class="p">,</span> <span class="n">agi</span><span class="p">);</span>
		<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="o">*</span><span class="n">bpp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xfs_buf_set_ref</span><span class="p">(</span><span class="o">*</span><span class="n">bpp</span><span class="p">,</span> <span class="n">XFS_AGI_REF</span><span class="p">);</span>

	<span class="n">xfs_check_agi_unlinked</span><span class="p">(</span><span class="n">agi</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">xfs_ialloc_read_agi</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>	<span class="cm">/* file system mount structure */</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>	<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_agnumber_t</span>		<span class="n">agno</span><span class="p">,</span>	<span class="cm">/* allocation group number */</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">**</span><span class="n">bpp</span><span class="p">)</span>	<span class="cm">/* allocation group hdr buf */</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_agi</span>		<span class="o">*</span><span class="n">agi</span><span class="p">;</span>	<span class="cm">/* allocation group header */</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span>	<span class="o">*</span><span class="n">pag</span><span class="p">;</span>	<span class="cm">/* per allocation group data */</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_read_agi</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">bpp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">agi</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGI</span><span class="p">(</span><span class="o">*</span><span class="n">bpp</span><span class="p">);</span>
	<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_init</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_freecount</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_freecount</span><span class="p">);</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_count</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_count</span><span class="p">);</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_init</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s possible for these to be out of sync if</span>
<span class="cm">	 * we are in the middle of a forced shutdown.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_freecount</span> <span class="o">==</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_freecount</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read in the agi to initialise the per-ag data in the mount structure</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xfs_ialloc_pagi_init</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>		<span class="cm">/* file system mount structure */</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>		<span class="cm">/* transaction pointer */</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">)</span>		<span class="cm">/* allocation group number */</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ialloc_read_agi</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="p">)</span>
		<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
