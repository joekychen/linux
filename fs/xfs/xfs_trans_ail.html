<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_trans_ail.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_trans_ail.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2002,2005 Silicon Graphics, Inc.</span>
<span class="cm"> * Copyright (c) 2008 Dave Chinner</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_trans_priv.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cm">/*</span>
<span class="cm"> * Check that the list is sorted as it should be.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_ail_check</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>	<span class="o">*</span><span class="n">ailp</span><span class="p">,</span>
	<span class="n">xfs_log_item_t</span>	<span class="o">*</span><span class="n">lip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_log_item_t</span>	<span class="o">*</span><span class="n">prev_lip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check the next and previous entries are valid.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_flags</span> <span class="o">&amp;</span> <span class="n">XFS_LI_IN_AIL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">prev_lip</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_ail</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">xfs_log_item_t</span><span class="p">,</span> <span class="n">li_ail</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">prev_lip</span><span class="o">-&gt;</span><span class="n">li_ail</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">)</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_LSN_CMP</span><span class="p">(</span><span class="n">prev_lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">,</span> <span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">prev_lip</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_ail</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">xfs_log_item_t</span><span class="p">,</span> <span class="n">li_ail</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">prev_lip</span><span class="o">-&gt;</span><span class="n">li_ail</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">)</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_LSN_CMP</span><span class="p">(</span><span class="n">prev_lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">,</span> <span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>


<span class="cp">#ifdef XFS_TRANS_DEBUG</span>
	<span class="cm">/*</span>
<span class="cm">	 * Walk the list checking lsn ordering, and that every entry has the</span>
<span class="cm">	 * XFS_LI_IN_AIL flag set. This is really expensive, so only do it</span>
<span class="cm">	 * when specifically debugging the transaction subsystem.</span>
<span class="cm">	 */</span>
	<span class="n">prev_lip</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">,</span> <span class="n">xfs_log_item_t</span><span class="p">,</span> <span class="n">li_ail</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">,</span> <span class="n">li_ail</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">prev_lip</span><span class="o">-&gt;</span><span class="n">li_ail</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">)</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_LSN_CMP</span><span class="p">(</span><span class="n">prev_lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">,</span> <span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">((</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_flags</span> <span class="o">&amp;</span> <span class="n">XFS_LI_IN_AIL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">prev_lip</span> <span class="o">=</span> <span class="n">lip</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* XFS_TRANS_DEBUG */</span><span class="cp"></span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !DEBUG */</span><span class="cp"></span>
<span class="cp">#define	xfs_ail_check(a,l)</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Return a pointer to the first item in the AIL.  If the AIL is empty, then</span>
<span class="cm"> * return NULL.</span>
<span class="cm"> */</span>
<span class="n">xfs_log_item_t</span> <span class="o">*</span>
<span class="nf">xfs_ail_min</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>  <span class="o">*</span><span class="n">ailp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">,</span> <span class="n">xfs_log_item_t</span><span class="p">,</span> <span class="n">li_ail</span><span class="p">);</span>
<span class="p">}</span>

 <span class="cm">/*</span>
<span class="cm"> * Return a pointer to the last item in the AIL.  If the AIL is empty, then</span>
<span class="cm"> * return NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">xfs_log_item_t</span> <span class="o">*</span>
<span class="nf">xfs_ail_max</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>  <span class="o">*</span><span class="n">ailp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">xfs_log_item_t</span><span class="p">,</span> <span class="n">li_ail</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a pointer to the item which follows the given item in the AIL.  If</span>
<span class="cm"> * the given item is the last item in the list, then return NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">xfs_log_item_t</span> <span class="o">*</span>
<span class="nf">xfs_ail_next</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>  <span class="o">*</span><span class="n">ailp</span><span class="p">,</span>
	<span class="n">xfs_log_item_t</span>  <span class="o">*</span><span class="n">lip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_ail</span><span class="p">.</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_ail</span><span class="p">,</span> <span class="n">xfs_log_item_t</span><span class="p">,</span> <span class="n">li_ail</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called by the log manager code to determine the LSN of the tail of</span>
<span class="cm"> * the log.  This is exactly the LSN of the first item in the AIL.  If the AIL</span>
<span class="cm"> * is empty, then this function returns 0.</span>
<span class="cm"> *</span>
<span class="cm"> * We need the AIL lock in order to get a coherent read of the lsn of the last</span>
<span class="cm"> * item in the AIL.</span>
<span class="cm"> */</span>
<span class="n">xfs_lsn_t</span>
<span class="nf">xfs_ail_min_lsn</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>	<span class="o">*</span><span class="n">ailp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_lsn_t</span>	<span class="n">lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_log_item_t</span>	<span class="o">*</span><span class="n">lip</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
	<span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_ail_min</span><span class="p">(</span><span class="n">ailp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lip</span><span class="p">)</span>
		<span class="n">lsn</span> <span class="o">=</span> <span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">lsn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the maximum lsn held in the AIL, or zero if the AIL is empty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">xfs_lsn_t</span>
<span class="nf">xfs_ail_max_lsn</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>  <span class="o">*</span><span class="n">ailp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_lsn_t</span>       <span class="n">lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_log_item_t</span>  <span class="o">*</span><span class="n">lip</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
	<span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_ail_max</span><span class="p">(</span><span class="n">ailp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lip</span><span class="p">)</span>
		<span class="n">lsn</span> <span class="o">=</span> <span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">lsn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The cursor keeps track of where our current traversal is up to by tracking</span>
<span class="cm"> * the next item in the list for us. However, for this to be safe, removing an</span>
<span class="cm"> * object from the AIL needs to invalidate any cursor that points to it. hence</span>
<span class="cm"> * the traversal cursor needs to be linked to the struct xfs_ail so that</span>
<span class="cm"> * deletion can search all the active cursors for invalidation.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_trans_ail_cursor_init</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>		<span class="o">*</span><span class="n">ailp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_ail_cursor</span>	<span class="o">*</span><span class="n">cur</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_cursors</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the next item in the traversal and advance the cursor.  If the cursor</span>
<span class="cm"> * was invalidated (indicated by a lip of 1), restart the traversal.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfs_log_item</span> <span class="o">*</span>
<span class="nf">xfs_trans_ail_cursor_next</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>		<span class="o">*</span><span class="n">ailp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_ail_cursor</span>	<span class="o">*</span><span class="n">cur</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_log_item</span>	<span class="o">*</span><span class="n">lip</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">__psint_t</span><span class="p">)</span><span class="n">lip</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_ail_min</span><span class="p">(</span><span class="n">ailp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lip</span><span class="p">)</span>
		<span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">=</span> <span class="n">xfs_ail_next</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="n">lip</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lip</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When the traversal is complete, we need to remove the cursor from the list</span>
<span class="cm"> * of traversing cursors.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_trans_ail_cursor_done</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>		<span class="o">*</span><span class="n">ailp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_ail_cursor</span>	<span class="o">*</span><span class="n">cur</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Invalidate any cursor that is pointing to this item. This is called when an</span>
<span class="cm"> * item is removed from the AIL. Any cursor pointing to this object is now</span>
<span class="cm"> * invalid and the traversal needs to be terminated so it doesn&#39;t reference a</span>
<span class="cm"> * freed object. We set the low bit of the cursor item pointer so we can</span>
<span class="cm"> * distinguish between an invalidation and the end of the list when getting the</span>
<span class="cm"> * next item from the cursor.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_trans_ail_cursor_clear</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>		<span class="o">*</span><span class="n">ailp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_log_item</span>	<span class="o">*</span><span class="n">lip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_ail_cursor</span>	<span class="o">*</span><span class="n">cur</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_cursors</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">==</span> <span class="n">lip</span><span class="p">)</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xfs_log_item</span> <span class="o">*</span><span class="p">)</span>
					<span class="p">((</span><span class="n">__psint_t</span><span class="p">)</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">|</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the first item in the AIL with the given @lsn by searching in ascending</span>
<span class="cm"> * LSN order and initialise the cursor to point to the next item for a</span>
<span class="cm"> * ascending traversal.  Pass a @lsn of zero to initialise the cursor to the</span>
<span class="cm"> * first item in the AIL. Returns NULL if the list is empty.</span>
<span class="cm"> */</span>
<span class="n">xfs_log_item_t</span> <span class="o">*</span>
<span class="nf">xfs_trans_ail_cursor_first</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>		<span class="o">*</span><span class="n">ailp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_ail_cursor</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">lsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_log_item_t</span>		<span class="o">*</span><span class="n">lip</span><span class="p">;</span>

	<span class="n">xfs_trans_ail_cursor_init</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lsn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_ail_min</span><span class="p">(</span><span class="n">ailp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">,</span> <span class="n">li_ail</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">XFS_LSN_CMP</span><span class="p">(</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">,</span> <span class="n">lsn</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lip</span><span class="p">)</span>
		<span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">=</span> <span class="n">xfs_ail_next</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="n">lip</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lip</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">xfs_log_item</span> <span class="o">*</span>
<span class="nf">__xfs_trans_ail_cursor_last</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>		<span class="o">*</span><span class="n">ailp</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">lsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_log_item_t</span>		<span class="o">*</span><span class="n">lip</span><span class="p">;</span>

	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">lip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">,</span> <span class="n">li_ail</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">XFS_LSN_CMP</span><span class="p">(</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">,</span> <span class="n">lsn</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">lip</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the last item in the AIL with the given @lsn by searching in descending</span>
<span class="cm"> * LSN order and initialise the cursor to point to that item.  If there is no</span>
<span class="cm"> * item with the value of @lsn, then it sets the cursor to the last item with an</span>
<span class="cm"> * LSN lower than @lsn.  Returns NULL if the list is empty.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfs_log_item</span> <span class="o">*</span>
<span class="nf">xfs_trans_ail_cursor_last</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>		<span class="o">*</span><span class="n">ailp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_ail_cursor</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">lsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_trans_ail_cursor_init</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">=</span> <span class="n">__xfs_trans_ail_cursor_last</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="n">lsn</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Splice the log item list into the AIL at the given LSN. We splice to the</span>
<span class="cm"> * tail of the given LSN to maintain insert order for push traversals. The</span>
<span class="cm"> * cursor is optional, allowing repeated updates to the same LSN to avoid</span>
<span class="cm"> * repeated traversals.  This should not be called with an empty list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xfs_ail_splice</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>		<span class="o">*</span><span class="n">ailp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_ail_cursor</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">list</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">lsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_log_item</span>	<span class="o">*</span><span class="n">lip</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use the cursor to determine the insertion point if one is</span>
<span class="cm">	 * provided.  If not, or if the one we got is not valid,</span>
<span class="cm">	 * find the place in the AIL where the items belong.</span>
<span class="cm">	 */</span>
	<span class="n">lip</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">?</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lip</span> <span class="o">||</span> <span class="p">(</span><span class="n">__psint_t</span><span class="p">)</span> <span class="n">lip</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">lip</span> <span class="o">=</span> <span class="n">__xfs_trans_ail_cursor_last</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="n">lsn</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a cursor is provided, we know we&#39;re processing the AIL</span>
<span class="cm">	 * in lsn order, and future items to be spliced in will</span>
<span class="cm">	 * follow the last one being inserted now.  Update the</span>
<span class="cm">	 * cursor to point to that last item, now while we have a</span>
<span class="cm">	 * reliable pointer to it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span>
		<span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_log_item</span><span class="p">,</span> <span class="n">li_ail</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finally perform the splice.  Unless the AIL was empty,</span>
<span class="cm">	 * lip points to the item in the AIL _after_ which the new</span>
<span class="cm">	 * items should go.  If lip is null the AIL was empty, so</span>
<span class="cm">	 * the new items go at the head of the AIL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lip</span><span class="p">)</span>
		<span class="n">list_splice</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_ail</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">list_splice</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Delete the given item from the AIL.  Return a pointer to the item.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xfs_ail_delete</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>  <span class="o">*</span><span class="n">ailp</span><span class="p">,</span>
	<span class="n">xfs_log_item_t</span>  <span class="o">*</span><span class="n">lip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_ail_check</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="n">lip</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_ail</span><span class="p">);</span>
	<span class="n">xfs_trans_ail_cursor_clear</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="n">lip</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span>
<span class="nf">xfsaild_push</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>		<span class="o">*</span><span class="n">ailp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_mount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_ail_cursor</span>	<span class="n">cur</span><span class="p">;</span>
	<span class="n">xfs_log_item_t</span>		<span class="o">*</span><span class="n">lip</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">lsn</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">target</span><span class="p">;</span>
	<span class="kt">long</span>			<span class="n">tout</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">stuck</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">flushing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we encountered pinned items or did not finish writing out all</span>
<span class="cm">	 * buffers the last time we ran, force the log first and wait for it</span>
<span class="cm">	 * before pushing again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_log_flush</span> <span class="o">&amp;&amp;</span> <span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_last_pushed_lsn</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">list_empty_careful</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_buf_list</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">xfs_ail_min_lsn</span><span class="p">(</span><span class="n">ailp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_log_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_push_ail_flush</span><span class="p">);</span>
		<span class="n">xfs_log_force</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_LOG_SYNC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
	<span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_trans_ail_cursor_first</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">,</span> <span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_last_pushed_lsn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lip</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the AIL is empty or our push has reached the end we are</span>
<span class="cm">		 * done now.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_trans_ail_cursor_done</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_push_ail</span><span class="p">);</span>

	<span class="n">lsn</span> <span class="o">=</span> <span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">;</span>
	<span class="n">target</span> <span class="o">=</span> <span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_target</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">XFS_LSN_CMP</span><span class="p">(</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">lock_result</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Note that IOP_PUSH may unlock and reacquire the AIL lock.  We</span>
<span class="cm">		 * rely on the AIL cursor implementation to be able to deal with</span>
<span class="cm">		 * the dropped lock.</span>
<span class="cm">		 */</span>
		<span class="n">lock_result</span> <span class="o">=</span> <span class="n">IOP_PUSH</span><span class="p">(</span><span class="n">lip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_buf_list</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">lock_result</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">XFS_ITEM_SUCCESS</span>:
			<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_push_ail_success</span><span class="p">);</span>
			<span class="n">trace_xfs_ail_push</span><span class="p">(</span><span class="n">lip</span><span class="p">);</span>

			<span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_last_pushed_lsn</span> <span class="o">=</span> <span class="n">lsn</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">XFS_ITEM_FLUSHING</span>:
			<span class="cm">/*</span>
<span class="cm">			 * The item or its backing buffer is already beeing</span>
<span class="cm">			 * flushed.  The typical reason for that is that an</span>
<span class="cm">			 * inode buffer is locked because we already pushed the</span>
<span class="cm">			 * updates to it as part of inode clustering.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We do not want to to stop flushing just because lots</span>
<span class="cm">			 * of items are already beeing flushed, but we need to</span>
<span class="cm">			 * re-try the flushing relatively soon if most of the</span>
<span class="cm">			 * AIL is beeing flushed.</span>
<span class="cm">			 */</span>
			<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_push_ail_flushing</span><span class="p">);</span>
			<span class="n">trace_xfs_ail_flushing</span><span class="p">(</span><span class="n">lip</span><span class="p">);</span>

			<span class="n">flushing</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_last_pushed_lsn</span> <span class="o">=</span> <span class="n">lsn</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">XFS_ITEM_PINNED</span>:
			<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_push_ail_pinned</span><span class="p">);</span>
			<span class="n">trace_xfs_ail_pinned</span><span class="p">(</span><span class="n">lip</span><span class="p">);</span>

			<span class="n">stuck</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_log_flush</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XFS_ITEM_LOCKED</span>:
			<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_push_ail_locked</span><span class="p">);</span>
			<span class="n">trace_xfs_ail_locked</span><span class="p">(</span><span class="n">lip</span><span class="p">);</span>

			<span class="n">stuck</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Are there too many items we can&#39;t do anything with?</span>
<span class="cm">		 *</span>
<span class="cm">		 * If we we are skipping too many items because we can&#39;t flush</span>
<span class="cm">		 * them or they are already being flushed, we back off and</span>
<span class="cm">		 * given them time to complete whatever operation is being</span>
<span class="cm">		 * done. i.e. remove pressure from the AIL while we can&#39;t make</span>
<span class="cm">		 * progress so traversals don&#39;t slow down further inserts and</span>
<span class="cm">		 * removals to/from the AIL.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The value of 100 is an arbitrary magic number based on</span>
<span class="cm">		 * observation.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stuck</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_trans_ail_cursor_next</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">lsn</span> <span class="o">=</span> <span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_trans_ail_cursor_done</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_buf_delwri_submit_nowait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_buf_list</span><span class="p">))</span>
		<span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_log_flush</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span> <span class="o">||</span> <span class="n">XFS_LSN_CMP</span><span class="p">(</span><span class="n">lsn</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">out_done:</span>
		<span class="cm">/*</span>
<span class="cm">		 * We reached the target or the AIL is empty, so wait a bit</span>
<span class="cm">		 * longer for I/O to complete and remove pushed items from the</span>
<span class="cm">		 * AIL before we start the next scan from the start of the AIL.</span>
<span class="cm">		 */</span>
		<span class="n">tout</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
		<span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_last_pushed_lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">stuck</span> <span class="o">+</span> <span class="n">flushing</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Either there is a lot of contention on the AIL or we are</span>
<span class="cm">		 * stuck due to operations in progress. &quot;Stuck&quot; in this case</span>
<span class="cm">		 * is defined as &gt;90% of the items we tried to push were stuck.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Backoff a bit more to allow some I/O to complete before</span>
<span class="cm">		 * restarting from the start of the AIL. This prevents us from</span>
<span class="cm">		 * spinning on the same items, and if they are pinned will all</span>
<span class="cm">		 * the restart to issue a log force to unpin the stuck items.</span>
<span class="cm">		 */</span>
		<span class="n">tout</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
		<span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_last_pushed_lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Assume we have more work to do in a short while.</span>
<span class="cm">		 */</span>
		<span class="n">tout</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">tout</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xfsaild</span><span class="p">(</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>	<span class="o">*</span><span class="n">ailp</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">long</span>		<span class="n">tout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* milliseconds */</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_MEMALLOC</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tout</span> <span class="o">&amp;&amp;</span> <span class="n">tout</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">)</span>
			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_KILLABLE</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">tout</span> <span class="o">?</span>
				 <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">tout</span><span class="p">)</span> <span class="o">:</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">);</span>

		<span class="n">try_to_freeze</span><span class="p">();</span>

		<span class="n">tout</span> <span class="o">=</span> <span class="n">xfsaild_push</span><span class="p">(</span><span class="n">ailp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine is called to move the tail of the AIL forward.  It does this by</span>
<span class="cm"> * trying to flush items in the AIL whose lsns are below the given</span>
<span class="cm"> * threshold_lsn.</span>
<span class="cm"> *</span>
<span class="cm"> * The push is run asynchronously in a workqueue, which means the caller needs</span>
<span class="cm"> * to handle waiting on the async flush for space to become available.</span>
<span class="cm"> * We don&#39;t want to interrupt any push that is in progress, hence we only queue</span>
<span class="cm"> * work if we set the pushing bit approriately.</span>
<span class="cm"> *</span>
<span class="cm"> * We do this unlocked - we only need to know whether there is anything in the</span>
<span class="cm"> * AIL at the time we are called. We don&#39;t need to access the contents of</span>
<span class="cm"> * any of the objects, so the lock is not needed.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_ail_push</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>	<span class="o">*</span><span class="n">ailp</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>	<span class="n">threshold_lsn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_log_item_t</span>	<span class="o">*</span><span class="n">lip</span><span class="p">;</span>

	<span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_ail_min</span><span class="p">(</span><span class="n">ailp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lip</span> <span class="o">||</span> <span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_mount</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">XFS_LSN_CMP</span><span class="p">(</span><span class="n">threshold_lsn</span><span class="p">,</span> <span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_target</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that the new target is noticed in push code before it clears</span>
<span class="cm">	 * the XFS_AIL_PUSHING_BIT.</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">xfs_trans_ail_copy_lsn</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threshold_lsn</span><span class="p">);</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Push out all items in the AIL immediately</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_ail_push_all</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>  <span class="o">*</span><span class="n">ailp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_lsn_t</span>       <span class="n">threshold_lsn</span> <span class="o">=</span> <span class="n">xfs_ail_max_lsn</span><span class="p">(</span><span class="n">ailp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">threshold_lsn</span><span class="p">)</span>
		<span class="n">xfs_ail_push</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="n">threshold_lsn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Push out all items in the AIL immediately and wait until the AIL is empty.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_ail_push_all_sync</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>  <span class="o">*</span><span class="n">ailp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_log_item</span>	<span class="o">*</span><span class="n">lip</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">lip</span> <span class="o">=</span> <span class="n">xfs_ail_max</span><span class="p">(</span><span class="n">ailp</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_empty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_target</span> <span class="o">=</span> <span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">;</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_task</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>

	<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_empty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_trans_ail_update - bulk AIL insertion operation.</span>
<span class="cm"> *</span>
<span class="cm"> * @xfs_trans_ail_update takes an array of log items that all need to be</span>
<span class="cm"> * positioned at the same LSN in the AIL. If an item is not in the AIL, it will</span>
<span class="cm"> * be added.  Otherwise, it will be repositioned  by removing it and re-adding</span>
<span class="cm"> * it to the AIL. If we move the first item in the AIL, update the log tail to</span>
<span class="cm"> * match the new minimum LSN in the AIL.</span>
<span class="cm"> *</span>
<span class="cm"> * This function takes the AIL lock once to execute the update operations on</span>
<span class="cm"> * all the items in the array, and as such should not be called with the AIL</span>
<span class="cm"> * lock held. As a result, once we have the AIL lock, we need to check each log</span>
<span class="cm"> * item LSN to confirm it needs to be moved forward in the AIL.</span>
<span class="cm"> *</span>
<span class="cm"> * To optimise the insert operation, we delete all the items from the AIL in</span>
<span class="cm"> * the first pass, moving them into a temporary list, then splice the temporary</span>
<span class="cm"> * list into the correct position in the AIL. This avoids needing to do an</span>
<span class="cm"> * insert operation on every item.</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be called with the AIL lock held.  The lock is dropped</span>
<span class="cm"> * before returning.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_trans_ail_update_bulk</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>		<span class="o">*</span><span class="n">ailp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_ail_cursor</span>	<span class="o">*</span><span class="n">cur</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_log_item</span>	<span class="o">**</span><span class="n">log_items</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">nr_items</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">lsn</span><span class="p">)</span> <span class="n">__releases</span><span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_log_item_t</span>		<span class="o">*</span><span class="n">mlip</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">mlip_changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">nr_items</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>		<span class="cm">/* Not required, but true. */</span>
	<span class="n">mlip</span> <span class="o">=</span> <span class="n">xfs_ail_min</span><span class="p">(</span><span class="n">ailp</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_items</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xfs_log_item</span> <span class="o">*</span><span class="n">lip</span> <span class="o">=</span> <span class="n">log_items</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_flags</span> <span class="o">&amp;</span> <span class="n">XFS_LI_IN_AIL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* check if we really need to move the item */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">XFS_LSN_CMP</span><span class="p">(</span><span class="n">lsn</span><span class="p">,</span> <span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">xfs_ail_delete</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="n">lip</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mlip</span> <span class="o">==</span> <span class="n">lip</span><span class="p">)</span>
				<span class="n">mlip_changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_flags</span> <span class="o">|=</span> <span class="n">XFS_LI_IN_AIL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span> <span class="o">=</span> <span class="n">lsn</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_ail</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">))</span>
		<span class="n">xfs_ail_splice</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">lsn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mlip_changed</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_mount</span><span class="p">))</span>
			<span class="n">xlog_assign_tail_lsn_locked</span><span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_mount</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>

		<span class="n">xfs_log_space_wake</span><span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_mount</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_trans_ail_delete_bulk - remove multiple log items from the AIL</span>
<span class="cm"> *</span>
<span class="cm"> * @xfs_trans_ail_delete_bulk takes an array of log items that all need to</span>
<span class="cm"> * removed from the AIL. The caller is already holding the AIL lock, and done</span>
<span class="cm"> * all the checks necessary to ensure the items passed in via @log_items are</span>
<span class="cm"> * ready for deletion. This includes checking that the items are in the AIL.</span>
<span class="cm"> *</span>
<span class="cm"> * For each log item to be removed, unlink it  from the AIL, clear the IN_AIL</span>
<span class="cm"> * flag from the item and reset the item&#39;s lsn to 0. If we remove the first</span>
<span class="cm"> * item in the AIL, update the log tail to match the new minimum LSN in the</span>
<span class="cm"> * AIL.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will not drop the AIL lock until all items are removed from</span>
<span class="cm"> * the AIL to minimise the amount of lock traffic on the AIL. This does not</span>
<span class="cm"> * greatly increase the AIL hold time, but does significantly reduce the amount</span>
<span class="cm"> * of traffic on the lock, especially during IO completion.</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be called with the AIL lock held.  The lock is dropped</span>
<span class="cm"> * before returning.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_trans_ail_delete_bulk</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>		<span class="o">*</span><span class="n">ailp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_log_item</span>	<span class="o">**</span><span class="n">log_items</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">nr_items</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">shutdown_type</span><span class="p">)</span> <span class="n">__releases</span><span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_log_item_t</span>		<span class="o">*</span><span class="n">mlip</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">mlip_changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="n">mlip</span> <span class="o">=</span> <span class="n">xfs_ail_min</span><span class="p">(</span><span class="n">ailp</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_items</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xfs_log_item</span> <span class="o">*</span><span class="n">lip</span> <span class="o">=</span> <span class="n">log_items</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_flags</span> <span class="o">&amp;</span> <span class="n">XFS_LI_IN_AIL</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_mount</span><span class="p">;</span>

			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">xfs_alert_tag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_PTAG_AILDELETE</span><span class="p">,</span>
		<span class="s">&quot;%s: attempting to delete a log item that is not in the AIL&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">);</span>
				<span class="n">xfs_force_shutdown</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">shutdown_type</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">xfs_ail_delete</span><span class="p">(</span><span class="n">ailp</span><span class="p">,</span> <span class="n">lip</span><span class="p">);</span>
		<span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XFS_LI_IN_AIL</span><span class="p">;</span>
		<span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_lsn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mlip</span> <span class="o">==</span> <span class="n">lip</span><span class="p">)</span>
			<span class="n">mlip_changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mlip_changed</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_mount</span><span class="p">))</span>
			<span class="n">xlog_assign_tail_lsn_locked</span><span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_mount</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">))</span>
			<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_empty</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>

		<span class="n">xfs_log_space_wake</span><span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_mount</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_trans_ail_init</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>	<span class="o">*</span><span class="n">ailp</span><span class="p">;</span>

	<span class="n">ailp</span> <span class="o">=</span> <span class="n">kmem_zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_ail</span><span class="p">),</span> <span class="n">KM_MAYFAIL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ailp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_mount</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_ail</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_cursors</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_buf_list</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_empty</span><span class="p">);</span>

	<span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">xfsaild</span><span class="p">,</span> <span class="n">ailp</span><span class="p">,</span> <span class="s">&quot;xfsaild/%s&quot;</span><span class="p">,</span>
			<span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_mount</span><span class="o">-&gt;</span><span class="n">m_fsname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_task</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free_ailp</span><span class="p">;</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ail</span> <span class="o">=</span> <span class="n">ailp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_ailp:</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">ailp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_trans_ail_destroy</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>	<span class="o">*</span><span class="n">ailp</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ail</span><span class="p">;</span>

	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">ailp</span><span class="o">-&gt;</span><span class="n">xa_task</span><span class="p">);</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">ailp</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
