<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_fs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_fs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 1995-2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU Lesser General Public License</span>
<span class="cm"> * as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU Lesser General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU Lesser General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __XFS_FS_H__</span>
<span class="cp">#define __XFS_FS_H__</span>

<span class="cm">/*</span>
<span class="cm"> * SGI&#39;s XFS filesystem&#39;s major stuff (constants, structures)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Direct I/O attribute record used with XFS_IOC_DIOINFO</span>
<span class="cm"> * d_miniosz is the min xfer size, xfer size multiple and file seek offset</span>
<span class="cm"> * alignment.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef HAVE_DIOATTR</span>
<span class="k">struct</span> <span class="n">dioattr</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">d_mem</span><span class="p">;</span>		<span class="cm">/* data buffer memory alignment */</span>
	<span class="n">__u32</span>		<span class="n">d_miniosz</span><span class="p">;</span>	<span class="cm">/* min xfer size		*/</span>
	<span class="n">__u32</span>		<span class="n">d_maxiosz</span><span class="p">;</span>	<span class="cm">/* max xfer size		*/</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Structure for XFS_IOC_FSGETXATTR[A] and XFS_IOC_FSSETXATTR.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef HAVE_FSXATTR</span>
<span class="k">struct</span> <span class="n">fsxattr</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">fsx_xflags</span><span class="p">;</span>	<span class="cm">/* xflags field value (get/set) */</span>
	<span class="n">__u32</span>		<span class="n">fsx_extsize</span><span class="p">;</span>	<span class="cm">/* extsize field value (get/set)*/</span>
	<span class="n">__u32</span>		<span class="n">fsx_nextents</span><span class="p">;</span>	<span class="cm">/* nextents field value (get)	*/</span>
	<span class="n">__u32</span>		<span class="n">fsx_projid</span><span class="p">;</span>	<span class="cm">/* project identifier (get/set) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">fsx_pad</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Flags for the bs_xflags/fsx_xflags field</span>
<span class="cm"> * There should be a one-to-one correspondence between these flags and the</span>
<span class="cm"> * XFS_DIFLAG_s.</span>
<span class="cm"> */</span>
<span class="cp">#define XFS_XFLAG_REALTIME	0x00000001	</span><span class="cm">/* data in realtime volume */</span><span class="cp"></span>
<span class="cp">#define XFS_XFLAG_PREALLOC	0x00000002	</span><span class="cm">/* preallocated file extents */</span><span class="cp"></span>
<span class="cp">#define XFS_XFLAG_IMMUTABLE	0x00000008	</span><span class="cm">/* file cannot be modified */</span><span class="cp"></span>
<span class="cp">#define XFS_XFLAG_APPEND	0x00000010	</span><span class="cm">/* all writes append */</span><span class="cp"></span>
<span class="cp">#define XFS_XFLAG_SYNC		0x00000020	</span><span class="cm">/* all writes synchronous */</span><span class="cp"></span>
<span class="cp">#define XFS_XFLAG_NOATIME	0x00000040	</span><span class="cm">/* do not update access time */</span><span class="cp"></span>
<span class="cp">#define XFS_XFLAG_NODUMP	0x00000080	</span><span class="cm">/* do not include in backups */</span><span class="cp"></span>
<span class="cp">#define XFS_XFLAG_RTINHERIT	0x00000100	</span><span class="cm">/* create with rt bit set */</span><span class="cp"></span>
<span class="cp">#define XFS_XFLAG_PROJINHERIT	0x00000200	</span><span class="cm">/* create with parents projid */</span><span class="cp"></span>
<span class="cp">#define XFS_XFLAG_NOSYMLINKS	0x00000400	</span><span class="cm">/* disallow symlink creation */</span><span class="cp"></span>
<span class="cp">#define XFS_XFLAG_EXTSIZE	0x00000800	</span><span class="cm">/* extent size allocator hint */</span><span class="cp"></span>
<span class="cp">#define XFS_XFLAG_EXTSZINHERIT	0x00001000	</span><span class="cm">/* inherit inode extent size */</span><span class="cp"></span>
<span class="cp">#define XFS_XFLAG_NODEFRAG	0x00002000  	</span><span class="cm">/* do not defragment */</span><span class="cp"></span>
<span class="cp">#define XFS_XFLAG_FILESTREAM	0x00004000	</span><span class="cm">/* use filestream allocator */</span><span class="cp"></span>
<span class="cp">#define XFS_XFLAG_HASATTR	0x80000000	</span><span class="cm">/* no DIFLAG for this	*/</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Structure for XFS_IOC_GETBMAP.</span>
<span class="cm"> * On input, fill in bmv_offset and bmv_length of the first structure</span>
<span class="cm"> * to indicate the area of interest in the file, and bmv_entries with</span>
<span class="cm"> * the number of array elements given back.  The first structure is</span>
<span class="cm"> * updated on return to give the offset and length for the next call.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef HAVE_GETBMAP</span>
<span class="k">struct</span> <span class="n">getbmap</span> <span class="p">{</span>
	<span class="n">__s64</span>		<span class="n">bmv_offset</span><span class="p">;</span>	<span class="cm">/* file offset of segment in blocks */</span>
	<span class="n">__s64</span>		<span class="n">bmv_block</span><span class="p">;</span>	<span class="cm">/* starting block (64-bit daddr_t)  */</span>
	<span class="n">__s64</span>		<span class="n">bmv_length</span><span class="p">;</span>	<span class="cm">/* length of segment, blocks	    */</span>
	<span class="n">__s32</span>		<span class="n">bmv_count</span><span class="p">;</span>	<span class="cm">/* # of entries in array incl. 1st  */</span>
	<span class="n">__s32</span>		<span class="n">bmv_entries</span><span class="p">;</span>	<span class="cm">/* # of entries filled in (output)  */</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *	Structure for XFS_IOC_GETBMAPX.	 Fields bmv_offset through bmv_entries</span>
<span class="cm"> *	are used exactly as in the getbmap structure.  The getbmapx structure</span>
<span class="cm"> *	has additional bmv_iflags and bmv_oflags fields. The bmv_iflags field</span>
<span class="cm"> *	is only used for the first structure.  It contains input flags</span>
<span class="cm"> *	specifying XFS_IOC_GETBMAPX actions.  The bmv_oflags field is filled</span>
<span class="cm"> *	in by the XFS_IOC_GETBMAPX command for each returned structure after</span>
<span class="cm"> *	the first.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef HAVE_GETBMAPX</span>
<span class="k">struct</span> <span class="n">getbmapx</span> <span class="p">{</span>
	<span class="n">__s64</span>		<span class="n">bmv_offset</span><span class="p">;</span>	<span class="cm">/* file offset of segment in blocks */</span>
	<span class="n">__s64</span>		<span class="n">bmv_block</span><span class="p">;</span>	<span class="cm">/* starting block (64-bit daddr_t)  */</span>
	<span class="n">__s64</span>		<span class="n">bmv_length</span><span class="p">;</span>	<span class="cm">/* length of segment, blocks	    */</span>
	<span class="n">__s32</span>		<span class="n">bmv_count</span><span class="p">;</span>	<span class="cm">/* # of entries in array incl. 1st  */</span>
	<span class="n">__s32</span>		<span class="n">bmv_entries</span><span class="p">;</span>	<span class="cm">/* # of entries filled in (output). */</span>
	<span class="n">__s32</span>		<span class="n">bmv_iflags</span><span class="p">;</span>	<span class="cm">/* input flags (1st structure)	    */</span>
	<span class="n">__s32</span>		<span class="n">bmv_oflags</span><span class="p">;</span>	<span class="cm">/* output flags (after 1st structure)*/</span>
	<span class="n">__s32</span>		<span class="n">bmv_unused1</span><span class="p">;</span>	<span class="cm">/* future use			    */</span>
	<span class="n">__s32</span>		<span class="n">bmv_unused2</span><span class="p">;</span>	<span class="cm">/* future use			    */</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/*	bmv_iflags values - set by XFS_IOC_GETBMAPX caller.	*/</span>
<span class="cp">#define BMV_IF_ATTRFORK		0x1	</span><span class="cm">/* return attr fork rather than data */</span><span class="cp"></span>
<span class="cp">#define BMV_IF_NO_DMAPI_READ	0x2	</span><span class="cm">/* Do not generate DMAPI read event  */</span><span class="cp"></span>
<span class="cp">#define BMV_IF_PREALLOC		0x4	</span><span class="cm">/* rtn status BMV_OF_PREALLOC if req */</span><span class="cp"></span>
<span class="cp">#define BMV_IF_DELALLOC		0x8	</span><span class="cm">/* rtn status BMV_OF_DELALLOC if req */</span><span class="cp"></span>
<span class="cp">#define BMV_IF_NO_HOLES		0x10	</span><span class="cm">/* Do not return holes */</span><span class="cp"></span>
<span class="cp">#define BMV_IF_VALID	\</span>
<span class="cp">	(BMV_IF_ATTRFORK|BMV_IF_NO_DMAPI_READ|BMV_IF_PREALLOC|	\</span>
<span class="cp">	 BMV_IF_DELALLOC|BMV_IF_NO_HOLES)</span>

<span class="cm">/*	bmv_oflags values - returned for each non-header segment */</span>
<span class="cp">#define BMV_OF_PREALLOC		0x1	</span><span class="cm">/* segment = unwritten pre-allocation */</span><span class="cp"></span>
<span class="cp">#define BMV_OF_DELALLOC		0x2	</span><span class="cm">/* segment = delayed allocation */</span><span class="cp"></span>
<span class="cp">#define BMV_OF_LAST		0x4	</span><span class="cm">/* segment is the last in the file */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Structure for XFS_IOC_FSSETDM.</span>
<span class="cm"> * For use by backup and restore programs to set the XFS on-disk inode</span>
<span class="cm"> * fields di_dmevmask and di_dmstate.  These must be set to exactly and</span>
<span class="cm"> * only values previously obtained via xfs_bulkstat!  (Specifically the</span>
<span class="cm"> * xfs_bstat_t fields bs_dmevmask and bs_dmstate.)</span>
<span class="cm"> */</span>
<span class="cp">#ifndef HAVE_FSDMIDATA</span>
<span class="k">struct</span> <span class="n">fsdmidata</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">fsd_dmevmask</span><span class="p">;</span>	<span class="cm">/* corresponds to di_dmevmask */</span>
	<span class="n">__u16</span>		<span class="n">fsd_padding</span><span class="p">;</span>
	<span class="n">__u16</span>		<span class="n">fsd_dmstate</span><span class="p">;</span>	<span class="cm">/* corresponds to di_dmstate  */</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * File segment locking set data type for 64 bit access.</span>
<span class="cm"> * Also used for all the RESV/FREE interfaces.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_flock64</span> <span class="p">{</span>
	<span class="n">__s16</span>		<span class="n">l_type</span><span class="p">;</span>
	<span class="n">__s16</span>		<span class="n">l_whence</span><span class="p">;</span>
	<span class="n">__s64</span>		<span class="n">l_start</span><span class="p">;</span>
	<span class="n">__s64</span>		<span class="n">l_len</span><span class="p">;</span>		<span class="cm">/* len == 0 means until end of file */</span>
	<span class="n">__s32</span>		<span class="n">l_sysid</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">l_pid</span><span class="p">;</span>
	<span class="n">__s32</span>		<span class="n">l_pad</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* reserve area			    */</span>
<span class="p">}</span> <span class="n">xfs_flock64_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Output for XFS_IOC_FSGEOMETRY_V1</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_fsop_geom_v1</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">blocksize</span><span class="p">;</span>	<span class="cm">/* filesystem (data) block size */</span>
	<span class="n">__u32</span>		<span class="n">rtextsize</span><span class="p">;</span>	<span class="cm">/* realtime extent size		*/</span>
	<span class="n">__u32</span>		<span class="n">agblocks</span><span class="p">;</span>	<span class="cm">/* fsblocks in an AG		*/</span>
	<span class="n">__u32</span>		<span class="n">agcount</span><span class="p">;</span>	<span class="cm">/* number of allocation groups	*/</span>
	<span class="n">__u32</span>		<span class="n">logblocks</span><span class="p">;</span>	<span class="cm">/* fsblocks in the log		*/</span>
	<span class="n">__u32</span>		<span class="n">sectsize</span><span class="p">;</span>	<span class="cm">/* (data) sector size, bytes	*/</span>
	<span class="n">__u32</span>		<span class="n">inodesize</span><span class="p">;</span>	<span class="cm">/* inode size in bytes		*/</span>
	<span class="n">__u32</span>		<span class="n">imaxpct</span><span class="p">;</span>	<span class="cm">/* max allowed inode space(%)	*/</span>
	<span class="n">__u64</span>		<span class="n">datablocks</span><span class="p">;</span>	<span class="cm">/* fsblocks in data subvolume	*/</span>
	<span class="n">__u64</span>		<span class="n">rtblocks</span><span class="p">;</span>	<span class="cm">/* fsblocks in realtime subvol	*/</span>
	<span class="n">__u64</span>		<span class="n">rtextents</span><span class="p">;</span>	<span class="cm">/* rt extents in realtime subvol*/</span>
	<span class="n">__u64</span>		<span class="n">logstart</span><span class="p">;</span>	<span class="cm">/* starting fsblock of the log	*/</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* unique id of the filesystem	*/</span>
	<span class="n">__u32</span>		<span class="n">sunit</span><span class="p">;</span>		<span class="cm">/* stripe unit, fsblocks	*/</span>
	<span class="n">__u32</span>		<span class="n">swidth</span><span class="p">;</span>		<span class="cm">/* stripe width, fsblocks	*/</span>
	<span class="n">__s32</span>		<span class="n">version</span><span class="p">;</span>	<span class="cm">/* structure version		*/</span>
	<span class="n">__u32</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* superblock version flags	*/</span>
	<span class="n">__u32</span>		<span class="n">logsectsize</span><span class="p">;</span>	<span class="cm">/* log sector size, bytes	*/</span>
	<span class="n">__u32</span>		<span class="n">rtsectsize</span><span class="p">;</span>	<span class="cm">/* realtime sector size, bytes	*/</span>
	<span class="n">__u32</span>		<span class="n">dirblocksize</span><span class="p">;</span>	<span class="cm">/* directory block size, bytes	*/</span>
<span class="p">}</span> <span class="n">xfs_fsop_geom_v1_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Output for XFS_IOC_FSGEOMETRY</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_fsop_geom</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">blocksize</span><span class="p">;</span>	<span class="cm">/* filesystem (data) block size */</span>
	<span class="n">__u32</span>		<span class="n">rtextsize</span><span class="p">;</span>	<span class="cm">/* realtime extent size		*/</span>
	<span class="n">__u32</span>		<span class="n">agblocks</span><span class="p">;</span>	<span class="cm">/* fsblocks in an AG		*/</span>
	<span class="n">__u32</span>		<span class="n">agcount</span><span class="p">;</span>	<span class="cm">/* number of allocation groups	*/</span>
	<span class="n">__u32</span>		<span class="n">logblocks</span><span class="p">;</span>	<span class="cm">/* fsblocks in the log		*/</span>
	<span class="n">__u32</span>		<span class="n">sectsize</span><span class="p">;</span>	<span class="cm">/* (data) sector size, bytes	*/</span>
	<span class="n">__u32</span>		<span class="n">inodesize</span><span class="p">;</span>	<span class="cm">/* inode size in bytes		*/</span>
	<span class="n">__u32</span>		<span class="n">imaxpct</span><span class="p">;</span>	<span class="cm">/* max allowed inode space(%)	*/</span>
	<span class="n">__u64</span>		<span class="n">datablocks</span><span class="p">;</span>	<span class="cm">/* fsblocks in data subvolume	*/</span>
	<span class="n">__u64</span>		<span class="n">rtblocks</span><span class="p">;</span>	<span class="cm">/* fsblocks in realtime subvol	*/</span>
	<span class="n">__u64</span>		<span class="n">rtextents</span><span class="p">;</span>	<span class="cm">/* rt extents in realtime subvol*/</span>
	<span class="n">__u64</span>		<span class="n">logstart</span><span class="p">;</span>	<span class="cm">/* starting fsblock of the log	*/</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* unique id of the filesystem	*/</span>
	<span class="n">__u32</span>		<span class="n">sunit</span><span class="p">;</span>		<span class="cm">/* stripe unit, fsblocks	*/</span>
	<span class="n">__u32</span>		<span class="n">swidth</span><span class="p">;</span>		<span class="cm">/* stripe width, fsblocks	*/</span>
	<span class="n">__s32</span>		<span class="n">version</span><span class="p">;</span>	<span class="cm">/* structure version		*/</span>
	<span class="n">__u32</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* superblock version flags	*/</span>
	<span class="n">__u32</span>		<span class="n">logsectsize</span><span class="p">;</span>	<span class="cm">/* log sector size, bytes	*/</span>
	<span class="n">__u32</span>		<span class="n">rtsectsize</span><span class="p">;</span>	<span class="cm">/* realtime sector size, bytes	*/</span>
	<span class="n">__u32</span>		<span class="n">dirblocksize</span><span class="p">;</span>	<span class="cm">/* directory block size, bytes	*/</span>
	<span class="n">__u32</span>		<span class="n">logsunit</span><span class="p">;</span>	<span class="cm">/* log stripe unit, bytes */</span>
<span class="p">}</span> <span class="n">xfs_fsop_geom_t</span><span class="p">;</span>

<span class="cm">/* Output for XFS_FS_COUNTS */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_fsop_counts</span> <span class="p">{</span>
	<span class="n">__u64</span>	<span class="n">freedata</span><span class="p">;</span>	<span class="cm">/* free data section blocks */</span>
	<span class="n">__u64</span>	<span class="n">freertx</span><span class="p">;</span>	<span class="cm">/* free rt extents */</span>
	<span class="n">__u64</span>	<span class="n">freeino</span><span class="p">;</span>	<span class="cm">/* free inodes */</span>
	<span class="n">__u64</span>	<span class="n">allocino</span><span class="p">;</span>	<span class="cm">/* total allocated inodes */</span>
<span class="p">}</span> <span class="n">xfs_fsop_counts_t</span><span class="p">;</span>

<span class="cm">/* Input/Output for XFS_GET_RESBLKS and XFS_SET_RESBLKS */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_fsop_resblks</span> <span class="p">{</span>
	<span class="n">__u64</span>  <span class="n">resblks</span><span class="p">;</span>
	<span class="n">__u64</span>  <span class="n">resblks_avail</span><span class="p">;</span>
<span class="p">}</span> <span class="n">xfs_fsop_resblks_t</span><span class="p">;</span>

<span class="cp">#define XFS_FSOP_GEOM_VERSION	0</span>

<span class="cp">#define XFS_FSOP_GEOM_FLAGS_ATTR	0x0001	</span><span class="cm">/* attributes in use	*/</span><span class="cp"></span>
<span class="cp">#define XFS_FSOP_GEOM_FLAGS_NLINK	0x0002	</span><span class="cm">/* 32-bit nlink values	*/</span><span class="cp"></span>
<span class="cp">#define XFS_FSOP_GEOM_FLAGS_QUOTA	0x0004	</span><span class="cm">/* quotas enabled	*/</span><span class="cp"></span>
<span class="cp">#define XFS_FSOP_GEOM_FLAGS_IALIGN	0x0008	</span><span class="cm">/* inode alignment	*/</span><span class="cp"></span>
<span class="cp">#define XFS_FSOP_GEOM_FLAGS_DALIGN	0x0010	</span><span class="cm">/* large data alignment */</span><span class="cp"></span>
<span class="cp">#define XFS_FSOP_GEOM_FLAGS_SHARED	0x0020	</span><span class="cm">/* read-only shared	*/</span><span class="cp"></span>
<span class="cp">#define XFS_FSOP_GEOM_FLAGS_EXTFLG	0x0040	</span><span class="cm">/* special extent flag	*/</span><span class="cp"></span>
<span class="cp">#define XFS_FSOP_GEOM_FLAGS_DIRV2	0x0080	</span><span class="cm">/* directory version 2	*/</span><span class="cp"></span>
<span class="cp">#define XFS_FSOP_GEOM_FLAGS_LOGV2	0x0100	</span><span class="cm">/* log format version 2	*/</span><span class="cp"></span>
<span class="cp">#define XFS_FSOP_GEOM_FLAGS_SECTOR	0x0200	</span><span class="cm">/* sector sizes &gt;1BB	*/</span><span class="cp"></span>
<span class="cp">#define XFS_FSOP_GEOM_FLAGS_ATTR2	0x0400	</span><span class="cm">/* inline attributes rework */</span><span class="cp"></span>
<span class="cp">#define XFS_FSOP_GEOM_FLAGS_DIRV2CI	0x1000	</span><span class="cm">/* ASCII only CI names */</span><span class="cp"></span>
<span class="cp">#define XFS_FSOP_GEOM_FLAGS_LAZYSB	0x4000	</span><span class="cm">/* lazy superblock counters */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * Minimum and maximum sizes need for growth checks</span>
<span class="cm"> */</span>
<span class="cp">#define XFS_MIN_AG_BLOCKS	64</span>
<span class="cp">#define XFS_MIN_LOG_BLOCKS	512ULL</span>
<span class="cp">#define XFS_MAX_LOG_BLOCKS	(1024 * 1024ULL)</span>
<span class="cp">#define XFS_MIN_LOG_BYTES	(10 * 1024 * 1024ULL)</span>

<span class="cm">/* keep the maximum size under 2^31 by a small amount */</span>
<span class="cp">#define XFS_MAX_LOG_BYTES \</span>
<span class="cp">	((2 * 1024 * 1024 * 1024ULL) - XFS_MIN_LOG_BYTES)</span>

<span class="cm">/* Used for sanity checks on superblock */</span>
<span class="cp">#define XFS_MAX_DBLOCKS(s) ((xfs_drfsbno_t)(s)-&gt;sb_agcount * (s)-&gt;sb_agblocks)</span>
<span class="cp">#define XFS_MIN_DBLOCKS(s) ((xfs_drfsbno_t)((s)-&gt;sb_agcount - 1) *	\</span>
<span class="cp">			 (s)-&gt;sb_agblocks + XFS_MIN_AG_BLOCKS)</span>

<span class="cm">/*</span>
<span class="cm"> * Structures for XFS_IOC_FSGROWFSDATA, XFS_IOC_FSGROWFSLOG &amp; XFS_IOC_FSGROWFSRT</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_growfs_data</span> <span class="p">{</span>
	<span class="n">__u64</span>		<span class="n">newblocks</span><span class="p">;</span>	<span class="cm">/* new data subvol size, fsblocks */</span>
	<span class="n">__u32</span>		<span class="n">imaxpct</span><span class="p">;</span>	<span class="cm">/* new inode space percentage limit */</span>
<span class="p">}</span> <span class="n">xfs_growfs_data_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_growfs_log</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">newblocks</span><span class="p">;</span>	<span class="cm">/* new log size, fsblocks */</span>
	<span class="n">__u32</span>		<span class="n">isint</span><span class="p">;</span>		<span class="cm">/* 1 if new log is internal */</span>
<span class="p">}</span> <span class="n">xfs_growfs_log_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_growfs_rt</span> <span class="p">{</span>
	<span class="n">__u64</span>		<span class="n">newblocks</span><span class="p">;</span>	<span class="cm">/* new realtime size, fsblocks */</span>
	<span class="n">__u32</span>		<span class="n">extsize</span><span class="p">;</span>	<span class="cm">/* new realtime extent size, fsblocks */</span>
<span class="p">}</span> <span class="n">xfs_growfs_rt_t</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * Structures returned from ioctl XFS_IOC_FSBULKSTAT &amp; XFS_IOC_FSBULKSTAT_SINGLE</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_bstime</span> <span class="p">{</span>
	<span class="kt">time_t</span>		<span class="n">tv_sec</span><span class="p">;</span>		<span class="cm">/* seconds		*/</span>
	<span class="n">__s32</span>		<span class="n">tv_nsec</span><span class="p">;</span>	<span class="cm">/* and nanoseconds	*/</span>
<span class="p">}</span> <span class="n">xfs_bstime_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_bstat</span> <span class="p">{</span>
	<span class="n">__u64</span>		<span class="n">bs_ino</span><span class="p">;</span>		<span class="cm">/* inode number			*/</span>
	<span class="n">__u16</span>		<span class="n">bs_mode</span><span class="p">;</span>	<span class="cm">/* type and mode		*/</span>
	<span class="n">__u16</span>		<span class="n">bs_nlink</span><span class="p">;</span>	<span class="cm">/* number of links		*/</span>
	<span class="n">__u32</span>		<span class="n">bs_uid</span><span class="p">;</span>		<span class="cm">/* user id			*/</span>
	<span class="n">__u32</span>		<span class="n">bs_gid</span><span class="p">;</span>		<span class="cm">/* group id			*/</span>
	<span class="n">__u32</span>		<span class="n">bs_rdev</span><span class="p">;</span>	<span class="cm">/* device value			*/</span>
	<span class="n">__s32</span>		<span class="n">bs_blksize</span><span class="p">;</span>	<span class="cm">/* block size			*/</span>
	<span class="n">__s64</span>		<span class="n">bs_size</span><span class="p">;</span>	<span class="cm">/* file size			*/</span>
	<span class="n">xfs_bstime_t</span>	<span class="n">bs_atime</span><span class="p">;</span>	<span class="cm">/* access time			*/</span>
	<span class="n">xfs_bstime_t</span>	<span class="n">bs_mtime</span><span class="p">;</span>	<span class="cm">/* modify time			*/</span>
	<span class="n">xfs_bstime_t</span>	<span class="n">bs_ctime</span><span class="p">;</span>	<span class="cm">/* inode change time		*/</span>
	<span class="kt">int64_t</span>		<span class="n">bs_blocks</span><span class="p">;</span>	<span class="cm">/* number of blocks		*/</span>
	<span class="n">__u32</span>		<span class="n">bs_xflags</span><span class="p">;</span>	<span class="cm">/* extended flags		*/</span>
	<span class="n">__s32</span>		<span class="n">bs_extsize</span><span class="p">;</span>	<span class="cm">/* extent size			*/</span>
	<span class="n">__s32</span>		<span class="n">bs_extents</span><span class="p">;</span>	<span class="cm">/* number of extents		*/</span>
	<span class="n">__u32</span>		<span class="n">bs_gen</span><span class="p">;</span>		<span class="cm">/* generation count		*/</span>
	<span class="n">__u16</span>		<span class="n">bs_projid_lo</span><span class="p">;</span>	<span class="cm">/* lower part of project id	*/</span>
<span class="cp">#define	bs_projid	bs_projid_lo	</span><span class="cm">/* (previously just bs_projid)	*/</span><span class="cp"></span>
	<span class="n">__u16</span>		<span class="n">bs_forkoff</span><span class="p">;</span>	<span class="cm">/* inode fork offset in bytes	*/</span>
	<span class="n">__u16</span>		<span class="n">bs_projid_hi</span><span class="p">;</span>	<span class="cm">/* higher part of project id	*/</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">bs_pad</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>	<span class="cm">/* pad space, unused		*/</span>
	<span class="n">__u32</span>		<span class="n">bs_dmevmask</span><span class="p">;</span>	<span class="cm">/* DMIG event mask		*/</span>
	<span class="n">__u16</span>		<span class="n">bs_dmstate</span><span class="p">;</span>	<span class="cm">/* DMIG state info		*/</span>
	<span class="n">__u16</span>		<span class="n">bs_aextents</span><span class="p">;</span>	<span class="cm">/* attribute number of extents	*/</span>
<span class="p">}</span> <span class="n">xfs_bstat_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The user-level BulkStat Request interface structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_fsop_bulkreq</span> <span class="p">{</span>
	<span class="n">__u64</span>		<span class="n">__user</span> <span class="o">*</span><span class="n">lastip</span><span class="p">;</span>	<span class="cm">/* last inode # pointer		*/</span>
	<span class="n">__s32</span>		<span class="n">icount</span><span class="p">;</span>		<span class="cm">/* count of entries in buffer	*/</span>
	<span class="kt">void</span>		<span class="n">__user</span> <span class="o">*</span><span class="n">ubuffer</span><span class="p">;</span><span class="cm">/* user buffer for inode desc.	*/</span>
	<span class="n">__s32</span>		<span class="n">__user</span> <span class="o">*</span><span class="n">ocount</span><span class="p">;</span>	<span class="cm">/* output count pointer		*/</span>
<span class="p">}</span> <span class="n">xfs_fsop_bulkreq_t</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * Structures returned from xfs_inumbers routine (XFS_IOC_FSINUMBERS).</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_inogrp</span> <span class="p">{</span>
	<span class="n">__u64</span>		<span class="n">xi_startino</span><span class="p">;</span>	<span class="cm">/* starting inode number	*/</span>
	<span class="n">__s32</span>		<span class="n">xi_alloccount</span><span class="p">;</span>	<span class="cm">/* # bits set in allocmask	*/</span>
	<span class="n">__u64</span>		<span class="n">xi_allocmask</span><span class="p">;</span>	<span class="cm">/* mask of allocated inodes	*/</span>
<span class="p">}</span> <span class="n">xfs_inogrp_t</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * Error injection.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_error_injection</span> <span class="p">{</span>
	<span class="n">__s32</span>		<span class="n">fd</span><span class="p">;</span>
	<span class="n">__s32</span>		<span class="n">errtag</span><span class="p">;</span>
<span class="p">}</span> <span class="n">xfs_error_injection_t</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * The user-level Handle Request interface structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_fsop_handlereq</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">fd</span><span class="p">;</span>		<span class="cm">/* fd for FD_TO_HANDLE		*/</span>
	<span class="kt">void</span>		<span class="n">__user</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>	<span class="cm">/* user pathname		*/</span>
	<span class="n">__u32</span>		<span class="n">oflags</span><span class="p">;</span>		<span class="cm">/* open flags			*/</span>
	<span class="kt">void</span>		<span class="n">__user</span> <span class="o">*</span><span class="n">ihandle</span><span class="p">;</span><span class="cm">/* user supplied handle		*/</span>
	<span class="n">__u32</span>		<span class="n">ihandlen</span><span class="p">;</span>	<span class="cm">/* user supplied length		*/</span>
	<span class="kt">void</span>		<span class="n">__user</span> <span class="o">*</span><span class="n">ohandle</span><span class="p">;</span><span class="cm">/* user buffer for handle	*/</span>
	<span class="n">__u32</span>		<span class="n">__user</span> <span class="o">*</span><span class="n">ohandlen</span><span class="p">;</span><span class="cm">/* user buffer length		*/</span>
<span class="p">}</span> <span class="n">xfs_fsop_handlereq_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Compound structures for passing args through Handle Request interfaces</span>
<span class="cm"> * xfs_fssetdm_by_handle, xfs_attrlist_by_handle, xfs_attrmulti_by_handle</span>
<span class="cm"> * - ioctls: XFS_IOC_FSSETDM_BY_HANDLE, XFS_IOC_ATTRLIST_BY_HANDLE, and</span>
<span class="cm"> *	     XFS_IOC_ATTRMULTI_BY_HANDLE</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_fsop_setdm_handlereq</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_fsop_handlereq</span>	<span class="n">hreq</span><span class="p">;</span>	<span class="cm">/* handle information	*/</span>
	<span class="k">struct</span> <span class="n">fsdmidata</span>		<span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>	<span class="cm">/* DMAPI data	*/</span>
<span class="p">}</span> <span class="n">xfs_fsop_setdm_handlereq_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_attrlist_cursor</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">opaque</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span> <span class="n">xfs_attrlist_cursor_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_fsop_attrlist_handlereq</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_fsop_handlereq</span>	<span class="n">hreq</span><span class="p">;</span> <span class="cm">/* handle interface structure */</span>
	<span class="k">struct</span> <span class="n">xfs_attrlist_cursor</span>	<span class="n">pos</span><span class="p">;</span> <span class="cm">/* opaque cookie, list offset */</span>
	<span class="n">__u32</span>				<span class="n">flags</span><span class="p">;</span>	<span class="cm">/* which namespace to use */</span>
	<span class="n">__u32</span>				<span class="n">buflen</span><span class="p">;</span>	<span class="cm">/* length of buffer supplied */</span>
	<span class="kt">void</span>				<span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>	<span class="cm">/* returned names */</span>
<span class="p">}</span> <span class="n">xfs_fsop_attrlist_handlereq_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_attr_multiop</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">am_opcode</span><span class="p">;</span>
<span class="cp">#define ATTR_OP_GET	1	</span><span class="cm">/* return the indicated attr&#39;s value */</span><span class="cp"></span>
<span class="cp">#define ATTR_OP_SET	2	</span><span class="cm">/* set/create the indicated attr/value pair */</span><span class="cp"></span>
<span class="cp">#define ATTR_OP_REMOVE	3	</span><span class="cm">/* remove the indicated attr */</span><span class="cp"></span>
	<span class="n">__s32</span>		<span class="n">am_error</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="n">__user</span> <span class="o">*</span><span class="n">am_attrname</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="n">__user</span> <span class="o">*</span><span class="n">am_attrvalue</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">am_length</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">am_flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">xfs_attr_multiop_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_fsop_attrmulti_handlereq</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_fsop_handlereq</span>	<span class="n">hreq</span><span class="p">;</span> <span class="cm">/* handle interface structure */</span>
	<span class="n">__u32</span>				<span class="n">opcount</span><span class="p">;</span><span class="cm">/* count of following multiop */</span>
	<span class="k">struct</span> <span class="n">xfs_attr_multiop</span>		<span class="n">__user</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span> <span class="cm">/* attr_multi data */</span>
<span class="p">}</span> <span class="n">xfs_fsop_attrmulti_handlereq_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * per machine unique filesystem identifier types.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="n">__u32</span> <span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="p">}</span> <span class="n">xfs_fsid_t</span><span class="p">;</span> <span class="cm">/* file system id type */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_fid</span> <span class="p">{</span>
	<span class="n">__u16</span>	<span class="n">fid_len</span><span class="p">;</span>		<span class="cm">/* length of remainder	*/</span>
	<span class="n">__u16</span>	<span class="n">fid_pad</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">fid_gen</span><span class="p">;</span>		<span class="cm">/* generation number	*/</span>
	<span class="n">__u64</span>	<span class="n">fid_ino</span><span class="p">;</span>		<span class="cm">/* 64 bits inode number */</span>
<span class="p">}</span> <span class="n">xfs_fid_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_handle</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__s64</span>	    <span class="n">align</span><span class="p">;</span>	<span class="cm">/* force alignment of ha_fid	 */</span>
		<span class="n">xfs_fsid_t</span>  <span class="n">_ha_fsid</span><span class="p">;</span>	<span class="cm">/* unique file system identifier */</span>
	<span class="p">}</span> <span class="n">ha_u</span><span class="p">;</span>
	<span class="n">xfs_fid_t</span>	<span class="n">ha_fid</span><span class="p">;</span>		<span class="cm">/* file system specific file ID	 */</span>
<span class="p">}</span> <span class="n">xfs_handle_t</span><span class="p">;</span>
<span class="cp">#define ha_fsid ha_u._ha_fsid</span>

<span class="cp">#define XFS_HSIZE(handle)	(((char *) &amp;(handle).ha_fid.fid_pad	 \</span>
<span class="cp">				 - (char *) &amp;(handle))			  \</span>
<span class="cp">				 + (handle).ha_fid.fid_len)</span>

<span class="cm">/*</span>
<span class="cm"> * Flags for going down operation</span>
<span class="cm"> */</span>
<span class="cp">#define XFS_FSOP_GOING_FLAGS_DEFAULT		0x0	</span><span class="cm">/* going down */</span><span class="cp"></span>
<span class="cp">#define XFS_FSOP_GOING_FLAGS_LOGFLUSH		0x1	</span><span class="cm">/* flush log but not data */</span><span class="cp"></span>
<span class="cp">#define XFS_FSOP_GOING_FLAGS_NOLOGFLUSH		0x2	</span><span class="cm">/* don&#39;t flush log nor data */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * ioctl commands that are used by Linux filesystems</span>
<span class="cm"> */</span>
<span class="cp">#define XFS_IOC_GETXFLAGS	FS_IOC_GETFLAGS</span>
<span class="cp">#define XFS_IOC_SETXFLAGS	FS_IOC_SETFLAGS</span>
<span class="cp">#define XFS_IOC_GETVERSION	FS_IOC_GETVERSION</span>

<span class="cm">/*</span>
<span class="cm"> * ioctl commands that replace IRIX fcntl()&#39;s</span>
<span class="cm"> * For &#39;documentation&#39; purposed more than anything else,</span>
<span class="cm"> * the &quot;cmd #&quot; field reflects the IRIX fcntl number.</span>
<span class="cm"> */</span>
<span class="cp">#define XFS_IOC_ALLOCSP		_IOW (&#39;X&#39;, 10, struct xfs_flock64)</span>
<span class="cp">#define XFS_IOC_FREESP		_IOW (&#39;X&#39;, 11, struct xfs_flock64)</span>
<span class="cp">#define XFS_IOC_DIOINFO		_IOR (&#39;X&#39;, 30, struct dioattr)</span>
<span class="cp">#define XFS_IOC_FSGETXATTR	_IOR (&#39;X&#39;, 31, struct fsxattr)</span>
<span class="cp">#define XFS_IOC_FSSETXATTR	_IOW (&#39;X&#39;, 32, struct fsxattr)</span>
<span class="cp">#define XFS_IOC_ALLOCSP64	_IOW (&#39;X&#39;, 36, struct xfs_flock64)</span>
<span class="cp">#define XFS_IOC_FREESP64	_IOW (&#39;X&#39;, 37, struct xfs_flock64)</span>
<span class="cp">#define XFS_IOC_GETBMAP		_IOWR(&#39;X&#39;, 38, struct getbmap)</span>
<span class="cp">#define XFS_IOC_FSSETDM		_IOW (&#39;X&#39;, 39, struct fsdmidata)</span>
<span class="cp">#define XFS_IOC_RESVSP		_IOW (&#39;X&#39;, 40, struct xfs_flock64)</span>
<span class="cp">#define XFS_IOC_UNRESVSP	_IOW (&#39;X&#39;, 41, struct xfs_flock64)</span>
<span class="cp">#define XFS_IOC_RESVSP64	_IOW (&#39;X&#39;, 42, struct xfs_flock64)</span>
<span class="cp">#define XFS_IOC_UNRESVSP64	_IOW (&#39;X&#39;, 43, struct xfs_flock64)</span>
<span class="cp">#define XFS_IOC_GETBMAPA	_IOWR(&#39;X&#39;, 44, struct getbmap)</span>
<span class="cp">#define XFS_IOC_FSGETXATTRA	_IOR (&#39;X&#39;, 45, struct fsxattr)</span>
<span class="cm">/*	XFS_IOC_SETBIOSIZE ---- deprecated 46	   */</span>
<span class="cm">/*	XFS_IOC_GETBIOSIZE ---- deprecated 47	   */</span>
<span class="cp">#define XFS_IOC_GETBMAPX	_IOWR(&#39;X&#39;, 56, struct getbmap)</span>
<span class="cp">#define XFS_IOC_ZERO_RANGE	_IOW (&#39;X&#39;, 57, struct xfs_flock64)</span>

<span class="cm">/*</span>
<span class="cm"> * ioctl commands that replace IRIX syssgi()&#39;s</span>
<span class="cm"> */</span>
<span class="cp">#define XFS_IOC_FSGEOMETRY_V1	     _IOR (&#39;X&#39;, 100, struct xfs_fsop_geom_v1)</span>
<span class="cp">#define XFS_IOC_FSBULKSTAT	     _IOWR(&#39;X&#39;, 101, struct xfs_fsop_bulkreq)</span>
<span class="cp">#define XFS_IOC_FSBULKSTAT_SINGLE    _IOWR(&#39;X&#39;, 102, struct xfs_fsop_bulkreq)</span>
<span class="cp">#define XFS_IOC_FSINUMBERS	     _IOWR(&#39;X&#39;, 103, struct xfs_fsop_bulkreq)</span>
<span class="cp">#define XFS_IOC_PATH_TO_FSHANDLE     _IOWR(&#39;X&#39;, 104, struct xfs_fsop_handlereq)</span>
<span class="cp">#define XFS_IOC_PATH_TO_HANDLE	     _IOWR(&#39;X&#39;, 105, struct xfs_fsop_handlereq)</span>
<span class="cp">#define XFS_IOC_FD_TO_HANDLE	     _IOWR(&#39;X&#39;, 106, struct xfs_fsop_handlereq)</span>
<span class="cp">#define XFS_IOC_OPEN_BY_HANDLE	     _IOWR(&#39;X&#39;, 107, struct xfs_fsop_handlereq)</span>
<span class="cp">#define XFS_IOC_READLINK_BY_HANDLE   _IOWR(&#39;X&#39;, 108, struct xfs_fsop_handlereq)</span>
<span class="cp">#define XFS_IOC_SWAPEXT		     _IOWR(&#39;X&#39;, 109, struct xfs_swapext)</span>
<span class="cp">#define XFS_IOC_FSGROWFSDATA	     _IOW (&#39;X&#39;, 110, struct xfs_growfs_data)</span>
<span class="cp">#define XFS_IOC_FSGROWFSLOG	     _IOW (&#39;X&#39;, 111, struct xfs_growfs_log)</span>
<span class="cp">#define XFS_IOC_FSGROWFSRT	     _IOW (&#39;X&#39;, 112, struct xfs_growfs_rt)</span>
<span class="cp">#define XFS_IOC_FSCOUNTS	     _IOR (&#39;X&#39;, 113, struct xfs_fsop_counts)</span>
<span class="cp">#define XFS_IOC_SET_RESBLKS	     _IOWR(&#39;X&#39;, 114, struct xfs_fsop_resblks)</span>
<span class="cp">#define XFS_IOC_GET_RESBLKS	     _IOR (&#39;X&#39;, 115, struct xfs_fsop_resblks)</span>
<span class="cp">#define XFS_IOC_ERROR_INJECTION	     _IOW (&#39;X&#39;, 116, struct xfs_error_injection)</span>
<span class="cp">#define XFS_IOC_ERROR_CLEARALL	     _IOW (&#39;X&#39;, 117, struct xfs_error_injection)</span>
<span class="cm">/*	XFS_IOC_ATTRCTL_BY_HANDLE -- deprecated 118	 */</span>
<span class="cm">/*	XFS_IOC_FREEZE		  -- FIFREEZE   119	 */</span>
<span class="cm">/*	XFS_IOC_THAW		  -- FITHAW     120	 */</span>
<span class="cp">#define XFS_IOC_FSSETDM_BY_HANDLE    _IOW (&#39;X&#39;, 121, struct xfs_fsop_setdm_handlereq)</span>
<span class="cp">#define XFS_IOC_ATTRLIST_BY_HANDLE   _IOW (&#39;X&#39;, 122, struct xfs_fsop_attrlist_handlereq)</span>
<span class="cp">#define XFS_IOC_ATTRMULTI_BY_HANDLE  _IOW (&#39;X&#39;, 123, struct xfs_fsop_attrmulti_handlereq)</span>
<span class="cp">#define XFS_IOC_FSGEOMETRY	     _IOR (&#39;X&#39;, 124, struct xfs_fsop_geom)</span>
<span class="cp">#define XFS_IOC_GOINGDOWN	     _IOR (&#39;X&#39;, 125, __uint32_t)</span>
<span class="cm">/*	XFS_IOC_GETFSUUID ---------- deprecated 140	 */</span>


<span class="cp">#ifndef HAVE_BBMACROS</span>
<span class="cm">/*</span>
<span class="cm"> * Block I/O parameterization.	A basic block (BB) is the lowest size of</span>
<span class="cm"> * filesystem allocation, and must equal 512.  Length units given to bio</span>
<span class="cm"> * routines are in BB&#39;s.</span>
<span class="cm"> */</span>
<span class="cp">#define BBSHIFT		9</span>
<span class="cp">#define BBSIZE		(1&lt;&lt;BBSHIFT)</span>
<span class="cp">#define BBMASK		(BBSIZE-1)</span>
<span class="cp">#define BTOBB(bytes)	(((__u64)(bytes) + BBSIZE - 1) &gt;&gt; BBSHIFT)</span>
<span class="cp">#define BTOBBT(bytes)	((__u64)(bytes) &gt;&gt; BBSHIFT)</span>
<span class="cp">#define BBTOB(bbs)	((bbs) &lt;&lt; BBSHIFT)</span>
<span class="cp">#endif</span>

<span class="cp">#endif	</span><span class="cm">/* __XFS_FS_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
