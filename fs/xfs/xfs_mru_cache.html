<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_mru_cache.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_mru_cache.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2006-2007 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_mru_cache.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * The MRU Cache data structure consists of a data store, an array of lists and</span>
<span class="cm"> * a lock to protect its internal state.  At initialisation time, the client</span>
<span class="cm"> * supplies an element lifetime in milliseconds and a group count, as well as a</span>
<span class="cm"> * function pointer to call when deleting elements.  A data structure for</span>
<span class="cm"> * queueing up work in the form of timed callbacks is also included.</span>
<span class="cm"> *</span>
<span class="cm"> * The group count controls how many lists are created, and thereby how finely</span>
<span class="cm"> * the elements are grouped in time.  When reaping occurs, all the elements in</span>
<span class="cm"> * all the lists whose time has expired are deleted.</span>
<span class="cm"> *</span>
<span class="cm"> * To give an example of how this works in practice, consider a client that</span>
<span class="cm"> * initialises an MRU Cache with a lifetime of ten seconds and a group count of</span>
<span class="cm"> * five.  Five internal lists will be created, each representing a two second</span>
<span class="cm"> * period in time.  When the first element is added, time zero for the data</span>
<span class="cm"> * structure is initialised to the current time.</span>
<span class="cm"> *</span>
<span class="cm"> * All the elements added in the first two seconds are appended to the first</span>
<span class="cm"> * list.  Elements added in the third second go into the second list, and so on.</span>
<span class="cm"> * If an element is accessed at any point, it is removed from its list and</span>
<span class="cm"> * inserted at the head of the current most-recently-used list.</span>
<span class="cm"> *</span>
<span class="cm"> * The reaper function will have nothing to do until at least twelve seconds</span>
<span class="cm"> * have elapsed since the first element was added.  The reason for this is that</span>
<span class="cm"> * if it were called at t=11s, there could be elements in the first list that</span>
<span class="cm"> * have only been inactive for nine seconds, so it still does nothing.  If it is</span>
<span class="cm"> * called anywhere between t=12 and t=14 seconds, it will delete all the</span>
<span class="cm"> * elements that remain in the first list.  It&#39;s therefore possible for elements</span>
<span class="cm"> * to remain in the data store even after they&#39;ve been inactive for up to</span>
<span class="cm"> * (t + t/g) seconds, where t is the inactive element lifetime and g is the</span>
<span class="cm"> * number of groups.</span>
<span class="cm"> *</span>
<span class="cm"> * The above example assumes that the reaper function gets called at least once</span>
<span class="cm"> * every (t/g) seconds.  If it is called less frequently, unused elements will</span>
<span class="cm"> * accumulate in the reap list until the reaper function is eventually called.</span>
<span class="cm"> * The current implementation uses work queue callbacks to carefully time the</span>
<span class="cm"> * reaper function calls, so this should happen rarely, if at all.</span>
<span class="cm"> *</span>
<span class="cm"> * From a design perspective, the primary reason for the choice of a list array</span>
<span class="cm"> * representing discrete time intervals is that it&#39;s only practical to reap</span>
<span class="cm"> * expired elements in groups of some appreciable size.  This automatically</span>
<span class="cm"> * introduces a granularity to element lifetimes, so there&#39;s no point storing an</span>
<span class="cm"> * individual timeout with each element that specifies a more precise reap time.</span>
<span class="cm"> * The bonus is a saving of sizeof(long) bytes of memory per element stored.</span>
<span class="cm"> *</span>
<span class="cm"> * The elements could have been stored in just one list, but an array of</span>
<span class="cm"> * counters or pointers would need to be maintained to allow them to be divided</span>
<span class="cm"> * up into discrete time groups.  More critically, the process of touching or</span>
<span class="cm"> * removing an element would involve walking large portions of the entire list,</span>
<span class="cm"> * which would have a detrimental effect on performance.  The additional memory</span>
<span class="cm"> * requirement for the array of list heads is minimal.</span>
<span class="cm"> *</span>
<span class="cm"> * When an element is touched or deleted, it needs to be removed from its</span>
<span class="cm"> * current list.  Doubly linked lists are used to make the list maintenance</span>
<span class="cm"> * portion of these operations O(1).  Since reaper timing can be imprecise,</span>
<span class="cm"> * inserts and lookups can occur when there are no free lists available.  When</span>
<span class="cm"> * this happens, all the elements on the LRU list need to be migrated to the end</span>
<span class="cm"> * of the reap list.  To keep the list maintenance portion of these operations</span>
<span class="cm"> * O(1) also, list tails need to be accessible without walking the entire list.</span>
<span class="cm"> * This is the reason why doubly linked list heads are used.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * An MRU Cache is a dynamic data structure that stores its elements in a way</span>
<span class="cm"> * that allows efficient lookups, but also groups them into discrete time</span>
<span class="cm"> * intervals based on insertion time.  This allows elements to be efficiently</span>
<span class="cm"> * and automatically reaped after a fixed period of inactivity.</span>
<span class="cm"> *</span>
<span class="cm"> * When a client data pointer is stored in the MRU Cache it needs to be added to</span>
<span class="cm"> * both the data store and to one of the lists.  It must also be possible to</span>
<span class="cm"> * access each of these entries via the other, i.e. to:</span>
<span class="cm"> *</span>
<span class="cm"> *    a) Walk a list, removing the corresponding data store entry for each item.</span>
<span class="cm"> *    b) Look up a data store entry, then access its list entry directly.</span>
<span class="cm"> *</span>
<span class="cm"> * To achieve both of these goals, each entry must contain both a list entry and</span>
<span class="cm"> * a key, in addition to the user&#39;s data pointer.  Note that it&#39;s not a good</span>
<span class="cm"> * idea to have the client embed one of these structures at the top of their own</span>
<span class="cm"> * data structure, because inserting the same item more than once would most</span>
<span class="cm"> * likely result in a loop in one of the lists.  That&#39;s a sure-fire recipe for</span>
<span class="cm"> * an infinite loop in the code.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_mru_cache_elem</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list_node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">key</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">xfs_mru_cache_elem_t</span><span class="p">;</span>

<span class="k">static</span> <span class="n">kmem_zone_t</span>		<span class="o">*</span><span class="n">xfs_mru_elem_zone</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span>	<span class="o">*</span><span class="n">xfs_mru_reap_wq</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * When inserting, destroying or reaping, it&#39;s first necessary to update the</span>
<span class="cm"> * lists relative to a particular time.  In the case of destroying, that time</span>
<span class="cm"> * will be well in the future to ensure that all items are moved to the reap</span>
<span class="cm"> * list.  In all other cases though, the time will be the current time.</span>
<span class="cm"> *</span>
<span class="cm"> * This function enters a loop, moving the contents of the LRU list to the reap</span>
<span class="cm"> * list again and again until either a) the lists are all empty, or b) time zero</span>
<span class="cm"> * has been advanced sufficiently to be within the immediate element lifetime.</span>
<span class="cm"> *</span>
<span class="cm"> * Case a) above is detected by counting how many groups are migrated and</span>
<span class="cm"> * stopping when they&#39;ve all been moved.  Case b) is detected by monitoring the</span>
<span class="cm"> * time_zero field, which is updated as each group is migrated.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the earliest time that more migration could be needed, or</span>
<span class="cm"> * zero if there&#39;s no need to schedule more work because the lists are empty.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">_xfs_mru_cache_migrate</span><span class="p">(</span>
	<span class="n">xfs_mru_cache_t</span>	<span class="o">*</span><span class="n">mru</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">grp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">migrated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lru_list</span><span class="p">;</span>

	<span class="cm">/* Nothing to do if the data store is empty. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">time_zero</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* While time zero is older than the time spanned by all the lists. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">time_zero</span> <span class="o">&lt;=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_count</span> <span class="o">*</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_time</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the LRU list isn&#39;t empty, migrate its elements to the tail</span>
<span class="cm">		 * of the reap list.</span>
<span class="cm">		 */</span>
		<span class="n">lru_list</span> <span class="o">=</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span> <span class="o">+</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">lru_grp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">lru_list</span><span class="p">))</span>
			<span class="n">list_splice_init</span><span class="p">(</span><span class="n">lru_list</span><span class="p">,</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">reap_list</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Advance the LRU group number, freeing the old LRU list to</span>
<span class="cm">		 * become the new MRU list; advance time zero accordingly.</span>
<span class="cm">		 */</span>
		<span class="n">mru</span><span class="o">-&gt;</span><span class="n">lru_grp</span> <span class="o">=</span> <span class="p">(</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lru_grp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_count</span><span class="p">;</span>
		<span class="n">mru</span><span class="o">-&gt;</span><span class="n">time_zero</span> <span class="o">+=</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_time</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If reaping is so far behind that all the elements on all the</span>
<span class="cm">		 * lists have been migrated to the reap list, it&#39;s now empty.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">migrated</span> <span class="o">==</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mru</span><span class="o">-&gt;</span><span class="n">lru_grp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">mru</span><span class="o">-&gt;</span><span class="n">time_zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Find the first non-empty list from the LRU end. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">grp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">grp</span> <span class="o">&lt;</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_count</span><span class="p">;</span> <span class="n">grp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Check the grp&#39;th list from the LRU end. */</span>
		<span class="n">lru_list</span> <span class="o">=</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span> <span class="o">+</span> <span class="p">((</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lru_grp</span> <span class="o">+</span> <span class="n">grp</span><span class="p">)</span> <span class="o">%</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">lru_list</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">time_zero</span> <span class="o">+</span>
			       <span class="p">(</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_count</span> <span class="o">+</span> <span class="n">grp</span><span class="p">)</span> <span class="o">*</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_time</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* All the lists must be empty. */</span>
	<span class="n">mru</span><span class="o">-&gt;</span><span class="n">lru_grp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mru</span><span class="o">-&gt;</span><span class="n">time_zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When inserting or doing a lookup, an element needs to be inserted into the</span>
<span class="cm"> * MRU list.  The lists must be migrated first to ensure that they&#39;re</span>
<span class="cm"> * up-to-date, otherwise the new element could be given a shorter lifetime in</span>
<span class="cm"> * the cache than it should.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">_xfs_mru_cache_list_insert</span><span class="p">(</span>
	<span class="n">xfs_mru_cache_t</span>		<span class="o">*</span><span class="n">mru</span><span class="p">,</span>
	<span class="n">xfs_mru_cache_elem_t</span>	<span class="o">*</span><span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">grp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the data store is empty, initialise time zero, leave grp set to</span>
<span class="cm">	 * zero and start the work queue timer if necessary.  Otherwise, set grp</span>
<span class="cm">	 * to the number of group times that have elapsed since time zero.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_xfs_mru_cache_migrate</span><span class="p">(</span><span class="n">mru</span><span class="p">,</span> <span class="n">now</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mru</span><span class="o">-&gt;</span><span class="n">time_zero</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mru</span><span class="o">-&gt;</span><span class="n">queued</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">xfs_mru_reap_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span>
			                   <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_count</span> <span class="o">*</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_time</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">grp</span> <span class="o">=</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">time_zero</span><span class="p">)</span> <span class="o">/</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_time</span><span class="p">;</span>
		<span class="n">grp</span> <span class="o">=</span> <span class="p">(</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lru_grp</span> <span class="o">+</span> <span class="n">grp</span><span class="p">)</span> <span class="o">%</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Insert the element at the tail of the corresponding list. */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">,</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span> <span class="o">+</span> <span class="n">grp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When destroying or reaping, all the elements that were migrated to the reap</span>
<span class="cm"> * list need to be deleted.  For each element this involves removing it from the</span>
<span class="cm"> * data store, removing it from the reap list, calling the client&#39;s free</span>
<span class="cm"> * function and deleting the element from the element zone.</span>
<span class="cm"> *</span>
<span class="cm"> * We get called holding the mru-&gt;lock, which we drop and then reacquire.</span>
<span class="cm"> * Sparse need special help with this to tell it we know what we are doing.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">_xfs_mru_cache_clear_reap_list</span><span class="p">(</span>
	<span class="n">xfs_mru_cache_t</span>		<span class="o">*</span><span class="n">mru</span><span class="p">)</span> <span class="n">__releases</span><span class="p">(</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span> <span class="n">__acquires</span><span class="p">(</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>

<span class="p">{</span>
	<span class="n">xfs_mru_cache_elem_t</span>	<span class="o">*</span><span class="n">elem</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">tmp</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">reap_list</span><span class="p">,</span> <span class="n">list_node</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Remove the element from the data store. */</span>
		<span class="n">radix_tree_delete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="n">elem</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * remove to temp list so it can be freed without</span>
<span class="cm">		 * needing to hold the lock</span>
<span class="cm">		 */</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">list_node</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Remove the element from the reap list. */</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>

		<span class="cm">/* Call the client&#39;s free function with the key and value pointer. */</span>
		<span class="n">mru</span><span class="o">-&gt;</span><span class="n">free_func</span><span class="p">(</span><span class="n">elem</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">elem</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>

		<span class="cm">/* Free the element structure. */</span>
		<span class="n">kmem_zone_free</span><span class="p">(</span><span class="n">xfs_mru_elem_zone</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We fire the reap timer every group expiry interval so</span>
<span class="cm"> * we always have a reaper ready to run. This makes shutdown</span>
<span class="cm"> * and flushing of the reaper easy to do. Hence we need to</span>
<span class="cm"> * keep when the next reap must occur so we can determine</span>
<span class="cm"> * at each interval whether there is anything we need to do.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">_xfs_mru_cache_reap</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mru_cache_t</span>		<span class="o">*</span><span class="n">mru</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">xfs_mru_cache_t</span><span class="p">,</span> <span class="n">work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">now</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">mru</span> <span class="o">&amp;&amp;</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mru</span> <span class="o">||</span> <span class="o">!</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">_xfs_mru_cache_migrate</span><span class="p">(</span><span class="n">mru</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>
	<span class="n">_xfs_mru_cache_clear_reap_list</span><span class="p">(</span><span class="n">mru</span><span class="p">);</span>

	<span class="n">mru</span><span class="o">-&gt;</span><span class="n">queued</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">queued</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&lt;=</span> <span class="n">now</span><span class="p">)</span>
			<span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">next</span> <span class="o">-=</span> <span class="n">now</span><span class="p">;</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">xfs_mru_reap_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_mru_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mru_elem_zone</span> <span class="o">=</span> <span class="n">kmem_zone_init</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_mru_cache_elem_t</span><span class="p">),</span>
	                                 <span class="s">&quot;xfs_mru_cache_elem&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_mru_elem_zone</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">xfs_mru_reap_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;xfs_mru_cache&quot;</span><span class="p">,</span> <span class="n">WQ_MEM_RECLAIM</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_mru_reap_wq</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_destroy_mru_elem_zone</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_destroy_mru_elem_zone:</span>
	<span class="n">kmem_zone_destroy</span><span class="p">(</span><span class="n">xfs_mru_elem_zone</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_mru_cache_uninit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">xfs_mru_reap_wq</span><span class="p">);</span>
	<span class="n">kmem_zone_destroy</span><span class="p">(</span><span class="n">xfs_mru_elem_zone</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * To initialise a struct xfs_mru_cache pointer, call xfs_mru_cache_create()</span>
<span class="cm"> * with the address of the pointer, a lifetime value in milliseconds, a group</span>
<span class="cm"> * count and a free function to use when deleting elements.  This function</span>
<span class="cm"> * returns 0 if the initialisation was successful.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_mru_cache_create</span><span class="p">(</span>
	<span class="n">xfs_mru_cache_t</span>		<span class="o">**</span><span class="n">mrup</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">lifetime_ms</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">grp_count</span><span class="p">,</span>
	<span class="n">xfs_mru_cache_free_func_t</span> <span class="n">free_func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mru_cache_t</span>	<span class="o">*</span><span class="n">mru</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">grp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">grp_time</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mrup</span><span class="p">)</span>
		<span class="o">*</span><span class="n">mrup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mrup</span> <span class="o">||</span> <span class="o">!</span><span class="n">grp_count</span> <span class="o">||</span> <span class="o">!</span><span class="n">lifetime_ms</span> <span class="o">||</span> <span class="o">!</span><span class="n">free_func</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">grp_time</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">lifetime_ms</span><span class="p">)</span> <span class="o">/</span> <span class="n">grp_count</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mru</span> <span class="o">=</span> <span class="n">kmem_zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mru</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* An extra list is needed to avoid reaping up to a grp_time early. */</span>
	<span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_count</span> <span class="o">=</span> <span class="n">grp_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span> <span class="o">=</span> <span class="n">kmem_zalloc</span><span class="p">(</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">grp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">grp</span> <span class="o">&lt;</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_count</span><span class="p">;</span> <span class="n">grp</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span> <span class="o">+</span> <span class="n">grp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We use GFP_KERNEL radix tree preload and do inserts under a</span>
<span class="cm">	 * spinlock so GFP_ATOMIC is appropriate for the radix tree itself.</span>
<span class="cm">	 */</span>
	<span class="n">INIT_RADIX_TREE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">reap_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">_xfs_mru_cache_reap</span><span class="p">);</span>

	<span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_time</span>  <span class="o">=</span> <span class="n">grp_time</span><span class="p">;</span>
	<span class="n">mru</span><span class="o">-&gt;</span><span class="n">free_func</span> <span class="o">=</span> <span class="n">free_func</span><span class="p">;</span>

	<span class="o">*</span><span class="n">mrup</span> <span class="o">=</span> <span class="n">mru</span><span class="p">;</span>

<span class="nl">exit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">mru</span> <span class="o">&amp;&amp;</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">)</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">mru</span><span class="p">)</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">mru</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Call xfs_mru_cache_flush() to flush out all cached entries, calling their</span>
<span class="cm"> * free functions as they&#39;re deleted.  When this function returns, the caller is</span>
<span class="cm"> * guaranteed that all the free functions for all the elements have finished</span>
<span class="cm"> * executing and the reaper is not running.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xfs_mru_cache_flush</span><span class="p">(</span>
	<span class="n">xfs_mru_cache_t</span>		<span class="o">*</span><span class="n">mru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mru</span> <span class="o">||</span> <span class="o">!</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">_xfs_mru_cache_migrate</span><span class="p">(</span><span class="n">mru</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_count</span> <span class="o">*</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">grp_time</span><span class="p">);</span>
	<span class="n">_xfs_mru_cache_clear_reap_list</span><span class="p">(</span><span class="n">mru</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_mru_cache_destroy</span><span class="p">(</span>
	<span class="n">xfs_mru_cache_t</span>		<span class="o">*</span><span class="n">mru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mru</span> <span class="o">||</span> <span class="o">!</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">xfs_mru_cache_flush</span><span class="p">(</span><span class="n">mru</span><span class="p">);</span>

	<span class="n">kmem_free</span><span class="p">(</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">);</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">mru</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * To insert an element, call xfs_mru_cache_insert() with the data store, the</span>
<span class="cm"> * element&#39;s key and the client data pointer.  This function returns 0 on</span>
<span class="cm"> * success or ENOMEM if memory for the data element couldn&#39;t be allocated.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_mru_cache_insert</span><span class="p">(</span>
	<span class="n">xfs_mru_cache_t</span>	<span class="o">*</span><span class="n">mru</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">key</span><span class="p">,</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mru_cache_elem_t</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">mru</span> <span class="o">&amp;&amp;</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mru</span> <span class="o">||</span> <span class="o">!</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">elem</span> <span class="o">=</span> <span class="n">kmem_zone_zalloc</span><span class="p">(</span><span class="n">xfs_mru_elem_zone</span><span class="p">,</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elem</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_preload</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kmem_zone_free</span><span class="p">(</span><span class="n">xfs_mru_elem_zone</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
	<span class="n">elem</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">elem</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">radix_tree_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>
	<span class="n">radix_tree_preload_end</span><span class="p">();</span>
	<span class="n">_xfs_mru_cache_list_insert</span><span class="p">(</span><span class="n">mru</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * To remove an element without calling the free function, call</span>
<span class="cm"> * xfs_mru_cache_remove() with the data store and the element&#39;s key.  On success</span>
<span class="cm"> * the client data pointer for the removed element is returned, otherwise this</span>
<span class="cm"> * function will return a NULL pointer.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">xfs_mru_cache_remove</span><span class="p">(</span>
	<span class="n">xfs_mru_cache_t</span>	<span class="o">*</span><span class="n">mru</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mru_cache_elem_t</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">mru</span> <span class="o">&amp;&amp;</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mru</span> <span class="o">||</span> <span class="o">!</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">elem</span> <span class="o">=</span> <span class="n">radix_tree_delete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">elem</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">elem</span><span class="p">)</span>
		<span class="n">kmem_zone_free</span><span class="p">(</span><span class="n">xfs_mru_elem_zone</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * To remove and element and call the free function, call xfs_mru_cache_delete()</span>
<span class="cm"> * with the data store and the element&#39;s key.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_mru_cache_delete</span><span class="p">(</span>
	<span class="n">xfs_mru_cache_t</span>	<span class="o">*</span><span class="n">mru</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">xfs_mru_cache_remove</span><span class="p">(</span><span class="n">mru</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span>
		<span class="n">mru</span><span class="o">-&gt;</span><span class="n">free_func</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * To look up an element using its key, call xfs_mru_cache_lookup() with the</span>
<span class="cm"> * data store and the element&#39;s key.  If found, the element will be moved to the</span>
<span class="cm"> * head of the MRU list to indicate that it&#39;s been touched.</span>
<span class="cm"> *</span>
<span class="cm"> * The internal data structures are protected by a spinlock that is STILL HELD</span>
<span class="cm"> * when this function returns.  Call xfs_mru_cache_done() to release it.  Note</span>
<span class="cm"> * that it is not safe to call any function that might sleep in the interim.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation could have used reference counting to avoid this</span>
<span class="cm"> * restriction, but since most clients simply want to get, set or test a member</span>
<span class="cm"> * of the returned data structure, the extra per-element memory isn&#39;t warranted.</span>
<span class="cm"> *</span>
<span class="cm"> * If the element isn&#39;t found, this function returns NULL and the spinlock is</span>
<span class="cm"> * released.  xfs_mru_cache_done() should NOT be called when this occurs.</span>
<span class="cm"> *</span>
<span class="cm"> * Because sparse isn&#39;t smart enough to know about conditional lock return</span>
<span class="cm"> * status, we need to help it get it right by annotating the path that does</span>
<span class="cm"> * not release the lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">xfs_mru_cache_lookup</span><span class="p">(</span>
	<span class="n">xfs_mru_cache_t</span>	<span class="o">*</span><span class="n">mru</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mru_cache_elem_t</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">mru</span> <span class="o">&amp;&amp;</span> <span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mru</span> <span class="o">||</span> <span class="o">!</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">elem</span> <span class="o">=</span> <span class="n">radix_tree_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="o">-&gt;</span><span class="n">list_node</span><span class="p">);</span>
		<span class="n">_xfs_mru_cache_list_insert</span><span class="p">(</span><span class="n">mru</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>
		<span class="n">__release</span><span class="p">(</span><span class="n">mru_lock</span><span class="p">);</span> <span class="cm">/* help sparse not be stupid */</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">elem</span> <span class="o">?</span> <span class="n">elem</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * To release the internal data structure spinlock after having performed an</span>
<span class="cm"> * xfs_mru_cache_lookup() or an xfs_mru_cache_peek(), call xfs_mru_cache_done()</span>
<span class="cm"> * with the data store pointer.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_mru_cache_done</span><span class="p">(</span>
	<span class="n">xfs_mru_cache_t</span>	<span class="o">*</span><span class="n">mru</span><span class="p">)</span> <span class="n">__releases</span><span class="p">(</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mru</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
