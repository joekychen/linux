<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_vnodeops.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_vnodeops.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2006 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_bit.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_dir2.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_da_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_ialloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode_item.h&quot;</span>
<span class="cp">#include &quot;xfs_itable.h&quot;</span>
<span class="cp">#include &quot;xfs_ialloc.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap.h&quot;</span>
<span class="cp">#include &quot;xfs_acl.h&quot;</span>
<span class="cp">#include &quot;xfs_attr.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_quota.h&quot;</span>
<span class="cp">#include &quot;xfs_utils.h&quot;</span>
<span class="cp">#include &quot;xfs_rtalloc.h&quot;</span>
<span class="cp">#include &quot;xfs_trans_space.h&quot;</span>
<span class="cp">#include &quot;xfs_log_priv.h&quot;</span>
<span class="cp">#include &quot;xfs_filestream.h&quot;</span>
<span class="cp">#include &quot;xfs_vnodeops.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * The maximum pathlen is 1024 bytes. Since the minimum file system</span>
<span class="cm"> * blocksize is 512 bytes, we can get a max of 2 extents back from</span>
<span class="cm"> * bmapi.</span>
<span class="cm"> */</span>
<span class="cp">#define SYMLINK_MAPS 2</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_readlink_bmap</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">pathlen</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span><span class="p">;</span>
	<span class="kt">int</span>             <span class="n">nmaps</span> <span class="o">=</span> <span class="n">SYMLINK_MAPS</span><span class="p">;</span>
	<span class="n">xfs_bmbt_irec_t</span> <span class="n">mval</span><span class="p">[</span><span class="n">SYMLINK_MAPS</span><span class="p">];</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">d</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">byte_cnt</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">n</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">pathlen</span><span class="p">),</span> <span class="n">mval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmaps</span><span class="p">,</span>
			       <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">nmaps</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mval</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">br_startblock</span><span class="p">);</span>
		<span class="n">byte_cnt</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mval</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">br_blockcount</span><span class="p">);</span>

		<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_read</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">byte_cnt</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_buf_ioerror_alert</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pathlen</span> <span class="o">&lt;</span> <span class="n">byte_cnt</span><span class="p">)</span>
			<span class="n">byte_cnt</span> <span class="o">=</span> <span class="n">pathlen</span><span class="p">;</span>
		<span class="n">pathlen</span> <span class="o">-=</span> <span class="n">byte_cnt</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">,</span> <span class="n">byte_cnt</span><span class="p">);</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">link</span><span class="p">[</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_readlink</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>     <span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">xfs_fsize_t</span>	<span class="n">pathlen</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">trace_xfs_readlink</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>

	<span class="n">pathlen</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pathlen</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pathlen</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pathlen</span> <span class="o">&gt;</span> <span class="n">MAXPATHLEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: inode (%llu) bad symlink length (%lld)&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pathlen</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFINLINE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">,</span> <span class="n">pathlen</span><span class="p">);</span>
		<span class="n">link</span><span class="p">[</span><span class="n">pathlen</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_readlink_bmap</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flags for xfs_free_eofblocks</span>
<span class="cm"> */</span>
<span class="cp">#define XFS_FREE_EOF_TRYLOCK	(1&lt;&lt;0)</span>

<span class="cm">/*</span>
<span class="cm"> * This is called by xfs_inactive to free any blocks beyond eof</span>
<span class="cm"> * when the link count isn&#39;t zero and by xfs_dm_punch_hole() when</span>
<span class="cm"> * punching a hole to EOF.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_free_eofblocks</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>	<span class="n">end_fsb</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>	<span class="n">last_fsb</span><span class="p">;</span>
	<span class="n">xfs_filblks_t</span>	<span class="n">map_len</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">nimaps</span><span class="p">;</span>
	<span class="n">xfs_bmbt_irec_t</span>	<span class="n">imap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Figure out if there are any blocks beyond the end</span>
<span class="cm">	 * of the file.  If not, then there is nothing to do.</span>
<span class="cm">	 */</span>
	<span class="n">end_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_ufsize_t</span><span class="p">)</span><span class="n">XFS_ISIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>
	<span class="n">last_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_ufsize_t</span><span class="p">)</span><span class="n">XFS_MAXIOFFSET</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_fsb</span> <span class="o">&lt;=</span> <span class="n">end_fsb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">map_len</span> <span class="o">=</span> <span class="n">last_fsb</span> <span class="o">-</span> <span class="n">end_fsb</span><span class="p">;</span>

	<span class="n">nimaps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">end_fsb</span><span class="p">,</span> <span class="n">map_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nimaps</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nimaps</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">HOLESTARTBLOCK</span> <span class="o">||</span>
	     <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_delayed_blks</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Attach the dquots to the inode up front.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_dqattach</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * There are blocks after the end of file.</span>
<span class="cm">		 * Free them up now by truncating the file to</span>
<span class="cm">		 * its current size.</span>
<span class="cm">		 */</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_INACTIVE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_FREE_EOF_TRYLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_ilock_nowait</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">XFS_ITRUNCATE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span>
					  <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span>
					  <span class="n">XFS_ITRUNCATE_LOG_COUNT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
			<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do not update the on-disk file size.  If we update the</span>
<span class="cm">		 * on-disk file size and then the system crashes before the</span>
<span class="cm">		 * contents of the file are flushed to disk then the files</span>
<span class="cm">		 * may be full of holes (ie NULL files bug).</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_itruncate_extents</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">,</span>
					      <span class="n">XFS_ISIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we get an error at this point we simply don&#39;t</span>
<span class="cm">			 * bother truncating the file.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">XFS_TRANS_RELEASE_LOG_RES</span> <span class="o">|</span>
					  <span class="n">XFS_TRANS_ABORT</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span>
						<span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="o">|</span><span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free a symlink that has blocks associated with it.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_inactive_symlink_rmt</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_trans_t</span>	<span class="o">**</span><span class="n">tpp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">committed</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">done</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_fsblock_t</span>	<span class="n">first_block</span><span class="p">;</span>
	<span class="n">xfs_bmap_free_t</span>	<span class="n">free_list</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_bmbt_irec_t</span>	<span class="n">mval</span><span class="p">[</span><span class="n">SYMLINK_MAPS</span><span class="p">];</span>
	<span class="kt">int</span>		<span class="n">nmaps</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">ntp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">size</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="o">*</span><span class="n">tpp</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">&gt;</span> <span class="n">XFS_IFORK_DSIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re freeing a symlink that has some</span>
<span class="cm">	 * blocks allocated to it.  Free the</span>
<span class="cm">	 * blocks here.  We know that we&#39;ve got</span>
<span class="cm">	 * either 1 or 2 extents and that we can</span>
<span class="cm">	 * free them all in one bunmapi call.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nextents</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nextents</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_ITRUNCATE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span> <span class="n">XFS_ITRUNCATE_LOG_COUNT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="o">*</span><span class="n">tpp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Lock the inode, fix the size, and join it to the transaction.</span>
<span class="cm">	 * Hold it so in the normal path, we still have it locked for</span>
<span class="cm">	 * the second transaction.  In the error paths we need it</span>
<span class="cm">	 * held so the cancel won&#39;t rele it, see below.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span> <span class="o">|</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Find the block(s) so we can inval and unmap them.</span>
<span class="cm">	 */</span>
	<span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_block</span><span class="p">);</span>
	<span class="n">nmaps</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mval</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span>
				<span class="n">mval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmaps</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Invalidate the block(s).</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nmaps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_trans_get_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span>
			<span class="n">XFS_FSB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mval</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_startblock</span><span class="p">),</span>
			<span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mval</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_blockcount</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">xfs_trans_binval</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Unmap the dead block(s) to the free_list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bunmapi</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">XFS_BMAPI_METADATA</span><span class="p">,</span> <span class="n">nmaps</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">first_block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">done</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Commit the first transaction.  This logs the EFI and the inode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">committed</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The transaction must have been committed, since there were</span>
<span class="cm">	 * actually extents freed by xfs_bunmapi.  See xfs_bmap_finish.</span>
<span class="cm">	 * The new tp has the extent freeing and EFDs.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">committed</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The first xact was committed, so add the inode to the new one.</span>
<span class="cm">	 * Mark it dirty so it will be logged and moved forward in the log as</span>
<span class="cm">	 * part of every commit.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get a new, empty transaction to return to our caller.</span>
<span class="cm">	 */</span>
	<span class="n">ntp</span> <span class="o">=</span> <span class="n">xfs_trans_dup</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Commit the transaction containing extent freeing and EFDs.</span>
<span class="cm">	 * If we get an error on the commit here or on the reserve below,</span>
<span class="cm">	 * we need to unlock the inode since the new transaction doesn&#39;t</span>
<span class="cm">	 * have the inode attached.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">ntp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * transaction commit worked ok so we can drop the extra ticket</span>
<span class="cm">	 * reference that we gained in xfs_trans_dup()</span>
<span class="cm">	 */</span>
	<span class="n">xfs_log_ticket_put</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_ticket</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove the memory for extent descriptions (just bookkeeping).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_bytes</span><span class="p">)</span>
		<span class="n">xfs_idata_realloc</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">-</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_bytes</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Put an itruncate log reservation in the new transaction</span>
<span class="cm">	 * for our caller.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_ITRUNCATE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span> <span class="n">XFS_ITRUNCATE_LOG_COUNT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Return with the inode locked but not joined to the transaction.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">tpp</span> <span class="o">=</span> <span class="n">tp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">error1:</span>
	<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">);</span>
 <span class="nl">error0:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Have to come here with the inode locked and either</span>
<span class="cm">	 * (held and in the transaction) or (not in the transaction).</span>
<span class="cm">	 * If the inode isn&#39;t held then cancel would iput it, but</span>
<span class="cm">	 * that&#39;s wrong since this is inactive and the vnode ref</span>
<span class="cm">	 * count is 0 already.</span>
<span class="cm">	 * Cancel won&#39;t do anything to the inode if held, but it still</span>
<span class="cm">	 * needs to be locked until the cancel is done, if it was</span>
<span class="cm">	 * joined to the transaction.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span> <span class="o">|</span> <span class="n">XFS_TRANS_ABORT</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span> <span class="o">|</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="o">*</span><span class="n">tpp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_inactive_symlink_local</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_trans_t</span>	<span class="o">**</span><span class="n">tpp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">&lt;=</span> <span class="n">XFS_IFORK_DSIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re freeing a symlink which fit into</span>
<span class="cm">	 * the inode.  Just free the memory used</span>
<span class="cm">	 * to hold the old symlink.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="o">*</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">XFS_ITRUNCATE_LOG_RES</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">),</span>
				  <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span>
				  <span class="n">XFS_ITRUNCATE_LOG_COUNT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="o">*</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="o">*</span><span class="n">tpp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span> <span class="o">|</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Zero length symlinks _can_ exist.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_idata_realloc</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span>
				  <span class="o">-</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_bytes</span><span class="p">),</span>
				  <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_inactive_attrs</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_trans_t</span>	<span class="o">**</span><span class="n">tpp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_isilocked</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">));</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="o">*</span><span class="n">tpp</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_forkoff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_unlock</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_inactive</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_unlock</span><span class="p">;</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_INACTIVE</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">XFS_IFREE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span>
				  <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span>
				  <span class="n">XFS_INACTIVE_LOG_COUNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_cancel</span><span class="p">;</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">xfs_idestroy_fork</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_anextents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="o">*</span><span class="n">tpp</span> <span class="o">=</span> <span class="n">tp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_cancel:</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
	<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">error_unlock:</span>
	<span class="o">*</span><span class="n">tpp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_release</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If this is a read-only mount, don&#39;t do this (would generate I/O) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">truncated</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we are using filestreams, and we have an unlinked</span>
<span class="cm">		 * file that we are processing the last close on, then nothing</span>
<span class="cm">		 * will be able to reopen and write to this file. Purge this</span>
<span class="cm">		 * inode from the filestreams cache so that it doesn&#39;t delay</span>
<span class="cm">		 * teardown of the inode.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">xfs_inode_is_filestream</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
			<span class="n">xfs_filestream_deassociate</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we previously truncated this file and removed old data</span>
<span class="cm">		 * in the process, we want to initiate &quot;early&quot; writeout on</span>
<span class="cm">		 * the last close.  This is an attempt to combat the notorious</span>
<span class="cm">		 * NULL files problem which is particularly noticeable from a</span>
<span class="cm">		 * truncate down, buffered (re-)write (delalloc), followed by</span>
<span class="cm">		 * a crash.  What we are effectively doing here is</span>
<span class="cm">		 * significantly reducing the time window where we&#39;d otherwise</span>
<span class="cm">		 * be exposed to that problem.</span>
<span class="cm">		 */</span>
		<span class="n">truncated</span> <span class="o">=</span> <span class="n">xfs_iflags_test_and_clear</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ITRUNCATED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">truncated</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_iflags_clear</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IDIRTY_RELEASE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">VN_DIRTY</span><span class="p">(</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_delayed_blks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">xfs_flush_pages</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">XBF_ASYNC</span><span class="p">,</span> <span class="n">FI_NONE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
	      <span class="p">(</span><span class="n">VN_CACHED</span><span class="p">(</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_delayed_blks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTENTS</span><span class="p">))</span>  <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_DIFLAG_PREALLOC</span> <span class="o">|</span> <span class="n">XFS_DIFLAG_APPEND</span><span class="p">))))</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we can&#39;t get the iolock just skip truncating the blocks</span>
<span class="cm">		 * past EOF because we could deadlock with the mmap_sem</span>
<span class="cm">		 * otherwise.  We&#39;ll get another chance to drop them once the</span>
<span class="cm">		 * last reference to the inode is dropped, so we&#39;ll never leak</span>
<span class="cm">		 * blocks permanently.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Further, check if the inode is being opened, written and</span>
<span class="cm">		 * closed frequently and we have delayed allocation blocks</span>
<span class="cm">		 * outstanding (e.g. streaming writes from the NFS server),</span>
<span class="cm">		 * truncating the blocks past EOF will cause fragmentation to</span>
<span class="cm">		 * occur.</span>
<span class="cm">		 *</span>
<span class="cm">		 * In this case don&#39;t do the truncation, either, but we have to</span>
<span class="cm">		 * be careful how we detect this case. Blocks beyond EOF show</span>
<span class="cm">		 * up as i_delayed_blks even when the inode is clean, so we</span>
<span class="cm">		 * need to truncate them away first before checking for a dirty</span>
<span class="cm">		 * release. Hence on the first dirty close we will still remove</span>
<span class="cm">		 * the speculative allocation, but after that we will leave it</span>
<span class="cm">		 * in place.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfs_iflags_test</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IDIRTY_RELEASE</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_free_eofblocks</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span>
					   <span class="n">XFS_FREE_EOF_TRYLOCK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="cm">/* delalloc blocks after truncation means it really is dirty */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_delayed_blks</span><span class="p">)</span>
			<span class="n">xfs_iflags_set</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IDIRTY_RELEASE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_inactive</span>
<span class="cm"> *</span>
<span class="cm"> * This is called when the vnode reference count for the vnode</span>
<span class="cm"> * goes to zero.  If the file has been unlinked, then it must</span>
<span class="cm"> * now be truncated.  Also, we clear all of the read-ahead state</span>
<span class="cm"> * kept for the inode here since the file is now closed.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_inactive</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_bmap_free_t</span>	<span class="n">free_list</span><span class="p">;</span>
	<span class="n">xfs_fsblock_t</span>	<span class="n">first_block</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">committed</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">truncate</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the inode is already free, then there can be nothing</span>
<span class="cm">	 * to clean up here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_real_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_broot_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">VN_INACTIVE_CACHE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only do a truncate if it&#39;s a regular file with</span>
<span class="cm">	 * some actual space in it.  It&#39;s OK to look at the</span>
<span class="cm">	 * inode&#39;s fields without the lock because we&#39;re the</span>
<span class="cm">	 * only one with a reference to the inode.</span>
<span class="cm">	 */</span>
	<span class="n">truncate</span> <span class="o">=</span> <span class="p">((</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">XFS_ISIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nextents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_delayed_blks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">S_ISREG</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">));</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If this is a read-only mount, don&#39;t do this (would generate I/O) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RDONLY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">VN_CACHED</span><span class="p">(</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_delayed_blks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span>
				<span class="p">(</span><span class="n">XFS_DIFLAG_PREALLOC</span> <span class="o">|</span> <span class="n">XFS_DIFLAG_APPEND</span><span class="p">))</span> <span class="o">||</span>
		     <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_delayed_blks</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_free_eofblocks</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">VN_INACTIVE_CACHE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_dqattach</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VN_INACTIVE_CACHE</span><span class="p">;</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_INACTIVE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">truncate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">XFS_ITRUNCATE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span>
					  <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span>
					  <span class="n">XFS_ITRUNCATE_LOG_COUNT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Don&#39;t call itruncate_cleanup */</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
			<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">VN_INACTIVE_CACHE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_itruncate_extents</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span>
				<span class="n">XFS_TRANS_RELEASE_LOG_RES</span> <span class="o">|</span> <span class="n">XFS_TRANS_ABORT</span><span class="p">);</span>
			<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span> <span class="o">|</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">VN_INACTIVE_CACHE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nextents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we get an error while cleaning up a</span>
<span class="cm">		 * symlink we bail out.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">&gt;</span> <span class="n">XFS_IFORK_DSIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="o">?</span>
			<span class="n">xfs_inactive_symlink_rmt</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tp</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">xfs_inactive_symlink_local</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">tp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">VN_INACTIVE_CACHE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">XFS_IFREE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span>
					  <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span>
					  <span class="n">XFS_INACTIVE_LOG_COUNT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
			<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">VN_INACTIVE_CACHE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span> <span class="o">|</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
		<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are attributes associated with the file</span>
<span class="cm">	 * then blow them away now.  The code calls a routine</span>
<span class="cm">	 * that recursively deconstructs the attribute fork.</span>
<span class="cm">	 * We need to just commit the current transaction</span>
<span class="cm">	 * because we can&#39;t use it for xfs_attr_inactive().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_anextents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inactive_attrs</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tp</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we got an error, the transaction is already</span>
<span class="cm">		 * cancelled, and the inode is unlocked. Just get out.</span>
<span class="cm">		 */</span>
		 <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			 <span class="k">return</span> <span class="n">VN_INACTIVE_CACHE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_afp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_idestroy_fork</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Free the inode.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_block</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ifree</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we fail to free the inode, shut down.  The cancel</span>
<span class="cm">		 * might do that, we need to make sure.  Otherwise the</span>
<span class="cm">		 * inode might be lost for a long time or forever.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_notice</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: xfs_ifree returned error %d&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="n">xfs_force_shutdown</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">SHUTDOWN_META_IO_ERROR</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="o">|</span><span class="n">XFS_TRANS_ABORT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Credit the quota account(s). The inode is gone.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_trans_mod_dquot_byino</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_TRANS_DQ_ICOUNT</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Just ignore errors at this point.  There is nothing we can</span>
<span class="cm">		 * do except to try to keep going. Make sure it&#39;s not a silent</span>
<span class="cm">		 * error.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="n">xfs_notice</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: xfs_bmap_finish returned error %d&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="n">xfs_notice</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: xfs_trans_commit returned error %d&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release the dquots held by inode, if any.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_qm_dqdetach</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span> <span class="o">|</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">VN_INACTIVE_CACHE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lookups up an inode from &quot;name&quot;. If ci_name is not NULL, then a CI match</span>
<span class="cm"> * is allowed, otherwise it has to be an exact match. If a CI match is found,</span>
<span class="cm"> * ci_name-&gt;name will point to a the actual name (caller must free) or</span>
<span class="cm"> * will be set to NULL if an exact match is found.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_lookup</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>		<span class="o">*</span><span class="n">name</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>		<span class="o">**</span><span class="n">ipp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>		<span class="o">*</span><span class="n">ci_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_ino_t</span>		<span class="n">inum</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">lock_mode</span><span class="p">;</span>

	<span class="n">trace_xfs_lookup</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">lock_mode</span> <span class="o">=</span> <span class="n">xfs_ilock_map_shared</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir_lookup</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inum</span><span class="p">,</span> <span class="n">ci_name</span><span class="p">);</span>
	<span class="n">xfs_iunlock_map_shared</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">lock_mode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iget</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">inum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ipp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_name</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_name:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ci_name</span><span class="p">)</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">ci_name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="o">*</span><span class="n">ipp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_create</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>		<span class="o">*</span><span class="n">name</span><span class="p">,</span>
	<span class="n">umode_t</span>			<span class="n">mode</span><span class="p">,</span>
	<span class="n">xfs_dev_t</span>		<span class="n">rdev</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>		<span class="o">**</span><span class="n">ipp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">is_dir</span> <span class="o">=</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_bmap_free_t</span>		<span class="n">free_list</span><span class="p">;</span>
	<span class="n">xfs_fsblock_t</span>		<span class="n">first_block</span><span class="p">;</span>
	<span class="n">boolean_t</span>		<span class="n">unlock_dp_on_error</span> <span class="o">=</span> <span class="n">B_FALSE</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">cancel_flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">committed</span><span class="p">;</span>
	<span class="n">prid_t</span>			<span class="n">prid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_dquot</span>	<span class="o">*</span><span class="n">udqp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_dquot</span>	<span class="o">*</span><span class="n">gdqp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">resblks</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">log_res</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">log_count</span><span class="p">;</span>

	<span class="n">trace_xfs_create</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_PROJINHERIT</span><span class="p">)</span>
		<span class="n">prid</span> <span class="o">=</span> <span class="n">xfs_get_projid</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">prid</span> <span class="o">=</span> <span class="n">XFS_PROJID_DEFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure that we have allocated dquot(s) on disk.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_vop_dqalloc</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">current_fsuid</span><span class="p">(),</span> <span class="n">current_fsgid</span><span class="p">(),</span> <span class="n">prid</span><span class="p">,</span>
			<span class="n">XFS_QMOPT_QUOTALL</span> <span class="o">|</span> <span class="n">XFS_QMOPT_INHERIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udqp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gdqp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rdev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">resblks</span> <span class="o">=</span> <span class="n">XFS_MKDIR_SPACE_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">log_res</span> <span class="o">=</span> <span class="n">XFS_MKDIR_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">log_count</span> <span class="o">=</span> <span class="n">XFS_MKDIR_LOG_COUNT</span><span class="p">;</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_MKDIR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">resblks</span> <span class="o">=</span> <span class="n">XFS_CREATE_SPACE_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">log_res</span> <span class="o">=</span> <span class="n">XFS_CREATE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">log_count</span> <span class="o">=</span> <span class="n">XFS_CREATE_LOG_COUNT</span><span class="p">;</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_CREATE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cancel_flags</span> <span class="o">=</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initially assume that the file does not exist and</span>
<span class="cm">	 * reserve the resources for that case.  If that is not</span>
<span class="cm">	 * the case we&#39;ll drop the one we have and get a more</span>
<span class="cm">	 * appropriate transaction later.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">resblks</span><span class="p">,</span> <span class="n">log_res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span> <span class="n">log_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* flush outstanding delalloc blocks and retry */</span>
		<span class="n">xfs_flush_inodes</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">resblks</span><span class="p">,</span> <span class="n">log_res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span> <span class="n">log_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No space at all so try a &quot;no-allocation&quot; reservation */</span>
		<span class="n">resblks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">log_res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span> <span class="n">log_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cancel_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_trans_cancel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span> <span class="o">|</span> <span class="n">XFS_ILOCK_PARENT</span><span class="p">);</span>
	<span class="n">unlock_dp_on_error</span> <span class="o">=</span> <span class="n">B_TRUE</span><span class="p">;</span>

	<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_block</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reserve disk quota and the inode.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve_quota</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">udqp</span><span class="p">,</span> <span class="n">gdqp</span><span class="p">,</span> <span class="n">resblks</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_trans_cancel</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir_canenter</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">resblks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_trans_cancel</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A newly created regular or special file just has one directory</span>
<span class="cm">	 * entry pointing to them, but a directory also the &quot;.&quot; entry</span>
<span class="cm">	 * pointing to itself.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir_ialloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">is_dir</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rdev</span><span class="p">,</span>
			       <span class="n">prid</span><span class="p">,</span> <span class="n">resblks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ENOSPC</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_trans_cancel</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_trans_abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we join the directory inode to the transaction.  We do not do it</span>
<span class="cm">	 * earlier because xfs_dir_ialloc might commit the previous transaction</span>
<span class="cm">	 * (and release all the locks).  An error from here on will result in</span>
<span class="cm">	 * the transaction cancel unlocking dp so don&#39;t do it explicitly in the</span>
<span class="cm">	 * error path.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="n">unlock_dp_on_error</span> <span class="o">=</span> <span class="n">B_FALSE</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir_createname</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">first_block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="n">resblks</span> <span class="o">?</span>
					<span class="n">resblks</span> <span class="o">-</span> <span class="n">XFS_IALLOC_SPACE_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">ENOSPC</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_trans_abort</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_trans_ichgtime</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ICHGTIME_MOD</span> <span class="o">|</span> <span class="n">XFS_ICHGTIME_CHG</span><span class="p">);</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir_init</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_bmap_cancel</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bumplink</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_bmap_cancel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a synchronous mount, make sure that the</span>
<span class="cm">	 * create transaction goes to disk before returning to</span>
<span class="cm">	 * the user.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_MOUNT_WSYNC</span><span class="o">|</span><span class="n">XFS_MOUNT_DIRSYNC</span><span class="p">))</span>
		<span class="n">xfs_trans_set_sync</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Attach the dquot(s) to the inodes and modify them incore.</span>
<span class="cm">	 * These ids of the inode couldn&#39;t have changed since the new</span>
<span class="cm">	 * inode has been locked ever since it was created.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_qm_vop_create_dqattach</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">udqp</span><span class="p">,</span> <span class="n">gdqp</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_bmap_cancel</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release_inode</span><span class="p">;</span>

	<span class="n">xfs_qm_dqrele</span><span class="p">(</span><span class="n">udqp</span><span class="p">);</span>
	<span class="n">xfs_qm_dqrele</span><span class="p">(</span><span class="n">gdqp</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ipp</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_bmap_cancel:</span>
	<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">);</span>
 <span class="nl">out_trans_abort:</span>
	<span class="n">cancel_flags</span> <span class="o">|=</span> <span class="n">XFS_TRANS_ABORT</span><span class="p">;</span>
 <span class="nl">out_trans_cancel:</span>
	<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">cancel_flags</span><span class="p">);</span>
 <span class="nl">out_release_inode:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Wait until after the current transaction is aborted to</span>
<span class="cm">	 * release the inode.  This prevents recursive transactions</span>
<span class="cm">	 * and deadlocks from xfs_inactive.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="p">)</span>
		<span class="n">IRELE</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="n">xfs_qm_dqrele</span><span class="p">(</span><span class="n">udqp</span><span class="p">);</span>
	<span class="n">xfs_qm_dqrele</span><span class="p">(</span><span class="n">gdqp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlock_dp_on_error</span><span class="p">)</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
<span class="kt">int</span> <span class="n">xfs_locked_n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">xfs_small_retries</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">xfs_middle_retries</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">xfs_lots_retries</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">xfs_lock_delays</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Bump the subclass so xfs_lock_inodes() acquires each lock with</span>
<span class="cm"> * a different value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xfs_lock_inumorder</span><span class="p">(</span><span class="kt">int</span> <span class="n">lock_mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">subclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lock_mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_IOLOCK_SHARED</span><span class="o">|</span><span class="n">XFS_IOLOCK_EXCL</span><span class="p">))</span>
		<span class="n">lock_mode</span> <span class="o">|=</span> <span class="p">(</span><span class="n">subclass</span> <span class="o">+</span> <span class="n">XFS_LOCK_INUMORDER</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">XFS_IOLOCK_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lock_mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_ILOCK_SHARED</span><span class="o">|</span><span class="n">XFS_ILOCK_EXCL</span><span class="p">))</span>
		<span class="n">lock_mode</span> <span class="o">|=</span> <span class="p">(</span><span class="n">subclass</span> <span class="o">+</span> <span class="n">XFS_LOCK_INUMORDER</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">XFS_ILOCK_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">lock_mode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following routine will lock n inodes in exclusive mode.</span>
<span class="cm"> * We assume the caller calls us with the inodes in i_ino order.</span>
<span class="cm"> *</span>
<span class="cm"> * We need to detect deadlock where an inode that we lock</span>
<span class="cm"> * is in the AIL and we start waiting for another inode that is locked</span>
<span class="cm"> * by a thread in a long running transaction (such as truncate). This can</span>
<span class="cm"> * result in deadlock since the long running trans might need to wait</span>
<span class="cm"> * for the inode we just locked in order to push the tail and free space</span>
<span class="cm"> * in the log.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_lock_inodes</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">**</span><span class="n">ips</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">inodes</span><span class="p">,</span>
	<span class="n">uint</span>		<span class="n">lock_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">attempts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">try_lock</span><span class="p">;</span>
	<span class="n">xfs_log_item_t</span>	<span class="o">*</span><span class="n">lp</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ips</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">inodes</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">));</span> <span class="cm">/* we need at least two */</span>

	<span class="n">try_lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ips</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ips</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">ips</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>	<span class="cm">/* Already locked */</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If try_lock is not set yet, make sure all locked inodes</span>
<span class="cm">		 * are not in the AIL.</span>
<span class="cm">		 * If any are, set try_lock to be used later.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_lock</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">try_lock</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_log_item_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ips</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">i_itemp</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">li_flags</span> <span class="o">&amp;</span> <span class="n">XFS_LI_IN_AIL</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">try_lock</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If any of the previous locks we have locked is in the AIL,</span>
<span class="cm">		 * we must TRY to get the second and subsequent locks. If</span>
<span class="cm">		 * we can&#39;t get any, we must release all we have</span>
<span class="cm">		 * and try again.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">try_lock</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* try_lock must be 0 if i is 0. */</span>
			<span class="cm">/*</span>
<span class="cm">			 * try_lock means we have an inode locked</span>
<span class="cm">			 * that is in the AIL.</span>
<span class="cm">			 */</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_ilock_nowait</span><span class="p">(</span><span class="n">ips</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xfs_lock_inumorder</span><span class="p">(</span><span class="n">lock_mode</span><span class="p">,</span> <span class="n">i</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">attempts</span><span class="o">++</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * Unlock all previous guys and try again.</span>
<span class="cm">				 * xfs_iunlock will try to push the tail</span>
<span class="cm">				 * if the inode is in the AIL.</span>
<span class="cm">				 */</span>

				<span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>

					<span class="cm">/*</span>
<span class="cm">					 * Check to see if we&#39;ve already</span>
<span class="cm">					 * unlocked this one.</span>
<span class="cm">					 * Not the first one going back,</span>
<span class="cm">					 * and the inode ptr is the same.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">j</span> <span class="o">!=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">ips</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span>
								<span class="n">ips</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
						<span class="k">continue</span><span class="p">;</span>

					<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ips</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">lock_mode</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">((</span><span class="n">attempts</span> <span class="o">%</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* Don&#39;t just spin the CPU */</span>
<span class="cp">#ifdef DEBUG</span>
					<span class="n">xfs_lock_delays</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
				<span class="p">}</span>
				<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">try_lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ips</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xfs_lock_inumorder</span><span class="p">(</span><span class="n">lock_mode</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attempts</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attempts</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="n">xfs_small_retries</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attempts</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="n">xfs_middle_retries</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="n">xfs_lots_retries</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xfs_locked_n</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_lock_two_inodes() can only be used to lock one type of lock</span>
<span class="cm"> * at a time - the iolock or the ilock, but not both at once. If</span>
<span class="cm"> * we lock both at once, lockdep will report false positives saying</span>
<span class="cm"> * we have violated locking orders.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_lock_two_inodes</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip0</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip1</span><span class="p">,</span>
	<span class="n">uint</span>			<span class="n">lock_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">attempts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_log_item_t</span>		<span class="o">*</span><span class="n">lp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lock_mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_IOLOCK_SHARED</span><span class="o">|</span><span class="n">XFS_IOLOCK_EXCL</span><span class="p">))</span>
		<span class="n">ASSERT</span><span class="p">((</span><span class="n">lock_mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_ILOCK_SHARED</span><span class="o">|</span><span class="n">XFS_ILOCK_EXCL</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip0</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">!=</span> <span class="n">ip1</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip0</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">&gt;</span> <span class="n">ip1</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">ip0</span><span class="p">;</span>
		<span class="n">ip0</span> <span class="o">=</span> <span class="n">ip1</span><span class="p">;</span>
		<span class="n">ip1</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">again:</span>
	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip0</span><span class="p">,</span> <span class="n">xfs_lock_inumorder</span><span class="p">(</span><span class="n">lock_mode</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the first lock we have locked is in the AIL, we must TRY to get</span>
<span class="cm">	 * the second lock. If we can&#39;t get it, we must release the first one</span>
<span class="cm">	 * and try again.</span>
<span class="cm">	 */</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_log_item_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ip0</span><span class="o">-&gt;</span><span class="n">i_itemp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">li_flags</span> <span class="o">&amp;</span> <span class="n">XFS_LI_IN_AIL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_ilock_nowait</span><span class="p">(</span><span class="n">ip1</span><span class="p">,</span> <span class="n">xfs_lock_inumorder</span><span class="p">(</span><span class="n">lock_mode</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip0</span><span class="p">,</span> <span class="n">lock_mode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">++</span><span class="n">attempts</span> <span class="o">%</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* Don&#39;t just spin the CPU */</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip1</span><span class="p">,</span> <span class="n">xfs_lock_inumorder</span><span class="p">(</span><span class="n">lock_mode</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_remove</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>             <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>		<span class="o">*</span><span class="n">name</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span>             <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">is_dir</span> <span class="o">=</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">);</span>
	<span class="kt">int</span>                     <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_bmap_free_t</span>         <span class="n">free_list</span><span class="p">;</span>
	<span class="n">xfs_fsblock_t</span>           <span class="n">first_block</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cancel_flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">committed</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">link_zero</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">resblks</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">log_count</span><span class="p">;</span>

	<span class="n">trace_xfs_remove</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_dqattach</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">std_return</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_dqattach</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">std_return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_RMDIR</span><span class="p">);</span>
		<span class="n">log_count</span> <span class="o">=</span> <span class="n">XFS_DEFAULT_LOG_COUNT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_REMOVE</span><span class="p">);</span>
		<span class="n">log_count</span> <span class="o">=</span> <span class="n">XFS_REMOVE_LOG_COUNT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cancel_flags</span> <span class="o">=</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We try to get the real space reservation first,</span>
<span class="cm">	 * allowing for directory btree deletion(s) implying</span>
<span class="cm">	 * possible bmap insert(s).  If we can&#39;t get the space</span>
<span class="cm">	 * reservation then we use 0 instead, and avoid the bmap</span>
<span class="cm">	 * btree insert(s) in the directory code by, if the bmap</span>
<span class="cm">	 * insert tries to happen, instead trimming the LAST</span>
<span class="cm">	 * block from the directory.</span>
<span class="cm">	 */</span>
	<span class="n">resblks</span> <span class="o">=</span> <span class="n">XFS_REMOVE_SPACE_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">resblks</span><span class="p">,</span> <span class="n">XFS_REMOVE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span> <span class="n">log_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">resblks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_REMOVE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span> <span class="n">log_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">ENOSPC</span><span class="p">);</span>
		<span class="n">cancel_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_trans_cancel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_lock_two_inodes</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re removing a directory perform some additional validation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOTEMPTY</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_trans_cancel</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_dir_isempty</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOTEMPTY</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_trans_cancel</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_block</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir_removename</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">first_block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="n">resblks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">ENOENT</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_bmap_cancel</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_trans_ichgtime</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ICHGTIME_MOD</span> <span class="o">|</span> <span class="n">XFS_ICHGTIME_CHG</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Drop the link from ip&#39;s &quot;..&quot;.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_droplink</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_bmap_cancel</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Drop the &quot;.&quot; link from ip to self.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_droplink</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_bmap_cancel</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * When removing a non-directory we need to log the parent</span>
<span class="cm">		 * inode here.  For a directory this is done implicitly</span>
<span class="cm">		 * by the xfs_droplink call for the &quot;..&quot; entry.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Drop the link from dp to ip.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_droplink</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_bmap_cancel</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine if this is the last link while</span>
<span class="cm">	 * we are in the transaction.</span>
<span class="cm">	 */</span>
	<span class="n">link_zero</span> <span class="o">=</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a synchronous mount, make sure that the</span>
<span class="cm">	 * remove transaction goes to disk before returning to</span>
<span class="cm">	 * the user.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_MOUNT_WSYNC</span><span class="o">|</span><span class="n">XFS_MOUNT_DIRSYNC</span><span class="p">))</span>
		<span class="n">xfs_trans_set_sync</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_bmap_cancel</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">std_return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are using filestreams, kill the stream association.</span>
<span class="cm">	 * If the file is still open it may get a new one but that</span>
<span class="cm">	 * will get killed on last close in xfs_close() so we don&#39;t</span>
<span class="cm">	 * have to worry about that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_dir</span> <span class="o">&amp;&amp;</span> <span class="n">link_zero</span> <span class="o">&amp;&amp;</span> <span class="n">xfs_inode_is_filestream</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
		<span class="n">xfs_filestream_deassociate</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_bmap_cancel:</span>
	<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">);</span>
	<span class="n">cancel_flags</span> <span class="o">|=</span> <span class="n">XFS_TRANS_ABORT</span><span class="p">;</span>
 <span class="nl">out_trans_cancel:</span>
	<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">cancel_flags</span><span class="p">);</span>
 <span class="nl">std_return:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_link</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">tdp</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">sip</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>		<span class="o">*</span><span class="n">target_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">tdp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_bmap_free_t</span>         <span class="n">free_list</span><span class="p">;</span>
	<span class="n">xfs_fsblock_t</span>           <span class="n">first_block</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cancel_flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">committed</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">resblks</span><span class="p">;</span>

	<span class="n">trace_xfs_link</span><span class="p">(</span><span class="n">tdp</span><span class="p">,</span> <span class="n">target_name</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">sip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_dqattach</span><span class="p">(</span><span class="n">sip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">std_return</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_dqattach</span><span class="p">(</span><span class="n">tdp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">std_return</span><span class="p">;</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_LINK</span><span class="p">);</span>
	<span class="n">cancel_flags</span> <span class="o">=</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">;</span>
	<span class="n">resblks</span> <span class="o">=</span> <span class="n">XFS_LINK_SPACE_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">target_name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">resblks</span><span class="p">,</span> <span class="n">XFS_LINK_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span> <span class="n">XFS_LINK_LOG_COUNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">resblks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_LINK_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span> <span class="n">XFS_LINK_LOG_COUNT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cancel_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_lock_two_inodes</span><span class="p">(</span><span class="n">sip</span><span class="p">,</span> <span class="n">tdp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">sip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tdp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are using project inheritance, we only allow hard link</span>
<span class="cm">	 * creation in our tree when the project IDs are the same; else</span>
<span class="cm">	 * the tree quota mechanism could be circumvented.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">tdp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_PROJINHERIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">xfs_get_projid</span><span class="p">(</span><span class="n">tdp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">xfs_get_projid</span><span class="p">(</span><span class="n">sip</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EXDEV</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir_canenter</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tdp</span><span class="p">,</span> <span class="n">target_name</span><span class="p">,</span> <span class="n">resblks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

	<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_block</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir_createname</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tdp</span><span class="p">,</span> <span class="n">target_name</span><span class="p">,</span> <span class="n">sip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">first_block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="n">resblks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_return</span><span class="p">;</span>
	<span class="n">xfs_trans_ichgtime</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tdp</span><span class="p">,</span> <span class="n">XFS_ICHGTIME_MOD</span> <span class="o">|</span> <span class="n">XFS_ICHGTIME_CHG</span><span class="p">);</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tdp</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bumplink</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">sip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">abort_return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a synchronous mount, make sure that the</span>
<span class="cm">	 * link transaction goes to disk before returning to</span>
<span class="cm">	 * the user.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_MOUNT_WSYNC</span><span class="o">|</span><span class="n">XFS_MOUNT_DIRSYNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_trans_set_sync</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>

 <span class="nl">abort_return:</span>
	<span class="n">cancel_flags</span> <span class="o">|=</span> <span class="n">XFS_TRANS_ABORT</span><span class="p">;</span>
 <span class="nl">error_return:</span>
	<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">cancel_flags</span><span class="p">);</span>
 <span class="nl">std_return:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_symlink</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>		<span class="o">*</span><span class="n">link_name</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">target_path</span><span class="p">,</span>
	<span class="n">umode_t</span>			<span class="n">mode</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>		<span class="o">**</span><span class="n">ipp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">pathlen</span><span class="p">;</span>
	<span class="n">xfs_bmap_free_t</span>		<span class="n">free_list</span><span class="p">;</span>
	<span class="n">xfs_fsblock_t</span>		<span class="n">first_block</span><span class="p">;</span>
	<span class="n">boolean_t</span>		<span class="n">unlock_dp_on_error</span> <span class="o">=</span> <span class="n">B_FALSE</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">cancel_flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">committed</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">first_fsb</span><span class="p">;</span>
	<span class="n">xfs_filblks_t</span>		<span class="n">fs_blocks</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nmaps</span><span class="p">;</span>
	<span class="n">xfs_bmbt_irec_t</span>		<span class="n">mval</span><span class="p">[</span><span class="n">SYMLINK_MAPS</span><span class="p">];</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">d</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">cur_chunk</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">byte_cnt</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">n</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">prid_t</span>			<span class="n">prid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_dquot</span>	<span class="o">*</span><span class="n">udqp</span><span class="p">,</span> <span class="o">*</span><span class="n">gdqp</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">resblks</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ipp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">trace_xfs_symlink</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">link_name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check component lengths of the target path name.</span>
<span class="cm">	 */</span>
	<span class="n">pathlen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">target_path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pathlen</span> <span class="o">&gt;=</span> <span class="n">MAXPATHLEN</span><span class="p">)</span>      <span class="cm">/* total string too long */</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>

	<span class="n">udqp</span> <span class="o">=</span> <span class="n">gdqp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_PROJINHERIT</span><span class="p">)</span>
		<span class="n">prid</span> <span class="o">=</span> <span class="n">xfs_get_projid</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">prid</span> <span class="o">=</span> <span class="n">XFS_PROJID_DEFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure that we have allocated dquot(s) on disk.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_vop_dqalloc</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">current_fsuid</span><span class="p">(),</span> <span class="n">current_fsgid</span><span class="p">(),</span> <span class="n">prid</span><span class="p">,</span>
			<span class="n">XFS_QMOPT_QUOTALL</span> <span class="o">|</span> <span class="n">XFS_QMOPT_INHERIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udqp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gdqp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">std_return</span><span class="p">;</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_SYMLINK</span><span class="p">);</span>
	<span class="n">cancel_flags</span> <span class="o">=</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The symlink will fit into the inode data fork?</span>
<span class="cm">	 * There can&#39;t be any attributes so we get the whole variable part.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pathlen</span> <span class="o">&lt;=</span> <span class="n">XFS_LITINO</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="n">fs_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">fs_blocks</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">pathlen</span><span class="p">);</span>
	<span class="n">resblks</span> <span class="o">=</span> <span class="n">XFS_SYMLINK_SPACE_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">link_name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">fs_blocks</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">resblks</span><span class="p">,</span> <span class="n">XFS_SYMLINK_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span> <span class="n">XFS_SYMLINK_LOG_COUNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">fs_blocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">resblks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_SYMLINK_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span> <span class="n">XFS_SYMLINK_LOG_COUNT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cancel_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span> <span class="o">|</span> <span class="n">XFS_ILOCK_PARENT</span><span class="p">);</span>
	<span class="n">unlock_dp_on_error</span> <span class="o">=</span> <span class="n">B_TRUE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check whether the directory allows new symlinks or not.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_NOSYMLINKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EPERM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reserve disk quota : blocks and inode.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve_quota</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">udqp</span><span class="p">,</span> <span class="n">gdqp</span><span class="p">,</span> <span class="n">resblks</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for ability to enter directory entry, if no space reserved.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir_canenter</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">link_name</span><span class="p">,</span> <span class="n">resblks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initialize the bmap freelist prior to calling either</span>
<span class="cm">	 * bmapi or the directory create code.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_block</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate an inode for the symlink.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir_ialloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">S_IFLNK</span> <span class="o">|</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">S_IFMT</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			       <span class="n">prid</span><span class="p">,</span> <span class="n">resblks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ENOSPC</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * An error after we&#39;ve joined dp to the transaction will result in the</span>
<span class="cm">	 * transaction cancel unlocking dp so don&#39;t do it explicitly in the</span>
<span class="cm">	 * error path.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="n">unlock_dp_on_error</span> <span class="o">=</span> <span class="n">B_FALSE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Also attach the dquot(s) to it, if applicable.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_qm_vop_create_dqattach</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">udqp</span><span class="p">,</span> <span class="n">gdqp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">resblks</span><span class="p">)</span>
		<span class="n">resblks</span> <span class="o">-=</span> <span class="n">XFS_IALLOC_SPACE_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the symlink will fit into the inode, write it inline.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pathlen</span> <span class="o">&lt;=</span> <span class="n">XFS_IFORK_DSIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_idata_realloc</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">pathlen</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">,</span> <span class="n">target_path</span><span class="p">,</span> <span class="n">pathlen</span><span class="p">);</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">=</span> <span class="n">pathlen</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * The inode was initially created in extent format.</span>
<span class="cm">		 */</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">XFS_IFEXTENTS</span> <span class="o">|</span> <span class="n">XFS_IFBROOT</span><span class="p">);</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_flags</span> <span class="o">|=</span> <span class="n">XFS_IFINLINE</span><span class="p">;</span>

		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">=</span> <span class="n">XFS_DINODE_FMT_LOCAL</span><span class="p">;</span>
		<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_DDATA</span> <span class="o">|</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">first_fsb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nmaps</span> <span class="o">=</span> <span class="n">SYMLINK_MAPS</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_write</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">first_fsb</span><span class="p">,</span> <span class="n">fs_blocks</span><span class="p">,</span>
				  <span class="n">XFS_BMAPI_METADATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_block</span><span class="p">,</span> <span class="n">resblks</span><span class="p">,</span>
				  <span class="n">mval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmaps</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">resblks</span><span class="p">)</span>
			<span class="n">resblks</span> <span class="o">-=</span> <span class="n">fs_blocks</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">=</span> <span class="n">pathlen</span><span class="p">;</span>
		<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>

		<span class="n">cur_chunk</span> <span class="o">=</span> <span class="n">target_path</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">nmaps</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">d</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mval</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">br_startblock</span><span class="p">);</span>
			<span class="n">byte_cnt</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mval</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">br_blockcount</span><span class="p">);</span>
			<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_trans_get_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span>
					       <span class="n">BTOBB</span><span class="p">(</span><span class="n">byte_cnt</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pathlen</span> <span class="o">&lt;</span> <span class="n">byte_cnt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">byte_cnt</span> <span class="o">=</span> <span class="n">pathlen</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">pathlen</span> <span class="o">-=</span> <span class="n">byte_cnt</span><span class="p">;</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">,</span> <span class="n">cur_chunk</span><span class="p">,</span> <span class="n">byte_cnt</span><span class="p">);</span>
			<span class="n">cur_chunk</span> <span class="o">+=</span> <span class="n">byte_cnt</span><span class="p">;</span>

			<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">byte_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create the directory entry for the symlink.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir_createname</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">link_name</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">first_block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="n">resblks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
	<span class="n">xfs_trans_ichgtime</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ICHGTIME_MOD</span> <span class="o">|</span> <span class="n">XFS_ICHGTIME_CHG</span><span class="p">);</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a synchronous mount, make sure that the</span>
<span class="cm">	 * symlink transaction goes to disk before returning to</span>
<span class="cm">	 * the user.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_MOUNT_WSYNC</span><span class="o">|</span><span class="n">XFS_MOUNT_DIRSYNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_trans_set_sync</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
	<span class="n">xfs_qm_dqrele</span><span class="p">(</span><span class="n">udqp</span><span class="p">);</span>
	<span class="n">xfs_qm_dqrele</span><span class="p">(</span><span class="n">gdqp</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ipp</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">error2:</span>
	<span class="n">IRELE</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
 <span class="nl">error1:</span>
	<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">);</span>
	<span class="n">cancel_flags</span> <span class="o">|=</span> <span class="n">XFS_TRANS_ABORT</span><span class="p">;</span>
 <span class="nl">error_return:</span>
	<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">cancel_flags</span><span class="p">);</span>
	<span class="n">xfs_qm_dqrele</span><span class="p">(</span><span class="n">udqp</span><span class="p">);</span>
	<span class="n">xfs_qm_dqrele</span><span class="p">(</span><span class="n">gdqp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlock_dp_on_error</span><span class="p">)</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
 <span class="nl">std_return:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_set_dmattrs</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>     <span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">u_int</span>		<span class="n">evmask</span><span class="p">,</span>
	<span class="n">u_int16_t</span>	<span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EPERM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_SET_DMATTRS</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_ICHANGE_LOG_RES</span> <span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_dmevmask</span> <span class="o">=</span> <span class="n">evmask</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_dmstate</span>  <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_alloc_file_space()</span>
<span class="cm"> *      This routine allocates disk space for the given file.</span>
<span class="cm"> *</span>
<span class="cm"> *	If alloc_type == 0, this request is for an ALLOCSP type</span>
<span class="cm"> *	request which will change the file size.  In this case, no</span>
<span class="cm"> *	DMAPI event will be generated by the call.  A TRUNCATE event</span>
<span class="cm"> *	will be generated later by xfs_setattr.</span>
<span class="cm"> *</span>
<span class="cm"> *	If alloc_type != 0, this request is for a RESVSP type</span>
<span class="cm"> *	request, and a DMAPI DM_EVENT_WRITE will be generated if the</span>
<span class="cm"> *	lower block boundary byte address is less than the file&#39;s</span>
<span class="cm"> *	length.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> *       0 on success</span>
<span class="cm"> *      errno on error</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_alloc_file_space</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_off_t</span>		<span class="n">offset</span><span class="p">,</span>
	<span class="n">xfs_off_t</span>		<span class="n">len</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">alloc_type</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">attr_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">xfs_off_t</span>		<span class="n">count</span><span class="p">;</span>
	<span class="n">xfs_filblks_t</span>		<span class="n">allocated_fsb</span><span class="p">;</span>
	<span class="n">xfs_filblks_t</span>		<span class="n">allocatesize_fsb</span><span class="p">;</span>
	<span class="n">xfs_extlen_t</span>		<span class="n">extsz</span><span class="p">,</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">startoffset_fsb</span><span class="p">;</span>
	<span class="n">xfs_fsblock_t</span>		<span class="n">firstfsb</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nimaps</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">quota_flag</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rt</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="n">xfs_bmbt_irec_t</span>		<span class="n">imaps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">imapp</span><span class="p">;</span>
	<span class="n">xfs_bmap_free_t</span>		<span class="n">free_list</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">qblocks</span><span class="p">,</span> <span class="n">resblks</span><span class="p">,</span> <span class="n">resrtextents</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">committed</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">trace_xfs_alloc_file_space</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_dqattach</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">rt</span> <span class="o">=</span> <span class="n">XFS_IS_REALTIME_INODE</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="n">extsz</span> <span class="o">=</span> <span class="n">xfs_get_extsz_hint</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">imapp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">imaps</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">nimaps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">startoffset_fsb</span>	<span class="o">=</span> <span class="n">XFS_B_TO_FSBT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">allocatesize_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate file space until done or until there is an error</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">allocatesize_fsb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_fileoff_t</span>	<span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Determine space reservations for data/realtime.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">extsz</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">s</span> <span class="o">=</span> <span class="n">startoffset_fsb</span><span class="p">;</span>
			<span class="n">do_div</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">extsz</span><span class="p">);</span>
			<span class="n">s</span> <span class="o">*=</span> <span class="n">extsz</span><span class="p">;</span>
			<span class="n">e</span> <span class="o">=</span> <span class="n">startoffset_fsb</span> <span class="o">+</span> <span class="n">allocatesize_fsb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">=</span> <span class="n">do_mod</span><span class="p">(</span><span class="n">startoffset_fsb</span><span class="p">,</span> <span class="n">extsz</span><span class="p">)))</span>
				<span class="n">e</span> <span class="o">+=</span> <span class="n">temp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">=</span> <span class="n">do_mod</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">extsz</span><span class="p">)))</span>
				<span class="n">e</span> <span class="o">+=</span> <span class="n">extsz</span> <span class="o">-</span> <span class="n">temp</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">e</span> <span class="o">=</span> <span class="n">allocatesize_fsb</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The transaction reservation is limited to a 32-bit block</span>
<span class="cm">		 * count, hence we need to limit the number of blocks we are</span>
<span class="cm">		 * trying to reserve to avoid an overflow. We can&#39;t allocate</span>
<span class="cm">		 * more than @nimaps extents, and an extent is limited on disk</span>
<span class="cm">		 * to MAXEXTLEN (21 bits), so use that to enforce the limit.</span>
<span class="cm">		 */</span>
		<span class="n">resblks</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">xfs_fileoff_t</span><span class="p">,</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">s</span><span class="p">),</span> <span class="p">(</span><span class="n">MAXEXTLEN</span> <span class="o">*</span> <span class="n">nimaps</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rt</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">resrtextents</span> <span class="o">=</span> <span class="n">qblocks</span> <span class="o">=</span> <span class="n">resblks</span><span class="p">;</span>
			<span class="n">resrtextents</span> <span class="o">/=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextsize</span><span class="p">;</span>
			<span class="n">resblks</span> <span class="o">=</span> <span class="n">XFS_DIOSTRAT_SPACE_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">quota_flag</span> <span class="o">=</span> <span class="n">XFS_QMOPT_RES_RTBLKS</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">resrtextents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">resblks</span> <span class="o">=</span> <span class="n">qblocks</span> <span class="o">=</span> <span class="n">XFS_DIOSTRAT_SPACE_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">resblks</span><span class="p">);</span>
			<span class="n">quota_flag</span> <span class="o">=</span> <span class="n">XFS_QMOPT_RES_REGBLKS</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Allocate and setup the transaction.</span>
<span class="cm">		 */</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_DIOSTRAT</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">resblks</span><span class="p">,</span>
					  <span class="n">XFS_WRITE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="n">resrtextents</span><span class="p">,</span>
					  <span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span>
					  <span class="n">XFS_WRITE_LOG_COUNT</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check for running out of space</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Free the transaction structure.</span>
<span class="cm">			 */</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ENOSPC</span> <span class="o">||</span> <span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
			<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve_quota_nblks</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">qblocks</span><span class="p">,</span>
						      <span class="mi">0</span><span class="p">,</span> <span class="n">quota_flag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>

		<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">firstfsb</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_write</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">startoffset_fsb</span><span class="p">,</span>
					<span class="n">allocatesize_fsb</span><span class="p">,</span> <span class="n">alloc_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">firstfsb</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="n">imapp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nimaps</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Complete the transaction</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">allocated_fsb</span> <span class="o">=</span> <span class="n">imapp</span><span class="o">-&gt;</span><span class="n">br_blockcount</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nimaps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSPC</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">startoffset_fsb</span> <span class="o">+=</span> <span class="n">allocated_fsb</span><span class="p">;</span>
		<span class="n">allocatesize_fsb</span> <span class="o">-=</span> <span class="n">allocated_fsb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">error0:</span>	<span class="cm">/* Cancel bmap, unlock inode, unreserve quota blocks, cancel trans */</span>
	<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">);</span>
	<span class="n">xfs_trans_unreserve_quota_nblks</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">qblocks</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">quota_flag</span><span class="p">);</span>

<span class="nl">error1:</span>	<span class="cm">/* Just cancel transaction */</span>
	<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span> <span class="o">|</span> <span class="n">XFS_TRANS_ABORT</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Zero file bytes between startoff and endoff inclusive.</span>
<span class="cm"> * The iolock is held exclusive and no blocks are buffered.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used by xfs_free_file_space() to zero</span>
<span class="cm"> * partial blocks when the range to free is not block aligned.</span>
<span class="cm"> * When unreserving space with boundaries that are not block</span>
<span class="cm"> * aligned we round up the start and round down the end</span>
<span class="cm"> * boundaries and then use this function to zero the parts of</span>
<span class="cm"> * the blocks that got dropped during the rounding.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_zero_remaining_bytes</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_off_t</span>		<span class="n">startoff</span><span class="p">,</span>
	<span class="n">xfs_off_t</span>		<span class="n">endoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_bmbt_irec_t</span>		<span class="n">imap</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">offset_fsb</span><span class="p">;</span>
	<span class="n">xfs_off_t</span>		<span class="n">lastoffset</span><span class="p">;</span>
	<span class="n">xfs_off_t</span>		<span class="n">offset</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nimap</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Avoid doing I/O beyond eof - it&#39;s not necessary</span>
<span class="cm">	 * since nothing can read beyond eof.  The space will</span>
<span class="cm">	 * be zeroed when the file is extended anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">startoff</span> <span class="o">&gt;=</span> <span class="n">XFS_ISIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">endoff</span> <span class="o">&gt;</span> <span class="n">XFS_ISIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
		<span class="n">endoff</span> <span class="o">=</span> <span class="n">XFS_ISIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_get_uncached</span><span class="p">(</span><span class="n">XFS_IS_REALTIME_INODE</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">?</span>
					<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rtdev_targp</span> <span class="o">:</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span>
				  <span class="n">BTOBB</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">xfs_buf_unlock</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="n">startoff</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">endoff</span><span class="p">;</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">lastoffset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSBT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">nimap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">offset_fsb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nimap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">||</span> <span class="n">nimap</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">imap</span><span class="p">.</span><span class="n">br_blockcount</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">imap</span><span class="p">.</span><span class="n">br_startoff</span> <span class="o">==</span> <span class="n">offset_fsb</span><span class="p">);</span>
		<span class="n">lastoffset</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_startoff</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lastoffset</span> <span class="o">&gt;</span> <span class="n">endoff</span><span class="p">)</span>
			<span class="n">lastoffset</span> <span class="o">=</span> <span class="n">endoff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">==</span> <span class="n">HOLESTARTBLOCK</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">imap</span><span class="p">.</span><span class="n">br_state</span> <span class="o">==</span> <span class="n">XFS_EXT_UNWRITTEN</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">XFS_BUF_UNDONE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">XFS_BUF_UNWRITE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">XFS_BUF_READ</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">XFS_BUF_SET_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">xfs_fsb_to_db</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span><span class="p">));</span>
		<span class="n">xfsbdstrat</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_buf_iowait</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_buf_ioerror_alert</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span>
					<span class="s">&quot;xfs_zero_remaining_bytes(read)&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_startoff</span><span class="p">)),</span>
		      <span class="mi">0</span><span class="p">,</span> <span class="n">lastoffset</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">XFS_BUF_UNDONE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">XFS_BUF_UNREAD</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">XFS_BUF_WRITE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">xfsbdstrat</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_buf_iowait</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_buf_ioerror_alert</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span>
					<span class="s">&quot;xfs_zero_remaining_bytes(write)&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">xfs_buf_free</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_free_file_space()</span>
<span class="cm"> *      This routine frees disk space for the given file.</span>
<span class="cm"> *</span>
<span class="cm"> *	This routine is only called by xfs_change_file_space</span>
<span class="cm"> *	for an UNRESVSP type call.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> *       0 on success</span>
<span class="cm"> *      errno on error</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_free_file_space</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_off_t</span>		<span class="n">offset</span><span class="p">,</span>
	<span class="n">xfs_off_t</span>		<span class="n">len</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">attr_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">committed</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">done</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">endoffset_fsb</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_fsblock_t</span>		<span class="n">firstfsb</span><span class="p">;</span>
	<span class="n">xfs_bmap_free_t</span>		<span class="n">free_list</span><span class="p">;</span>
	<span class="n">xfs_bmbt_irec_t</span>		<span class="n">imap</span><span class="p">;</span>
	<span class="n">xfs_off_t</span>		<span class="n">ioffset</span><span class="p">;</span>
	<span class="n">xfs_extlen_t</span>		<span class="n">mod</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nimap</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">resblks</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">rounding</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rt</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">startoffset_fsb</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">need_iolock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>

	<span class="n">trace_xfs_free_file_space</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_dqattach</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* if nothing being freed */</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">rt</span> <span class="o">=</span> <span class="n">XFS_IS_REALTIME_INODE</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="n">startoffset_fsb</span>	<span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">endoffset_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSBT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr_flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_NOLOCK</span><span class="p">)</span>
		<span class="n">need_iolock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_iolock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
		<span class="cm">/* wait for the completion of any pending DIOs */</span>
		<span class="n">inode_dio_wait</span><span class="p">(</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">rounding</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">uint</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocklog</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="n">ioffset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">rounding</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VN_CACHED</span><span class="p">(</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_flushinval_pages</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">ioffset</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">FI_REMAPF_LOCKED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock_iolock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to zero the stuff we&#39;re not freeing, on disk.</span>
<span class="cm">	 * If it&#39;s a realtime file &amp; can&#39;t use unwritten extents then we</span>
<span class="cm">	 * actually need to zero the extent edges.  Otherwise xfs_bunmapi</span>
<span class="cm">	 * will take care of it for us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xfs_sb_version_hasextflgbit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nimap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">startoffset_fsb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nimap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock_iolock</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nimap</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nimap</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nimap</span> <span class="o">&amp;&amp;</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">HOLESTARTBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_daddr_t</span>	<span class="n">block</span><span class="p">;</span>

			<span class="n">ASSERT</span><span class="p">(</span><span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">);</span>
			<span class="n">block</span> <span class="o">=</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span><span class="p">;</span>
			<span class="n">mod</span> <span class="o">=</span> <span class="n">do_div</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextsize</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="p">)</span>
				<span class="n">startoffset_fsb</span> <span class="o">+=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextsize</span> <span class="o">-</span> <span class="n">mod</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nimap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">endoffset_fsb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nimap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock_iolock</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nimap</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nimap</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nimap</span> <span class="o">&amp;&amp;</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">HOLESTARTBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">);</span>
			<span class="n">mod</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mod</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mod</span> <span class="o">!=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextsize</span><span class="p">))</span>
				<span class="n">endoffset_fsb</span> <span class="o">-=</span> <span class="n">mod</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">done</span> <span class="o">=</span> <span class="p">(</span><span class="n">endoffset_fsb</span> <span class="o">&lt;=</span> <span class="n">startoffset_fsb</span><span class="p">)))</span>
		<span class="cm">/*</span>
<span class="cm">		 * One contiguous piece to clear</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_zero_remaining_bytes</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some full blocks, possibly two pieces to clear</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">startoffset_fsb</span><span class="p">))</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_zero_remaining_bytes</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
				<span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">startoffset_fsb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span>
		    <span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">endoffset_fsb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_zero_remaining_bytes</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span>
				<span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">endoffset_fsb</span><span class="p">),</span>
				<span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * free file space until done or until there is an error</span>
<span class="cm">	 */</span>
	<span class="n">resblks</span> <span class="o">=</span> <span class="n">XFS_DIOSTRAT_SPACE_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * allocate and setup the transaction. Allow this</span>
<span class="cm">		 * transaction to dip into the reserve blocks to ensure</span>
<span class="cm">		 * the freeing of the space succeeds at ENOSPC.</span>
<span class="cm">		 */</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_DIOSTRAT</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">|=</span> <span class="n">XFS_TRANS_RESERVE</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span>
					  <span class="n">resblks</span><span class="p">,</span>
					  <span class="n">XFS_WRITE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span>
					  <span class="mi">0</span><span class="p">,</span>
					  <span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span>
					  <span class="n">XFS_WRITE_LOG_COUNT</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * check for running out of space</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Free the transaction structure.</span>
<span class="cm">			 */</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ENOSPC</span> <span class="o">||</span> <span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
			<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve_quota</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span>
				<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_udquot</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_gdquot</span><span class="p">,</span>
				<span class="n">resblks</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_QMOPT_RES_REGBLKS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>

		<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * issue the bunmapi() call to free the blocks</span>
<span class="cm">		 */</span>
		<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">firstfsb</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bunmapi</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">startoffset_fsb</span><span class="p">,</span>
				  <span class="n">endoffset_fsb</span> <span class="o">-</span> <span class="n">startoffset_fsb</span><span class="p">,</span>
				  <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">firstfsb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * complete the transaction</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">error0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="p">}</span>

 <span class="nl">out_unlock_iolock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_iolock</span><span class="p">)</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

 <span class="nl">error0:</span>
	<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">);</span>
 <span class="nl">error1:</span>
	<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span> <span class="o">|</span> <span class="n">XFS_TRANS_ABORT</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">need_iolock</span> <span class="o">?</span> <span class="p">(</span><span class="n">XFS_ILOCK_EXCL</span> <span class="o">|</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">)</span> <span class="o">:</span>
		    <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_change_file_space()</span>
<span class="cm"> *      This routine allocates or frees disk space for the given file.</span>
<span class="cm"> *      The user specified parameters are checked for alignment and size</span>
<span class="cm"> *      limitations.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> *       0 on success</span>
<span class="cm"> *      errno on error</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_change_file_space</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">cmd</span><span class="p">,</span>
	<span class="n">xfs_flock64_t</span>	<span class="o">*</span><span class="n">bf</span><span class="p">,</span>
	<span class="n">xfs_off_t</span>	<span class="n">offset</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">attr_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">clrprealloc</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_fsize_t</span>	<span class="n">fsize</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">setprealloc</span><span class="p">;</span>
	<span class="n">xfs_off_t</span>	<span class="n">startoffset</span><span class="p">;</span>
	<span class="n">xfs_off_t</span>	<span class="n">llen</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iattr</span>	<span class="n">iattr</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">prealloc_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_whence</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/*SEEK_SET*/</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="cm">/*SEEK_CUR*/</span>
		<span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_start</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="cm">/*SEEK_END*/</span>
		<span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_start</span> <span class="o">+=</span> <span class="n">XFS_ISIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">llen</span> <span class="o">=</span> <span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span>   <span class="p">(</span><span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_start</span> <span class="o">&gt;</span> <span class="n">XFS_MAXIOFFSET</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_start</span> <span class="o">+</span> <span class="n">llen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_start</span> <span class="o">+</span> <span class="n">llen</span> <span class="o">&gt;</span> <span class="n">XFS_MAXIOFFSET</span><span class="p">(</span><span class="n">mp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_whence</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">startoffset</span> <span class="o">=</span> <span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_start</span><span class="p">;</span>
	<span class="n">fsize</span> <span class="o">=</span> <span class="n">XFS_ISIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * XFS_IOC_RESVSP and XFS_IOC_UNRESVSP will reserve or unreserve</span>
<span class="cm">	 * file space.</span>
<span class="cm">	 * These calls do NOT zero the data space allocated to the file,</span>
<span class="cm">	 * nor do they change the file size.</span>
<span class="cm">	 *</span>
<span class="cm">	 * XFS_IOC_ALLOCSP and XFS_IOC_FREESP will allocate and free file</span>
<span class="cm">	 * space.</span>
<span class="cm">	 * These calls cause the new file data to be zeroed and the file</span>
<span class="cm">	 * size to be changed.</span>
<span class="cm">	 */</span>
	<span class="n">setprealloc</span> <span class="o">=</span> <span class="n">clrprealloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">prealloc_type</span> <span class="o">=</span> <span class="n">XFS_BMAPI_PREALLOC</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_IOC_ZERO_RANGE</span>:
		<span class="n">prealloc_type</span> <span class="o">|=</span> <span class="n">XFS_BMAPI_CONVERT</span><span class="p">;</span>
		<span class="n">xfs_tosspages</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">startoffset</span><span class="p">,</span> <span class="n">startoffset</span> <span class="o">+</span> <span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* FALLTHRU */</span>
	<span class="k">case</span> <span class="n">XFS_IOC_RESVSP</span>:
	<span class="k">case</span> <span class="n">XFS_IOC_RESVSP64</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_file_space</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">startoffset</span><span class="p">,</span> <span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_len</span><span class="p">,</span>
						<span class="n">prealloc_type</span><span class="p">,</span> <span class="n">attr_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">setprealloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">XFS_IOC_UNRESVSP</span>:
	<span class="k">case</span> <span class="n">XFS_IOC_UNRESVSP64</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_free_file_space</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">startoffset</span><span class="p">,</span> <span class="n">bf</span><span class="o">-&gt;</span><span class="n">l_len</span><span class="p">,</span>
								<span class="n">attr_flags</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">XFS_IOC_ALLOCSP</span>:
	<span class="k">case</span> <span class="n">XFS_IOC_ALLOCSP64</span>:
	<span class="k">case</span> <span class="n">XFS_IOC_FREESP</span>:
	<span class="k">case</span> <span class="n">XFS_IOC_FREESP64</span>:
		<span class="cm">/*</span>
<span class="cm">		 * These operations actually do IO when extending the file, but</span>
<span class="cm">		 * the allocation is done seperately to the zeroing that is</span>
<span class="cm">		 * done. This set of operations need to be serialised against</span>
<span class="cm">		 * other IO operations, such as truncate and buffered IO. We</span>
<span class="cm">		 * need to take the IOLOCK here to serialise the allocation and</span>
<span class="cm">		 * zeroing IO to prevent other IOLOCK holders (e.g. getbmap,</span>
<span class="cm">		 * truncate, direct IO) from racing against the transient</span>
<span class="cm">		 * allocated but not written state we can have here.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">startoffset</span> <span class="o">&gt;</span> <span class="n">fsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_file_space</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">fsize</span><span class="p">,</span>
					<span class="n">startoffset</span> <span class="o">-</span> <span class="n">fsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">attr_flags</span> <span class="o">|</span> <span class="n">XFS_ATTR_NOLOCK</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">iattr</span><span class="p">.</span><span class="n">ia_valid</span> <span class="o">=</span> <span class="n">ATTR_SIZE</span><span class="p">;</span>
		<span class="n">iattr</span><span class="p">.</span><span class="n">ia_size</span> <span class="o">=</span> <span class="n">startoffset</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_setattr_size</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iattr</span><span class="p">,</span>
					 <span class="n">attr_flags</span> <span class="o">|</span> <span class="n">XFS_ATTR_NOLOCK</span><span class="p">);</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">clrprealloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * update the inode timestamp, mode, and prealloc flag bits</span>
<span class="cm">	 */</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_WRITEID</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_WRITEID_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span>
				      <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* ASSERT(0); */</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">attr_flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_DMI</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_ISUID</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Note that we don&#39;t have to worry about mandatory</span>
<span class="cm">		 * file locking being disabled here because we only</span>
<span class="cm">		 * clear the S_ISGID bit if the Group execute bit is</span>
<span class="cm">		 * on, but if it was on then mandatory locking wouldn&#39;t</span>
<span class="cm">		 * have been enabled.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">&amp;</span> <span class="n">S_IXGRP</span><span class="p">)</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_ISGID</span><span class="p">;</span>

		<span class="n">xfs_trans_ichgtime</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ICHGTIME_MOD</span> <span class="o">|</span> <span class="n">XFS_ICHGTIME_CHG</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">setprealloc</span><span class="p">)</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">|=</span> <span class="n">XFS_DIFLAG_PREALLOC</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">clrprealloc</span><span class="p">)</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XFS_DIFLAG_PREALLOC</span><span class="p">;</span>

	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr_flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_SYNC</span><span class="p">)</span>
		<span class="n">xfs_trans_set_sync</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
