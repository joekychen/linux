<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_da_btree.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_da_btree.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_bit.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_da_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_dir2.h&quot;</span>
<span class="cp">#include &quot;xfs_dir2_format.h&quot;</span>
<span class="cp">#include &quot;xfs_dir2_priv.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode_item.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap.h&quot;</span>
<span class="cp">#include &quot;xfs_attr.h&quot;</span>
<span class="cp">#include &quot;xfs_attr_leaf.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_da_btree.c</span>
<span class="cm"> *</span>
<span class="cm"> * Routines to implement directories as Btrees of hashed names.</span>
<span class="cm"> */</span>

<span class="cm">/*========================================================================</span>
<span class="cm"> * Function prototypes for the kernel.</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Routines used for growing the Btree.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_da_root_split</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					    <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">existing_root</span><span class="p">,</span>
					    <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">new_child</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_da_node_split</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					    <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">existing_blk</span><span class="p">,</span>
					    <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">split_blk</span><span class="p">,</span>
					    <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk_to_add</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">treelevel</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="o">*</span><span class="n">result</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span> <span class="n">xfs_da_node_rebalance</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					 <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">node_blk_1</span><span class="p">,</span>
					 <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">node_blk_2</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span> <span class="n">xfs_da_node_add</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				   <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">old_node_blk</span><span class="p">,</span>
				   <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">new_node_blk</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Routines used for shrinking the Btree.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_da_root_join</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					   <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">root_blk</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_da_node_toosmall</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">retval</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span> <span class="n">xfs_da_node_remove</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					      <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">drop_blk</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span> <span class="n">xfs_da_node_unbalance</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					 <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">src_node_blk</span><span class="p">,</span>
					 <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">dst_node_blk</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Utility routines.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="n">uint</span>	<span class="n">xfs_da_node_lasthash</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span>	<span class="n">xfs_da_node_order</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">node1_bp</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">node2_bp</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">xfs_da_buf_make</span><span class="p">(</span><span class="kt">int</span> <span class="n">nbuf</span><span class="p">,</span> <span class="n">xfs_buf_t</span> <span class="o">**</span><span class="n">bps</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span>	<span class="n">xfs_da_blk_unlink</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				  <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">drop_blk</span><span class="p">,</span>
				  <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">save_blk</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span>	<span class="n">xfs_da_state_kill_altpath</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>

<span class="cm">/*========================================================================</span>
<span class="cm"> * Routines used for growing the Btree.</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Create the initial contents of an intermediate node.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_da_node_create</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">xfs_dablk_t</span> <span class="n">blkno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
				 <span class="n">xfs_dabuf_t</span> <span class="o">**</span><span class="n">bpp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whichfork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>

	<span class="n">trace_xfs_da_node_create</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_get_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">forw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">back</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">);</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>

	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
		<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">)));</span>

	<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Split a leaf node, rebalance, then possibly split</span>
<span class="cm"> * intermediate nodes, rebalance, etc.</span>
<span class="cm"> */</span>
<span class="kt">int</span>							<span class="cm">/* error */</span>
<span class="n">xfs_da_split</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">oldblk</span><span class="p">,</span> <span class="o">*</span><span class="n">newblk</span><span class="p">,</span> <span class="o">*</span><span class="n">addblk</span><span class="p">;</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">trace_xfs_da_split</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Walk back up the tree splitting/inserting/adjusting as necessary.</span>
<span class="cm">	 * If we need to insert and there isn&#39;t room, split the node, then</span>
<span class="cm">	 * decide which fragment to insert the new block from below into.</span>
<span class="cm">	 * Note that we may split the root this way, but we need more fixup.</span>
<span class="cm">	 */</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">max</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="n">XFS_DA_NODE_MAXDEPTH</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">max</span><span class="p">].</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span> <span class="o">||</span>
	       <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">max</span><span class="p">].</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">);</span>

	<span class="n">addblk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">max</span><span class="p">];</span>		<span class="cm">/* initial dummy value */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">addblk</span><span class="p">;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="o">--</span><span class="p">,</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oldblk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">newblk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * If a leaf node then</span>
<span class="cm">		 *     Allocate a new leaf node, then rebalance across them.</span>
<span class="cm">		 * else if an intermediate node then</span>
<span class="cm">		 *     We split on the last layer, must we split the node?</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_split</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">oldblk</span><span class="p">,</span> <span class="n">newblk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">ENOSPC</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>	<span class="cm">/* GROT: attr is inconsistent */</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">addblk</span> <span class="o">=</span> <span class="n">newblk</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Entry wouldn&#39;t fit, split the leaf again.</span>
<span class="cm">			 */</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">state</span><span class="o">-&gt;</span><span class="n">extraafter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* before newblk */</span>
				<span class="n">trace_xfs_attr_leaf_split_before</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_split</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">oldblk</span><span class="p">,</span>
							    <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">state</span><span class="o">-&gt;</span><span class="n">extraafter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* after newblk */</span>
				<span class="n">trace_xfs_attr_leaf_split_after</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_split</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">newblk</span><span class="p">,</span>
							    <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>	<span class="cm">/* GROT: attr inconsistent */</span>
			<span class="n">addblk</span> <span class="o">=</span> <span class="n">newblk</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_leafn_split</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">oldblk</span><span class="p">,</span> <span class="n">newblk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="n">addblk</span> <span class="o">=</span> <span class="n">newblk</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XFS_DA_NODE_MAGIC</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_node_split</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">oldblk</span><span class="p">,</span> <span class="n">newblk</span><span class="p">,</span> <span class="n">addblk</span><span class="p">,</span>
							 <span class="n">max</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="p">);</span>
			<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">addblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">addblk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>	<span class="cm">/* GROT: dir is inconsistent */</span>
			<span class="cm">/*</span>
<span class="cm">			 * Record the newly split block for the next time thru?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span>
				<span class="n">addblk</span> <span class="o">=</span> <span class="n">newblk</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">addblk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Update the btree to show the new hashval for this child.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_da_fixhashpath</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we won&#39;t need this block again, it&#39;s getting dropped</span>
<span class="cm">		 * from the active path by the loop control, so we need</span>
<span class="cm">		 * to mark it done now.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">addblk</span><span class="p">)</span>
			<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addblk</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Split the root node.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">oldblk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_root_split</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">oldblk</span><span class="p">,</span> <span class="n">addblk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">addblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">addblk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>	<span class="cm">/* GROT: dir is inconsistent */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update pointers to the node which used to be block 0 and</span>
<span class="cm">	 * just got bumped because of the addition of a new root node.</span>
<span class="cm">	 * There might be three blocks involved if a double split occurred,</span>
<span class="cm">	 * and the original block 0 could be at any position in the list.</span>
<span class="cm">	 */</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">forw</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">forw</span><span class="p">)</span> <span class="o">==</span> <span class="n">addblk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bp</span> <span class="o">=</span> <span class="n">addblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span><span class="p">);</span>
			<span class="n">bp</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">back</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
		    <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">,</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">)));</span>
	<span class="p">}</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">back</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">back</span><span class="p">)</span> <span class="o">==</span> <span class="n">addblk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bp</span> <span class="o">=</span> <span class="n">addblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span><span class="p">);</span>
			<span class="n">bp</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">forw</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
		    <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">,</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">)));</span>
	<span class="p">}</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">addblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">addblk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Split the root.  We have to create a new root and point to the two</span>
<span class="cm"> * parts (the split old root) that we just created.  Copy block zero to</span>
<span class="cm"> * the EOF, extending the inode in process.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_da_root_split</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk1</span><span class="p">,</span>
				 <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">oldroot</span><span class="p">;</span>
	<span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
	<span class="n">xfs_dablk_t</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_dir2_leaf_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>

	<span class="n">trace_xfs_da_root_split</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the existing (incorrect) block from the root node position</span>
<span class="cm">	 * to a free space somewhere.</span>
<span class="cm">	 */</span>
	<span class="n">args</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_grow_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_get_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">oldroot</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldroot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">oldroot</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">oldroot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)]</span> <span class="o">-</span>
			     <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">oldroot</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">oldroot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">));</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_leaf_t</span> <span class="o">*</span><span class="p">)</span><span class="n">oldroot</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)]</span> <span class="o">-</span>
			     <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">leaf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">oldroot</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="n">blk1</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up the new root node.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_node_create</span><span class="p">(</span><span class="n">args</span><span class="p">,</span>
		<span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span> <span class="o">==</span> <span class="n">XFS_DATA_FORK</span><span class="p">)</span> <span class="o">?</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirleafblk</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">level</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">blk1</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">before</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">blk1</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">blk2</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">before</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">blk2</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldroot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk1</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirleafblk</span> <span class="o">&amp;&amp;</span>
		       <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirfreeblk</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk2</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">&gt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirleafblk</span> <span class="o">&amp;&amp;</span>
		       <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirfreeblk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Header is already logged by xfs_da_node_create */</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
		<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_da_node_entry_t</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Split the node, rebalance, then add the new entry.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_da_node_split</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">oldblk</span><span class="p">,</span>
				 <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">newblk</span><span class="p">,</span>
				 <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">addblk</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">treelevel</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">xfs_dablk_t</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">newcount</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">useextra</span><span class="p">;</span>

	<span class="n">trace_xfs_da_node_split</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * With V2 dirs the extra block is data or freespace.</span>
<span class="cm">	 */</span>
	<span class="n">useextra</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span> <span class="o">==</span> <span class="n">XFS_ATTR_FORK</span><span class="p">;</span>
	<span class="n">newcount</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">useextra</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do we have to split the node?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="n">newcount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">node_ents</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allocate a new node, add to the doubly linked chain of</span>
<span class="cm">		 * nodes, then move some of our excess entries into it.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_grow_inode</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkno</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>	<span class="cm">/* GROT: dir is inconsistent */</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_node_create</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">treelevel</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">newblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>	<span class="cm">/* GROT: dir is inconsistent */</span>
		<span class="n">newblk</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span>
		<span class="n">newblk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">XFS_DA_NODE_MAGIC</span><span class="p">;</span>
		<span class="n">xfs_da_node_rebalance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">oldblk</span><span class="p">,</span> <span class="n">newblk</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_blk_link</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">oldblk</span><span class="p">,</span> <span class="n">newblk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Insert the new entry(s) into the correct block</span>
<span class="cm">	 * (updating last hashval in the process).</span>
<span class="cm">	 *</span>
<span class="cm">	 * xfs_da_node_add() inserts BEFORE the given index,</span>
<span class="cm">	 * and as a result of using node_lookup_int() we always</span>
<span class="cm">	 * point to a valid entry (not after one), but a split</span>
<span class="cm">	 * operation always results in a new block whose hashvals</span>
<span class="cm">	 * FOLLOW the current block.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we had double-split op below us, then add the extra block too.</span>
<span class="cm">	 */</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="n">xfs_da_node_add</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">oldblk</span><span class="p">,</span> <span class="n">addblk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">useextra</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extraafter</span><span class="p">)</span>
				<span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
			<span class="n">xfs_da_node_add</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">oldblk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">);</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">newblk</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="n">xfs_da_node_add</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">newblk</span><span class="p">,</span> <span class="n">addblk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">useextra</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extraafter</span><span class="p">)</span>
				<span class="n">newblk</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
			<span class="n">xfs_da_node_add</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">newblk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">);</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Balance the btree elements between two intermediate nodes,</span>
<span class="cm"> * usually one full and one empty.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: if blk2 is empty, then it will get the upper half of blk1.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="n">xfs_da_node_rebalance</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk1</span><span class="p">,</span>
				     <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node1</span><span class="p">,</span> <span class="o">*</span><span class="n">node2</span><span class="p">,</span> <span class="o">*</span><span class="n">tmpnode</span><span class="p">;</span>
	<span class="n">xfs_da_node_entry_t</span> <span class="o">*</span><span class="n">btree_s</span><span class="p">,</span> <span class="o">*</span><span class="n">btree_d</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>

	<span class="n">trace_xfs_da_node_rebalance</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>

	<span class="n">node1</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">node2</span> <span class="o">=</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Figure out how many entries need to move, and in which direction.</span>
<span class="cm">	 * Swap the nodes around if that makes it simpler.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hashval</span><span class="p">))</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span>
	      <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">tmpnode</span> <span class="o">=</span> <span class="n">node1</span><span class="p">;</span>
		<span class="n">node1</span> <span class="o">=</span> <span class="n">node2</span><span class="p">;</span>
		<span class="n">node2</span> <span class="o">=</span> <span class="n">tmpnode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
	<span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Two cases: high-to-low and low-to-high.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Move elements in node2 up to make a hole.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">*=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_da_node_entry_t</span><span class="p">);</span>
			<span class="n">btree_s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">btree_d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>
			<span class="n">memmove</span><span class="p">(</span><span class="n">btree_d</span><span class="p">,</span> <span class="n">btree_s</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Move the req&#39;d B-tree elements from high in node1 to</span>
<span class="cm">		 * low in node2.</span>
<span class="cm">		 */</span>
		<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_da_node_entry_t</span><span class="p">);</span>
		<span class="n">btree_s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">count</span><span class="p">];</span>
		<span class="n">btree_d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">btree_d</span><span class="p">,</span> <span class="n">btree_s</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="o">-</span><span class="n">count</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Move the req&#39;d B-tree elements from low in node2 to</span>
<span class="cm">		 * high in node1.</span>
<span class="cm">		 */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">count</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_da_node_entry_t</span><span class="p">);</span>
		<span class="n">btree_s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">btree_d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)];</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">btree_d</span><span class="p">,</span> <span class="n">btree_s</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
			<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">btree_d</span><span class="p">,</span> <span class="n">tmp</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Move elements in node2 down to fill the hole.</span>
<span class="cm">		 */</span>
		<span class="n">tmp</span>  <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">*=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_da_node_entry_t</span><span class="p">);</span>
		<span class="n">btree_s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>
		<span class="n">btree_d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">btree_d</span><span class="p">,</span> <span class="n">btree_s</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="o">-</span><span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Log header of node 1 and all current bits of node 2.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
		<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">)));</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
		<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">)</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Record the last hashval from each block for upward propagation.</span>
<span class="cm">	 * (note: don&#39;t use the swapped node pointers)</span>
<span class="cm">	 */</span>
	<span class="n">node1</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">node2</span> <span class="o">=</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">blk1</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
	<span class="n">blk2</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Adjust the expected index for insertion.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk1</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">blk2</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">-</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
		<span class="n">blk1</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* make it invalid */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a new entry to an intermediate node.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="n">xfs_da_node_add</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">oldblk</span><span class="p">,</span>
			       <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">newblk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">xfs_da_node_entry_t</span> <span class="o">*</span><span class="n">btree</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">trace_xfs_da_node_add</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">newblk</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span> <span class="o">==</span> <span class="n">XFS_DATA_FORK</span><span class="p">)</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">newblk</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">&gt;=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirleafblk</span> <span class="o">&amp;&amp;</span>
		       <span class="n">newblk</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">&lt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirfreeblk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We may need to make some room before we insert the new node.</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">btree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span> <span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">btree</span><span class="p">);</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">btree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">btree</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btree</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">newblk</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>
	<span class="n">btree</span><span class="o">-&gt;</span><span class="n">before</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">newblk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
		<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">btree</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">btree</span><span class="p">)));</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
		<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the last hash value from the oldblk to propagate upwards.</span>
<span class="cm">	 */</span>
	<span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*========================================================================</span>
<span class="cm"> * Routines used for shrinking the Btree.</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Deallocate an empty leaf node, remove it from its parent,</span>
<span class="cm"> * possibly deallocating that block, etc...</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xfs_da_join</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">drop_blk</span><span class="p">,</span> <span class="o">*</span><span class="n">save_blk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">action</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">trace_xfs_da_join</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>

	<span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">drop_blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="o">-</span><span class="mi">1</span> <span class="p">];</span>
	<span class="n">save_blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="o">-</span><span class="mi">1</span> <span class="p">];</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DA_NODE_MAGIC</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span> <span class="o">||</span>
	       <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Walk back up the tree joining/deallocating as necessary.</span>
<span class="cm">	 * When we stop dropping blocks, break out.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span>  <span class="p">;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">drop_blk</span><span class="o">--</span><span class="p">,</span> <span class="n">save_blk</span><span class="o">--</span><span class="p">,</span>
		 <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * See if we can combine the block with a neighbor.</span>
<span class="cm">		 *   (action == 0) =&gt; no options, just leave</span>
<span class="cm">		 *   (action == 1) =&gt; coalesce, then unlink</span>
<span class="cm">		 *   (action == 2) =&gt; block empty, unlink it</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_toosmall</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">xfs_attr_leaf_unbalance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">drop_blk</span><span class="p">,</span> <span class="n">save_blk</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dir2_leafn_toosmall</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">xfs_dir2_leafn_unbalance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">drop_blk</span><span class="p">,</span> <span class="n">save_blk</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XFS_DA_NODE_MAGIC</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Remove the offending node, fixup hashvals,</span>
<span class="cm">			 * check for a toosmall neighbor.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_da_node_remove</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">drop_blk</span><span class="p">);</span>
			<span class="n">xfs_da_fixhashpath</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_node_toosmall</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">xfs_da_node_unbalance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">drop_blk</span><span class="p">,</span> <span class="n">save_blk</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">xfs_da_fixhashpath</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_blk_unlink</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">drop_blk</span><span class="p">,</span> <span class="n">save_blk</span><span class="p">);</span>
		<span class="n">xfs_da_state_kill_altpath</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_shrink_inode</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">,</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span>
							 <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We joined all the way to the top.  If it turns out that</span>
<span class="cm">	 * we only have one entry in the root, make the child block</span>
<span class="cm">	 * the new root.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_da_node_remove</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">drop_blk</span><span class="p">);</span>
	<span class="n">xfs_da_fixhashpath</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_root_join</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef	DEBUG</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="n">xfs_da_blkinfo_onlychild_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_da_blkinfo</span> <span class="o">*</span><span class="n">blkinfo</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be16</span>	<span class="n">magic</span> <span class="o">=</span> <span class="n">blkinfo</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">)</span> <span class="o">||</span>
		       <span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">blkinfo</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">blkinfo</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else	</span><span class="cm">/* !DEBUG */</span><span class="cp"></span>
<span class="cp">#define	xfs_da_blkinfo_onlychild_validate(blkinfo, level)</span>
<span class="cp">#endif	</span><span class="cm">/* !DEBUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * We have only one entry in the root.  Copy the only remaining child of</span>
<span class="cm"> * the old root to block 0 as the new root node.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_da_root_join</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">root_blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">oldroot</span><span class="p">;</span>
	<span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
	<span class="n">xfs_dablk_t</span> <span class="n">child</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">trace_xfs_da_root_join</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>

	<span class="n">args</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">root_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DA_NODE_MAGIC</span><span class="p">);</span>
	<span class="n">oldroot</span> <span class="o">=</span> <span class="n">root_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">oldroot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">oldroot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">forw</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">oldroot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">back</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the root has more than one child, then don&#39;t do anything.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">oldroot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read in the (only) child block, then copy those bytes into</span>
<span class="cm">	 * the root block&#39;s buffer and free the original child block.</span>
<span class="cm">	 */</span>
	<span class="n">child</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">oldroot</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">before</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">child</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span>
					     <span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">xfs_da_blkinfo_onlychild_validate</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
					<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">oldroot</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">level</span><span class="p">));</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">root_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">);</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">root_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_shrink_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check a node block and its neighbors to see if the block should be</span>
<span class="cm"> * collapsed into one or the other neighbor.  Always keep the block</span>
<span class="cm"> * with the smaller block number.</span>
<span class="cm"> * If the current block is over 50% full, don&#39;t try to join it, return 0.</span>
<span class="cm"> * If the block is empty, fill in the state structure and return 2.</span>
<span class="cm"> * If it can be collapsed, fill in the state structure and return 1.</span>
<span class="cm"> * If nothing can be done, return 0.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_da_node_toosmall</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk</span><span class="p">;</span>
	<span class="n">xfs_da_blkinfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_dablk_t</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for the degenerate case of the block being over 50% full.</span>
<span class="cm">	 * If so, it&#39;s not worth even looking to see if we might be able</span>
<span class="cm">	 * to coalesce with a sibling.</span>
<span class="cm">	 */</span>
	<span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="o">-</span><span class="mi">1</span> <span class="p">];</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
	<span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">node_ents</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* blk over 50%, don&#39;t try to join */</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* blk over 50%, don&#39;t try to join */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for the degenerate case of the block being empty.</span>
<span class="cm">	 * If the block is empty, we&#39;ll simply delete it, no need to</span>
<span class="cm">	 * coalesce it with a sibling block.  We choose (arbitrarily)</span>
<span class="cm">	 * to merge with the forward block unless it is NULL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make altpath point to the block we want to keep and</span>
<span class="cm">		 * path point to the block we want to drop (this one).</span>
<span class="cm">		 */</span>
		<span class="n">forward</span> <span class="o">=</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">forw</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">));</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_path_shift</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span>
						 <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Examine each sibling block to see if we can coalesce with</span>
<span class="cm">	 * at least 25% free space to spare.  We need to figure out</span>
<span class="cm">	 * whether to merge with the forward or the backward block.</span>
<span class="cm">	 * We prefer coalescing with the lower numbered sibling so as</span>
<span class="cm">	 * to shrink a directory over time.</span>
<span class="cm">	 */</span>
	<span class="cm">/* start with smaller blk num */</span>
	<span class="n">forward</span> <span class="o">=</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">forward</span> <span class="o">=</span> <span class="o">!</span><span class="n">forward</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">forward</span><span class="p">)</span>
			<span class="n">blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span>
					<span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
		<span class="n">count</span>  <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">node_ents</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">node_ents</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* fits with at least 25% to spare */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make altpath point to the block we want to keep (the lower</span>
<span class="cm">	 * numbered block) and path point to the block we want to drop.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">&lt;</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_path_shift</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span>
						 <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_path_shift</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span>
						 <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Walk back up the tree adjusting hash values as necessary,</span>
<span class="cm"> * when we stop making changes, return.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="n">xfs_da_fixhashpath</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">xfs_da_state_path_t</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk</span><span class="p">;</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">xfs_da_node_entry_t</span> <span class="o">*</span><span class="n">btree</span><span class="p">;</span>
	<span class="n">xfs_dahash_t</span> <span class="n">lasthash</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">level</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span> <span class="n">level</span> <span class="p">];</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span>:
		<span class="n">lasthash</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_lasthash</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span>:
		<span class="n">lasthash</span> <span class="o">=</span> <span class="n">xfs_dir2_leafn_lasthash</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_DA_NODE_MAGIC</span>:
		<span class="n">lasthash</span> <span class="o">=</span> <span class="n">xfs_da_node_lasthash</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">blk</span><span class="o">--</span><span class="p">,</span> <span class="n">level</span><span class="o">--</span><span class="p">;</span> <span class="n">level</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">blk</span><span class="o">--</span><span class="p">,</span> <span class="n">level</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
		<span class="n">btree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">==</span> <span class="n">lasthash</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">blk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">lasthash</span><span class="p">;</span>
		<span class="n">btree</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">lasthash</span><span class="p">);</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
				  <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">btree</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">btree</span><span class="p">)));</span>

		<span class="n">lasthash</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove an entry from an intermediate node.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="n">xfs_da_node_remove</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">drop_blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">xfs_da_node_entry_t</span> <span class="o">*</span><span class="n">btree</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">trace_xfs_da_node_remove</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy over the offending entry, or just zero it out.</span>
<span class="cm">	 */</span>
	<span class="n">btree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span>  <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">*=</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_da_node_entry_t</span><span class="p">);</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">btree</span><span class="p">,</span> <span class="n">btree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
		    <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">btree</span><span class="p">,</span> <span class="n">tmp</span><span class="p">));</span>
		<span class="n">btree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">btree</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_da_node_entry_t</span><span class="p">));</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
	    <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">btree</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">btree</span><span class="p">)));</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
	    <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the last hash value from the block to propagate upwards.</span>
<span class="cm">	 */</span>
	<span class="n">btree</span><span class="o">--</span><span class="p">;</span>
	<span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unbalance the btree elements between two intermediate nodes,</span>
<span class="cm"> * move all Btree elements from one node into another.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="n">xfs_da_node_unbalance</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">drop_blk</span><span class="p">,</span>
				     <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">save_blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">drop_node</span><span class="p">,</span> <span class="o">*</span><span class="n">save_node</span><span class="p">;</span>
	<span class="n">xfs_da_node_entry_t</span> <span class="o">*</span><span class="n">btree</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>

	<span class="n">trace_xfs_da_node_unbalance</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>

	<span class="n">drop_node</span> <span class="o">=</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">save_node</span> <span class="o">=</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">drop_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the dying block has lower hashvals, then move all the</span>
<span class="cm">	 * elements in the remaining block up to make a hole.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">drop_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span> <span class="mi">0</span> <span class="p">].</span><span class="n">hashval</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">drop_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span>
	     <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">)))</span>
	<span class="p">{</span>
		<span class="n">btree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)];</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_da_node_entry_t</span><span class="p">);</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">btree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="n">btree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
			<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">save_node</span><span class="p">,</span> <span class="n">btree</span><span class="p">,</span>
				<span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="o">*</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_da_node_entry_t</span><span class="p">)));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">btree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)];</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
			<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">save_node</span><span class="p">,</span> <span class="n">btree</span><span class="p">,</span>
				<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">*</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_da_node_entry_t</span><span class="p">)));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Move all the B-tree elements from drop_blk to save_blk.</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_da_node_entry_t</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">btree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drop_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">));</span>

	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
		<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">save_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save the last hashval in the remaining block for upward propagation.</span>
<span class="cm">	 */</span>
	<span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">save_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*========================================================================</span>
<span class="cm"> * Routines used for finding things in the Btree.</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Walk down the Btree looking for a particular filename, filling</span>
<span class="cm"> * in the state structure as we go.</span>
<span class="cm"> *</span>
<span class="cm"> * We will set the state structure to point to each of the elements</span>
<span class="cm"> * in each of the nodes where either the hashval is or should be.</span>
<span class="cm"> *</span>
<span class="cm"> * We support duplicate hashval&#39;s so for each entry in the current</span>
<span class="cm"> * node that could contain the desired hashval, descend.  This is a</span>
<span class="cm"> * pruned depth-first tree search.</span>
<span class="cm"> */</span>
<span class="kt">int</span>							<span class="cm">/* error */</span>
<span class="n">xfs_da_node_lookup_int</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk</span><span class="p">;</span>
	<span class="n">xfs_da_blkinfo_t</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">xfs_da_node_entry_t</span> <span class="o">*</span><span class="n">btree</span><span class="p">;</span>
	<span class="n">xfs_dablk_t</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">probe</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">xfs_dahash_t</span> <span class="n">hashval</span><span class="p">,</span> <span class="n">btreehashval</span><span class="p">;</span>
	<span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>

	<span class="n">args</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Descend thru the B-tree searching each level for the right</span>
<span class="cm">	 * node to use, until the right hashval is found.</span>
<span class="cm">	 */</span>
	<span class="n">blkno</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span> <span class="o">==</span> <span class="n">XFS_DATA_FORK</span><span class="p">)</span><span class="o">?</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirleafblk</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			 <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span> <span class="o">&lt;=</span> <span class="n">XFS_DA_NODE_MAXDEPTH</span><span class="p">;</span>
			 <span class="n">blk</span><span class="o">++</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Read the next node down in the tree.</span>
<span class="cm">		 */</span>
		<span class="n">blk</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span>
					<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="o">--</span><span class="p">;</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DA_NODE_MAGIC</span> <span class="o">||</span>
		       <span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span> <span class="o">||</span>
		       <span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Search an intermediate node for a match.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DA_NODE_MAGIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">max</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Binary search.  (note: small blocks will skip loop)</span>
<span class="cm">			 */</span>
			<span class="n">probe</span> <span class="o">=</span> <span class="n">span</span> <span class="o">=</span> <span class="n">max</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">hashval</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">btree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">probe</span><span class="p">];</span> <span class="n">span</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">;</span>
				   <span class="n">btree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">probe</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">span</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">btreehashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">btreehashval</span> <span class="o">&lt;</span> <span class="n">hashval</span><span class="p">)</span>
					<span class="n">probe</span> <span class="o">+=</span> <span class="n">span</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">btreehashval</span> <span class="o">&gt;</span> <span class="n">hashval</span><span class="p">)</span>
					<span class="n">probe</span> <span class="o">-=</span> <span class="n">span</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ASSERT</span><span class="p">((</span><span class="n">probe</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">probe</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">));</span>
			<span class="n">ASSERT</span><span class="p">((</span><span class="n">span</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">==</span> <span class="n">hashval</span><span class="p">));</span>

			<span class="cm">/*</span>
<span class="cm">			 * Since we may have duplicate hashval&#39;s, find the first</span>
<span class="cm">			 * matching hashval in the node.</span>
<span class="cm">			 */</span>
			<span class="k">while</span> <span class="p">((</span><span class="n">probe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">hashval</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">btree</span><span class="o">--</span><span class="p">;</span>
				<span class="n">probe</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">while</span> <span class="p">((</span><span class="n">probe</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">hashval</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">btree</span><span class="o">++</span><span class="p">;</span>
				<span class="n">probe</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Pick the right block to descend on.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">probe</span> <span class="o">==</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">max</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="n">blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">max</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">before</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">probe</span><span class="p">;</span>
				<span class="n">blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">before</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_lasthash</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">xfs_dir2_leafn_lasthash</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * A leaf block that ends in the hashval that we are interested in</span>
<span class="cm">	 * (final hashval == search hashval) means that the next block may</span>
<span class="cm">	 * contain more entries with the same hashval, shift upward to the</span>
<span class="cm">	 * next leaf and keep searching.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">xfs_dir2_leafn_lookup_int</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_lookup_int</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">retval</span> <span class="o">==</span> <span class="n">ENOENT</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">ENOATTR</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_path_shift</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* path_shift() gives ENOENT */</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOATTR</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*========================================================================</span>
<span class="cm"> * Utility routines.</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Link a new block into a doubly linked list of blocks (of whatever type).</span>
<span class="cm"> */</span>
<span class="kt">int</span>							<span class="cm">/* error */</span>
<span class="n">xfs_da_blk_link</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">old_blk</span><span class="p">,</span>
			       <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">new_blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_blkinfo_t</span> <span class="o">*</span><span class="n">old_info</span><span class="p">,</span> <span class="o">*</span><span class="n">new_info</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_info</span><span class="p">;</span>
	<span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">before</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up environment.</span>
<span class="cm">	 */</span>
	<span class="n">args</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">old_info</span> <span class="o">=</span> <span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">new_info</span> <span class="o">=</span> <span class="n">new_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DA_NODE_MAGIC</span> <span class="o">||</span>
	       <span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span> <span class="o">||</span>
	       <span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">old_info</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">new_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">new_info</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">new_blk</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span>:
		<span class="n">before</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_order</span><span class="p">(</span><span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">new_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span>:
		<span class="n">before</span> <span class="o">=</span> <span class="n">xfs_dir2_leafn_order</span><span class="p">(</span><span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">new_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_DA_NODE_MAGIC</span>:
		<span class="n">before</span> <span class="o">=</span> <span class="n">xfs_da_node_order</span><span class="p">(</span><span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">new_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Link blocks in appropriate order.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Link new block in before existing block.</span>
<span class="cm">		 */</span>
		<span class="n">trace_xfs_da_link_before</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="n">new_info</span><span class="o">-&gt;</span><span class="n">forw</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
		<span class="n">new_info</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">old_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span>
						<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">old_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">),</span>
						<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">tmp_info</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">tmp_info</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">)</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">old_info</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">));</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">tmp_info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">)</span> <span class="o">==</span> <span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
			<span class="n">tmp_info</span><span class="o">-&gt;</span><span class="n">forw</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">new_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
			<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tmp_info</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">old_info</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">new_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Link new block in after existing block.</span>
<span class="cm">		 */</span>
		<span class="n">trace_xfs_da_link_after</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="n">new_info</span><span class="o">-&gt;</span><span class="n">forw</span> <span class="o">=</span> <span class="n">old_info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">;</span>
		<span class="n">new_info</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span>
						<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">old_info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">),</span>
						<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">tmp_info</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">tmp_info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">old_info</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">tmp_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">)</span> <span class="o">==</span> <span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
			<span class="n">tmp_info</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">new_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
			<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tmp_info</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">old_info</span><span class="o">-&gt;</span><span class="n">forw</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">new_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">old_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tmp_info</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">new_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tmp_info</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compare two intermediate nodes for &quot;order&quot;.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="n">xfs_da_node_order</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">node1_bp</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">node2_bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node1</span><span class="p">,</span> <span class="o">*</span><span class="n">node2</span><span class="p">;</span>

	<span class="n">node1</span> <span class="o">=</span> <span class="n">node1_bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">node2</span> <span class="o">=</span> <span class="n">node2_bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span>
	      <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hashval</span><span class="p">))</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span>
	      <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">))))</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pick up the last hashvalue from an intermediate node.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="n">uint</span>
<span class="n">xfs_da_node_lasthash</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unlink a block from a doubly linked list of blocks.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>						<span class="cm">/* error */</span>
<span class="n">xfs_da_blk_unlink</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">drop_blk</span><span class="p">,</span>
				 <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">save_blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_blkinfo_t</span> <span class="o">*</span><span class="n">drop_info</span><span class="p">,</span> <span class="o">*</span><span class="n">save_info</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_info</span><span class="p">;</span>
	<span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up environment.</span>
<span class="cm">	 */</span>
	<span class="n">args</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">save_info</span> <span class="o">=</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">drop_info</span> <span class="o">=</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DA_NODE_MAGIC</span> <span class="o">||</span>
	       <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span> <span class="o">||</span>
	       <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">save_info</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_info</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">save_info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">)</span> <span class="o">==</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">save_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">)</span> <span class="o">==</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">drop_info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">)</span> <span class="o">==</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">drop_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">)</span> <span class="o">==</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unlink the leaf block from the doubly linked chain of leaves.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">save_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">)</span> <span class="o">==</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_xfs_da_unlink_back</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="n">save_info</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">drop_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drop_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span>
						<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">drop_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">),</span>
						<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">tmp_info</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">tmp_info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">save_info</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">tmp_info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">)</span> <span class="o">==</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
			<span class="n">tmp_info</span><span class="o">-&gt;</span><span class="n">forw</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
			<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						    <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tmp_info</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">trace_xfs_da_unlink_forward</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="n">save_info</span><span class="o">-&gt;</span><span class="n">forw</span> <span class="o">=</span> <span class="n">drop_info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drop_info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span>
						<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">drop_info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">),</span>
						<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">tmp_info</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">tmp_info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">save_info</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">tmp_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">)</span> <span class="o">==</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
			<span class="n">tmp_info</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">);</span>
			<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						    <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tmp_info</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">save_info</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move a path &quot;forward&quot; or &quot;!forward&quot; one block at the current level.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will adjust a &quot;path&quot; to point to the next block</span>
<span class="cm"> * &quot;forward&quot; (higher hashvalues) or &quot;!forward&quot; (lower hashvals) in the</span>
<span class="cm"> * Btree, including updating pointers to the intermediate nodes between</span>
<span class="cm"> * the new bottom and the root.</span>
<span class="cm"> */</span>
<span class="kt">int</span>							<span class="cm">/* error */</span>
<span class="n">xfs_da_path_shift</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">xfs_da_state_path_t</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">forward</span><span class="p">,</span> <span class="kt">int</span> <span class="n">release</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk</span><span class="p">;</span>
	<span class="n">xfs_da_blkinfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
	<span class="n">xfs_dablk_t</span> <span class="n">blkno</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Roll up the Btree looking for the first block where our</span>
<span class="cm">	 * current index is not at the edge of the block.  Note that</span>
<span class="cm">	 * we skip the bottom layer because we want the sibling block.</span>
<span class="cm">	 */</span>
	<span class="n">args</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">path</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">&lt;</span> <span class="n">XFS_DA_NODE_MAXDEPTH</span><span class="p">));</span>
	<span class="n">level</span> <span class="o">=</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* skip bottom layer in path */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">blk</span><span class="p">[</span><span class="n">level</span><span class="p">];</span> <span class="n">level</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">blk</span><span class="o">--</span><span class="p">,</span> <span class="n">level</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">forward</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
			<span class="n">blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">before</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">forward</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">--</span><span class="p">;</span>
			<span class="n">blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">before</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOENT</span><span class="p">);</span>	<span class="cm">/* we&#39;re out of our tree */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_OKNOENT</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Roll down the edge of the subtree until we reach the</span>
<span class="cm">	 * same depth we were at originally.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">blk</span><span class="o">++</span><span class="p">,</span> <span class="n">level</span><span class="o">++</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span> <span class="n">blk</span><span class="o">++</span><span class="p">,</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Release the old block.</span>
<span class="cm">		 * (if it&#39;s dirty, trans won&#39;t actually let go)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">release</span><span class="p">)</span>
			<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Read the next child block.</span>
<span class="cm">		 */</span>
		<span class="n">blk</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">)</span> <span class="o">||</span>
		       <span class="n">info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">)</span> <span class="o">||</span>
		       <span class="n">info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
		<span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DA_NODE_MAGIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">forward</span><span class="p">)</span>
				<span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">before</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">active</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">blk</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">switch</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span>:
				<span class="n">blk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_lasthash</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
								      <span class="nb">NULL</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span>:
				<span class="n">blk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">xfs_dir2_leafn_lasthash</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span>
								       <span class="nb">NULL</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span> <span class="o">||</span>
				       <span class="n">blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*========================================================================</span>
<span class="cm"> * Utility routines.</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Implement a simple hash on a character string.</span>
<span class="cm"> * Rotate the hash value by 7 bits, then XOR each character in.</span>
<span class="cm"> * This is implemented with some source-level loop unrolling.</span>
<span class="cm"> */</span>
<span class="n">xfs_dahash_t</span>
<span class="n">xfs_da_hashname</span><span class="p">(</span><span class="k">const</span> <span class="n">__uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_dahash_t</span> <span class="n">hash</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do four characters at a time as long as we can.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">namelen</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">namelen</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">name</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">^</span>
		       <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="n">rol32</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="mi">7</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now do the rest of the characters.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">namelen</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">^</span>
		       <span class="n">rol32</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="mi">7</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="n">rol32</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="mi">7</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="n">rol32</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="mi">7</span> <span class="o">*</span> <span class="mi">1</span><span class="p">);</span>
	<span class="nl">default:</span> <span class="cm">/* case 0: */</span>
		<span class="k">return</span> <span class="n">hash</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">xfs_dacmp</span>
<span class="n">xfs_da_compname</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_da_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">==</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
					<span class="n">XFS_CMP_EXACT</span> <span class="o">:</span> <span class="n">XFS_CMP_DIFFERENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">xfs_dahash_t</span>
<span class="n">xfs_default_hashname</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfs_da_hashname</span><span class="p">(</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">xfs_nameops</span> <span class="n">xfs_default_nameops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">hashname</span>	<span class="o">=</span> <span class="n">xfs_default_hashname</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compname</span>	<span class="o">=</span> <span class="n">xfs_da_compname</span>
<span class="p">};</span>

<span class="kt">int</span>
<span class="nf">xfs_da_grow_inode_int</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_da_args</span>	<span class="o">*</span><span class="n">args</span><span class="p">,</span>
	<span class="n">xfs_fileoff_t</span>		<span class="o">*</span><span class="n">bno</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">w</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span><span class="p">;</span>
	<span class="n">xfs_drfsbno_t</span>		<span class="n">nblks</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nblocks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_bmbt_irec</span>	<span class="n">map</span><span class="p">,</span> <span class="o">*</span><span class="n">mapp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nmap</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">got</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mapi</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find a spot in the file space to put the new block.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_first_unused</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try mapping it in one filesystem block.</span>
<span class="cm">	 */</span>
	<span class="n">nmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_write</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="o">*</span><span class="n">bno</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
			<span class="n">xfs_bmapi_aflag</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">|</span><span class="n">XFS_BMAPI_METADATA</span><span class="o">|</span><span class="n">XFS_BMAPI_CONTIG</span><span class="p">,</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">total</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmap</span><span class="p">,</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">nmap</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nmap</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mapp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">;</span>
		<span class="n">mapi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nmap</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_fileoff_t</span>		<span class="n">b</span><span class="p">;</span>
		<span class="kt">int</span>			<span class="n">c</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we didn&#39;t get it and the block might work if fragmented,</span>
<span class="cm">		 * try without the CONTIG flag.  Loop until we get it all.</span>
<span class="cm">		 */</span>
		<span class="n">mapp</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mapp</span><span class="p">)</span> <span class="o">*</span> <span class="n">count</span><span class="p">,</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="o">*</span><span class="n">bno</span><span class="p">,</span> <span class="n">mapi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">bno</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">nmap</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">XFS_BMAP_MAX_NMAP</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
			<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">bno</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_write</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span>
					<span class="n">xfs_bmapi_aflag</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">|</span><span class="n">XFS_BMAPI_METADATA</span><span class="p">,</span>
					<span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">total</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">mapp</span><span class="p">[</span><span class="n">mapi</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">nmap</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_free_map</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nmap</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">mapi</span> <span class="o">+=</span> <span class="n">nmap</span><span class="p">;</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">mapp</span><span class="p">[</span><span class="n">mapi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">br_startoff</span> <span class="o">+</span>
			    <span class="n">mapp</span><span class="p">[</span><span class="n">mapi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">br_blockcount</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mapi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mapp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Count the blocks we got, make sure it matches the total.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">got</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mapi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">got</span> <span class="o">+=</span> <span class="n">mapp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_blockcount</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">got</span> <span class="o">!=</span> <span class="n">count</span> <span class="o">||</span> <span class="n">mapp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">br_startoff</span> <span class="o">!=</span> <span class="o">*</span><span class="n">bno</span> <span class="o">||</span>
	    <span class="n">mapp</span><span class="p">[</span><span class="n">mapi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">br_startoff</span> <span class="o">+</span> <span class="n">mapp</span><span class="p">[</span><span class="n">mapi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">br_blockcount</span> <span class="o">!=</span>
	    <span class="o">*</span><span class="n">bno</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSPC</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_map</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* account for newly allocated blocks in reserved blocks total */</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">total</span> <span class="o">-=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nblocks</span> <span class="o">-</span> <span class="n">nblks</span><span class="p">;</span>

<span class="nl">out_free_map:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapp</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">)</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">mapp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a block to the btree ahead of the file.</span>
<span class="cm"> * Return the new block number to the caller.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_da_grow_inode</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_da_args</span>	<span class="o">*</span><span class="n">args</span><span class="p">,</span>
	<span class="n">xfs_dablk_t</span>		<span class="o">*</span><span class="n">new_blkno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">bno</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">trace_xfs_da_grow_inode</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span> <span class="o">==</span> <span class="n">XFS_DATA_FORK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bno</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="o">-&gt;</span><span class="n">m_dirleafblk</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="o">-&gt;</span><span class="n">m_dirblkfsbs</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_grow_inode_int</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bno</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="o">*</span><span class="n">new_blkno</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dablk_t</span><span class="p">)</span><span class="n">bno</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ick.  We need to always be able to remove a btree block, even</span>
<span class="cm"> * if there&#39;s no space reservation because the filesystem is full.</span>
<span class="cm"> * This is called if xfs_bunmapi on a btree block fails due to ENOSPC.</span>
<span class="cm"> * It swaps the target block with the last block in the file.  The</span>
<span class="cm"> * last block in the file can always be removed since it can&#39;t cause</span>
<span class="cm"> * a bmap btree split to do that.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_da_swap_lastblock</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">xfs_dablk_t</span> <span class="o">*</span><span class="n">dead_blknop</span><span class="p">,</span>
		      <span class="n">xfs_dabuf_t</span> <span class="o">**</span><span class="n">dead_bufp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_dablk_t</span> <span class="n">dead_blkno</span><span class="p">,</span> <span class="n">last_blkno</span><span class="p">,</span> <span class="n">sib_blkno</span><span class="p">,</span> <span class="n">par_blkno</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">dead_buf</span><span class="p">,</span> <span class="o">*</span><span class="n">last_buf</span><span class="p">,</span> <span class="o">*</span><span class="n">sib_buf</span><span class="p">,</span> <span class="o">*</span><span class="n">par_buf</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span> <span class="n">lastoff</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">entno</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">dead_level</span><span class="p">;</span>
	<span class="n">xfs_da_blkinfo_t</span> <span class="o">*</span><span class="n">dead_info</span><span class="p">,</span> <span class="o">*</span><span class="n">sib_info</span><span class="p">;</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">par_node</span><span class="p">,</span> <span class="o">*</span><span class="n">dead_node</span><span class="p">;</span>
	<span class="n">xfs_dir2_leaf_t</span> <span class="o">*</span><span class="n">dead_leaf2</span><span class="p">;</span>
	<span class="n">xfs_dahash_t</span> <span class="n">dead_hash</span><span class="p">;</span>

	<span class="n">trace_xfs_da_swap_lastblock</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">dead_buf</span> <span class="o">=</span> <span class="o">*</span><span class="n">dead_bufp</span><span class="p">;</span>
	<span class="n">dead_blkno</span> <span class="o">=</span> <span class="o">*</span><span class="n">dead_blknop</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">ip</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">w</span> <span class="o">==</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">lastoff</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirfreeblk</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_last_before</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lastoff</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">lastoff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_da_swap_lastblock(1)&quot;</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
				 <span class="n">mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read the last block in the btree space.</span>
<span class="cm">	 */</span>
	<span class="n">last_blkno</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dablk_t</span><span class="p">)</span><span class="n">lastoff</span> <span class="o">-</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblkfsbs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">last_blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_buf</span><span class="p">,</span> <span class="n">w</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy the last block into the dead buffer and log it.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dead_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">last_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblksize</span><span class="p">);</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dead_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">dead_info</span> <span class="o">=</span> <span class="n">dead_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get values from the moved block.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dead_info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dead_leaf2</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dir2_leaf_t</span> <span class="o">*</span><span class="p">)</span><span class="n">dead_info</span><span class="p">;</span>
		<span class="n">dead_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dead_hash</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">dead_leaf2</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dead_leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">dead_info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
		<span class="n">dead_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">dead_info</span><span class="p">;</span>
		<span class="n">dead_level</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dead_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">level</span><span class="p">);</span>
		<span class="n">dead_hash</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">dead_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dead_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">sib_buf</span> <span class="o">=</span> <span class="n">par_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the moved block has a left sibling, fix up the pointers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sib_blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">dead_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">sib_blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sib_buf</span><span class="p">,</span> <span class="n">w</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="n">sib_info</span> <span class="o">=</span> <span class="n">sib_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span>
		    <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sib_info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">)</span> <span class="o">!=</span> <span class="n">last_blkno</span> <span class="o">||</span>
		    <span class="n">sib_info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">dead_info</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_da_swap_lastblock(2)&quot;</span><span class="p">,</span>
					 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sib_info</span><span class="o">-&gt;</span><span class="n">forw</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">dead_blkno</span><span class="p">);</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">sib_buf</span><span class="p">,</span>
			<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">sib_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sib_info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">sib_info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">)));</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">sib_buf</span><span class="p">);</span>
		<span class="n">sib_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the moved block has a right sibling, fix up the pointers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sib_blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">dead_info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">sib_blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sib_buf</span><span class="p">,</span> <span class="n">w</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="n">sib_info</span> <span class="o">=</span> <span class="n">sib_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span>
		       <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sib_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">)</span> <span class="o">!=</span> <span class="n">last_blkno</span> <span class="o">||</span>
		       <span class="n">sib_info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">dead_info</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_da_swap_lastblock(3)&quot;</span><span class="p">,</span>
					 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sib_info</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">dead_blkno</span><span class="p">);</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">sib_buf</span><span class="p">,</span>
			<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">sib_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sib_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">sib_info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">)));</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">sib_buf</span><span class="p">);</span>
		<span class="n">sib_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">par_blkno</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirleafblk</span><span class="p">;</span>
	<span class="n">level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Walk down the tree looking for the parent of the moved block.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">par_blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">par_buf</span><span class="p">,</span> <span class="n">w</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="n">par_node</span> <span class="o">=</span> <span class="n">par_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">par_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">!=</span>
		    <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">level</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">level</span> <span class="o">!=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">par_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">level</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_da_swap_lastblock(4)&quot;</span><span class="p">,</span>
					 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">par_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">level</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">entno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">entno</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">par_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">par_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">entno</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dead_hash</span><span class="p">;</span>
		     <span class="n">entno</span><span class="o">++</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">entno</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">par_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_da_swap_lastblock(5)&quot;</span><span class="p">,</span>
					 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">par_blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">par_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">entno</span><span class="p">].</span><span class="n">before</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">dead_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">par_buf</span><span class="p">);</span>
		<span class="n">par_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re in the right parent block.</span>
<span class="cm">	 * Look for the right entry.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(;</span>
		     <span class="n">entno</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">par_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">par_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">entno</span><span class="p">].</span><span class="n">before</span><span class="p">)</span> <span class="o">!=</span> <span class="n">last_blkno</span><span class="p">;</span>
		     <span class="n">entno</span><span class="o">++</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entno</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">par_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">par_blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">par_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">forw</span><span class="p">);</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">par_buf</span><span class="p">);</span>
		<span class="n">par_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">par_blkno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_da_swap_lastblock(6)&quot;</span><span class="p">,</span>
					 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">par_blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">par_buf</span><span class="p">,</span> <span class="n">w</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="n">par_node</span> <span class="o">=</span> <span class="n">par_buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span>
		    <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">par_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">level</span><span class="p">)</span> <span class="o">!=</span> <span class="n">level</span> <span class="o">||</span>
		    <span class="n">par_node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_da_swap_lastblock(7)&quot;</span><span class="p">,</span>
					 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">entno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Update the parent entry pointing to the moved block.</span>
<span class="cm">	 */</span>
	<span class="n">par_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">entno</span><span class="p">].</span><span class="n">before</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">dead_blkno</span><span class="p">);</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">par_buf</span><span class="p">,</span>
		<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">par_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">par_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">entno</span><span class="p">].</span><span class="n">before</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">par_node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">entno</span><span class="p">].</span><span class="n">before</span><span class="p">)));</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">par_buf</span><span class="p">);</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">dead_buf</span><span class="p">);</span>
	<span class="o">*</span><span class="n">dead_blknop</span> <span class="o">=</span> <span class="n">last_blkno</span><span class="p">;</span>
	<span class="o">*</span><span class="n">dead_bufp</span> <span class="o">=</span> <span class="n">last_buf</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">par_buf</span><span class="p">)</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">par_buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sib_buf</span><span class="p">)</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">sib_buf</span><span class="p">);</span>
	<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">last_buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a btree block from a directory or attribute.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_da_shrink_inode</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">xfs_dablk_t</span> <span class="n">dead_blkno</span><span class="p">,</span>
		    <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">dead_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>

	<span class="n">trace_xfs_da_shrink_inode</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">w</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">whichfork</span><span class="p">;</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">==</span> <span class="n">XFS_DATA_FORK</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblkfsbs</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Remove extents.  If we get ENOSPC for a dir we have to move</span>
<span class="cm">		 * the last block to the place we want to kill.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bunmapi</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">dead_blkno</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
				<span class="n">xfs_bmapi_aflag</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">|</span><span class="n">XFS_BMAPI_METADATA</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">done</span><span class="p">))</span> <span class="o">==</span> <span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">!=</span> <span class="n">XFS_DATA_FORK</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_swap_lastblock</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dead_blkno</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">dead_buf</span><span class="p">)))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">xfs_da_binval</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dead_buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * See if the mapping(s) for this btree block are valid, i.e.</span>
<span class="cm"> * don&#39;t contain holes, are logically contiguous, and cover the whole range.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_da_map_covers_blocks</span><span class="p">(</span>
	<span class="kt">int</span>		<span class="n">nmap</span><span class="p">,</span>
	<span class="n">xfs_bmbt_irec_t</span>	<span class="o">*</span><span class="n">mapp</span><span class="p">,</span>
	<span class="n">xfs_dablk_t</span>	<span class="n">bno</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>	<span class="n">off</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">off</span> <span class="o">=</span> <span class="n">bno</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nmap</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mapp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_startblock</span> <span class="o">==</span> <span class="n">HOLESTARTBLOCK</span> <span class="o">||</span>
		    <span class="n">mapp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_startblock</span> <span class="o">==</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">!=</span> <span class="n">mapp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_startoff</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">off</span> <span class="o">+=</span> <span class="n">mapp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_blockcount</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">off</span> <span class="o">==</span> <span class="n">bno</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Make a dabuf.</span>
<span class="cm"> * Used for get_buf, read_buf, read_bufr, and reada_buf.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_da_do_buf</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">trans</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">dp</span><span class="p">,</span>
	<span class="n">xfs_dablk_t</span>	<span class="n">bno</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>	<span class="o">*</span><span class="n">mappedbnop</span><span class="p">,</span>
	<span class="n">xfs_dabuf_t</span>	<span class="o">**</span><span class="n">bpp</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">whichfork</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">bplist</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_bmbt_irec_t</span>	<span class="n">map</span><span class="p">;</span>
	<span class="n">xfs_bmbt_irec_t</span>	<span class="o">*</span><span class="n">mapp</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">mappedbno</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">nbplist</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">nfsb</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">nmap</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span>	<span class="o">*</span><span class="n">rbp</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">nfsb</span> <span class="o">=</span> <span class="p">(</span><span class="n">whichfork</span> <span class="o">==</span> <span class="n">XFS_DATA_FORK</span><span class="p">)</span> <span class="o">?</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dirblkfsbs</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mappedbno</span> <span class="o">=</span> <span class="o">*</span><span class="n">mappedbnop</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Caller doesn&#39;t have a mapping.  -2 means don&#39;t complain</span>
<span class="cm">	 * if we land in a hole.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mappedbno</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">mappedbno</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Optimize the one-block case.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfsb</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">mapp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mapp</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mapp</span><span class="p">)</span> <span class="o">*</span> <span class="n">nfsb</span><span class="p">,</span> <span class="n">KM_SLEEP</span><span class="p">);</span>

		<span class="n">nmap</span> <span class="o">=</span> <span class="n">nfsb</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_fileoff_t</span><span class="p">)</span><span class="n">bno</span><span class="p">,</span> <span class="n">nfsb</span><span class="p">,</span> <span class="n">mapp</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">nmap</span><span class="p">,</span> <span class="n">xfs_bmapi_aflag</span><span class="p">(</span><span class="n">whichfork</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">=</span> <span class="n">XFS_DADDR_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mappedbno</span><span class="p">);</span>
		<span class="n">map</span><span class="p">.</span><span class="n">br_startoff</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_fileoff_t</span><span class="p">)</span><span class="n">bno</span><span class="p">;</span>
		<span class="n">map</span><span class="p">.</span><span class="n">br_blockcount</span> <span class="o">=</span> <span class="n">nfsb</span><span class="p">;</span>
		<span class="n">mapp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">;</span>
		<span class="n">nmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_da_map_covers_blocks</span><span class="p">(</span><span class="n">nmap</span><span class="p">,</span> <span class="n">mapp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="n">nfsb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">mappedbno</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">EFSCORRUPTED</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xfs_error_level</span> <span class="o">&gt;=</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: bno %lld dir: inode %lld&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bno</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nmap</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
<span class="s">&quot;[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d&quot;</span><span class="p">,</span>
						<span class="n">i</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">mapp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_startoff</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">mapp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_startblock</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">mapp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_blockcount</span><span class="p">,</span>
						<span class="n">mapp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_state</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_da_do_buf(1)&quot;</span><span class="p">,</span>
					 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">exit0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">caller</span> <span class="o">!=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">nmap</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bplist</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bplist</span><span class="p">)</span> <span class="o">*</span> <span class="n">nmap</span><span class="p">,</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
		<span class="n">nbplist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">bplist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Turn the mapping(s) into buffer(s).</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nmap</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">nmapped</span><span class="p">;</span>

		<span class="n">mappedbno</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mapp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_startblock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">*</span><span class="n">mappedbnop</span> <span class="o">=</span> <span class="n">mappedbno</span><span class="p">;</span>
		<span class="n">nmapped</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mapp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">br_blockcount</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">caller</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_trans_get_buf</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span>
				<span class="n">mappedbno</span><span class="p">,</span> <span class="n">nmapped</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">bp</span> <span class="o">?</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_error</span> <span class="o">:</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_read_buf</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span>
				<span class="n">mappedbno</span><span class="p">,</span> <span class="n">nmapped</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="n">xfs_buf_readahead</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span> <span class="n">mappedbno</span><span class="p">,</span> <span class="n">nmapped</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="p">)</span>
				<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">caller</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">whichfork</span> <span class="o">==</span> <span class="n">XFS_ATTR_FORK</span><span class="p">)</span>
				<span class="n">xfs_buf_set_ref</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_ATTR_BTREE_REF</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">xfs_buf_set_ref</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_DIR_BTREE_REF</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bplist</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bplist</span><span class="p">[</span><span class="n">nbplist</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Build a dabuf structure.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bplist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rbp</span> <span class="o">=</span> <span class="n">xfs_da_buf_make</span><span class="p">(</span><span class="n">nbplist</span><span class="p">,</span> <span class="n">bplist</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="p">)</span>
		<span class="n">rbp</span> <span class="o">=</span> <span class="n">xfs_da_buf_make</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * For read_buf, check the magic number.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">caller</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_dir2_data_hdr_t</span>	<span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">rbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">xfs_dir2_free_t</span>		<span class="o">*</span><span class="n">free</span> <span class="o">=</span> <span class="n">rbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">xfs_da_blkinfo_t</span>	<span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">rbp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">uint</span>			<span class="n">magic</span><span class="p">,</span> <span class="n">magic1</span><span class="p">;</span>

		<span class="n">magic</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
		<span class="n">magic1</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span>
		    <span class="n">XFS_TEST_ERROR</span><span class="p">((</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">XFS_DA_NODE_MAGIC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				   <span class="p">(</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				   <span class="p">(</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">XFS_DIR2_LEAF1_MAGIC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				   <span class="p">(</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">XFS_DIR2_LEAFN_MAGIC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				   <span class="p">(</span><span class="n">magic1</span> <span class="o">!=</span> <span class="n">XFS_DIR2_BLOCK_MAGIC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				   <span class="p">(</span><span class="n">magic1</span> <span class="o">!=</span> <span class="n">XFS_DIR2_DATA_MAGIC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				   <span class="p">(</span><span class="n">free</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">XFS_DIR2_FREE_MAGIC</span><span class="p">)),</span>
				<span class="n">mp</span><span class="p">,</span> <span class="n">XFS_ERRTAG_DA_READ_BUF</span><span class="p">,</span>
				<span class="n">XFS_RANDOM_DA_READ_BUF</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">trace_xfs_da_btree_corrupt</span><span class="p">(</span><span class="n">rbp</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_RET_IP_</span><span class="p">);</span>
			<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_da_do_buf(2)&quot;</span><span class="p">,</span>
					     <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
			<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">rbp</span><span class="p">);</span>
			<span class="n">nbplist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bplist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">bplist</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapp</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">mapp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bpp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">rbp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">exit1:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bplist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbplist</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">bplist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">bplist</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">exit0:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapp</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">)</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">mapp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bpp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get a buffer for the dir/attr block.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_da_get_buf</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">trans</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">dp</span><span class="p">,</span>
	<span class="n">xfs_dablk_t</span>	<span class="n">bno</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">mappedbno</span><span class="p">,</span>
	<span class="n">xfs_dabuf_t</span>	<span class="o">**</span><span class="n">bpp</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">whichfork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfs_da_do_buf</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mappedbno</span><span class="p">,</span> <span class="n">bpp</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get a buffer for the dir/attr block, fill in the contents.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_da_read_buf</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">trans</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">dp</span><span class="p">,</span>
	<span class="n">xfs_dablk_t</span>	<span class="n">bno</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">mappedbno</span><span class="p">,</span>
	<span class="n">xfs_dabuf_t</span>	<span class="o">**</span><span class="n">bpp</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">whichfork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfs_da_do_buf</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mappedbno</span><span class="p">,</span> <span class="n">bpp</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Readahead the dir/attr block.</span>
<span class="cm"> */</span>
<span class="n">xfs_daddr_t</span>
<span class="nf">xfs_da_reada_buf</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">trans</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">dp</span><span class="p">,</span>
	<span class="n">xfs_dablk_t</span>	<span class="n">bno</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">whichfork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">rval</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_da_do_buf</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">kmem_zone_t</span> <span class="o">*</span><span class="n">xfs_da_state_zone</span><span class="p">;</span>	<span class="cm">/* anchor for state struct zone */</span>
<span class="n">kmem_zone_t</span> <span class="o">*</span><span class="n">xfs_dabuf_zone</span><span class="p">;</span>		<span class="cm">/* dabuf zone */</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a dir-state structure.</span>
<span class="cm"> * We don&#39;t put them on the stack since they&#39;re large.</span>
<span class="cm"> */</span>
<span class="n">xfs_da_state_t</span> <span class="o">*</span>
<span class="nf">xfs_da_state_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmem_zone_zalloc</span><span class="p">(</span><span class="n">xfs_da_state_zone</span><span class="p">,</span> <span class="n">KM_NOFS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Kill the altpath contents of a da-state structure.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_da_state_kill_altpath</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">.</span><span class="n">active</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bp</span> <span class="o">!=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bp</span><span class="p">)</span>
				<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">.</span><span class="n">active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free a da-state structure.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_da_state_free</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="n">xfs_da_state_kill_altpath</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bp</span><span class="p">)</span>
			<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extravalid</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span><span class="p">)</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extrablk</span><span class="p">.</span><span class="n">bp</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">));</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>
	<span class="n">kmem_zone_free</span><span class="p">(</span><span class="n">xfs_da_state_zone</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create a dabuf.</span>
<span class="cm"> */</span>
<span class="cm">/* ARGSUSED */</span>
<span class="n">STATIC</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span>
<span class="nf">xfs_da_buf_make</span><span class="p">(</span><span class="kt">int</span> <span class="n">nbuf</span><span class="p">,</span> <span class="n">xfs_buf_t</span> <span class="o">**</span><span class="n">bps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span>	<span class="o">*</span><span class="n">dabuf</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">off</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nbuf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">dabuf</span> <span class="o">=</span> <span class="n">kmem_zone_alloc</span><span class="p">(</span><span class="n">xfs_dabuf_zone</span><span class="p">,</span> <span class="n">KM_NOFS</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dabuf</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">XFS_DA_BUF_SIZE</span><span class="p">(</span><span class="n">nbuf</span><span class="p">),</span> <span class="n">KM_NOFS</span><span class="p">);</span>
	<span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbuf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">nbuf</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bbcount</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">;</span>
		<span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">;</span>
		<span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">nbuf</span> <span class="o">=</span> <span class="n">nbuf</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bbcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbuf</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bp</span> <span class="o">=</span> <span class="n">bps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bbcount</span> <span class="o">+=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">BBTOB</span><span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bbcount</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbuf</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">off</span> <span class="o">+=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bp</span> <span class="o">=</span> <span class="n">bps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">,</span>
				<span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dabuf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Un-dirty a dabuf.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_da_buf_clean</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">dabuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">off</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">nbuf</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">nbuf</span><span class="p">;</span>
				<span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">off</span> <span class="o">+=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bp</span> <span class="o">=</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">,</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span>
						<span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release a dabuf.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_da_buf_done</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">dabuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dabuf</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">nbuf</span> <span class="o">&amp;&amp;</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&amp;&amp;</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bbcount</span> <span class="o">&amp;&amp;</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span>
		<span class="n">xfs_da_buf_clean</span><span class="p">(</span><span class="n">dabuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">nbuf</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">dabuf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kmem_zone_free</span><span class="p">(</span><span class="n">xfs_dabuf_zone</span><span class="p">,</span> <span class="n">dabuf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Log transaction from a dabuf.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_da_log_buf</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">dabuf</span><span class="p">,</span> <span class="n">uint</span> <span class="n">first</span><span class="p">,</span> <span class="n">uint</span> <span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">f</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">l</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">off</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">nbuf</span> <span class="o">&amp;&amp;</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&amp;&amp;</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bbcount</span> <span class="o">&amp;&amp;</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">nbuf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">);</span>
		<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">first</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">nbuf</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">off</span> <span class="o">+=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">f</span> <span class="o">=</span> <span class="n">off</span><span class="p">;</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">f</span> <span class="o">+</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="n">first</span><span class="p">)</span>
			<span class="n">f</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">last</span><span class="p">)</span>
			<span class="n">l</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">)</span>
			<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">f</span> <span class="o">-</span> <span class="n">off</span><span class="p">,</span> <span class="n">l</span> <span class="o">-</span> <span class="n">off</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * B_DONE is set by xfs_trans_log buf.</span>
<span class="cm">		 * If we don&#39;t set it on a new buffer (get not read)</span>
<span class="cm">		 * then if we don&#39;t put anything in the buffer it won&#39;t</span>
<span class="cm">		 * be set, and at commit it it released into the cache,</span>
<span class="cm">		 * and then a read will fail.</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">XFS_BUF_ISDONE</span><span class="p">(</span><span class="n">bp</span><span class="p">)))</span>
		  <span class="n">XFS_BUF_DONE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">last</span> <span class="o">&lt;</span> <span class="n">off</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release dabuf from a transaction.</span>
<span class="cm"> * Have to free up the dabuf before the buffers are released,</span>
<span class="cm"> * since the synchronization on the dabuf is really the lock on the buffer.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_da_brelse</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">dabuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">bplist</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">nbuf</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">nbuf</span> <span class="o">&amp;&amp;</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&amp;&amp;</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bbcount</span> <span class="o">&amp;&amp;</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">nbuf</span> <span class="o">=</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">nbuf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bplist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">;</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bplist</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">nbuf</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bplist</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">bplist</span><span class="p">,</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">,</span> <span class="n">nbuf</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bplist</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">dabuf</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbuf</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bplist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bplist</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">)</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">bplist</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Invalidate dabuf from a transaction.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_da_binval</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">dabuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">bplist</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">nbuf</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">nbuf</span> <span class="o">&amp;&amp;</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&amp;&amp;</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bbcount</span> <span class="o">&amp;&amp;</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">nbuf</span> <span class="o">=</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">nbuf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bplist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">;</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bplist</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">nbuf</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bplist</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">bplist</span><span class="p">,</span> <span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">,</span> <span class="n">nbuf</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bplist</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">dabuf</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbuf</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">xfs_trans_binval</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bplist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bplist</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">)</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">bplist</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the first daddr from a dabuf.</span>
<span class="cm"> */</span>
<span class="n">xfs_daddr_t</span>
<span class="nf">xfs_da_blkno</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">dabuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">nbuf</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">XFS_BUF_ADDR</span><span class="p">(</span><span class="n">dabuf</span><span class="o">-&gt;</span><span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
