<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_buf.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_buf.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2006 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/migrate.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>

<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>

<span class="k">static</span> <span class="n">kmem_zone_t</span> <span class="o">*</span><span class="n">xfs_buf_zone</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">xfslogd_workqueue</span><span class="p">;</span>

<span class="cp">#ifdef XFS_BUF_LOCK_TRACKING</span>
<span class="cp"># define XB_SET_OWNER(bp)	((bp)-&gt;b_last_holder = current-&gt;pid)</span>
<span class="cp"># define XB_CLEAR_OWNER(bp)	((bp)-&gt;b_last_holder = -1)</span>
<span class="cp"># define XB_GET_OWNER(bp)	((bp)-&gt;b_last_holder)</span>
<span class="cp">#else</span>
<span class="cp"># define XB_SET_OWNER(bp)	do { } while (0)</span>
<span class="cp"># define XB_CLEAR_OWNER(bp)	do { } while (0)</span>
<span class="cp"># define XB_GET_OWNER(bp)	do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#define xb_to_gfp(flags) \</span>
<span class="cp">	((((flags) &amp; XBF_READ_AHEAD) ? __GFP_NORETRY : GFP_NOFS) | __GFP_NOWARN)</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xfs_buf_is_vmapped</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Return true if the buffer is vmapped.</span>
<span class="cm">	 *</span>
<span class="cm">	 * b_addr is null if the buffer is not mapped, but the code is clever</span>
<span class="cm">	 * enough to know it doesn&#39;t have to map a single page, so the check has</span>
<span class="cm">	 * to be both for b_addr and bp-&gt;b_page_count &gt; 1.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">&amp;&amp;</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xfs_buf_vmap_len</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_count</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">-</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_buf_lru_add - add a buffer to the LRU.</span>
<span class="cm"> *</span>
<span class="cm"> * The LRU takes a new reference to the buffer so that it will only be freed</span>
<span class="cm"> * once the shrinker takes the buffer off the LRU.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_buf_lru_add</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_buftarg</span> <span class="o">*</span><span class="n">btp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_target</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_hold</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru</span><span class="p">);</span>
		<span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_nr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_buf_lru_del - remove a buffer from the LRU</span>
<span class="cm"> *</span>
<span class="cm"> * The unlocked check is safe here because it only occurs when there are not</span>
<span class="cm"> * b_lru_ref counts left on the inode under the pag-&gt;pag_buf_lock. it is there</span>
<span class="cm"> * to optimise the shrinker removing the buffer from the LRU and calling</span>
<span class="cm"> * xfs_buf_free(). i.e. it removes an unnecessary round trip on the</span>
<span class="cm"> * bt_lru_lock.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_buf_lru_del</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_buftarg</span> <span class="o">*</span><span class="n">btp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_target</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru</span><span class="p">);</span>
		<span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_nr</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When we mark a buffer stale, we remove the buffer from the LRU and clear the</span>
<span class="cm"> * b_lru_ref count so that the buffer is freed immediately when the buffer</span>
<span class="cm"> * reference count falls to zero. If the buffer is already on the LRU, we need</span>
<span class="cm"> * to remove the reference that LRU holds on the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This prevents build-up of stale buffers on the LRU.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_buf_stale</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_buf_islocked</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">XBF_STALE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the delwri status so that a delwri queue walker will not</span>
<span class="cm">	 * flush this buffer to disk now that it is stale. The delwri queue has</span>
<span class="cm">	 * a reference to the buffer, so this is safe to do.</span>
<span class="cm">	 */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_XBF_DELWRI_Q</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_lru_ref</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xfs_buftarg</span> <span class="o">*</span><span class="n">btp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_target</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru</span><span class="p">);</span>
			<span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_nr</span><span class="o">--</span><span class="p">;</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_hold</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_hold</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">xfs_buf</span> <span class="o">*</span>
<span class="nf">xfs_buf_alloc</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buftarg</span>	<span class="o">*</span><span class="n">target</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">blkno</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">numblks</span><span class="p">,</span>
	<span class="n">xfs_buf_flags_t</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">kmem_zone_zalloc</span><span class="p">(</span><span class="n">xfs_buf_zone</span><span class="p">,</span> <span class="n">KM_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want certain flags to appear in b_flags unless they are</span>
<span class="cm">	 * specifically set by later operations on the buffer.</span>
<span class="cm">	 */</span>
	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">XBF_UNMAPPED</span> <span class="o">|</span> <span class="n">XBF_TRYLOCK</span> <span class="o">|</span> <span class="n">XBF_ASYNC</span> <span class="o">|</span> <span class="n">XBF_READ_AHEAD</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_hold</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru_ref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iowait</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_list</span><span class="p">);</span>
	<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_rbnode</span><span class="p">);</span>
	<span class="n">sema_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_sema</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* held, no waiters */</span>
	<span class="n">XB_SET_OWNER</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_target</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set length and io_length to the same value initially.</span>
<span class="cm">	 * I/O routines should use io_length, which will be the same in</span>
<span class="cm">	 * most cases but may be reset (e.g. XFS recovery).</span>
<span class="cm">	 */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span> <span class="o">=</span> <span class="n">numblks</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_length</span> <span class="o">=</span> <span class="n">numblks</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_bn</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pin_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_waiters</span><span class="p">);</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xb_create</span><span class="p">);</span>
	<span class="n">trace_xfs_buf_init</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Allocate a page array capable of holding a specified number</span>
<span class="cm"> *	of pages, and point the page buf at it.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">_xfs_buf_get_pages</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">page_count</span><span class="p">,</span>
	<span class="n">xfs_buf_flags_t</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Make sure that we have a page list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_count</span> <span class="o">=</span> <span class="n">page_count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span> <span class="o">&lt;=</span> <span class="n">XB_PAGES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_array</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span>
						 <span class="n">page_count</span><span class="p">,</span> <span class="n">KM_NOFS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">page_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Frees b_pages if it was allocated.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">_xfs_buf_free_pages</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span> <span class="o">!=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_array</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">);</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Releases the specified buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * 	The modification state of any associated pages is left unchanged.</span>
<span class="cm"> * 	The buffer most not be on any hash - use xfs_buf_rele instead for</span>
<span class="cm"> * 	hashed and refcounted buffers</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_buf_free</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xfs_buf_free</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">_XBF_PAGES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uint</span>		<span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">xfs_buf_is_vmapped</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
			<span class="n">vm_unmap_ram</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">-</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_offset</span><span class="p">,</span>
					<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_count</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span>	<span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">_XBF_KMEM</span><span class="p">)</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">);</span>
	<span class="n">_xfs_buf_free_pages</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">kmem_zone_free</span><span class="p">(</span><span class="n">xfs_buf_zone</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocates all the pages for buffer in question and builds it&#39;s page list.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_buf_allocate_memory</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="n">uint</span>			<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span>			<span class="n">size</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">nbytes</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">gfp_t</span>			<span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">xb_to_gfp</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">page_count</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_off_t</span>		<span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * for buffers that are contained within a single page, just allocate</span>
<span class="cm">	 * the memory from the heap - there&#39;s no need for the complexity of</span>
<span class="cm">	 * page arrays to keep allocation down to order 0.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">KM_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* low memory - use alloc_page loop instead */</span>
			<span class="k">goto</span> <span class="n">use_alloc_page</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* b_addr spans two pages - use alloc_page instead */</span>
			<span class="n">kmem_free</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">);</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">use_alloc_page</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_offset</span> <span class="o">=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">);</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_array</span><span class="p">;</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">);</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">_XBF_KMEM</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">use_alloc_page:</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_bn</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_bn</span> <span class="o">+</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">page_count</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">_xfs_buf_get_pages</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">page_count</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_offset</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">_XBF_PAGES</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span>	<span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="n">uint</span>		<span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">retry:</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XBF_READ_AHEAD</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_count</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_free_pages</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * This could deadlock.</span>
<span class="cm">			 *</span>
<span class="cm">			 * But until all the XFS lowlevel code is revamped to</span>
<span class="cm">			 * handle buffer allocation failures we can&#39;t do much.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">++</span><span class="n">retries</span> <span class="o">%</span> <span class="mi">100</span><span class="p">))</span>
				<span class="n">xfs_err</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
		<span class="s">&quot;possible memory allocation deadlock in %s (mode:0x%x)&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>

			<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xb_page_retries</span><span class="p">);</span>
			<span class="n">congestion_wait</span><span class="p">(</span><span class="n">BLK_RW_ASYNC</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">50</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xb_page_found</span><span class="p">);</span>

		<span class="n">nbytes</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">nbytes</span><span class="p">;</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_pages:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Map buffer into kernel address-space if necessary.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">_xfs_buf_map_pages</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="n">uint</span>			<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">_XBF_PAGES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* A single page buffer is always mappable */</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_offset</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XBF_UNMAPPED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">retried</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">=</span> <span class="n">vm_map_ram</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_count</span><span class="p">,</span>
						<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">vm_unmap_aliases</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">retried</span><span class="o">++</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">+=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_offset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Finding and Reading Buffers</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	Look up, and creates if absent, a lockable buffer for</span>
<span class="cm"> *	a given range of an inode.  The buffer is returned</span>
<span class="cm"> *	locked.	No I/O is implied by this call.</span>
<span class="cm"> */</span>
<span class="n">xfs_buf_t</span> <span class="o">*</span>
<span class="nf">_xfs_buf_find</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buftarg</span>	<span class="o">*</span><span class="n">btp</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">blkno</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">numblks</span><span class="p">,</span>
	<span class="n">xfs_buf_flags_t</span>		<span class="n">flags</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">new_bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span>			<span class="n">numbytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span>	<span class="o">*</span><span class="n">pag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="o">**</span><span class="n">rbp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="n">numbytes</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">numblks</span><span class="p">);</span>

	<span class="cm">/* Check for IOs smaller than the sector size / not sector aligned */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">numbytes</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_sshift</span><span class="p">)));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">BBTOB</span><span class="p">(</span><span class="n">blkno</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xfs_off_t</span><span class="p">)</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_smask</span><span class="p">));</span>

	<span class="cm">/* get tree root */</span>
	<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_mount</span><span class="p">,</span>
				<span class="n">xfs_daddr_to_agno</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_mount</span><span class="p">,</span> <span class="n">blkno</span><span class="p">));</span>

	<span class="cm">/* walk tree */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_buf_lock</span><span class="p">);</span>
	<span class="n">rbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_buf_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">rbp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">rbp</span><span class="p">;</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_buf</span><span class="p">,</span> <span class="n">b_rbnode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">&lt;</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_bn</span><span class="p">)</span>
			<span class="n">rbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rbp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">&gt;</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_bn</span><span class="p">)</span>
			<span class="n">rbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rbp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * found a block number match. If the range doesn&#39;t</span>
<span class="cm">			 * match, the only way this is allowed is if the buffer</span>
<span class="cm">			 * in the cache is stale and the transaction that made</span>
<span class="cm">			 * it stale has not yet committed. i.e. we are</span>
<span class="cm">			 * reallocating a busy extent. Skip this buffer and</span>
<span class="cm">			 * continue searching to the right for an exact match.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span> <span class="o">!=</span> <span class="n">numblks</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_STALE</span><span class="p">);</span>
				<span class="n">rbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rbp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_hold</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* No match found */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_bp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_bp</span><span class="o">-&gt;</span><span class="n">b_rbnode</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">rbp</span><span class="p">);</span>
		<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_bp</span><span class="o">-&gt;</span><span class="n">b_rbnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_buf_tree</span><span class="p">);</span>
		<span class="cm">/* the buffer keeps the perag reference until it is freed */</span>
		<span class="n">new_bp</span><span class="o">-&gt;</span><span class="n">b_pag</span> <span class="o">=</span> <span class="n">pag</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_buf_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xb_miss_locked</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_buf_lock</span><span class="p">);</span>
		<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">new_bp</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_buf_lock</span><span class="p">);</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_buf_trylock</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XBF_TRYLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_buf_rele</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xb_busy_locked</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">xfs_buf_lock</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xb_get_locked_waited</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * if the buffer is stale, clear all the external state associated with</span>
<span class="cm">	 * it. We need to keep flags such as how we allocated the buffer memory</span>
<span class="cm">	 * intact here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_STALE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">((</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">_XBF_DELWRI_Q</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;=</span> <span class="n">_XBF_KMEM</span> <span class="o">|</span> <span class="n">_XBF_PAGES</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_xfs_buf_find</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xb_get_locked</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Assembles a buffer covering the specified range. The code is optimised for</span>
<span class="cm"> * cache hits, as metadata intensive workloads will see 3 orders of magnitude</span>
<span class="cm"> * more hits than misses.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfs_buf</span> <span class="o">*</span>
<span class="nf">xfs_buf_get</span><span class="p">(</span>
	<span class="n">xfs_buftarg_t</span>		<span class="o">*</span><span class="n">target</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">blkno</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">numblks</span><span class="p">,</span>
	<span class="n">xfs_buf_flags_t</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">new_bp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">_xfs_buf_find</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">numblks</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>

	<span class="n">new_bp</span> <span class="o">=</span> <span class="n">xfs_buf_alloc</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">numblks</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">new_bp</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_buf_allocate_memory</span><span class="p">(</span><span class="n">new_bp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_zone_free</span><span class="p">(</span><span class="n">xfs_buf_zone</span><span class="p">,</span> <span class="n">new_bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">_xfs_buf_find</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">numblks</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">new_bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_buf_free</span><span class="p">(</span><span class="n">new_bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="n">new_bp</span><span class="p">)</span>
		<span class="n">xfs_buf_free</span><span class="p">(</span><span class="n">new_bp</span><span class="p">);</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_length</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">_xfs_buf_map_pages</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">bt_mount</span><span class="p">,</span>
				<span class="s">&quot;%s: failed to map pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xb_get</span><span class="p">);</span>
	<span class="n">trace_xfs_buf_get</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">_xfs_buf_read</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="n">xfs_buf_flags_t</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XBF_WRITE</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_bn</span> <span class="o">!=</span> <span class="n">XFS_BUF_DADDR_NULL</span><span class="p">);</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">XBF_WRITE</span> <span class="o">|</span> <span class="n">XBF_ASYNC</span> <span class="o">|</span> <span class="n">XBF_READ_AHEAD</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XBF_READ</span> <span class="o">|</span> <span class="n">XBF_ASYNC</span> <span class="o">|</span> <span class="n">XBF_READ_AHEAD</span><span class="p">);</span>

	<span class="n">xfs_buf_iorequest</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XBF_ASYNC</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">xfs_buf_iowait</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">xfs_buf_t</span> <span class="o">*</span>
<span class="nf">xfs_buf_read</span><span class="p">(</span>
	<span class="n">xfs_buftarg_t</span>		<span class="o">*</span><span class="n">target</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">blkno</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">numblks</span><span class="p">,</span>
	<span class="n">xfs_buf_flags_t</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">|=</span> <span class="n">XBF_READ</span><span class="p">;</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_get</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">numblks</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_xfs_buf_read</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XFS_BUF_ISDONE</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xb_get_read</span><span class="p">);</span>
			<span class="n">_xfs_buf_read</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XBF_ASYNC</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Read ahead call which is already satisfied,</span>
<span class="cm">			 * drop the buffer</span>
<span class="cm">			 */</span>
			<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* We do not want read in the flags */</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XBF_READ</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	If we are not low on memory then do the readahead in a deadlock</span>
<span class="cm"> *	safe manner.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_buf_readahead</span><span class="p">(</span>
	<span class="n">xfs_buftarg_t</span>		<span class="o">*</span><span class="n">target</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">blkno</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">numblks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdi_read_congested</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">bt_bdi</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">xfs_buf_read</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">numblks</span><span class="p">,</span>
		     <span class="n">XBF_TRYLOCK</span><span class="o">|</span><span class="n">XBF_ASYNC</span><span class="o">|</span><span class="n">XBF_READ_AHEAD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read an uncached buffer from disk. Allocates and returns a locked</span>
<span class="cm"> * buffer containing the disk contents or nothing.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfs_buf</span> <span class="o">*</span>
<span class="nf">xfs_buf_read_uncached</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buftarg</span>	<span class="o">*</span><span class="n">target</span><span class="p">,</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">daddr</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">numblks</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_get_uncached</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">numblks</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* set up the buffer for a read IO */</span>
	<span class="n">XFS_BUF_SET_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">daddr</span><span class="p">);</span>
	<span class="n">XFS_BUF_READ</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="n">xfsbdstrat</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">bt_mount</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_buf_iowait</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a buffer allocated as an empty buffer and associated to external</span>
<span class="cm"> * memory via xfs_buf_associate_memory() back to it&#39;s empty state.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_buf_set_empty</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">numblks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">)</span>
		<span class="n">_xfs_buf_free_pages</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span> <span class="o">=</span> <span class="n">numblks</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_length</span> <span class="o">=</span> <span class="n">numblks</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_bn</span> <span class="o">=</span> <span class="n">XFS_BUF_DADDR_NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">mem_to_page</span><span class="p">(</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">is_vmalloc_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">vmalloc_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_buf_associate_memory</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">mem</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">rval</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">pageaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">offset</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">buflen</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">page_count</span><span class="p">;</span>

	<span class="n">pageaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mem</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mem</span> <span class="o">-</span> <span class="n">pageaddr</span><span class="p">;</span>
	<span class="n">buflen</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">page_count</span> <span class="o">=</span> <span class="n">buflen</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="cm">/* Free any previous set of page pointers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">)</span>
		<span class="n">_xfs_buf_free_pages</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">=</span> <span class="n">mem</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">_xfs_buf_get_pages</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">page_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem_to_page</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pageaddr</span><span class="p">);</span>
		<span class="n">pageaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_length</span> <span class="o">=</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span> <span class="o">=</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">buflen</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">xfs_buf_t</span> <span class="o">*</span>
<span class="nf">xfs_buf_get_uncached</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buftarg</span>	<span class="o">*</span><span class="n">target</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">numblks</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">page_count</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_alloc</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">XFS_BUF_DADDR_NULL</span><span class="p">,</span> <span class="n">numblks</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">page_count</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">numblks</span> <span class="o">&lt;&lt;</span> <span class="n">BBSHIFT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">_xfs_buf_get_pages</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">page_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_free_buf</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">page_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">xb_to_gfp</span><span class="p">(</span><span class="n">flags</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">fail_free_mem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">_XBF_PAGES</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">_xfs_buf_map_pages</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">bt_mount</span><span class="p">,</span>
			<span class="s">&quot;%s: failed to map pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_free_mem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_xfs_buf_get_uncached</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bp</span><span class="p">;</span>

 <span class="nl">fail_free_mem:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">_xfs_buf_free_pages</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
 <span class="nl">fail_free_buf:</span>
	<span class="n">kmem_zone_free</span><span class="p">(</span><span class="n">xfs_buf_zone</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
 <span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Increment reference count on buffer, to hold the buffer concurrently</span>
<span class="cm"> *	with another thread which may release (free) the buffer asynchronously.</span>
<span class="cm"> *	Must hold the buffer already to call this function.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_buf_hold</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xfs_buf_hold</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_hold</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Releases a hold on the specified buffer.  If the</span>
<span class="cm"> *	the hold count is 1, calls xfs_buf_free.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_buf_rele</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span>	<span class="o">*</span><span class="n">pag</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pag</span><span class="p">;</span>

	<span class="n">trace_xfs_buf_rele</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pag</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru</span><span class="p">));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">RB_EMPTY_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_rbnode</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_hold</span><span class="p">))</span>
			<span class="n">xfs_buf_free</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">RB_EMPTY_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_rbnode</span><span class="p">));</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_hold</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_hold</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_buf_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_STALE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru_ref</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_buf_lru_add</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_buf_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xfs_buf_lru_del</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">_XBF_DELWRI_Q</span><span class="p">));</span>
			<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_rbnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_buf_tree</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_buf_lock</span><span class="p">);</span>
			<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
			<span class="n">xfs_buf_free</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	Lock a buffer object, if it is not already locked.</span>
<span class="cm"> *</span>
<span class="cm"> *	If we come across a stale, pinned, locked buffer, we know that we are</span>
<span class="cm"> *	being asked to lock a buffer that has been reallocated. Because it is</span>
<span class="cm"> *	pinned, we know that the log has not been pushed to disk and hence it</span>
<span class="cm"> *	will still be locked.  Rather than continuing to have trylock attempts</span>
<span class="cm"> *	fail until someone else pushes the log, push it ourselves before</span>
<span class="cm"> *	returning.  This means that the xfsaild will not get stuck trying</span>
<span class="cm"> *	to push on stale inode buffers.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_buf_trylock</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">locked</span><span class="p">;</span>

	<span class="n">locked</span> <span class="o">=</span> <span class="n">down_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_sema</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">XB_SET_OWNER</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pin_count</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_STALE</span><span class="p">))</span>
		<span class="n">xfs_log_force</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_target</span><span class="o">-&gt;</span><span class="n">bt_mount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">trace_xfs_buf_trylock</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">locked</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Lock a buffer object.</span>
<span class="cm"> *</span>
<span class="cm"> *	If we come across a stale, pinned, locked buffer, we know that we</span>
<span class="cm"> *	are being asked to lock a buffer that has been reallocated. Because</span>
<span class="cm"> *	it is pinned, we know that the log has not been pushed to disk and</span>
<span class="cm"> *	hence it will still be locked. Rather than sleeping until someone</span>
<span class="cm"> *	else pushes the log, push it ourselves before trying to get the lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_buf_lock</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xfs_buf_lock</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pin_count</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_STALE</span><span class="p">))</span>
		<span class="n">xfs_log_force</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_target</span><span class="o">-&gt;</span><span class="n">bt_mount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_sema</span><span class="p">);</span>
	<span class="n">XB_SET_OWNER</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="n">trace_xfs_buf_lock_done</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_buf_unlock</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">XB_CLEAR_OWNER</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_sema</span><span class="p">);</span>

	<span class="n">trace_xfs_buf_unlock</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_buf_wait_unpin</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span>	<span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pin_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_waiters</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pin_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">io_schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_waiters</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Buffer Utility Routines</span>
<span class="cm"> */</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_buf_iodone_work</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">xfs_buf_t</span><span class="p">,</span> <span class="n">b_iodone_work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone</span><span class="p">))(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_ASYNC</span><span class="p">)</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_buf_ioend</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">schedule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xfs_buf_iodone</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">XBF_READ</span> <span class="o">|</span> <span class="n">XBF_WRITE</span> <span class="o">|</span> <span class="n">XBF_READ_AHEAD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">XBF_DONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_ASYNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">schedule</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone_work</span><span class="p">,</span> <span class="n">xfs_buf_iodone_work</span><span class="p">);</span>
			<span class="n">queue_work</span><span class="p">(</span><span class="n">xfslogd_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone_work</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xfs_buf_iodone_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone_work</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iowait</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_buf_ioerror</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">error</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">error</span> <span class="o">&lt;=</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_error</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">error</span><span class="p">;</span>
	<span class="n">trace_xfs_buf_ioerror</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_buf_ioerror_alert</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_alert</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_target</span><span class="o">-&gt;</span><span class="n">bt_mount</span><span class="p">,</span>
<span class="s">&quot;metadata I/O error: block 0x%llx (</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">) error %d numblks %d&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">__uint64_t</span><span class="p">)</span><span class="n">XFS_BUF_ADDR</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">func</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_error</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_length</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_bwrite</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_buf_islocked</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">XBF_WRITE</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">XBF_ASYNC</span> <span class="o">|</span> <span class="n">XBF_READ</span> <span class="o">|</span> <span class="n">_XBF_DELWRI_Q</span><span class="p">);</span>

	<span class="n">xfs_bdstrat_cb</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_buf_iowait</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_force_shutdown</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_target</span><span class="o">-&gt;</span><span class="n">bt_mount</span><span class="p">,</span>
				   <span class="n">SHUTDOWN_META_IO_ERROR</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when we want to stop a buffer from getting written or read.</span>
<span class="cm"> * We attach the EIO error, muck with its flags, and call xfs_buf_ioend</span>
<span class="cm"> * so that the proper iodone callbacks get called.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_bioerror</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef XFSERRORDEBUG</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_BUF_ISREAD</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">||</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * No need to wait until the buffer is unpinned, we aren&#39;t flushing it.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_buf_ioerror</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">EIO</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re calling xfs_buf_ioend, so delete XBF_DONE flag.</span>
<span class="cm">	 */</span>
	<span class="n">XFS_BUF_UNREAD</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">XFS_BUF_UNDONE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_buf_stale</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="n">xfs_buf_ioend</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Same as xfs_bioerror, except that we are releasing the buffer</span>
<span class="cm"> * here ourselves, and avoiding the xfs_buf_ioend call.</span>
<span class="cm"> * This is meant for userdata errors; metadata bufs come with</span>
<span class="cm"> * iodone functions attached, so that we can track down errors.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_bioerror_relse</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int64_t</span>		<span class="n">fl</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * No need to wait until the buffer is unpinned.</span>
<span class="cm">	 * We aren&#39;t flushing it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * chunkhold expects B_DONE to be set, whether</span>
<span class="cm">	 * we actually finish the I/O or not. We don&#39;t want to</span>
<span class="cm">	 * change that interface.</span>
<span class="cm">	 */</span>
	<span class="n">XFS_BUF_UNREAD</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">XFS_BUF_DONE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_buf_stale</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fl</span> <span class="o">&amp;</span> <span class="n">XBF_ASYNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Mark b_error and B_ERROR _both_.</span>
<span class="cm">		 * Lot&#39;s of chunkcache code assumes that.</span>
<span class="cm">		 * There&#39;s no reason to mark error for</span>
<span class="cm">		 * ASYNC buffers.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_buf_ioerror</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">EIO</span><span class="p">);</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iowait</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * All xfs metadata buffers except log state machine buffers</span>
<span class="cm"> * get this attached as their b_bdstrat callback function.</span>
<span class="cm"> * This is so that we can catch a buffer</span>
<span class="cm"> * after prematurely unpinning it to forcibly shutdown the filesystem.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_bdstrat_cb</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_target</span><span class="o">-&gt;</span><span class="n">bt_mount</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trace_xfs_bdstrat_shut</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Metadata write that didn&#39;t get logged but</span>
<span class="cm">		 * written delayed anyway. These aren&#39;t associated</span>
<span class="cm">		 * with a transaction, and can be ignored.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">XFS_BUF_ISREAD</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">xfs_bioerror_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">xfs_bioerror</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xfs_buf_iorequest</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wrapper around bdstrat so that we can stop data from going to disk in case</span>
<span class="cm"> * we are shutting down the filesystem.  Typically user data goes thru this</span>
<span class="cm"> * path; one of the exceptions is the superblock.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfsbdstrat</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trace_xfs_bdstrat_shut</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
		<span class="n">xfs_bioerror_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_buf_iorequest</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">_xfs_buf_ioend</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">schedule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_remaining</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">xfs_buf_ioend</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">schedule</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_buf_bio_end_io</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">bio</span>		<span class="o">*</span><span class="n">bio</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_buf_t</span> <span class="o">*</span><span class="p">)</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>

	<span class="n">xfs_buf_ioerror</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">-</span><span class="n">error</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">xfs_buf_is_vmapped</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_READ</span><span class="p">))</span>
		<span class="n">invalidate_kernel_vmap_range</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">,</span> <span class="n">xfs_buf_vmap_len</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>

	<span class="n">_xfs_buf_ioend</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">_xfs_buf_ioapply</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">rw</span><span class="p">,</span> <span class="n">map_i</span><span class="p">,</span> <span class="n">total_nr_pages</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span>		<span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">offset</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_offset</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">size</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_length</span><span class="p">);</span>
	<span class="n">sector_t</span>		<span class="n">sector</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_bn</span><span class="p">;</span>

	<span class="n">total_nr_pages</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_page_count</span><span class="p">;</span>
	<span class="n">map_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_SYNCIO</span><span class="p">)</span>
			<span class="n">rw</span> <span class="o">=</span> <span class="n">WRITE_SYNC</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">rw</span> <span class="o">=</span> <span class="n">WRITE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_FUA</span><span class="p">)</span>
			<span class="n">rw</span> <span class="o">|=</span> <span class="n">REQ_FUA</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_FLUSH</span><span class="p">)</span>
			<span class="n">rw</span> <span class="o">|=</span> <span class="n">REQ_FLUSH</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_READ_AHEAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rw</span> <span class="o">=</span> <span class="n">READA</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rw</span> <span class="o">=</span> <span class="n">READ</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we only use the buffer cache for meta-data */</span>
	<span class="n">rw</span> <span class="o">|=</span> <span class="n">REQ_META</span><span class="p">;</span>

<span class="nl">next_chunk:</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_remaining</span><span class="p">);</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">BIO_MAX_SECTORS</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="n">BBSHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="n">total_nr_pages</span><span class="p">)</span>
		<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">total_nr_pages</span><span class="p">;</span>

	<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">GFP_NOIO</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_target</span><span class="o">-&gt;</span><span class="n">bt_bdev</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">sector</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">xfs_buf_bio_end_io</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>


	<span class="k">for</span> <span class="p">(;</span> <span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">nr_pages</span><span class="o">--</span><span class="p">,</span> <span class="n">map_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">rbytes</span><span class="p">,</span> <span class="n">nbytes</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
			<span class="n">nbytes</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">rbytes</span> <span class="o">=</span> <span class="n">bio_add_page</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">[</span><span class="n">map_i</span><span class="p">],</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rbytes</span> <span class="o">&lt;</span> <span class="n">nbytes</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sector</span> <span class="o">+=</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">nbytes</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">nbytes</span><span class="p">;</span>
		<span class="n">total_nr_pages</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfs_buf_is_vmapped</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">flush_kernel_vmap_range</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">,</span>
						<span class="n">xfs_buf_vmap_len</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">submit_bio</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next_chunk</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xfs_buf_ioerror</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">EIO</span><span class="p">);</span>
		<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_buf_iorequest</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xfs_buf_iorequest</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">_XBF_DELWRI_Q</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_WRITE</span><span class="p">)</span>
		<span class="n">xfs_buf_wait_unpin</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_buf_hold</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* Set the count to 1 initially, this will stop an I/O</span>
<span class="cm">	 * completion callout which happens before we have started</span>
<span class="cm">	 * all the I/O from calling xfs_buf_ioend too early.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_remaining</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">_xfs_buf_ioapply</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">_xfs_buf_ioend</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">xfs_buf_rele</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Waits for I/O to complete on the buffer supplied.  It returns immediately if</span>
<span class="cm"> * no I/O is pending or there is already a pending error on the buffer.  It</span>
<span class="cm"> * returns the I/O error code, if any, or 0 if there was no error.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_buf_iowait</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xfs_buf_iowait</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_error</span><span class="p">)</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iowait</span><span class="p">);</span>

	<span class="n">trace_xfs_buf_iowait_done</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">xfs_caddr_t</span>
<span class="nf">xfs_buf_offset</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">+=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_offset</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">[</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">];</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">xfs_caddr_t</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Move data into or out of a buffer.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_buf_iomove</span><span class="p">(</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>	<span class="cm">/* buffer to process		*/</span>
	<span class="kt">size_t</span>			<span class="n">boff</span><span class="p">,</span>	<span class="cm">/* starting buffer offset	*/</span>
	<span class="kt">size_t</span>			<span class="n">bsize</span><span class="p">,</span>	<span class="cm">/* length to copy		*/</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">data</span><span class="p">,</span>	<span class="cm">/* data address			*/</span>
	<span class="n">xfs_buf_rw_t</span>		<span class="n">mode</span><span class="p">)</span>	<span class="cm">/* read/write/zero flag		*/</span>
<span class="p">{</span>
	<span class="kt">size_t</span>			<span class="n">bend</span><span class="p">;</span>

	<span class="n">bend</span> <span class="o">=</span> <span class="n">boff</span> <span class="o">+</span> <span class="n">bsize</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">boff</span> <span class="o">&lt;</span> <span class="n">bend</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span>	<span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">page_index</span><span class="p">,</span> <span class="n">page_offset</span><span class="p">,</span> <span class="n">csize</span><span class="p">;</span>

		<span class="n">page_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">boff</span> <span class="o">+</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_offset</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">page_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">boff</span> <span class="o">+</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_pages</span><span class="p">[</span><span class="n">page_index</span><span class="p">];</span>
		<span class="n">csize</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">page_offset</span><span class="p">,</span>
				      <span class="n">BBTOB</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_io_length</span><span class="p">)</span> <span class="o">-</span> <span class="n">boff</span><span class="p">);</span>

		<span class="n">ASSERT</span><span class="p">((</span><span class="n">csize</span> <span class="o">+</span> <span class="n">page_offset</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">XBRW_ZERO</span>:
			<span class="n">memset</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">page_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">csize</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XBRW_READ</span>:
			<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">page_offset</span><span class="p">,</span> <span class="n">csize</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XBRW_WRITE</span>:
			<span class="n">memcpy</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">page_offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">csize</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">boff</span> <span class="o">+=</span> <span class="n">csize</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">+=</span> <span class="n">csize</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Handling of buffer targets (buftargs).</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for any bufs with callbacks that have been submitted but have not yet</span>
<span class="cm"> * returned. These buffers will have an elevated hold count, so wait on those</span>
<span class="cm"> * while freeing all the buffers only held by the LRU.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_wait_buftarg</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buftarg</span>	<span class="o">*</span><span class="n">btp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_buf</span><span class="p">,</span> <span class="n">b_lru</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_hold</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_lock</span><span class="p">);</span>
			<span class="n">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * clear the LRU reference count so the buffer doesn&#39;t get</span>
<span class="cm">		 * ignored in xfs_buf_rele().</span>
<span class="cm">		 */</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru_ref</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_lock</span><span class="p">);</span>
		<span class="n">xfs_buf_rele</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_buftarg_shrink</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">shrinker</span>		<span class="o">*</span><span class="n">shrink</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">shrink_control</span>	<span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_buftarg</span>	<span class="o">*</span><span class="n">btp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">shrink</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">xfs_buftarg</span><span class="p">,</span> <span class="n">bt_shrinker</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_to_scan</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_scan</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">dispose</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_to_scan</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_nr</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_to_scan</span><span class="o">--</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">bp</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_buf</span><span class="p">,</span> <span class="n">b_lru</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Decrement the b_lru_ref count unless the value is already</span>
<span class="cm">		 * zero. If the value is already zero, we need to reclaim the</span>
<span class="cm">		 * buffer, otherwise it gets another trip through the LRU.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru_ref</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * remove the buffer from the LRU now to avoid needing another</span>
<span class="cm">		 * lock round trip inside xfs_buf_rele().</span>
<span class="cm">		 */</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dispose</span><span class="p">);</span>
		<span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_nr</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dispose</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dispose</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_buf</span><span class="p">,</span> <span class="n">b_lru</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_lru</span><span class="p">);</span>
		<span class="n">xfs_buf_rele</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_free_buftarg</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_buftarg</span>	<span class="o">*</span><span class="n">btp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_shrinker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_shrinker</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_BARRIER</span><span class="p">)</span>
		<span class="n">xfs_blkdev_issue_flush</span><span class="p">(</span><span class="n">btp</span><span class="p">);</span>

	<span class="n">kmem_free</span><span class="p">(</span><span class="n">btp</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_setsize_buftarg_flags</span><span class="p">(</span>
	<span class="n">xfs_buftarg_t</span>		<span class="o">*</span><span class="n">btp</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">blocksize</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sectorsize</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">verbose</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_bsize</span> <span class="o">=</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_sshift</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">sectorsize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_smask</span> <span class="o">=</span> <span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">set_blocksize</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_bdev</span><span class="p">,</span> <span class="n">sectorsize</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

		<span class="n">bdevname</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_bdev</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_mount</span><span class="p">,</span>
			<span class="s">&quot;Cannot set_blocksize to %u on device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sectorsize</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	When allocating the initial buffer target we have not yet</span>
<span class="cm"> *	read in the superblock, so don&#39;t know what sized sectors</span>
<span class="cm"> *	are being used is at this early stage.  Play safe.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_setsize_buftarg_early</span><span class="p">(</span>
	<span class="n">xfs_buftarg_t</span>		<span class="o">*</span><span class="n">btp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">block_device</span>	<span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfs_setsize_buftarg_flags</span><span class="p">(</span><span class="n">btp</span><span class="p">,</span>
			<span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">bdev_logical_block_size</span><span class="p">(</span><span class="n">bdev</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_setsize_buftarg</span><span class="p">(</span>
	<span class="n">xfs_buftarg_t</span>		<span class="o">*</span><span class="n">btp</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">blocksize</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sectorsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfs_setsize_buftarg_flags</span><span class="p">(</span><span class="n">btp</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">sectorsize</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">xfs_buftarg_t</span> <span class="o">*</span>
<span class="nf">xfs_alloc_buftarg</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">block_device</span>	<span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">external</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">fsname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buftarg_t</span>		<span class="o">*</span><span class="n">btp</span><span class="p">;</span>

	<span class="n">btp</span> <span class="o">=</span> <span class="n">kmem_zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">btp</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="p">);</span>

	<span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_mount</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
	<span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_dev</span> <span class="o">=</span>  <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">;</span>
	<span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_bdev</span> <span class="o">=</span> <span class="n">bdev</span><span class="p">;</span>
	<span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_bdi</span> <span class="o">=</span> <span class="n">blk_get_backing_dev_info</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_bdi</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_lru_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_setsize_buftarg_early</span><span class="p">(</span><span class="n">btp</span><span class="p">,</span> <span class="n">bdev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_shrinker</span><span class="p">.</span><span class="n">shrink</span> <span class="o">=</span> <span class="n">xfs_buftarg_shrink</span><span class="p">;</span>
	<span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_shrinker</span><span class="p">.</span><span class="n">seeks</span> <span class="o">=</span> <span class="n">DEFAULT_SEEKS</span><span class="p">;</span>
	<span class="n">register_shrinker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btp</span><span class="o">-&gt;</span><span class="n">bt_shrinker</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">btp</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">btp</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a buffer to the delayed write list.</span>
<span class="cm"> *</span>
<span class="cm"> * This queues a buffer for writeout if it hasn&#39;t already been.  Note that</span>
<span class="cm"> * neither this routine nor the buffer list submission functions perform</span>
<span class="cm"> * any internal synchronization.  It is expected that the lists are thread-local</span>
<span class="cm"> * to the callers.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if we queued up the buffer, or false if it already had</span>
<span class="cm"> * been on the buffer list.</span>
<span class="cm"> */</span>
<span class="n">bool</span>
<span class="nf">xfs_buf_delwri_queue</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_buf_islocked</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">XBF_READ</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the buffer is already marked delwri it already is queued up</span>
<span class="cm">	 * by someone else for imediate writeout.  Just ignore it in that</span>
<span class="cm">	 * case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">_XBF_DELWRI_Q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_xfs_buf_delwri_queued</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_xfs_buf_delwri_queue</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a buffer gets written out synchronously or marked stale while it</span>
<span class="cm">	 * is on a delwri list we lazily remove it. To do this, the other party</span>
<span class="cm">	 * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.</span>
<span class="cm">	 * It remains referenced and on the list.  In a rare corner case it</span>
<span class="cm">	 * might get readded to a delwri list after the synchronous writeout, in</span>
<span class="cm">	 * which case we need just need to re-add the flag here.</span>
<span class="cm">	 */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">_XBF_DELWRI_Q</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_hold</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compare function is more complex than it needs to be because</span>
<span class="cm"> * the return value is only 32 bits and we are doing comparisons</span>
<span class="cm"> * on 64 bit values</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xfs_buf_cmp</span><span class="p">(</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">priv</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>	<span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_buf</span><span class="p">,</span> <span class="n">b_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>	<span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_buf</span><span class="p">,</span> <span class="n">b_list</span><span class="p">);</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">diff</span><span class="p">;</span>

	<span class="n">diff</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">b_bn</span> <span class="o">-</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_bn</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__xfs_buf_delwri_submit</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">buffer_list</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">io_list</span><span class="p">,</span>
	<span class="n">bool</span>			<span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_plug</span>		<span class="n">plug</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">pinned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">buffer_list</span><span class="p">,</span> <span class="n">b_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xfs_buf_ispinned</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pinned</span><span class="o">++</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_buf_trylock</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xfs_buf_lock</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Someone else might have written the buffer synchronously or</span>
<span class="cm">		 * marked it stale in the meantime.  In that case only the</span>
<span class="cm">		 * _XBF_DELWRI_Q flag got cleared, and we have to drop the</span>
<span class="cm">		 * reference and remove it from the list here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">_XBF_DELWRI_Q</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_list</span><span class="p">);</span>
			<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_list</span><span class="p">,</span> <span class="n">io_list</span><span class="p">);</span>
		<span class="n">trace_xfs_buf_delwri_split</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_sort</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">io_list</span><span class="p">,</span> <span class="n">xfs_buf_cmp</span><span class="p">);</span>

	<span class="n">blk_start_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">io_list</span><span class="p">,</span> <span class="n">b_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">_XBF_DELWRI_Q</span> <span class="o">|</span> <span class="n">XBF_ASYNC</span><span class="p">);</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">XBF_WRITE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">|=</span> <span class="n">XBF_ASYNC</span><span class="p">;</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_list</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">xfs_bdstrat_cb</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">blk_finish_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pinned</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write out a buffer list asynchronously.</span>
<span class="cm"> *</span>
<span class="cm"> * This will take the @buffer_list, write all non-locked and non-pinned buffers</span>
<span class="cm"> * out and not wait for I/O completion on any of the buffers.  This interface</span>
<span class="cm"> * is only safely useable for callers that can track I/O completion by higher</span>
<span class="cm"> * level means, e.g. AIL pushing as the @buffer_list is consumed in this</span>
<span class="cm"> * function.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_buf_delwri_submit_nowait</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">buffer_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span>		<span class="p">(</span><span class="n">io_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__xfs_buf_delwri_submit</span><span class="p">(</span><span class="n">buffer_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_list</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write out a buffer list synchronously.</span>
<span class="cm"> *</span>
<span class="cm"> * This will take the @buffer_list, write all buffers out and wait for I/O</span>
<span class="cm"> * completion on all of the buffers. @buffer_list is consumed by the function,</span>
<span class="cm"> * so callers must have some other way of tracking buffers if they require such</span>
<span class="cm"> * functionality.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_buf_delwri_submit</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">buffer_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span>		<span class="p">(</span><span class="n">io_list</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="n">__xfs_buf_delwri_submit</span><span class="p">(</span><span class="n">buffer_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_list</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="cm">/* Wait for IO to complete. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_buf</span><span class="p">,</span> <span class="n">b_list</span><span class="p">);</span>

		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_list</span><span class="p">);</span>
		<span class="n">error2</span> <span class="o">=</span> <span class="n">xfs_buf_iowait</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">error2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span>
<span class="nf">xfs_buf_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_zone</span> <span class="o">=</span> <span class="n">kmem_zone_init_flags</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_buf_t</span><span class="p">),</span> <span class="s">&quot;xfs_buf&quot;</span><span class="p">,</span>
						<span class="n">KM_ZONE_HWALIGN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_buf_zone</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">xfslogd_workqueue</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;xfslogd&quot;</span><span class="p">,</span>
					<span class="n">WQ_MEM_RECLAIM</span> <span class="o">|</span> <span class="n">WQ_HIGHPRI</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfslogd_workqueue</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_buf_zone</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_free_buf_zone:</span>
	<span class="n">kmem_zone_destroy</span><span class="p">(</span><span class="n">xfs_buf_zone</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_buf_terminate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">xfslogd_workqueue</span><span class="p">);</span>
	<span class="n">kmem_zone_destroy</span><span class="p">(</span><span class="n">xfs_buf_zone</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
