<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_mount.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_mount.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_bit.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_inum.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_trans_priv.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_dir2.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_ialloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_ialloc.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_rtalloc.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_quota.h&quot;</span>
<span class="cp">#include &quot;xfs_fsops.h&quot;</span>
<span class="cp">#include &quot;xfs_utils.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>


<span class="cp">#ifdef HAVE_PERCPU_SB</span>
<span class="n">STATIC</span> <span class="kt">void</span>	<span class="n">xfs_icsb_balance_counter</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_sb_field_t</span><span class="p">,</span>
						<span class="kt">int</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span>	<span class="n">xfs_icsb_balance_counter_locked</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_sb_field_t</span><span class="p">,</span>
						<span class="kt">int</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span>	<span class="n">xfs_icsb_disable_counter</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_sb_field_t</span><span class="p">);</span>
<span class="cp">#else</span>

<span class="cp">#define xfs_icsb_balance_counter(mp, a, b)		do { } while (0)</span>
<span class="cp">#define xfs_icsb_balance_counter_locked(mp, a, b)	do { } while (0)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">short</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* 0 = integer</span>
<span class="cm">			 * 1 = binary / string (no translation)</span>
<span class="cm">			 */</span>
<span class="p">}</span> <span class="n">xfs_sb_info</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_magicnum</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_blocksize</span><span class="p">),</span>  <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_dblocks</span><span class="p">),</span>    <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_rblocks</span><span class="p">),</span>    <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_rextents</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_uuid</span><span class="p">),</span>       <span class="mi">1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_logstart</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_rootino</span><span class="p">),</span>    <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_rbmino</span><span class="p">),</span>     <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_rsumino</span><span class="p">),</span>    <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_rextsize</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_agblocks</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_agcount</span><span class="p">),</span>    <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_rbmblocks</span><span class="p">),</span>  <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_logblocks</span><span class="p">),</span>  <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_versionnum</span><span class="p">),</span> <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_sectsize</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_inodesize</span><span class="p">),</span>  <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_inopblock</span><span class="p">),</span>  <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_fname</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>   <span class="mi">1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_blocklog</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_sectlog</span><span class="p">),</span>    <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_inodelog</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_inopblog</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_agblklog</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_rextslog</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_inprogress</span><span class="p">),</span> <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_imax_pct</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_icount</span><span class="p">),</span>     <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_ifree</span><span class="p">),</span>      <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_fdblocks</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_frextents</span><span class="p">),</span>  <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_uquotino</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_gquotino</span><span class="p">),</span>   <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_qflags</span><span class="p">),</span>     <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_flags</span><span class="p">),</span>      <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_shared_vn</span><span class="p">),</span>  <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_inoalignmt</span><span class="p">),</span> <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_unit</span><span class="p">),</span>	 <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_width</span><span class="p">),</span>	 <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_dirblklog</span><span class="p">),</span>	 <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_logsectlog</span><span class="p">),</span> <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_logsectsize</span><span class="p">),</span><span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_logsunit</span><span class="p">),</span>	 <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_features2</span><span class="p">),</span>	 <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">,</span> <span class="n">sb_bad_features2</span><span class="p">),</span> <span class="mi">0</span> <span class="p">},</span>
    <span class="p">{</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">),</span>			 <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">xfs_uuid_table_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xfs_uuid_table_size</span><span class="p">;</span>
<span class="k">static</span> <span class="n">uuid_t</span> <span class="o">*</span><span class="n">xfs_uuid_table</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * See if the UUID is unique among mounted XFS filesystems.</span>
<span class="cm"> * Mount fails if UUID is nil or a FS with the same UUID is already mounted.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_uuid_mount</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uuid_t</span>			<span class="o">*</span><span class="n">uuid</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_uuid</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">hole</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_NOUUID</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uuid_is_nil</span><span class="p">(</span><span class="n">uuid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;Filesystem has nil UUID - can&#39;t mount&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfs_uuid_table_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hole</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">xfs_uuid_table_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uuid_is_nil</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfs_uuid_table</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">hole</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uuid_equal</span><span class="p">(</span><span class="n">uuid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xfs_uuid_table</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">goto</span> <span class="n">out_duplicate</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hole</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_uuid_table</span> <span class="o">=</span> <span class="n">kmem_realloc</span><span class="p">(</span><span class="n">xfs_uuid_table</span><span class="p">,</span>
			<span class="p">(</span><span class="n">xfs_uuid_table_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">xfs_uuid_table</span><span class="p">),</span>
			<span class="n">xfs_uuid_table_size</span>  <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">xfs_uuid_table</span><span class="p">),</span>
			<span class="n">KM_SLEEP</span><span class="p">);</span>
		<span class="n">hole</span> <span class="o">=</span> <span class="n">xfs_uuid_table_size</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_uuid_table</span><span class="p">[</span><span class="n">hole</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">uuid</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfs_uuid_table_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_duplicate:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfs_uuid_table_mutex</span><span class="p">);</span>
	<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;Filesystem has duplicate UUID %pU - can&#39;t mount&quot;</span><span class="p">,</span> <span class="n">uuid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_uuid_unmount</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uuid_t</span>			<span class="o">*</span><span class="n">uuid</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_uuid</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_NOUUID</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfs_uuid_table_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">xfs_uuid_table_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uuid_is_nil</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfs_uuid_table</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uuid_equal</span><span class="p">(</span><span class="n">uuid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xfs_uuid_table</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfs_uuid_table</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uuid_t</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">xfs_uuid_table_size</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xfs_uuid_table_mutex</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Reference counting access wrappers to the perag structures.</span>
<span class="cm"> * Because we never free per-ag structures, the only thing we</span>
<span class="cm"> * have to protect against changes is the tree structure itself.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfs_perag</span> <span class="o">*</span>
<span class="nf">xfs_perag_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_mount</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="n">xfs_agnumber_t</span> <span class="n">agno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span>	<span class="o">*</span><span class="n">pag</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">pag</span> <span class="o">=</span> <span class="n">radix_tree_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_perag_tree</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pag</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_ref</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_ref</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">trace_xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * search from @first to find the next perag with the given tag set.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfs_perag</span> <span class="o">*</span>
<span class="nf">xfs_perag_get_tag</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_agnumber_t</span>		<span class="n">first</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span>	<span class="o">*</span><span class="n">pag</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">found</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ref</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">radix_tree_gang_lookup_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_perag_tree</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pag</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ref</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_ref</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">trace_xfs_perag_get_tag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_agno</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pag</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_perag_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_perag</span> <span class="o">*</span><span class="n">pag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">ref</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_ref</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ref</span> <span class="o">=</span> <span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_ref</span><span class="p">);</span>
	<span class="n">trace_xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_mount</span><span class="p">,</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_agno</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">__xfs_free_perag</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>	<span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span> <span class="o">*</span><span class="n">pag</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_perag</span><span class="p">,</span> <span class="n">rcu_head</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_ref</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free up the per-ag resources associated with the mount structure.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_free_perag</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span> <span class="o">*</span><span class="n">pag</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">agno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">agno</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">;</span> <span class="n">agno</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_perag_lock</span><span class="p">);</span>
		<span class="n">pag</span> <span class="o">=</span> <span class="n">radix_tree_delete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_perag_tree</span><span class="p">,</span> <span class="n">agno</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_perag_lock</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_ref</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">rcu_head</span><span class="p">,</span> <span class="n">__xfs_free_perag</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check size of device based on the (data/realtime) block count.</span>
<span class="cm"> * Note: this check is used by the growfs code as well as mount.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_sb_validate_fsb_count</span><span class="p">(</span>
	<span class="n">xfs_sb_t</span>	<span class="o">*</span><span class="n">sbp</span><span class="p">,</span>
	<span class="n">__uint64_t</span>	<span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">&gt;=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span> <span class="o">&gt;=</span> <span class="n">BBSHIFT</span><span class="p">);</span>

<span class="cp">#if XFS_BIG_BLKNOS     </span><span class="cm">/* Limited by ULONG_MAX of page cache index */</span><span class="cp"></span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nblocks</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ULONG_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EFBIG</span><span class="p">;</span>
<span class="cp">#else                  </span><span class="cm">/* Limited by UINT_MAX of sectors */</span><span class="cp"></span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nblocks</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span> <span class="o">-</span> <span class="n">BBSHIFT</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EFBIG</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check the validity of the SB found.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_mount_validate_sb</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_sb_t</span>	<span class="o">*</span><span class="n">sbp</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">loud</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_MFSI_QUIET</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the log device and data device have the</span>
<span class="cm">	 * same device number, the log is internal.</span>
<span class="cm">	 * Consequently, the sb_logstart should be non-zero.  If</span>
<span class="cm">	 * we have a zero sb_logstart in this case, we may be trying to mount</span>
<span class="cm">	 * a volume filesystem in a non-volume manner.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_magicnum</span> <span class="o">!=</span> <span class="n">XFS_SB_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loud</span><span class="p">)</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;bad magic number&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EWRONGFS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_sb_good_version</span><span class="p">(</span><span class="n">sbp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loud</span><span class="p">)</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;bad version&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EWRONGFS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_logstart</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span> <span class="o">==</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loud</span><span class="p">)</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
		<span class="s">&quot;filesystem is marked as having an external log; &quot;</span>
		<span class="s">&quot;specify logdev on the mount command line.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_logstart</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span> <span class="o">!=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loud</span><span class="p">)</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
		<span class="s">&quot;filesystem is marked as having an internal log; &quot;</span>
		<span class="s">&quot;do not specify logdev on the mount command line.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * More sanity checking.  Most of these were stolen directly from</span>
<span class="cm">	 * xfs_repair.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_agcount</span> <span class="o">&lt;=</span> <span class="mi">0</span>					<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_sectsize</span> <span class="o">&lt;</span> <span class="n">XFS_MIN_SECTORSIZE</span>			<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_sectsize</span> <span class="o">&gt;</span> <span class="n">XFS_MAX_SECTORSIZE</span>			<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_sectlog</span> <span class="o">&lt;</span> <span class="n">XFS_MIN_SECTORSIZE_LOG</span>			<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_sectlog</span> <span class="o">&gt;</span> <span class="n">XFS_MAX_SECTORSIZE_LOG</span>			<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_sectsize</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_sectlog</span><span class="p">)</span>			<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span> <span class="o">&lt;</span> <span class="n">XFS_MIN_BLOCKSIZE</span>			<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span> <span class="o">&gt;</span> <span class="n">XFS_MAX_BLOCKSIZE</span>			<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span> <span class="o">&lt;</span> <span class="n">XFS_MIN_BLOCKSIZE_LOG</span>			<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span> <span class="o">&gt;</span> <span class="n">XFS_MAX_BLOCKSIZE_LOG</span>			<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span><span class="p">)</span>		<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inodesize</span> <span class="o">&lt;</span> <span class="n">XFS_DINODE_MIN_SIZE</span>			<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inodesize</span> <span class="o">&gt;</span> <span class="n">XFS_DINODE_MAX_SIZE</span>			<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inodelog</span> <span class="o">&lt;</span> <span class="n">XFS_DINODE_MIN_LOG</span>			<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inodelog</span> <span class="o">&gt;</span> <span class="n">XFS_DINODE_MAX_LOG</span>			<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inodesize</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inodelog</span><span class="p">)</span>		<span class="o">||</span>
	    <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span> <span class="o">-</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inodelog</span> <span class="o">!=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inopblog</span><span class="p">)</span>	<span class="o">||</span>
	    <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rextsize</span> <span class="o">*</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span> <span class="o">&gt;</span> <span class="n">XFS_MAX_RTEXTSIZE</span><span class="p">)</span>	<span class="o">||</span>
	    <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rextsize</span> <span class="o">*</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span> <span class="o">&lt;</span> <span class="n">XFS_MIN_RTEXTSIZE</span><span class="p">)</span>	<span class="o">||</span>
	    <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_imax_pct</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="cm">/* zero sb_imax_pct is valid */</span><span class="p">)</span>	<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_dblocks</span> <span class="o">==</span> <span class="mi">0</span>					<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_dblocks</span> <span class="o">&gt;</span> <span class="n">XFS_MAX_DBLOCKS</span><span class="p">(</span><span class="n">sbp</span><span class="p">)</span>			<span class="o">||</span>
	    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_dblocks</span> <span class="o">&lt;</span> <span class="n">XFS_MIN_DBLOCKS</span><span class="p">(</span><span class="n">sbp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loud</span><span class="p">)</span>
			<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;SB sanity check failed&quot;</span><span class="p">,</span>
				<span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">sbp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Until this is fixed only page-sized or smaller data blocks work.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loud</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
		<span class="s">&quot;File system with blocksize %d bytes. &quot;</span>
		<span class="s">&quot;Only pagesize (%ld) or less will currently work.&quot;</span><span class="p">,</span>
				<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSYS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Currently only very few inode sizes are supported.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inodesize</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">256</span>:
	<span class="k">case</span> <span class="mi">512</span>:
	<span class="k">case</span> <span class="mi">1024</span>:
	<span class="k">case</span> <span class="mi">2048</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loud</span><span class="p">)</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;inode size of %d bytes not supported&quot;</span><span class="p">,</span>
				<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inodesize</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSYS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_validate_fsb_count</span><span class="p">(</span><span class="n">sbp</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_dblocks</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">xfs_sb_validate_fsb_count</span><span class="p">(</span><span class="n">sbp</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rblocks</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loud</span><span class="p">)</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
		<span class="s">&quot;file system too large to be mounted on this system.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFBIG</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inprogress</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loud</span><span class="p">)</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;file system busy&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Version 1 directory format has never worked on Linux.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">xfs_sb_version_hasdirv2</span><span class="p">(</span><span class="n">sbp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loud</span><span class="p">)</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
				<span class="s">&quot;file system using version 1 directory format&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSYS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_initialize_perag</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agcount</span><span class="p">,</span>
	<span class="n">xfs_agnumber_t</span>	<span class="o">*</span><span class="n">maxagi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">index</span><span class="p">,</span> <span class="n">max_metadata</span><span class="p">;</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">first_initialised</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_perag_t</span>	<span class="o">*</span><span class="n">pag</span><span class="p">;</span>
	<span class="n">xfs_agino_t</span>	<span class="n">agino</span><span class="p">;</span>
	<span class="n">xfs_ino_t</span>	<span class="n">ino</span><span class="p">;</span>
	<span class="n">xfs_sb_t</span>	<span class="o">*</span><span class="n">sbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Walk the current per-ag tree so we don&#39;t try to initialise AGs</span>
<span class="cm">	 * that already exist (growfs case). Allocate and insert all the</span>
<span class="cm">	 * AGs we don&#39;t find ready for initialisation.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">agcount</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pag</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_initialised</span><span class="p">)</span>
			<span class="n">first_initialised</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

		<span class="n">pag</span> <span class="o">=</span> <span class="n">kmem_zalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pag</span><span class="p">),</span> <span class="n">KM_MAYFAIL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pag</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unwind</span><span class="p">;</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_agno</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_mount</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_ici_lock</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_ici_reclaim_lock</span><span class="p">);</span>
		<span class="n">INIT_RADIX_TREE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_ici_root</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_buf_lock</span><span class="p">);</span>
		<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_buf_tree</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_preload</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_unwind</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_perag_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_perag_tree</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">pag</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG</span><span class="p">();</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_perag_lock</span><span class="p">);</span>
			<span class="n">radix_tree_preload_end</span><span class="p">();</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unwind</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_perag_lock</span><span class="p">);</span>
		<span class="n">radix_tree_preload_end</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we mount with the inode64 option, or no inode overflows</span>
<span class="cm">	 * the legacy 32-bit address space clear the inode32 option.</span>
<span class="cm">	 */</span>
	<span class="n">agino</span> <span class="o">=</span> <span class="n">XFS_OFFBNO_TO_AGINO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_agblocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">XFS_AGINO_TO_INO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agcount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">agino</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_SMALL_INUMS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ino</span> <span class="o">&gt;</span> <span class="n">XFS_MAXINUMBER_32</span><span class="p">)</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">XFS_MOUNT_32BITINODES</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XFS_MOUNT_32BITINODES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_32BITINODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Calculate how much should be reserved for inodes to meet</span>
<span class="cm">		 * the max inode percentage.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxicount</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__uint64_t</span>	<span class="n">icount</span><span class="p">;</span>

			<span class="n">icount</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_dblocks</span> <span class="o">*</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_imax_pct</span><span class="p">;</span>
			<span class="n">do_div</span><span class="p">(</span><span class="n">icount</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
			<span class="n">icount</span> <span class="o">+=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_agblocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">do_div</span><span class="p">(</span><span class="n">icount</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_agblocks</span><span class="p">);</span>
			<span class="n">max_metadata</span> <span class="o">=</span> <span class="n">icount</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">max_metadata</span> <span class="o">=</span> <span class="n">agcount</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">agcount</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ino</span> <span class="o">=</span> <span class="n">XFS_AGINO_TO_INO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">agino</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&gt;</span> <span class="n">XFS_MAXINUMBER_32</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">index</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
			<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_inodeok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">max_metadata</span><span class="p">)</span>
				<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_metadata</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">agcount</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
			<span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_inodeok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">maxagi</span><span class="p">)</span>
		<span class="o">*</span><span class="n">maxagi</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unwind:</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">first_initialised</span><span class="p">;</span> <span class="n">index</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pag</span> <span class="o">=</span> <span class="n">radix_tree_delete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_perag_tree</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_sb_from_disk</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_dsb_t</span>	<span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_sb</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">;</span>

	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_magicnum</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_magicnum</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_dblocks</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_dblocks</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_rblocks</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_rblocks</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_rextents</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_rextents</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_uuid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_uuid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_uuid</span><span class="p">));</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_logstart</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_logstart</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_rootino</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_rootino</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_rbmino</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_rbmino</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_rsumino</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_rsumino</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_rextsize</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_rextsize</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_agblocks</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_agblocks</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_agcount</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_agcount</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_rbmblocks</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_rbmblocks</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_logblocks</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_logblocks</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_versionnum</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_versionnum</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_sectsize</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_sectsize</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_inodesize</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_inodesize</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_inopblock</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_inopblock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_fname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_fname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_fname</span><span class="p">));</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_sectlog</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_sectlog</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_inodelog</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_inodelog</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_inopblog</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_inopblog</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_agblklog</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_agblklog</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_rextslog</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_rextslog</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_inprogress</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_inprogress</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_imax_pct</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_imax_pct</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_icount</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_icount</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_ifree</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_ifree</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_fdblocks</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_fdblocks</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_frextents</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_frextents</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_uquotino</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_uquotino</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_gquotino</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_gquotino</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_qflags</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_qflags</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_flags</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_flags</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_shared_vn</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_shared_vn</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_inoalignmt</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_inoalignmt</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_unit</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_unit</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_width</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_width</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_dirblklog</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_dirblklog</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_logsectlog</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_logsectlog</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_logsectsize</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_logsectsize</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_logsunit</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_logsunit</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_features2</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_features2</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">sb_bad_features2</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">sb_bad_features2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy in core superblock to ondisk one.</span>
<span class="cm"> *</span>
<span class="cm"> * The fields argument is mask of superblock fields to copy.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_sb_to_disk</span><span class="p">(</span>
	<span class="n">xfs_dsb_t</span>	<span class="o">*</span><span class="n">to</span><span class="p">,</span>
	<span class="n">xfs_sb_t</span>	<span class="o">*</span><span class="n">from</span><span class="p">,</span>
	<span class="n">__int64_t</span>	<span class="n">fields</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_caddr_t</span>	<span class="n">to_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_caddr_t</span><span class="p">)</span><span class="n">to</span><span class="p">;</span>
	<span class="n">xfs_caddr_t</span>	<span class="n">from_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_caddr_t</span><span class="p">)</span><span class="n">from</span><span class="p">;</span>
	<span class="n">xfs_sb_field_t</span>	<span class="n">f</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">first</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">size</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">fields</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fields</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_sb_field_t</span><span class="p">)</span><span class="n">xfs_lowbit64</span><span class="p">((</span><span class="n">__uint64_t</span><span class="p">)</span><span class="n">fields</span><span class="p">);</span>
		<span class="n">first</span> <span class="o">=</span> <span class="n">xfs_sb_info</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">xfs_sb_info</span><span class="p">[</span><span class="n">f</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">offset</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_sb_info</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">xfs_sb_info</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">xfs_sb_info</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">to_ptr</span> <span class="o">+</span> <span class="n">first</span><span class="p">,</span> <span class="n">from_ptr</span> <span class="o">+</span> <span class="n">first</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">2</span>:
				<span class="o">*</span><span class="p">(</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)(</span><span class="n">to_ptr</span> <span class="o">+</span> <span class="n">first</span><span class="p">)</span> <span class="o">=</span>
					<span class="n">cpu_to_be16</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__u16</span> <span class="o">*</span><span class="p">)(</span><span class="n">from_ptr</span> <span class="o">+</span> <span class="n">first</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">4</span>:
				<span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)(</span><span class="n">to_ptr</span> <span class="o">+</span> <span class="n">first</span><span class="p">)</span> <span class="o">=</span>
					<span class="n">cpu_to_be32</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">from_ptr</span> <span class="o">+</span> <span class="n">first</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">8</span>:
				<span class="o">*</span><span class="p">(</span><span class="n">__be64</span> <span class="o">*</span><span class="p">)(</span><span class="n">to_ptr</span> <span class="o">+</span> <span class="n">first</span><span class="p">)</span> <span class="o">=</span>
					<span class="n">cpu_to_be64</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__u64</span> <span class="o">*</span><span class="p">)(</span><span class="n">from_ptr</span> <span class="o">+</span> <span class="n">first</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">fields</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_readsb</span>
<span class="cm"> *</span>
<span class="cm"> * Does the initial read of the superblock.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_readsb</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">sector_size</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">loud</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_MFSI_QUIET</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_bp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate a (locked) buffer to hold the superblock.</span>
<span class="cm">	 * This will be kept around at all times to optimize</span>
<span class="cm">	 * access to the superblock.</span>
<span class="cm">	 */</span>
	<span class="n">sector_size</span> <span class="o">=</span> <span class="n">xfs_getsize_buftarg</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">);</span>

<span class="nl">reread:</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_read_uncached</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span> <span class="n">XFS_SB_DADDR</span><span class="p">,</span>
					<span class="n">BTOBB</span><span class="p">(</span><span class="n">sector_size</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loud</span><span class="p">)</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;SB buffer read failed&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the mount structure from the superblock.</span>
<span class="cm">	 * But first do some basic consistency checking.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_sb_from_disk</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_BUF_TO_SBP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_mount_validate_sb</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loud</span><span class="p">)</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;SB validate failed&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">release_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must be able to do sector-sized and sector-aligned IO.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_sectsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loud</span><span class="p">)</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;device supports %u byte sectors (not %u)&quot;</span><span class="p">,</span>
				<span class="n">sector_size</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_sectsize</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ENOSYS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">release_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If device sector size is smaller than the superblock size,</span>
<span class="cm">	 * re-read the superblock so the buffer is correctly sized.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sector_size</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_sectsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="n">sector_size</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_sectsize</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">reread</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize per-cpu counters */</span>
	<span class="n">xfs_icsb_reinit_counters</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_bp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_buf_unlock</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">release_buf:</span>
	<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * xfs_mount_common</span>
<span class="cm"> *</span>
<span class="cm"> * Mount initialization code establishing various mount</span>
<span class="cm"> * fields from the superblock associated with the given</span>
<span class="cm"> * mount structure</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_mount_common</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="n">xfs_sb_t</span> <span class="o">*</span><span class="n">sbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agfrotor</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agirotor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agirotor_lock</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxagi</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_blkbit_log</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span> <span class="o">+</span> <span class="n">XFS_NBBYLOG</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_blkbb_log</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span> <span class="o">-</span> <span class="n">BBSHIFT</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sectbb_log</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_sectlog</span> <span class="o">-</span> <span class="n">BBSHIFT</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agno_log</span> <span class="o">=</span> <span class="n">xfs_highbit32</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_agcount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_agino_log</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inopblog</span> <span class="o">+</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_agblklog</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_blockmask</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_blockwsize</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span> <span class="o">&gt;&gt;</span> <span class="n">XFS_WORDLOG</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_blockwmask</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_blockwsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_alloc_mxr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xfs_allocbt_maxrecs</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_alloc_mxr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xfs_allocbt_maxrecs</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_alloc_mnr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_alloc_mxr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_alloc_mnr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_alloc_mxr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inobt_mxr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xfs_inobt_maxrecs</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inobt_mxr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xfs_inobt_maxrecs</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inobt_mnr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inobt_mxr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inobt_mnr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inobt_mxr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_bmap_dmxr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xfs_bmbt_maxrecs</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_bmap_dmxr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xfs_bmbt_maxrecs</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_bmap_dmnr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_bmap_dmxr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_bmap_dmnr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_bmap_dmxr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_bsize</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ialloc_inos</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">MAX</span><span class="p">((</span><span class="n">__uint16_t</span><span class="p">)</span><span class="n">XFS_INODES_PER_CHUNK</span><span class="p">,</span>
					<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inopblock</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ialloc_blks</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ialloc_inos</span> <span class="o">&gt;&gt;</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inopblog</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_initialize_perag_data</span>
<span class="cm"> *</span>
<span class="cm"> * Read in each per-ag structure so we can count up the number of</span>
<span class="cm"> * allocated inodes, free inodes and used filesystem blocks as this</span>
<span class="cm"> * information is no longer persistent in the superblock. Once we have</span>
<span class="cm"> * this information, write it into the in-core superblock structure.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_initialize_perag_data</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="n">xfs_agnumber_t</span> <span class="n">agcount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">index</span><span class="p">;</span>
	<span class="n">xfs_perag_t</span>	<span class="o">*</span><span class="n">pag</span><span class="p">;</span>
	<span class="n">xfs_sb_t</span>	<span class="o">*</span><span class="n">sbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">;</span>
	<span class="kt">uint64_t</span>	<span class="n">ifree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint64_t</span>	<span class="n">ialloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint64_t</span>	<span class="n">bfree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint64_t</span>	<span class="n">bfreelst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint64_t</span>	<span class="n">btree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">agcount</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * read the agf, then the agi. This gets us</span>
<span class="cm">		 * all the information we need and populates the</span>
<span class="cm">		 * per-ag structures for us.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_alloc_pagf_init</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ialloc_pagi_init</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">ifree</span> <span class="o">+=</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_freecount</span><span class="p">;</span>
		<span class="n">ialloc</span> <span class="o">+=</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagi_count</span><span class="p">;</span>
		<span class="n">bfree</span> <span class="o">+=</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_freeblks</span><span class="p">;</span>
		<span class="n">bfreelst</span> <span class="o">+=</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_flcount</span><span class="p">;</span>
		<span class="n">btree</span> <span class="o">+=</span> <span class="n">pag</span><span class="o">-&gt;</span><span class="n">pagf_btreeblks</span><span class="p">;</span>
		<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Overwrite incore superblock counters with just-read data</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
	<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_ifree</span> <span class="o">=</span> <span class="n">ifree</span><span class="p">;</span>
	<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_icount</span> <span class="o">=</span> <span class="n">ialloc</span><span class="p">;</span>
	<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_fdblocks</span> <span class="o">=</span> <span class="n">bfree</span> <span class="o">+</span> <span class="n">bfreelst</span> <span class="o">+</span> <span class="n">btree</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>

	<span class="cm">/* Fixup the per-cpu counters as well. */</span>
	<span class="n">xfs_icsb_reinit_counters</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update alignment values based on mount options and sb values</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_update_alignment</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_sb_t</span>	<span class="o">*</span><span class="n">sbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If stripe unit and stripe width are not multiples</span>
<span class="cm">		 * of the fs blocksize turn off alignment.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">BBTOB</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_blockmask</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">BBTOB</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_swidth</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_blockmask</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RETERR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;alignment check failed: &quot;</span>
					 <span class="s">&quot;(sunit/swidth vs. blocksize)&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_swidth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Convert the stripe unit and width to FSBs.</span>
<span class="cm">			 */</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span> <span class="o">=</span> <span class="n">XFS_BB_TO_FSBT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_agblocks</span> <span class="o">%</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RETERR</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;alignment check failed: &quot;</span>
						 <span class="s">&quot;(sunit/swidth vs. ag size)&quot;</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
		<span class="s">&quot;stripe alignment turned off: sunit(%d)/swidth(%d) &quot;</span>
		<span class="s">&quot;incompatible with agsize(%d)&quot;</span><span class="p">,</span>
					<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_swidth</span><span class="p">,</span>
					<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_agblocks</span><span class="p">);</span>

				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_swidth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_swidth</span> <span class="o">=</span> <span class="n">XFS_BB_TO_FSBT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_swidth</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RETERR</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;alignment check failed: &quot;</span>
						<span class="s">&quot;sunit(%d) less than bsize(%d)&quot;</span><span class="p">,</span>
						<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span><span class="p">,</span>
						<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_blockmask</span> <span class="o">+</span><span class="mi">1</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_swidth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Update superblock with new values</span>
<span class="cm">		 * and log changes</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_hasdalign</span><span class="p">(</span><span class="n">sbp</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_unit</span> <span class="o">!=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_unit</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span><span class="p">;</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_update_flags</span> <span class="o">|=</span> <span class="n">XFS_SB_UNIT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_width</span> <span class="o">!=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_swidth</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_width</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_swidth</span><span class="p">;</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_update_flags</span> <span class="o">|=</span> <span class="n">XFS_SB_WIDTH</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_NOALIGN</span><span class="p">)</span> <span class="o">!=</span> <span class="n">XFS_MOUNT_NOALIGN</span> <span class="o">&amp;&amp;</span>
		    <span class="n">xfs_sb_version_hasdalign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_unit</span><span class="p">;</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_swidth</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_width</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the maximum inode count for this filesystem</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_set_maxicount</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_sb_t</span>	<span class="o">*</span><span class="n">sbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">);</span>
	<span class="n">__uint64_t</span>	<span class="n">icount</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_imax_pct</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make sure the maximum inode count is a multiple</span>
<span class="cm">		 * of the units we allocate inodes in.</span>
<span class="cm">		 */</span>
		<span class="n">icount</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_dblocks</span> <span class="o">*</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_imax_pct</span><span class="p">;</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">icount</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">icount</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ialloc_blks</span><span class="p">);</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxicount</span> <span class="o">=</span> <span class="p">(</span><span class="n">icount</span> <span class="o">*</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ialloc_blks</span><span class="p">)</span>  <span class="o">&lt;&lt;</span>
				   <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_inopblog</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxicount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the default minimum read and write sizes unless</span>
<span class="cm"> * already specified in a mount option.</span>
<span class="cm"> * We use smaller I/O sizes when the file system</span>
<span class="cm"> * is being used for NFS service (wsync mount option).</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_set_rw_sizes</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_sb_t</span>	<span class="o">*</span><span class="n">sbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">readio_log</span><span class="p">,</span> <span class="n">writeio_log</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_DFLT_IOSIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_WSYNC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">readio_log</span> <span class="o">=</span> <span class="n">XFS_WSYNC_READIO_LOG</span><span class="p">;</span>
			<span class="n">writeio_log</span> <span class="o">=</span> <span class="n">XFS_WSYNC_WRITEIO_LOG</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">readio_log</span> <span class="o">=</span> <span class="n">XFS_READIO_LOG_LARGE</span><span class="p">;</span>
			<span class="n">writeio_log</span> <span class="o">=</span> <span class="n">XFS_WRITEIO_LOG_LARGE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">readio_log</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_readio_log</span><span class="p">;</span>
		<span class="n">writeio_log</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_writeio_log</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span> <span class="o">&gt;</span> <span class="n">readio_log</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_readio_log</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_readio_log</span> <span class="o">=</span> <span class="n">readio_log</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_readio_blocks</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_readio_log</span> <span class="o">-</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span> <span class="o">&gt;</span> <span class="n">writeio_log</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_writeio_log</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_writeio_log</span> <span class="o">=</span> <span class="n">writeio_log</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_writeio_blocks</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_writeio_log</span> <span class="o">-</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * precalculate the low space thresholds for dynamic speculative preallocation.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_set_low_space_thresholds</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">XFS_LOWSP_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__uint64_t</span> <span class="n">space</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_dblocks</span><span class="p">;</span>

		<span class="n">do_div</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_low_space</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">space</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Set whether we&#39;re using inode alignment.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_set_inoalignment</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_hasalign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inoalignmt</span> <span class="o">&gt;=</span>
	    <span class="n">XFS_B_TO_FSBT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inode_cluster_size</span><span class="p">))</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inoalign_mask</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inoalignmt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inoalign_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we are using stripe alignment, check whether</span>
<span class="cm">	 * the stripe unit is a multiple of the inode alignment</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span> <span class="o">&amp;&amp;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inoalign_mask</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span> <span class="o">&amp;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inoalign_mask</span><span class="p">))</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sinoalign</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dalign</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sinoalign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check that the data (and log if separate) are an ok size.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_check_sizes</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span>	<span class="n">d</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_daddr_t</span><span class="p">)</span><span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_dblocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_BB_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_dblocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;filesystem size mismatch detected&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFBIG</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_read_uncached</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span>
					<span class="n">d</span> <span class="o">-</span> <span class="n">XFS_FSS_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
					<span class="n">XFS_FSS_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;last sector read failed&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span> <span class="o">!=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_daddr_t</span><span class="p">)</span><span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_logblocks</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">XFS_BB_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_logblocks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;log size mismatch detected&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFBIG</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_buf_read_uncached</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span><span class="p">,</span>
					<span class="n">d</span> <span class="o">-</span> <span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
					<span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;log device read failed&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear the quotaflags in memory and in the superblock.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_mount_reset_sbqflags</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_qflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is OK to look at sb_qflags here in mount path,</span>
<span class="cm">	 * without m_sb_lock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_qflags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_qflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the fs is readonly, let the incore superblock run</span>
<span class="cm">	 * with quotas off but don&#39;t flush the update out to disk</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_QM_SBCHANGE</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_sectsize</span> <span class="o">+</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="n">XFS_DEFAULT_LOG_COUNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: Superblock update failed!&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_SB_QFLAGS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__uint64_t</span>
<span class="nf">xfs_default_resblks</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__uint64_t</span> <span class="n">resblks</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We default to 5% or 8192 fsbs of space reserved, whichever is</span>
<span class="cm">	 * smaller.  This is intended to cover concurrent allocation</span>
<span class="cm">	 * transactions when we initially hit enospc. These each require a 4</span>
<span class="cm">	 * block reservation. Hence by default we cover roughly 2000 concurrent</span>
<span class="cm">	 * allocation reservations.</span>
<span class="cm">	 */</span>
	<span class="n">resblks</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_dblocks</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">resblks</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">resblks</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">__uint64_t</span><span class="p">,</span> <span class="n">resblks</span><span class="p">,</span> <span class="mi">8192</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">resblks</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function does the following on an initial mount of a file system:</span>
<span class="cm"> *	- reads the superblock from disk and init the mount struct</span>
<span class="cm"> *	- if we&#39;re a 32-bit kernel, do a size check on the superblock</span>
<span class="cm"> *		so we don&#39;t mount terabyte filesystems</span>
<span class="cm"> *	- init mount struct realtime fields</span>
<span class="cm"> *	- allocate inode hash table for fs</span>
<span class="cm"> *	- init directory manager</span>
<span class="cm"> *	- perform recovery and init the log manager</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_mountfs</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_sb_t</span>	<span class="o">*</span><span class="n">sbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">);</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">rip</span><span class="p">;</span>
	<span class="n">__uint64_t</span>	<span class="n">resblks</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">quotamount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">quotaflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">xfs_mount_common</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">sbp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for a mismatched features2 values.  Older kernels</span>
<span class="cm">	 * read &amp; wrote into the wrong sb offset for sb_features2</span>
<span class="cm">	 * on some platforms due to xfs_sb_t not being 64bit size aligned</span>
<span class="cm">	 * when sb_features2 was added, which made older superblock</span>
<span class="cm">	 * reading/writing routines swap it as a 64-bit value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For backwards compatibility, we make both slots equal.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we detect a mismatched field, we OR the set bits into the</span>
<span class="cm">	 * existing features2 field in case it has already been modified; we</span>
<span class="cm">	 * don&#39;t want to lose any features.  We then update the bad location</span>
<span class="cm">	 * with the ORed value so that older kernels will see any features2</span>
<span class="cm">	 * flags, and mark the two fields as needing updates once the</span>
<span class="cm">	 * transaction subsystem is online.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_has_mismatched_features2</span><span class="p">(</span><span class="n">sbp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;correcting sb_features alignment problem&quot;</span><span class="p">);</span>
		<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_features2</span> <span class="o">|=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_bad_features2</span><span class="p">;</span>
		<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_bad_features2</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_features2</span><span class="p">;</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_update_flags</span> <span class="o">|=</span> <span class="n">XFS_SB_FEATURES2</span> <span class="o">|</span> <span class="n">XFS_SB_BAD_FEATURES2</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Re-check for ATTR2 in case it was found in bad_features2</span>
<span class="cm">		 * slot.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_hasattr2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="o">!</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_NOATTR2</span><span class="p">))</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">XFS_MOUNT_ATTR2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_hasattr2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_NOATTR2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_sb_version_removeattr2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">);</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_update_flags</span> <span class="o">|=</span> <span class="n">XFS_SB_FEATURES2</span><span class="p">;</span>

		<span class="cm">/* update sb_versionnum for the clearing of the morebits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_features2</span><span class="p">)</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_update_flags</span> <span class="o">|=</span> <span class="n">XFS_SB_VERSIONNUM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if sb_agblocks is aligned at stripe boundary</span>
<span class="cm">	 * If sb_agblocks is NOT aligned turn off m_dalign since</span>
<span class="cm">	 * allocator alignment is within an ag, therefore ag has</span>
<span class="cm">	 * to be aligned at stripe boundary.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_update_alignment</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">xfs_alloc_compute_maxlevels</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">xfs_bmap_compute_maxlevels</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
	<span class="n">xfs_bmap_compute_maxlevels</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="n">xfs_ialloc_compute_maxlevels</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="n">xfs_set_maxicount</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxioffset</span> <span class="o">=</span> <span class="n">xfs_max_file_offset</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_blocklog</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_uuid_mount</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the minimum read and write sizes</span>
<span class="cm">	 */</span>
	<span class="n">xfs_set_rw_sizes</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/* set the low space thresholds for dynamic preallocation */</span>
	<span class="n">xfs_set_low_space_thresholds</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the inode cluster size.</span>
<span class="cm">	 * This may still be overridden by the file system</span>
<span class="cm">	 * block size if it is larger than the chosen cluster size.</span>
<span class="cm">	 */</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inode_cluster_size</span> <span class="o">=</span> <span class="n">XFS_INODE_BIG_CLUSTER_SIZE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set inode alignment fields</span>
<span class="cm">	 */</span>
	<span class="n">xfs_set_inoalignment</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check that the data (and log if separate) are an ok size.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_check_sizes</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_remove_uuid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize realtime fields in the mount structure</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtmount_init</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;RT mount failed&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_remove_uuid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Copies the low order bits of the timestamp and the randomly</span>
<span class="cm">	 *  set &quot;sequence&quot; number out of a UUID.</span>
<span class="cm">	 */</span>
	<span class="n">uuid_getnodeuniq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_uuid</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_fixedfsid</span><span class="p">);</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_dmevmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* not persistent; set after each mount */</span>

	<span class="n">xfs_dir_mount</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the attribute manager&#39;s entries.</span>
<span class="cm">	 */</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_attr_magicpct</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span> <span class="o">*</span> <span class="mi">37</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the precomputed transaction reservations values.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_init</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate and initialize the per-ag data.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_perag_lock</span><span class="p">);</span>
	<span class="n">INIT_RADIX_TREE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_perag_tree</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_initialize_perag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_agcount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxagi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;Failed per-ag init: %d&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_remove_uuid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_logblocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;no log defined&quot;</span><span class="p">);</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_mountfs&quot;</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_perag</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * log&#39;s mount-time initialization. Perform 1st part recovery if needed</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_log_mount</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span><span class="p">,</span>
			      <span class="n">XFS_FSB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_logstart</span><span class="p">),</span>
			      <span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_logblocks</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;log mount failed&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_fail_wait</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now the log is mounted, we know if it was an unclean shutdown or</span>
<span class="cm">	 * not. If it was, with the first phase of recovery has completed, we</span>
<span class="cm">	 * have consistent AG blocks on disk. We have not recovered EFIs yet,</span>
<span class="cm">	 * but they are recovered transactionally in the second recovery phase</span>
<span class="cm">	 * later.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Hence we can safely re-initialise incore superblock counters from</span>
<span class="cm">	 * the per-ag data. These may not be correct if the filesystem was not</span>
<span class="cm">	 * cleanly unmounted, so we need to wait for recovery to finish before</span>
<span class="cm">	 * doing this.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the filesystem was cleanly unmounted, then we can trust the</span>
<span class="cm">	 * values in the superblock to be correct and we don&#39;t need to do</span>
<span class="cm">	 * anything here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we are currently making the filesystem, the initialisation will</span>
<span class="cm">	 * fail as the perag data is in an undefined state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_haslazysbcount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">XFS_LAST_UNMOUNT_WAS_CLEAN</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inprogress</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_initialize_perag_data</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_agcount</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_fail_wait</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get and sanity-check the root inode.</span>
<span class="cm">	 * Save the pointer to it in the mount structure.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iget</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">sb_rootino</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;failed to read root inode&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_log_dealloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">rip</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">rip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;corrupted root inode %llu: not a directory&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">rip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">rip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_mountfs_int(2)&quot;</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
				 <span class="n">mp</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_rele_rip</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rootip</span> <span class="o">=</span> <span class="n">rip</span><span class="p">;</span>	<span class="cm">/* save it */</span>

	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">rip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize realtime inode pointers in the mount structure</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_rtmount_inodes</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Free up the root inode.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;failed to read RT inodes&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_rele_rip</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a read-only mount defer the superblock updates until</span>
<span class="cm">	 * the next remount into writeable mode.  Otherwise we would never</span>
<span class="cm">	 * perform the update e.g. for the root filesystem.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_update_flags</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RDONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_mount_log_sb</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_update_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;failed to write sb changes&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_rtunmount</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialise the XFS quota management subsystem for this mount</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_IS_QUOTA_RUNNING</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_newmount</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">quotamount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">quotaflags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_rtunmount</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">XFS_IS_QUOTA_ON</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * If a file system had quotas running earlier, but decided to</span>
<span class="cm">		 * mount without -o uquota/pquota/gquota options, revoke the</span>
<span class="cm">		 * quotachecked license.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_qflags</span> <span class="o">&amp;</span> <span class="n">XFS_ALL_QUOTA_ACCT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_notice</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;resetting quota flags&quot;</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_mount_reset_sbqflags</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finish recovering the file system.  This part needed to be</span>
<span class="cm">	 * delayed until after the root and real-time bitmap inodes</span>
<span class="cm">	 * were consistently read in.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_log_mount_finish</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;log mount finish failed&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_rtunmount</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Complete the quota initialisation, post-log-replay component.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">quotamount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_qflags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_qflags</span> <span class="o">=</span> <span class="n">quotaflags</span><span class="p">;</span>

		<span class="n">xfs_qm_mount_quotas</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we are mounted, reserve a small amount of unused space for</span>
<span class="cm">	 * privileged transactions. This is needed so that transaction</span>
<span class="cm">	 * space required for critical operations can dip into this pool</span>
<span class="cm">	 * when at ENOSPC. This is needed for operations like create with</span>
<span class="cm">	 * attr, unwritten extent conversion at ENOSPC, etc. Data allocations</span>
<span class="cm">	 * are not allowed to use this reserved space.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This may drive us straight to ENOSPC on mount, but that implies</span>
<span class="cm">	 * we were already there on the last unmount. Warn if this occurs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RDONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">resblks</span> <span class="o">=</span> <span class="n">xfs_default_resblks</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_reserve_blocks</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resblks</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
	<span class="s">&quot;Unable to allocate reserve blocks. Continuing without reserve pool.&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_rtunmount:</span>
	<span class="n">xfs_rtunmount_inodes</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
 <span class="nl">out_rele_rip:</span>
	<span class="n">IRELE</span><span class="p">(</span><span class="n">rip</span><span class="p">);</span>
 <span class="nl">out_log_dealloc:</span>
	<span class="n">xfs_log_unmount</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
 <span class="nl">out_fail_wait:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span> <span class="o">&amp;&amp;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span> <span class="o">!=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">)</span>
		<span class="n">xfs_wait_buftarg</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span><span class="p">);</span>
	<span class="n">xfs_wait_buftarg</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">);</span>
 <span class="nl">out_free_perag:</span>
	<span class="n">xfs_free_perag</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
 <span class="nl">out_remove_uuid:</span>
	<span class="n">xfs_uuid_unmount</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This flushes out the inodes,dquots and the superblock, unmounts the</span>
<span class="cm"> * log and makes sure that incore structures are freed.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_unmountfs</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__uint64_t</span>		<span class="n">resblks</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">xfs_qm_unmount_quotas</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">xfs_rtunmount_inodes</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">IRELE</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rootip</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can potentially deadlock here if we have an inode cluster</span>
<span class="cm">	 * that has been freed has its buffer still pinned in memory because</span>
<span class="cm">	 * the transaction is still sitting in a iclog. The stale inodes</span>
<span class="cm">	 * on that buffer will have their flush locks held until the</span>
<span class="cm">	 * transaction hits the disk and the callbacks run. the inode</span>
<span class="cm">	 * flush takes the flush lock unconditionally and with nothing to</span>
<span class="cm">	 * push out the iclog we will never get that unlocked. hence we</span>
<span class="cm">	 * need to force the log first.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_log_force</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_LOG_SYNC</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flush all pending changes from the AIL.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_ail_push_all_sync</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ail</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * And reclaim all inodes.  At this point there should be no dirty</span>
<span class="cm">	 * inode, and none should be pinned or locked, but use synchronous</span>
<span class="cm">	 * reclaim just to be sure.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_reclaim_inodes</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">SYNC_WAIT</span><span class="p">);</span>

	<span class="n">xfs_qm_unmount</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flush out the log synchronously so that we know for sure</span>
<span class="cm">	 * that nothing is pinned.  This is important because bflush()</span>
<span class="cm">	 * will skip pinned buffers.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_log_force</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_LOG_SYNC</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unreserve any blocks we have so that when we unmount we don&#39;t account</span>
<span class="cm">	 * the reserved free space as used. This is really only necessary for</span>
<span class="cm">	 * lazy superblock counting because it trusts the incore superblock</span>
<span class="cm">	 * counters to be absolutely correct on clean unmount.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We don&#39;t bother correcting this elsewhere for lazy superblock</span>
<span class="cm">	 * counting because on mount of an unclean filesystem we reconstruct the</span>
<span class="cm">	 * correct counter value and this is irrelevant.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For non-lazy counter filesystems, this doesn&#39;t matter at all because</span>
<span class="cm">	 * we only every apply deltas to the superblock and hence the incore</span>
<span class="cm">	 * value does not matter....</span>
<span class="cm">	 */</span>
	<span class="n">resblks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_reserve_blocks</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resblks</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;Unable to free reserved block pool. &quot;</span>
				<span class="s">&quot;Freespace may not be correct on next mount.&quot;</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_log_sbcount</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;Unable to update superblock counters. &quot;</span>
				<span class="s">&quot;Freespace may not be correct on next mount.&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point we might have modified the superblock again and thus</span>
<span class="cm">	 * added an item to the AIL, thus flush it again.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_ail_push_all_sync</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ail</span><span class="p">);</span>
	<span class="n">xfs_wait_buftarg</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">);</span>

	<span class="n">xfs_log_unmount_write</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">xfs_log_unmount</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">xfs_uuid_unmount</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

<span class="cp">#if defined(DEBUG)</span>
	<span class="n">xfs_errortag_clearall</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">xfs_free_perag</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_fs_writable</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">xfs_test_for_freeze</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">||</span> <span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RDONLY</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_log_sbcount</span>
<span class="cm"> *</span>
<span class="cm"> * Sync the superblock counters to disk.</span>
<span class="cm"> *</span>
<span class="cm"> * Note this code can be called during the process of freezing, so</span>
<span class="cm"> * we may need to use the transaction allocator which does not</span>
<span class="cm"> * block when the transaction subsystem is in its frozen state.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_log_sbcount</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_fs_writable</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">xfs_icsb_sync_counters</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we don&#39;t need to do this if we are updating the superblock</span>
<span class="cm">	 * counters on every modification.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_sb_version_haslazysbcount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">_xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_COUNT</span><span class="p">,</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_sectsize</span> <span class="o">+</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">XFS_DEFAULT_LOG_COUNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_SB_IFREE</span> <span class="o">|</span> <span class="n">XFS_SB_ICOUNT</span> <span class="o">|</span> <span class="n">XFS_SB_FDBLOCKS</span><span class="p">);</span>
	<span class="n">xfs_trans_set_sync</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_mod_sb() can be used to copy arbitrary changes to the</span>
<span class="cm"> * in-core superblock into the superblock buffer to be logged.</span>
<span class="cm"> * It does not provide the higher level of locking that is</span>
<span class="cm"> * needed to protect the in-core superblock from concurrent</span>
<span class="cm"> * access.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_mod_sb</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">__int64_t</span> <span class="n">fields</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">first</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">last</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_sb_field_t</span>	<span class="n">f</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">fields</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fields</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_trans_getsb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">first</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_sb_t</span><span class="p">);</span>
	<span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* translate/copy */</span>

	<span class="n">xfs_sb_to_disk</span><span class="p">(</span><span class="n">XFS_BUF_TO_SBP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">,</span> <span class="n">fields</span><span class="p">);</span>

	<span class="cm">/* find modified range */</span>
	<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_sb_field_t</span><span class="p">)</span><span class="n">xfs_highbit64</span><span class="p">((</span><span class="n">__uint64_t</span><span class="p">)</span><span class="n">fields</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">XFS_SB_MOD_BITS</span><span class="p">);</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">xfs_sb_info</span><span class="p">[</span><span class="n">f</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_sb_field_t</span><span class="p">)</span><span class="n">xfs_lowbit64</span><span class="p">((</span><span class="n">__uint64_t</span><span class="p">)</span><span class="n">fields</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">XFS_SB_MOD_BITS</span><span class="p">);</span>
	<span class="n">first</span> <span class="o">=</span> <span class="n">xfs_sb_info</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>

	<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * xfs_mod_incore_sb_unlocked() is a utility routine common used to apply</span>
<span class="cm"> * a delta to a specified field in the in-core superblock.  Simply</span>
<span class="cm"> * switch on the field indicated and apply the delta to that field.</span>
<span class="cm"> * Fields are not allowed to dip below zero, so if the delta would</span>
<span class="cm"> * do this do not apply it and return EINVAL.</span>
<span class="cm"> *</span>
<span class="cm"> * The m_sb_lock must be held when this routine is called.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_mod_incore_sb_unlocked</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_sb_field_t</span>	<span class="n">field</span><span class="p">,</span>
	<span class="kt">int64_t</span>		<span class="n">delta</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">rsvd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">scounter</span><span class="p">;</span>	<span class="cm">/* short counter for 32 bit fields */</span>
	<span class="kt">long</span> <span class="kt">long</span>	<span class="n">lcounter</span><span class="p">;</span>	<span class="cm">/* long counter for 64 bit fields */</span>
	<span class="kt">long</span> <span class="kt">long</span>	<span class="n">res_used</span><span class="p">,</span> <span class="n">rem</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * With the in-core superblock spin lock held, switch</span>
<span class="cm">	 * on the indicated field.  Apply the delta to the</span>
<span class="cm">	 * proper field.  If the fields value would dip below</span>
<span class="cm">	 * 0, then do not apply the delta and return EINVAL.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_SBS_ICOUNT</span>:
		<span class="n">lcounter</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_icount</span><span class="p">;</span>
		<span class="n">lcounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lcounter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_icount</span> <span class="o">=</span> <span class="n">lcounter</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_SBS_IFREE</span>:
		<span class="n">lcounter</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_ifree</span><span class="p">;</span>
		<span class="n">lcounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lcounter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_ifree</span> <span class="o">=</span> <span class="n">lcounter</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_SBS_FDBLOCKS</span>:
		<span class="n">lcounter</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_fdblocks</span> <span class="o">-</span> <span class="n">XFS_ALLOC_SET_ASIDE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">res_used</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_resblks</span> <span class="o">-</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_resblks_avail</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* Putting blocks back */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res_used</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_resblks_avail</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">rem</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">-</span> <span class="n">res_used</span><span class="p">;</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_resblks_avail</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_resblks</span><span class="p">;</span>
				<span class="n">lcounter</span> <span class="o">+=</span> <span class="n">rem</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>				<span class="cm">/* Taking blocks away */</span>
			<span class="n">lcounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lcounter</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_fdblocks</span> <span class="o">=</span> <span class="n">lcounter</span> <span class="o">+</span>
							<span class="n">XFS_ALLOC_SET_ASIDE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * We are out of blocks, use any available reserved</span>
<span class="cm">			 * blocks if were allowed to.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsvd</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSPC</span><span class="p">);</span>

			<span class="n">lcounter</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_resblks_avail</span> <span class="o">+</span> <span class="n">delta</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lcounter</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_resblks_avail</span> <span class="o">=</span> <span class="n">lcounter</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;Filesystem </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">: reserve blocks depleted! &quot;</span>
				<span class="s">&quot;Consider increasing reserve pool size.&quot;</span><span class="p">,</span>
				<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_fsname</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSPC</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_fdblocks</span> <span class="o">=</span> <span class="n">lcounter</span> <span class="o">+</span> <span class="n">XFS_ALLOC_SET_ASIDE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_SBS_FREXTENTS</span>:
		<span class="n">lcounter</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_frextents</span><span class="p">;</span>
		<span class="n">lcounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lcounter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSPC</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_frextents</span> <span class="o">=</span> <span class="n">lcounter</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_SBS_DBLOCKS</span>:
		<span class="n">lcounter</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_dblocks</span><span class="p">;</span>
		<span class="n">lcounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lcounter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_dblocks</span> <span class="o">=</span> <span class="n">lcounter</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_SBS_AGCOUNT</span>:
		<span class="n">scounter</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span><span class="p">;</span>
		<span class="n">scounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scounter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_agcount</span> <span class="o">=</span> <span class="n">scounter</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_SBS_IMAX_PCT</span>:
		<span class="n">scounter</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_imax_pct</span><span class="p">;</span>
		<span class="n">scounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scounter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_imax_pct</span> <span class="o">=</span> <span class="n">scounter</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_SBS_REXTSIZE</span>:
		<span class="n">scounter</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextsize</span><span class="p">;</span>
		<span class="n">scounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scounter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextsize</span> <span class="o">=</span> <span class="n">scounter</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_SBS_RBMBLOCKS</span>:
		<span class="n">scounter</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rbmblocks</span><span class="p">;</span>
		<span class="n">scounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scounter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rbmblocks</span> <span class="o">=</span> <span class="n">scounter</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_SBS_RBLOCKS</span>:
		<span class="n">lcounter</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rblocks</span><span class="p">;</span>
		<span class="n">lcounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lcounter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rblocks</span> <span class="o">=</span> <span class="n">lcounter</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_SBS_REXTENTS</span>:
		<span class="n">lcounter</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextents</span><span class="p">;</span>
		<span class="n">lcounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lcounter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextents</span> <span class="o">=</span> <span class="n">lcounter</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_SBS_REXTSLOG</span>:
		<span class="n">scounter</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextslog</span><span class="p">;</span>
		<span class="n">scounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scounter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextslog</span> <span class="o">=</span> <span class="n">scounter</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_mod_incore_sb() is used to change a field in the in-core</span>
<span class="cm"> * superblock structure by the specified delta.  This modification</span>
<span class="cm"> * is protected by the m_sb_lock.  Just use the xfs_mod_incore_sb_unlocked()</span>
<span class="cm"> * routine to do the work.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_mod_incore_sb</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_sb_field_t</span>		<span class="n">field</span><span class="p">,</span>
	<span class="kt">int64_t</span>			<span class="n">delta</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">rsvd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

<span class="cp">#ifdef HAVE_PERCPU_SB</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">field</span> <span class="o">&lt;</span> <span class="n">XFS_SBS_ICOUNT</span> <span class="o">||</span> <span class="n">field</span> <span class="o">&gt;</span> <span class="n">XFS_SBS_FDBLOCKS</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">xfs_mod_incore_sb_unlocked</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">rsvd</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Change more than one field in the in-core superblock structure at a time.</span>
<span class="cm"> *</span>
<span class="cm"> * The fields and changes to those fields are specified in the array of</span>
<span class="cm"> * xfs_mod_sb structures passed in.  Either all of the specified deltas</span>
<span class="cm"> * will be applied or none of them will.  If any modified field dips below 0,</span>
<span class="cm"> * then all modifications will be backed out and EINVAL will be returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function may not be used for the superblock values that</span>
<span class="cm"> * are tracked with the in-memory per-cpu counters - a direct call to</span>
<span class="cm"> * xfs_icsb_modify_counters is required for these.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_mod_incore_sb_batch</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_mod_sb_t</span>		<span class="o">*</span><span class="n">msb</span><span class="p">,</span>
	<span class="n">uint</span>			<span class="n">nmsb</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">rsvd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mod_sb_t</span>		<span class="o">*</span><span class="n">msbp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Loop through the array of mod structures and apply each individually.</span>
<span class="cm">	 * If any fail, then back out all those which have already been applied.</span>
<span class="cm">	 * Do all of this within the scope of the m_sb_lock so that all of the</span>
<span class="cm">	 * changes will be atomic.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">msbp</span> <span class="o">=</span> <span class="n">msb</span><span class="p">;</span> <span class="n">msbp</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">msb</span> <span class="o">+</span> <span class="n">nmsb</span><span class="p">);</span> <span class="n">msbp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">msbp</span><span class="o">-&gt;</span><span class="n">msb_field</span> <span class="o">&lt;</span> <span class="n">XFS_SBS_ICOUNT</span> <span class="o">||</span>
		       <span class="n">msbp</span><span class="o">-&gt;</span><span class="n">msb_field</span> <span class="o">&gt;</span> <span class="n">XFS_SBS_FDBLOCKS</span><span class="p">);</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_mod_incore_sb_unlocked</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">msbp</span><span class="o">-&gt;</span><span class="n">msb_field</span><span class="p">,</span>
						   <span class="n">msbp</span><span class="o">-&gt;</span><span class="n">msb_delta</span><span class="p">,</span> <span class="n">rsvd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">unwind:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">msbp</span> <span class="o">&gt;=</span> <span class="n">msb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_mod_incore_sb_unlocked</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">msbp</span><span class="o">-&gt;</span><span class="n">msb_field</span><span class="p">,</span>
						   <span class="o">-</span><span class="n">msbp</span><span class="o">-&gt;</span><span class="n">msb_delta</span><span class="p">,</span> <span class="n">rsvd</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_getsb() is called to obtain the buffer for the superblock.</span>
<span class="cm"> * The buffer is returned locked and read in from disk.</span>
<span class="cm"> * The buffer should be released with a call to xfs_brelse().</span>
<span class="cm"> *</span>
<span class="cm"> * If the flags parameter is BUF_TRYLOCK, then we&#39;ll only return</span>
<span class="cm"> * the superblock buffer if it can be locked without sleeping.</span>
<span class="cm"> * If it can&#39;t then we&#39;ll return NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfs_buf</span> <span class="o">*</span>
<span class="nf">xfs_getsb</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_bp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_buf_trylock</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XBF_TRYLOCK</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">xfs_buf_lock</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xfs_buf_hold</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_BUF_ISDONE</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Used to free the superblock along various error paths.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_freesb</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_bp</span><span class="p">;</span>

	<span class="n">xfs_buf_lock</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Used to log changes to the superblock unit and width fields which could</span>
<span class="cm"> * be altered by the mount options, as well as any potential sb_features2</span>
<span class="cm"> * fixup. Only the first superblock is updated.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_mount_log_sb</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">__int64_t</span>	<span class="n">fields</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">fields</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XFS_SB_UNIT</span> <span class="o">|</span> <span class="n">XFS_SB_WIDTH</span> <span class="o">|</span> <span class="n">XFS_SB_UUID</span> <span class="o">|</span>
			 <span class="n">XFS_SB_FEATURES2</span> <span class="o">|</span> <span class="n">XFS_SB_BAD_FEATURES2</span> <span class="o">|</span>
			 <span class="n">XFS_SB_VERSIONNUM</span><span class="p">));</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_SB_UNIT</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_sectsize</span> <span class="o">+</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">XFS_DEFAULT_LOG_COUNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">fields</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If the underlying (data/log/rt) device is readonly, there are some</span>
<span class="cm"> * operations that cannot proceed.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_dev_is_read_only</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_readonly_buftarg</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">xfs_readonly_buftarg</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_logdev_targp</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rtdev_targp</span> <span class="o">&amp;&amp;</span> <span class="n">xfs_readonly_buftarg</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rtdev_targp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_notice</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s required on read-only device.&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
		<span class="n">xfs_notice</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;write access unavailable, cannot proceed.&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EROFS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef HAVE_PERCPU_SB</span>
<span class="cm">/*</span>
<span class="cm"> * Per-cpu incore superblock counters</span>
<span class="cm"> *</span>
<span class="cm"> * Simple concept, difficult implementation</span>
<span class="cm"> *</span>
<span class="cm"> * Basically, replace the incore superblock counters with a distributed per cpu</span>
<span class="cm"> * counter for contended fields (e.g.  free block count).</span>
<span class="cm"> *</span>
<span class="cm"> * Difficulties arise in that the incore sb is used for ENOSPC checking, and</span>
<span class="cm"> * hence needs to be accurately read when we are running low on space. Hence</span>
<span class="cm"> * there is a method to enable and disable the per-cpu counters based on how</span>
<span class="cm"> * much &quot;stuff&quot; is available in them.</span>
<span class="cm"> *</span>
<span class="cm"> * Basically, a counter is enabled if there is enough free resource to justify</span>
<span class="cm"> * running a per-cpu fast-path. If the per-cpu counter runs out (i.e. a local</span>
<span class="cm"> * ENOSPC), then we disable the counters to synchronise all callers and</span>
<span class="cm"> * re-distribute the available resources.</span>
<span class="cm"> *</span>
<span class="cm"> * If, once we redistributed the available resources, we still get a failure,</span>
<span class="cm"> * we disable the per-cpu counter and go through the slow path.</span>
<span class="cm"> *</span>
<span class="cm"> * The slow path is the current xfs_mod_incore_sb() function.  This means that</span>
<span class="cm"> * when we disable a per-cpu counter, we need to drain its resources back to</span>
<span class="cm"> * the global superblock. We do this after disabling the counter to prevent</span>
<span class="cm"> * more threads from queueing up on the counter.</span>
<span class="cm"> *</span>
<span class="cm"> * Essentially, this means that we still need a lock in the fast path to enable</span>
<span class="cm"> * synchronisation between the global counters and the per-cpu counters. This</span>
<span class="cm"> * is not a problem because the lock will be local to a CPU almost all the time</span>
<span class="cm"> * and have little contention except when we get to ENOSPC conditions.</span>
<span class="cm"> *</span>
<span class="cm"> * Basically, this lock becomes a barrier that enables us to lock out the fast</span>
<span class="cm"> * path while we do things like enabling and disabling counters and</span>
<span class="cm"> * synchronising the counters.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking rules:</span>
<span class="cm"> *</span>
<span class="cm"> * 	1. m_sb_lock before picking up per-cpu locks</span>
<span class="cm"> * 	2. per-cpu locks always picked up via for_each_online_cpu() order</span>
<span class="cm"> * 	3. accurate counter sync requires m_sb_lock + per cpu locks</span>
<span class="cm"> * 	4. modifying per-cpu counters requires holding per-cpu lock</span>
<span class="cm"> * 	5. modifying global counters requires holding m_sb_lock</span>
<span class="cm"> *	6. enabling or disabling a counter requires holding the m_sb_lock </span>
<span class="cm"> *	   and _none_ of the per-cpu locks.</span>
<span class="cm"> *</span>
<span class="cm"> * Disabled counters are only ever re-enabled by a balance operation</span>
<span class="cm"> * that results in more free resources per CPU than a given threshold.</span>
<span class="cm"> * To ensure counters don&#39;t remain disabled, they are rebalanced when</span>
<span class="cm"> * the global resource goes above a higher threshold (i.e. some hysteresis</span>
<span class="cm"> * is present to prevent thrashing).</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="cm">/*</span>
<span class="cm"> * hot-plug CPU notifier support.</span>
<span class="cm"> *</span>
<span class="cm"> * We need a notifier per filesystem as we need to be able to identify</span>
<span class="cm"> * the filesystem to balance the counters out. This is achieved by</span>
<span class="cm"> * having a notifier block embedded in the xfs_mount_t and doing pointer</span>
<span class="cm"> * magic to get the mount pointer from the notifier block address.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_icsb_cpu_notify</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_icsb_cnts_t</span> <span class="o">*</span><span class="n">cntp</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="p">)</span><span class="n">container_of</span><span class="p">(</span><span class="n">nfb</span><span class="p">,</span> <span class="n">xfs_mount_t</span><span class="p">,</span> <span class="n">m_icsb_notifier</span><span class="p">);</span>
	<span class="n">cntp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_icsb_cnts_t</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_cnts</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE_FROZEN</span>:
		<span class="cm">/* Easy Case - initialize the area and locks, and</span>
<span class="cm">		 * then rebalance when online does everything else for us. */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">cntp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_icsb_cnts_t</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
	<span class="k">case</span> <span class="n">CPU_ONLINE_FROZEN</span>:
		<span class="n">xfs_icsb_lock</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">xfs_icsb_balance_counter</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_ICOUNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">xfs_icsb_balance_counter</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_IFREE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">xfs_icsb_balance_counter</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_FDBLOCKS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">xfs_icsb_unlock</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD_FROZEN</span>:
		<span class="cm">/* Disable all the counters, then fold the dead cpu&#39;s</span>
<span class="cm">		 * count into the total on the global superblock and</span>
<span class="cm">		 * re-enable the counters. */</span>
		<span class="n">xfs_icsb_lock</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
		<span class="n">xfs_icsb_disable_counter</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_ICOUNT</span><span class="p">);</span>
		<span class="n">xfs_icsb_disable_counter</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_IFREE</span><span class="p">);</span>
		<span class="n">xfs_icsb_disable_counter</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_FDBLOCKS</span><span class="p">);</span>

		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_icount</span> <span class="o">+=</span> <span class="n">cntp</span><span class="o">-&gt;</span><span class="n">icsb_icount</span><span class="p">;</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_ifree</span> <span class="o">+=</span> <span class="n">cntp</span><span class="o">-&gt;</span><span class="n">icsb_ifree</span><span class="p">;</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_fdblocks</span> <span class="o">+=</span> <span class="n">cntp</span><span class="o">-&gt;</span><span class="n">icsb_fdblocks</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">cntp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_icsb_cnts_t</span><span class="p">));</span>

		<span class="n">xfs_icsb_balance_counter_locked</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_ICOUNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">xfs_icsb_balance_counter_locked</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_IFREE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">xfs_icsb_balance_counter_locked</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_FDBLOCKS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
		<span class="n">xfs_icsb_unlock</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">xfs_icsb_init_counters</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_icsb_cnts_t</span> <span class="o">*</span><span class="n">cntp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_cnts</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="n">xfs_icsb_cnts_t</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_cnts</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_icsb_notifier</span><span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">xfs_icsb_cpu_notify</span><span class="p">;</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_icsb_notifier</span><span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">register_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_icsb_notifier</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cntp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_icsb_cnts_t</span> <span class="o">*</span><span class="p">)</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_cnts</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">cntp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_icsb_cnts_t</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_icsb_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * start with all counters disabled so that the</span>
<span class="cm">	 * initial balance kicks us off correctly</span>
<span class="cm">	 */</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_icsb_counters</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_icsb_reinit_counters</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_icsb_lock</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * start with all counters disabled so that the</span>
<span class="cm">	 * initial balance kicks us off correctly</span>
<span class="cm">	 */</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_icsb_counters</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">xfs_icsb_balance_counter</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_ICOUNT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">xfs_icsb_balance_counter</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_IFREE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">xfs_icsb_balance_counter</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_FDBLOCKS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">xfs_icsb_unlock</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_icsb_destroy_counters</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_cnts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unregister_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_icsb_notifier</span><span class="p">);</span>
		<span class="n">free_percpu</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_cnts</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_icsb_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_icsb_lock_cntr</span><span class="p">(</span>
	<span class="n">xfs_icsb_cnts_t</span>	<span class="o">*</span><span class="n">icsbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">XFS_ICSB_FLAG_LOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icsbp</span><span class="o">-&gt;</span><span class="n">icsb_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ndelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_icsb_unlock_cntr</span><span class="p">(</span>
	<span class="n">xfs_icsb_cnts_t</span>	<span class="o">*</span><span class="n">icsbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">XFS_ICSB_FLAG_LOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icsbp</span><span class="o">-&gt;</span><span class="n">icsb_flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_icsb_lock_all_counters</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_icsb_cnts_t</span> <span class="o">*</span><span class="n">cntp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cntp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_icsb_cnts_t</span> <span class="o">*</span><span class="p">)</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_cnts</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">xfs_icsb_lock_cntr</span><span class="p">(</span><span class="n">cntp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_icsb_unlock_all_counters</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_icsb_cnts_t</span> <span class="o">*</span><span class="n">cntp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cntp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_icsb_cnts_t</span> <span class="o">*</span><span class="p">)</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_cnts</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">xfs_icsb_unlock_cntr</span><span class="p">(</span><span class="n">cntp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_icsb_count</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_icsb_cnts_t</span>	<span class="o">*</span><span class="n">cnt</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_icsb_cnts_t</span> <span class="o">*</span><span class="n">cntp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_icsb_cnts_t</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ICSB_LAZY_COUNT</span><span class="p">))</span>
		<span class="n">xfs_icsb_lock_all_counters</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cntp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_icsb_cnts_t</span> <span class="o">*</span><span class="p">)</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_cnts</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">cnt</span><span class="o">-&gt;</span><span class="n">icsb_icount</span> <span class="o">+=</span> <span class="n">cntp</span><span class="o">-&gt;</span><span class="n">icsb_icount</span><span class="p">;</span>
		<span class="n">cnt</span><span class="o">-&gt;</span><span class="n">icsb_ifree</span> <span class="o">+=</span> <span class="n">cntp</span><span class="o">-&gt;</span><span class="n">icsb_ifree</span><span class="p">;</span>
		<span class="n">cnt</span><span class="o">-&gt;</span><span class="n">icsb_fdblocks</span> <span class="o">+=</span> <span class="n">cntp</span><span class="o">-&gt;</span><span class="n">icsb_fdblocks</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ICSB_LAZY_COUNT</span><span class="p">))</span>
		<span class="n">xfs_icsb_unlock_all_counters</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_icsb_counter_disabled</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_sb_field_t</span>	<span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">field</span> <span class="o">&gt;=</span> <span class="n">XFS_SBS_ICOUNT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">field</span> <span class="o">&lt;=</span> <span class="n">XFS_SBS_FDBLOCKS</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_icsb_counters</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_icsb_disable_counter</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_sb_field_t</span>	<span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_icsb_cnts_t</span>	<span class="n">cnt</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">((</span><span class="n">field</span> <span class="o">&gt;=</span> <span class="n">XFS_SBS_ICOUNT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">field</span> <span class="o">&lt;=</span> <span class="n">XFS_SBS_FDBLOCKS</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are already disabled, then there is nothing to do</span>
<span class="cm">	 * here. We check before locking all the counters to avoid</span>
<span class="cm">	 * the expensive lock operation when being called in the</span>
<span class="cm">	 * slow path and the counter is already disabled. This is</span>
<span class="cm">	 * safe because the only time we set or clear this state is under</span>
<span class="cm">	 * the m_icsb_mutex.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_icsb_counter_disabled</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">field</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">xfs_icsb_lock_all_counters</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_icsb_counters</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* drain back to superblock */</span>

		<span class="n">xfs_icsb_count</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="n">XFS_ICSB_LAZY_COUNT</span><span class="p">);</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">XFS_SBS_ICOUNT</span>:
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_icount</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">.</span><span class="n">icsb_icount</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XFS_SBS_IFREE</span>:
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_ifree</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">.</span><span class="n">icsb_ifree</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XFS_SBS_FDBLOCKS</span>:
			<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_fdblocks</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">.</span><span class="n">icsb_fdblocks</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">xfs_icsb_unlock_all_counters</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_icsb_enable_counter</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_sb_field_t</span>	<span class="n">field</span><span class="p">,</span>
	<span class="kt">uint64_t</span>	<span class="n">count</span><span class="p">,</span>
	<span class="kt">uint64_t</span>	<span class="n">resid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_icsb_cnts_t</span>	<span class="o">*</span><span class="n">cntp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">((</span><span class="n">field</span> <span class="o">&gt;=</span> <span class="n">XFS_SBS_ICOUNT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">field</span> <span class="o">&lt;=</span> <span class="n">XFS_SBS_FDBLOCKS</span><span class="p">));</span>

	<span class="n">xfs_icsb_lock_all_counters</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cntp</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_cnts</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">XFS_SBS_ICOUNT</span>:
			<span class="n">cntp</span><span class="o">-&gt;</span><span class="n">icsb_icount</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="n">resid</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XFS_SBS_IFREE</span>:
			<span class="n">cntp</span><span class="o">-&gt;</span><span class="n">icsb_ifree</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="n">resid</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XFS_SBS_FDBLOCKS</span>:
			<span class="n">cntp</span><span class="o">-&gt;</span><span class="n">icsb_fdblocks</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="n">resid</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">resid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_icsb_counters</span><span class="p">);</span>
	<span class="n">xfs_icsb_unlock_all_counters</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_icsb_sync_counters_locked</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_icsb_cnts_t</span>	<span class="n">cnt</span><span class="p">;</span>

	<span class="n">xfs_icsb_count</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_icsb_counter_disabled</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_ICOUNT</span><span class="p">))</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_icount</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">.</span><span class="n">icsb_icount</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_icsb_counter_disabled</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_IFREE</span><span class="p">))</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_ifree</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">.</span><span class="n">icsb_ifree</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_icsb_counter_disabled</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_SBS_FDBLOCKS</span><span class="p">))</span>
		<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_fdblocks</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">.</span><span class="n">icsb_fdblocks</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Accurate update of per-cpu counters to incore superblock</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_icsb_sync_counters</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
	<span class="n">xfs_icsb_sync_counters_locked</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Balance and enable/disable counters as necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * Thresholds for re-enabling counters are somewhat magic.  inode counts are</span>
<span class="cm"> * chosen to be the same number as single on disk allocation chunk per CPU, and</span>
<span class="cm"> * free blocks is something far enough zero that we aren&#39;t going thrash when we</span>
<span class="cm"> * get near ENOSPC. We also need to supply a minimum we require per cpu to</span>
<span class="cm"> * prevent looping endlessly when xfs_alloc_space asks for more than will</span>
<span class="cm"> * be distributed to a single CPU but each CPU has enough blocks to be</span>
<span class="cm"> * reenabled.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we can be called when counters are already disabled.</span>
<span class="cm"> * xfs_icsb_disable_counter() optimises the counter locking in this case to</span>
<span class="cm"> * prevent locking every per-cpu counter needlessly.</span>
<span class="cm"> */</span>

<span class="cp">#define XFS_ICSB_INO_CNTR_REENABLE	(uint64_t)64</span>
<span class="cp">#define XFS_ICSB_FDBLK_CNTR_REENABLE(mp) \</span>
<span class="cp">		(uint64_t)(512 + XFS_ALLOC_SET_ASIDE(mp))</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_icsb_balance_counter_locked</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_sb_field_t</span>  <span class="n">field</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">min_per_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span>	<span class="n">count</span><span class="p">,</span> <span class="n">resid</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">weight</span> <span class="o">=</span> <span class="n">num_online_cpus</span><span class="p">();</span>
	<span class="kt">uint64_t</span>	<span class="n">min</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">min_per_cpu</span><span class="p">;</span>

	<span class="cm">/* disable counter and sync counter */</span>
	<span class="n">xfs_icsb_disable_counter</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">field</span><span class="p">);</span>

	<span class="cm">/* update counters  - first CPU gets residual*/</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_SBS_ICOUNT</span>:
		<span class="n">count</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_icount</span><span class="p">;</span>
		<span class="n">resid</span> <span class="o">=</span> <span class="n">do_div</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">XFS_ICSB_INO_CNTR_REENABLE</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_SBS_IFREE</span>:
		<span class="n">count</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_ifree</span><span class="p">;</span>
		<span class="n">resid</span> <span class="o">=</span> <span class="n">do_div</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">XFS_ICSB_INO_CNTR_REENABLE</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_SBS_FDBLOCKS</span>:
		<span class="n">count</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_fdblocks</span><span class="p">;</span>
		<span class="n">resid</span> <span class="o">=</span> <span class="n">do_div</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">XFS_ICSB_FDBLK_CNTR_REENABLE</span><span class="p">(</span><span class="n">mp</span><span class="p">)))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">resid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* quiet, gcc */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_icsb_enable_counter</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">resid</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_icsb_balance_counter</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_sb_field_t</span>  <span class="n">fields</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">min_per_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
	<span class="n">xfs_icsb_balance_counter_locked</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">min_per_cpu</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_icsb_modify_counters</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_sb_field_t</span>	<span class="n">field</span><span class="p">,</span>
	<span class="kt">int64_t</span>		<span class="n">delta</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">rsvd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_icsb_cnts_t</span>	<span class="o">*</span><span class="n">icsbp</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span>	<span class="n">lcounter</span><span class="p">;</span>	<span class="cm">/* long counter for 64 bit fields */</span>
	<span class="kt">int</span>		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>
<span class="nl">again:</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">icsbp</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_cnts</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if the counter is disabled, go to slow path</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">xfs_icsb_counter_disabled</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">field</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">slow_path</span><span class="p">;</span>
	<span class="n">xfs_icsb_lock_cntr</span><span class="p">(</span><span class="n">icsbp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">xfs_icsb_counter_disabled</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">field</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_icsb_unlock_cntr</span><span class="p">(</span><span class="n">icsbp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">slow_path</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_SBS_ICOUNT</span>:
		<span class="n">lcounter</span> <span class="o">=</span> <span class="n">icsbp</span><span class="o">-&gt;</span><span class="n">icsb_icount</span><span class="p">;</span>
		<span class="n">lcounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">lcounter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">balance_counter</span><span class="p">;</span>
		<span class="n">icsbp</span><span class="o">-&gt;</span><span class="n">icsb_icount</span> <span class="o">=</span> <span class="n">lcounter</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">XFS_SBS_IFREE</span>:
		<span class="n">lcounter</span> <span class="o">=</span> <span class="n">icsbp</span><span class="o">-&gt;</span><span class="n">icsb_ifree</span><span class="p">;</span>
		<span class="n">lcounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">lcounter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">balance_counter</span><span class="p">;</span>
		<span class="n">icsbp</span><span class="o">-&gt;</span><span class="n">icsb_ifree</span> <span class="o">=</span> <span class="n">lcounter</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">XFS_SBS_FDBLOCKS</span>:
		<span class="n">BUG_ON</span><span class="p">((</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_resblks</span> <span class="o">-</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_resblks_avail</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">lcounter</span> <span class="o">=</span> <span class="n">icsbp</span><span class="o">-&gt;</span><span class="n">icsb_fdblocks</span> <span class="o">-</span> <span class="n">XFS_ALLOC_SET_ASIDE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">lcounter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">lcounter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">balance_counter</span><span class="p">;</span>
		<span class="n">icsbp</span><span class="o">-&gt;</span><span class="n">icsb_fdblocks</span> <span class="o">=</span> <span class="n">lcounter</span> <span class="o">+</span> <span class="n">XFS_ALLOC_SET_ASIDE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_icsb_unlock_cntr</span><span class="p">(</span><span class="n">icsbp</span><span class="p">);</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">slow_path:</span>
	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * serialise with a mutex so we don&#39;t burn lots of cpu on</span>
<span class="cm">	 * the superblock lock. We still need to hold the superblock</span>
<span class="cm">	 * lock, however, when we modify the global structures.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_icsb_lock</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now running atomically.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the counter is enabled, someone has beaten us to rebalancing.</span>
<span class="cm">	 * Drop the lock and try again in the fast path....</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">xfs_icsb_counter_disabled</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">field</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_icsb_unlock</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The counter is currently disabled. Because we are</span>
<span class="cm">	 * running atomically here, we know a rebalance cannot</span>
<span class="cm">	 * be in progress. Hence we can go straight to operating</span>
<span class="cm">	 * on the global superblock. We do not call xfs_mod_incore_sb()</span>
<span class="cm">	 * here even though we need to get the m_sb_lock. Doing so</span>
<span class="cm">	 * will cause us to re-enter this function and deadlock.</span>
<span class="cm">	 * Hence we get the m_sb_lock ourselves and then call</span>
<span class="cm">	 * xfs_mod_incore_sb_unlocked() as the unlocked path operates</span>
<span class="cm">	 * directly on the global counters.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">xfs_mod_incore_sb_unlocked</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">rsvd</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that we&#39;ve modified the global superblock, we</span>
<span class="cm">	 * may be able to re-enable the distributed counters</span>
<span class="cm">	 * (e.g. lots of space just got freed). After that</span>
<span class="cm">	 * we are done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">ENOSPC</span><span class="p">)</span>
		<span class="n">xfs_icsb_balance_counter</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">xfs_icsb_unlock</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">balance_counter:</span>
	<span class="n">xfs_icsb_unlock_cntr</span><span class="p">(</span><span class="n">icsbp</span><span class="p">);</span>
	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * We may have multiple threads here if multiple per-cpu</span>
<span class="cm">	 * counters run dry at the same time. This will mean we can</span>
<span class="cm">	 * do more balances than strictly necessary but it is not</span>
<span class="cm">	 * the common slowpath case.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_icsb_lock</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * running atomically.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This will leave the counter in the correct state for future</span>
<span class="cm">	 * accesses. After the rebalance, we simply try again and our retry</span>
<span class="cm">	 * will either succeed through the fast path or slow path without</span>
<span class="cm">	 * another balance operation being required.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_icsb_balance_counter</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
	<span class="n">xfs_icsb_unlock</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
