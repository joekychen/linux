<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_iops.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_iops.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_acl.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_quota.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap.h&quot;</span>
<span class="cp">#include &quot;xfs_rtalloc.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_itable.h&quot;</span>
<span class="cp">#include &quot;xfs_attr.h&quot;</span>
<span class="cp">#include &quot;xfs_buf_item.h&quot;</span>
<span class="cp">#include &quot;xfs_utils.h&quot;</span>
<span class="cp">#include &quot;xfs_vnodeops.h&quot;</span>
<span class="cp">#include &quot;xfs_inode_item.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/xattr.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/posix_acl.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/fiemap.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">xfs_initxattrs</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">xattr</span>	<span class="o">*</span><span class="n">xattr_array</span><span class="p">,</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">fs_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">xattr</span>	<span class="o">*</span><span class="n">xattr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">xattr</span> <span class="o">=</span> <span class="n">xattr_array</span><span class="p">;</span> <span class="n">xattr</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">xattr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_set</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">xattr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">xattr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span>
				     <span class="n">xattr</span><span class="o">-&gt;</span><span class="n">value_len</span><span class="p">,</span> <span class="n">ATTR_SECURE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hook in SELinux.  This is not quite correct yet, what we really need</span>
<span class="cm"> * here (as we do for default ACLs) is a mechanism by which creation of</span>
<span class="cm"> * these attrs can be journalled at inode creation time (along with the</span>
<span class="cm"> * inode, of course, such that log replay can&#39;t cause these to be lost).</span>
<span class="cm"> */</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_init_security</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">qstr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">security_inode_init_security</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">qstr</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">xfs_initxattrs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xfs_dentry_to_name</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="o">*</span><span class="n">namep</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">namep</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="n">namep</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_cleanup_inode</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="n">teardown</span><span class="p">;</span>

	<span class="cm">/* Oh, the horror.</span>
<span class="cm">	 * If we can&#39;t add the ACL or we fail in</span>
<span class="cm">	 * xfs_init_security we must back out.</span>
<span class="cm">	 * ENOSPC can hit here, among other things.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_dentry_to_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">teardown</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="n">xfs_remove</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">teardown</span><span class="p">,</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vn_mknod</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
	<span class="n">umode_t</span>		<span class="n">mode</span><span class="p">,</span>
	<span class="n">dev_t</span>		<span class="n">rdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">posix_acl</span> <span class="o">*</span><span class="n">default_acl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Irix uses Missed&#39;em&#39;V split, but doesn&#39;t want to see</span>
<span class="cm">	 * the upper 5 bits of (14bit) major.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">sysv_valid_dev</span><span class="p">(</span><span class="n">rdev</span><span class="p">)</span> <span class="o">||</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">rdev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x1ff</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">rdev</span> <span class="o">=</span> <span class="n">sysv_encode_dev</span><span class="p">(</span><span class="n">rdev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rdev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_POSIXACL</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">default_acl</span> <span class="o">=</span> <span class="n">xfs_get_acl</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">ACL_TYPE_DEFAULT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">default_acl</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">default_acl</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">default_acl</span><span class="p">)</span>
			<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">current_umask</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">xfs_dentry_to_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_create</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free_acl</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_init_security</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_cleanup_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">default_acl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">xfs_inherit_acl</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">default_acl</span><span class="p">);</span>
		<span class="n">default_acl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_cleanup_inode</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>

 <span class="nl">out_cleanup_inode:</span>
	<span class="n">xfs_cleanup_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
 <span class="nl">out_free_acl:</span>
	<span class="n">posix_acl_release</span><span class="p">(</span><span class="n">default_acl</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vn_create</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
	<span class="n">umode_t</span>		<span class="n">mode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfs_vn_mknod</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vn_mkdir</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
	<span class="n">umode_t</span>		<span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfs_vn_mknod</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="o">|</span><span class="n">S_IFDIR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span>
<span class="nf">xfs_vn_lookup</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span> <span class="o">*</span><span class="n">cip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">MAXNAMELEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>

	<span class="n">xfs_dentry_to_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_lookup</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cip</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">ENOENT</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">error</span><span class="p">);</span>
		<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">d_splice_alias</span><span class="p">(</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">cip</span><span class="p">),</span> <span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span>
<span class="nf">xfs_vn_ci_lookup</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="n">xname</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_name</span> <span class="n">ci_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qstr</span>	<span class="n">dname</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">MAXNAMELEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>

	<span class="n">xfs_dentry_to_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xname</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_lookup</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">xname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">ENOENT</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">error</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * call d_add(dentry, NULL) here when d_drop_negative_children</span>
<span class="cm">		 * is called in xfs_vn_mknod (ie. allow negative dentries</span>
<span class="cm">		 * with CI filesystems).</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if exact match, just splice and exit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ci_name</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">d_splice_alias</span><span class="p">(</span><span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">),</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="cm">/* else case-insensitive match... */</span>
	<span class="n">dname</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">ci_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="n">dname</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">ci_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_add_ci</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">dname</span><span class="p">);</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">ci_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vn_link</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">xfs_dentry_to_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_link</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>

	<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vn_unlink</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">xfs_dentry_to_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">xfs_remove</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * With unlink, the VFS makes the dentry &quot;negative&quot;: no inode,</span>
<span class="cm">	 * but still hashed. This is incompatible with case-insensitive</span>
<span class="cm">	 * mode, so invalidate (unhash) the dentry in CI-mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_hasasciici</span><span class="p">(</span><span class="o">&amp;</span><span class="n">XFS_M</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span>
		<span class="n">d_invalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vn_symlink</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">symname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span> <span class="o">*</span><span class="n">cip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="n">umode_t</span>		<span class="n">mode</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">S_IFLNK</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">irix_symlink_mode</span> <span class="o">?</span> <span class="mo">0777</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">current_umask</span><span class="p">()</span> <span class="o">:</span> <span class="n">S_IRWXUGO</span><span class="p">);</span>
	<span class="n">xfs_dentry_to_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_symlink</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">symname</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">VFS_I</span><span class="p">(</span><span class="n">cip</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_init_security</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_cleanup_inode</span><span class="p">;</span>

	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_cleanup_inode:</span>
	<span class="n">xfs_cleanup_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vn_rename</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">odir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">odentry</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">ndir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">ndentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">new_inode</span> <span class="o">=</span> <span class="n">ndentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="n">oname</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_name</span>	<span class="n">nname</span><span class="p">;</span>

	<span class="n">xfs_dentry_to_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oname</span><span class="p">,</span> <span class="n">odentry</span><span class="p">);</span>
	<span class="n">xfs_dentry_to_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nname</span><span class="p">,</span> <span class="n">ndentry</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">xfs_rename</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">odir</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">oname</span><span class="p">,</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">odentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">),</span>
			   <span class="n">XFS_I</span><span class="p">(</span><span class="n">ndir</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">nname</span><span class="p">,</span> <span class="n">new_inode</span> <span class="o">?</span>
			   			<span class="n">XFS_I</span><span class="p">(</span><span class="n">new_inode</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * careful here - this function can get called recursively, so</span>
<span class="cm"> * we need to be very careful about how much stack we use.</span>
<span class="cm"> * uio is kmalloced for this reason...</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">xfs_vn_follow_link</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">nameidata</span>	<span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">link</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">MAXPATHLEN</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">xfs_readlink</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">),</span> <span class="n">link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_kfree</span><span class="p">;</span>

	<span class="n">nd_set_link</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

 <span class="nl">out_kfree:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
 <span class="nl">out_err:</span>
	<span class="n">nd_set_link</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">));</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_vn_put_link</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">nd_get_link</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vn_getattr</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">vfsmount</span>		<span class="o">*</span><span class="n">mnt</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">kstat</span>		<span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>

	<span class="n">trace_xfs_getattr</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">XFS_ISIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_dev</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">nlink</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_uid</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_gid</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">ctime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">blocks</span> <span class="o">=</span>
		<span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nblocks</span> <span class="o">+</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_delayed_blks</span><span class="p">);</span>


	<span class="k">switch</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFBLK</span>:
	<span class="k">case</span> <span class="n">S_IFCHR</span>:
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">blksize</span> <span class="o">=</span> <span class="n">BLKDEV_IOSIZE</span><span class="p">;</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">rdev</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">sysv_major</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_rdev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1ff</span><span class="p">,</span>
				   <span class="n">sysv_minor</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_rdev</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">XFS_IS_REALTIME_INODE</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the file blocks are being allocated from a</span>
<span class="cm">			 * realtime volume, then return the inode&#39;s realtime</span>
<span class="cm">			 * extent size or the realtime volume&#39;s extent size.</span>
<span class="cm">			 */</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">blksize</span> <span class="o">=</span>
				<span class="n">xfs_get_extsz_hint</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocklog</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">blksize</span> <span class="o">=</span> <span class="n">xfs_preferred_iosize</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">rdev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_setattr_nonsize</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">iattr</span>		<span class="o">*</span><span class="n">iattr</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">mask</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_valid</span><span class="p">;</span>
	<span class="n">xfs_trans_t</span>		<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="n">uid_t</span>			<span class="n">uid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iuid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">gid_t</span>			<span class="n">gid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">igid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_dquot</span>	<span class="o">*</span><span class="n">udqp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">gdqp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_dquot</span>	<span class="o">*</span><span class="n">olddquot1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">olddquot2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">trace_xfs_setattr</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EROFS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">inode_change_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If disk quotas is on, we make sure that the dquots do exist on disk,</span>
<span class="cm">	 * before we start any other transactions. Trying to do this later</span>
<span class="cm">	 * is messy. We don&#39;t care to take a readlock to look at the ids</span>
<span class="cm">	 * in inode here, because we can&#39;t hold it across the trans_reserve.</span>
<span class="cm">	 * If the IDs do change before we take the ilock, we&#39;re covered</span>
<span class="cm">	 * because the i_*dquot fields will get updated anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_IS_QUOTA_ON</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATTR_UID</span><span class="o">|</span><span class="n">ATTR_GID</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">uint</span>	<span class="n">qflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">XFS_IS_UQUOTA_ON</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">uid</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_uid</span><span class="p">;</span>
			<span class="n">qflags</span> <span class="o">|=</span> <span class="n">XFS_QMOPT_UQUOTA</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uid</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_uid</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">XFS_IS_GQUOTA_ON</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">gid</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_gid</span><span class="p">;</span>
			<span class="n">qflags</span> <span class="o">|=</span> <span class="n">XFS_QMOPT_GQUOTA</span><span class="p">;</span>
		<span class="p">}</span>  <span class="k">else</span> <span class="p">{</span>
			<span class="n">gid</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_gid</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We take a reference when we initialize udqp and gdqp,</span>
<span class="cm">		 * so it is important that we never blindly double trip on</span>
<span class="cm">		 * the same variable. See xfs_create() for an example.</span>
<span class="cm">		 */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">udqp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">gdqp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_vop_dqalloc</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">gid</span><span class="p">,</span> <span class="n">xfs_get_projid</span><span class="p">(</span><span class="n">ip</span><span class="p">),</span>
					 <span class="n">qflags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udqp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gdqp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_SETATTR_NOT_SIZE</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_ICHANGE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dqrele</span><span class="p">;</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Change file ownership.  Must be the owner or privileged.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATTR_UID</span><span class="o">|</span><span class="n">ATTR_GID</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * These IDs could have changed since we last looked at them.</span>
<span class="cm">		 * But, we&#39;re assured that if the ownership did change</span>
<span class="cm">		 * while we didn&#39;t have the inode locked, inode&#39;s dquot(s)</span>
<span class="cm">		 * would have changed also.</span>
<span class="cm">		 */</span>
		<span class="n">iuid</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_uid</span><span class="p">;</span>
		<span class="n">igid</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_gid</span><span class="p">;</span>
		<span class="n">gid</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span><span class="p">)</span> <span class="o">?</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_gid</span> <span class="o">:</span> <span class="n">igid</span><span class="p">;</span>
		<span class="n">uid</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span><span class="p">)</span> <span class="o">?</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_uid</span> <span class="o">:</span> <span class="n">iuid</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do a quota reservation only if uid/gid is actually</span>
<span class="cm">		 * going to change.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">XFS_IS_QUOTA_RUNNING</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">XFS_IS_UQUOTA_ON</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">iuid</span> <span class="o">!=</span> <span class="n">uid</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">XFS_IS_GQUOTA_ON</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">igid</span> <span class="o">!=</span> <span class="n">gid</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_vop_chown_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">udqp</span><span class="p">,</span> <span class="n">gdqp</span><span class="p">,</span>
						<span class="n">capable</span><span class="p">(</span><span class="n">CAP_FOWNER</span><span class="p">)</span> <span class="o">?</span>
						<span class="n">XFS_QMOPT_FORCE_RES</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>	<span class="cm">/* out of quota */</span>
				<span class="k">goto</span> <span class="n">out_trans_cancel</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Change file ownership.  Must be the owner or privileged.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATTR_UID</span><span class="o">|</span><span class="n">ATTR_GID</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * CAP_FSETID overrides the following restrictions:</span>
<span class="cm">		 *</span>
<span class="cm">		 * The set-user-ID and set-group-ID bits of a file will be</span>
<span class="cm">		 * cleared upon successful return from chown()</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">S_ISUID</span><span class="o">|</span><span class="n">S_ISGID</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_FSETID</span><span class="p">))</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">S_ISUID</span><span class="o">|</span><span class="n">S_ISGID</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Change the ownerships and register quota modifications</span>
<span class="cm">		 * in the transaction.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iuid</span> <span class="o">!=</span> <span class="n">uid</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">XFS_IS_QUOTA_RUNNING</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">XFS_IS_UQUOTA_ON</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span><span class="p">);</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">udqp</span><span class="p">);</span>
				<span class="n">olddquot1</span> <span class="o">=</span> <span class="n">xfs_qm_vop_chown</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_udquot</span><span class="p">,</span> <span class="n">udqp</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_uid</span> <span class="o">=</span> <span class="n">uid</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">uid</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">igid</span> <span class="o">!=</span> <span class="n">gid</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">XFS_IS_QUOTA_RUNNING</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">XFS_IS_GQUOTA_ON</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">XFS_IS_PQUOTA_ON</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span><span class="p">);</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">gdqp</span><span class="p">);</span>
				<span class="n">olddquot2</span> <span class="o">=</span> <span class="n">xfs_qm_vop_chown</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_gdquot</span><span class="p">,</span> <span class="n">gdqp</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_gid</span> <span class="o">=</span> <span class="n">gid</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">gid</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Change file access modes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">umode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_mode</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_group_p</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_FSETID</span><span class="p">))</span>
			<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_ISGID</span><span class="p">;</span>

		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">&amp;=</span> <span class="n">S_IFMT</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">|=</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">S_IFMT</span><span class="p">;</span>

		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;=</span> <span class="n">S_IFMT</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">|=</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">S_IFMT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Change file access or modified times.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ATTR_ATIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_atime</span><span class="p">.</span><span class="n">t_sec</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_atime</span><span class="p">.</span><span class="n">t_nsec</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ATTR_CTIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_ctime</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">t_sec</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">t_nsec</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_ctime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ATTR_MTIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_sec</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_nsec</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_ig_attrchg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_WSYNC</span><span class="p">)</span>
		<span class="n">xfs_trans_set_sync</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release any dquot(s) the inode had kept before chown.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_qm_dqrele</span><span class="p">(</span><span class="n">olddquot1</span><span class="p">);</span>
	<span class="n">xfs_qm_dqrele</span><span class="p">(</span><span class="n">olddquot2</span><span class="p">);</span>
	<span class="n">xfs_qm_dqrele</span><span class="p">(</span><span class="n">udqp</span><span class="p">);</span>
	<span class="n">xfs_qm_dqrele</span><span class="p">(</span><span class="n">gdqp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX(hch): Updating the ACL entries is not atomic vs the i_mode</span>
<span class="cm">	 * 	     update.  We could avoid this with linked transactions</span>
<span class="cm">	 * 	     and passing down the transaction pointer all the way</span>
<span class="cm">	 *	     to attr_set.  No previous user of the generic</span>
<span class="cm">	 * 	     Posix ACL code seems to care about this issue either.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_NOACL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">xfs_acl_chmod</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_trans_cancel:</span>
	<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
<span class="nl">out_dqrele:</span>
	<span class="n">xfs_qm_dqrele</span><span class="p">(</span><span class="n">udqp</span><span class="p">);</span>
	<span class="n">xfs_qm_dqrele</span><span class="p">(</span><span class="n">gdqp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Truncate file.  Must have write permission and not be a directory.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_setattr_size</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">iattr</span>		<span class="o">*</span><span class="n">iattr</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">VFS_I</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">mask</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_valid</span><span class="p">;</span>
	<span class="n">xfs_off_t</span>		<span class="n">oldsize</span><span class="p">,</span> <span class="n">newsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">lock_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">commit_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">trace_xfs_setattr</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EROFS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">inode_change_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATTR_MODE</span><span class="o">|</span><span class="n">ATTR_UID</span><span class="o">|</span><span class="n">ATTR_GID</span><span class="o">|</span><span class="n">ATTR_ATIME</span><span class="o">|</span><span class="n">ATTR_ATIME_SET</span><span class="o">|</span>
			<span class="n">ATTR_MTIME_SET</span><span class="o">|</span><span class="n">ATTR_KILL_SUID</span><span class="o">|</span><span class="n">ATTR_KILL_SGID</span><span class="o">|</span>
			<span class="n">ATTR_KILL_PRIV</span><span class="o">|</span><span class="n">ATTR_TIMES_SET</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_NOLOCK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lock_flags</span> <span class="o">|=</span> <span class="n">XFS_IOLOCK_EXCL</span><span class="p">;</span>
		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">oldsize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">newsize</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Short circuit the truncate case for zero length files.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">oldsize</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nextents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATTR_CTIME</span><span class="o">|</span><span class="n">ATTR_MTIME</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Use the regular setattr path to update the timestamps.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATTR_SIZE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">xfs_setattr_nonsize</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">iattr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure that the dquots are attached to the inode.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_qm_dqattach</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we can make the changes.  Before we join the inode to the</span>
<span class="cm">	 * transaction, take care of the part of the truncation that must be</span>
<span class="cm">	 * done without the inode lock.  This needs to be done before joining</span>
<span class="cm">	 * the inode to the transaction, because the inode cannot be unlocked</span>
<span class="cm">	 * once it is a part of the transaction.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">&gt;</span> <span class="n">oldsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do the first part of growing a file: zero any data in the</span>
<span class="cm">		 * last block that is beyond the old EOF.  We need to do this</span>
<span class="cm">		 * before the inode is joined to the transaction to modify</span>
<span class="cm">		 * i_size.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_zero_eof</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">newsize</span><span class="p">,</span> <span class="n">oldsize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are going to log the inode size change in this transaction so</span>
<span class="cm">	 * any previous writes that are beyond the on disk EOF and the new</span>
<span class="cm">	 * EOF that have not been written out need to be written here.  If we</span>
<span class="cm">	 * do not write the data out, we expose ourselves to the null files</span>
<span class="cm">	 * problem.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Only flush from the on disk size to the smaller of the in memory</span>
<span class="cm">	 * file size or the new size as that&#39;s the range we really care about</span>
<span class="cm">	 * here and prevents waiting for other data not within the range we</span>
<span class="cm">	 * care about here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldsize</span> <span class="o">!=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">&amp;&amp;</span> <span class="n">newsize</span> <span class="o">&gt;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_flush_pages</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span><span class="p">,</span> <span class="n">newsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">FI_NONE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for all direct I/O to complete.</span>
<span class="cm">	 */</span>
	<span class="n">inode_dio_wait</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">block_truncate_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">newsize</span><span class="p">,</span> <span class="n">xfs_get_blocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_SETATTR_SIZE</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_ITRUNCATE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span>
				 <span class="n">XFS_ITRUNCATE_LOG_COUNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_trans_cancel</span><span class="p">;</span>

	<span class="n">truncate_setsize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>

	<span class="n">commit_flags</span> <span class="o">=</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">;</span>
	<span class="n">lock_flags</span> <span class="o">|=</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">;</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>

	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only change the c/mtime if we are changing the size or we are</span>
<span class="cm">	 * explicitly asked to change it.  This handles the semantic difference</span>
<span class="cm">	 * between truncate() and ftruncate() as implemented in the VFS.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a</span>
<span class="cm">	 * special case where we need to update the times despite not having</span>
<span class="cm">	 * these flags set.  For all other operations the VFS set these flags</span>
<span class="cm">	 * explicitly if it wants a timestamp update.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">!=</span> <span class="n">oldsize</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATTR_CTIME</span> <span class="o">|</span> <span class="n">ATTR_MTIME</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_ctime</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span> <span class="o">=</span>
			<span class="n">current_fs_time</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">ATTR_CTIME</span> <span class="o">|</span> <span class="n">ATTR_MTIME</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The first thing we do is set the size to new_size permanently on</span>
<span class="cm">	 * disk.  This way we don&#39;t have to worry about anyone ever being able</span>
<span class="cm">	 * to look at the data being freed even in the face of a crash.</span>
<span class="cm">	 * What we&#39;re getting around here is the case where we free a block, it</span>
<span class="cm">	 * is allocated to another file, it is written to, and then we crash.</span>
<span class="cm">	 * If the new data gets written to the file but the log buffers</span>
<span class="cm">	 * containing the free and reallocation don&#39;t, then we&#39;d end up with</span>
<span class="cm">	 * garbage in the blocks being freed.  As long as we make the new size</span>
<span class="cm">	 * permanent before actually freeing any blocks it doesn&#39;t matter if</span>
<span class="cm">	 * they get written to.</span>
<span class="cm">	 */</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">=</span> <span class="n">newsize</span><span class="p">;</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">&lt;=</span> <span class="n">oldsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_itruncate_extents</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_trans_abort</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Truncated &quot;down&quot;, so we&#39;re removing references to old data</span>
<span class="cm">		 * here - if we delay flushing for a long time, we expose</span>
<span class="cm">		 * ourselves unduly to the notorious NULL files problem.  So,</span>
<span class="cm">		 * we mark this inode and flush it when the file is closed,</span>
<span class="cm">		 * and do not wait the usual (long) time for writeout.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_iflags_set</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ITRUNCATED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ATTR_CTIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_ctime</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">t_sec</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">t_nsec</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_ctime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ATTR_MTIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_sec</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_nsec</span> <span class="o">=</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_ig_attrchg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_WSYNC</span><span class="p">)</span>
		<span class="n">xfs_trans_set_sync</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_TRANS_RELEASE_LOG_RES</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lock_flags</span><span class="p">)</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">out_trans_abort:</span>
	<span class="n">commit_flags</span> <span class="o">|=</span> <span class="n">XFS_TRANS_ABORT</span><span class="p">;</span>
<span class="nl">out_trans_cancel:</span>
	<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">commit_flags</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vn_setattr</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">iattr</span>	<span class="o">*</span><span class="n">iattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">xfs_setattr_size</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">),</span> <span class="n">iattr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">xfs_setattr_nonsize</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">),</span> <span class="n">iattr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define XFS_FIEMAP_FLAGS	(FIEMAP_FLAG_SYNC|FIEMAP_FLAG_XATTR)</span>

<span class="cm">/*</span>
<span class="cm"> * Call fiemap helper to fill in user data.</span>
<span class="cm"> * Returns positive errors to xfs_getbmap.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_fiemap_format</span><span class="p">(</span>
	<span class="kt">void</span>			<span class="o">**</span><span class="n">arg</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">getbmapx</span>		<span class="o">*</span><span class="n">bmv</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">full</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span> <span class="o">=</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">fiemap_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">logical</span><span class="p">,</span> <span class="n">physical</span><span class="p">,</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* Do nothing for a hole */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmv</span><span class="o">-&gt;</span><span class="n">bmv_block</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1LL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">logical</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bmv</span><span class="o">-&gt;</span><span class="n">bmv_offset</span><span class="p">);</span>
	<span class="n">physical</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bmv</span><span class="o">-&gt;</span><span class="n">bmv_block</span><span class="p">);</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">bmv</span><span class="o">-&gt;</span><span class="n">bmv_length</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bmv</span><span class="o">-&gt;</span><span class="n">bmv_oflags</span> <span class="o">&amp;</span> <span class="n">BMV_OF_PREALLOC</span><span class="p">)</span>
		<span class="n">fiemap_flags</span> <span class="o">|=</span> <span class="n">FIEMAP_EXTENT_UNWRITTEN</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bmv</span><span class="o">-&gt;</span><span class="n">bmv_oflags</span> <span class="o">&amp;</span> <span class="n">BMV_OF_DELALLOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fiemap_flags</span> <span class="o">|=</span> <span class="n">FIEMAP_EXTENT_DELALLOC</span><span class="p">;</span>
		<span class="n">physical</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="cm">/* no block yet */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmv</span><span class="o">-&gt;</span><span class="n">bmv_oflags</span> <span class="o">&amp;</span> <span class="n">BMV_OF_LAST</span><span class="p">)</span>
		<span class="n">fiemap_flags</span> <span class="o">|=</span> <span class="n">FIEMAP_EXTENT_LAST</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">fiemap_fill_next_extent</span><span class="p">(</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span> <span class="n">physical</span><span class="p">,</span>
					<span class="n">length</span><span class="p">,</span> <span class="n">fiemap_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">full</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* user array now full */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vn_fiemap</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span>
	<span class="n">u64</span>			<span class="n">start</span><span class="p">,</span>
	<span class="n">u64</span>			<span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">getbmapx</span>		<span class="n">bm</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">fiemap_check_flags</span><span class="p">(</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">XFS_FIEMAP_FLAGS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* Set up bmap header for xfs internal routine */</span>
	<span class="n">bm</span><span class="p">.</span><span class="n">bmv_offset</span> <span class="o">=</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="cm">/* Special case for whole file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="n">FIEMAP_MAX_OFFSET</span><span class="p">)</span>
		<span class="n">bm</span><span class="p">.</span><span class="n">bmv_length</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1LL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bm</span><span class="p">.</span><span class="n">bmv_length</span> <span class="o">=</span> <span class="n">BTOBB</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>

	<span class="cm">/* We add one because in getbmap world count includes the header */</span>
	<span class="n">bm</span><span class="p">.</span><span class="n">bmv_count</span> <span class="o">=</span> <span class="o">!</span><span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_extents_max</span> <span class="o">?</span> <span class="n">MAXEXTNUM</span> <span class="o">:</span>
					<span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_extents_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bm</span><span class="p">.</span><span class="n">bmv_count</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">__s32</span><span class="p">,</span> <span class="n">bm</span><span class="p">.</span><span class="n">bmv_count</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">getbmapx</span><span class="p">)));</span>
	<span class="n">bm</span><span class="p">.</span><span class="n">bmv_iflags</span> <span class="o">=</span> <span class="n">BMV_IF_PREALLOC</span> <span class="o">|</span> <span class="n">BMV_IF_NO_HOLES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_flags</span> <span class="o">&amp;</span> <span class="n">FIEMAP_FLAG_XATTR</span><span class="p">)</span>
		<span class="n">bm</span><span class="p">.</span><span class="n">bmv_iflags</span> <span class="o">|=</span> <span class="n">BMV_IF_ATTRFORK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_flags</span> <span class="o">&amp;</span> <span class="n">FIEMAP_FLAG_SYNC</span><span class="p">))</span>
		<span class="n">bm</span><span class="p">.</span><span class="n">bmv_iflags</span> <span class="o">|=</span> <span class="n">BMV_IF_DELALLOC</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_getbmap</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bm</span><span class="p">,</span> <span class="n">xfs_fiemap_format</span><span class="p">,</span> <span class="n">fieinfo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">xfs_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_acl</span>		<span class="o">=</span> <span class="n">xfs_get_acl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>		<span class="o">=</span> <span class="n">xfs_vn_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>		<span class="o">=</span> <span class="n">xfs_vn_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setxattr</span>		<span class="o">=</span> <span class="n">generic_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>		<span class="o">=</span> <span class="n">generic_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>		<span class="o">=</span> <span class="n">generic_removexattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>		<span class="o">=</span> <span class="n">xfs_vn_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fiemap</span>			<span class="o">=</span> <span class="n">xfs_vn_fiemap</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">xfs_dir_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">create</span>			<span class="o">=</span> <span class="n">xfs_vn_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lookup</span>			<span class="o">=</span> <span class="n">xfs_vn_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">link</span>			<span class="o">=</span> <span class="n">xfs_vn_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlink</span>			<span class="o">=</span> <span class="n">xfs_vn_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symlink</span>		<span class="o">=</span> <span class="n">xfs_vn_symlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mkdir</span>			<span class="o">=</span> <span class="n">xfs_vn_mkdir</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Yes, XFS uses the same method for rmdir and unlink.</span>
<span class="cm">	 *</span>
<span class="cm">	 * There are some subtile differences deeper in the code,</span>
<span class="cm">	 * but we use S_ISDIR to check for those.</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">rmdir</span>			<span class="o">=</span> <span class="n">xfs_vn_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mknod</span>			<span class="o">=</span> <span class="n">xfs_vn_mknod</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rename</span>			<span class="o">=</span> <span class="n">xfs_vn_rename</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_acl</span>		<span class="o">=</span> <span class="n">xfs_get_acl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>		<span class="o">=</span> <span class="n">xfs_vn_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>		<span class="o">=</span> <span class="n">xfs_vn_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setxattr</span>		<span class="o">=</span> <span class="n">generic_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>		<span class="o">=</span> <span class="n">generic_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>		<span class="o">=</span> <span class="n">generic_removexattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>		<span class="o">=</span> <span class="n">xfs_vn_listxattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">xfs_dir_ci_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">create</span>			<span class="o">=</span> <span class="n">xfs_vn_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lookup</span>			<span class="o">=</span> <span class="n">xfs_vn_ci_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">link</span>			<span class="o">=</span> <span class="n">xfs_vn_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlink</span>			<span class="o">=</span> <span class="n">xfs_vn_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symlink</span>		<span class="o">=</span> <span class="n">xfs_vn_symlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mkdir</span>			<span class="o">=</span> <span class="n">xfs_vn_mkdir</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Yes, XFS uses the same method for rmdir and unlink.</span>
<span class="cm">	 *</span>
<span class="cm">	 * There are some subtile differences deeper in the code,</span>
<span class="cm">	 * but we use S_ISDIR to check for those.</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">rmdir</span>			<span class="o">=</span> <span class="n">xfs_vn_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mknod</span>			<span class="o">=</span> <span class="n">xfs_vn_mknod</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rename</span>			<span class="o">=</span> <span class="n">xfs_vn_rename</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_acl</span>		<span class="o">=</span> <span class="n">xfs_get_acl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>		<span class="o">=</span> <span class="n">xfs_vn_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>		<span class="o">=</span> <span class="n">xfs_vn_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setxattr</span>		<span class="o">=</span> <span class="n">generic_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>		<span class="o">=</span> <span class="n">generic_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>		<span class="o">=</span> <span class="n">generic_removexattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>		<span class="o">=</span> <span class="n">xfs_vn_listxattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">xfs_symlink_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readlink</span>		<span class="o">=</span> <span class="n">generic_readlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">follow_link</span>		<span class="o">=</span> <span class="n">xfs_vn_follow_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_link</span>		<span class="o">=</span> <span class="n">xfs_vn_put_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_acl</span>		<span class="o">=</span> <span class="n">xfs_get_acl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>		<span class="o">=</span> <span class="n">xfs_vn_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>		<span class="o">=</span> <span class="n">xfs_vn_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setxattr</span>		<span class="o">=</span> <span class="n">generic_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>		<span class="o">=</span> <span class="n">generic_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>		<span class="o">=</span> <span class="n">generic_removexattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>		<span class="o">=</span> <span class="n">xfs_vn_listxattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_diflags_to_iflags</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_IMMUTABLE</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_IMMUTABLE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_IMMUTABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_APPEND</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_APPEND</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_APPEND</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_SYNC</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_SYNC</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_SYNC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_NOATIME</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_NOATIME</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_NOATIME</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the Linux inode, set up the operation vectors and</span>
<span class="cm"> * unlock the inode.</span>
<span class="cm"> *</span>
<span class="cm"> * When reading existing inodes from disk this is called directly</span>
<span class="cm"> * from xfs_iget, when creating a new inode it is called from</span>
<span class="cm"> * xfs_ialloc after setting up the inode.</span>
<span class="cm"> *</span>
<span class="cm"> * We are always called with an uninitialised linux inode here.</span>
<span class="cm"> * We need to initialise the necessary fields and take a reference</span>
<span class="cm"> * on it.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_setup_inode</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_vnode</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">=</span> <span class="n">I_NEW</span><span class="p">;</span>

	<span class="n">inode_sb_list_add</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="cm">/* make the inode look hashed for the writeback code */</span>
	<span class="n">hlist_add_fake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_hash</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span>	<span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">;</span>
	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span>	<span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_uid</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span>	<span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_gid</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFBLK</span>:
	<span class="k">case</span> <span class="n">S_IFCHR</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span> <span class="o">=</span>
			<span class="n">MKDEV</span><span class="p">(</span><span class="n">sysv_major</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_rdev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1ff</span><span class="p">,</span>
			      <span class="n">sysv_minor</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_rdev</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_gen</span><span class="p">;</span>
	<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span>	<span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_atime</span><span class="p">.</span><span class="n">t_sec</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span>	<span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_atime</span><span class="p">.</span><span class="n">t_nsec</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span>	<span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_sec</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span>	<span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_nsec</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span>	<span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">t_sec</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span>	<span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">t_nsec</span><span class="p">;</span>
	<span class="n">xfs_diflags_to_iflags</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFREG</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfs_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfs_file_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfs_address_space_operations</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_hasasciici</span><span class="p">(</span><span class="o">&amp;</span><span class="n">XFS_M</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfs_dir_ci_inode_operations</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfs_dir_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfs_dir_file_operations</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFLNK</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfs_symlink_inode_operations</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFINLINE</span><span class="p">))</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfs_address_space_operations</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xfs_inode_operations</span><span class="p">;</span>
		<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is no attribute fork no ACL can exist on this inode,</span>
<span class="cm">	 * and it can&#39;t have any file capabilities attached to it either.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XFS_IFORK_Q</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode_has_no_xattr</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">cache_no_acl</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xfs_iflags_clear</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_INEW</span><span class="p">);</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
