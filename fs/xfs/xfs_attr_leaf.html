<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_attr_leaf.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_attr_leaf.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_bit.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_da_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_ialloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_attr_sf.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode_item.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap.h&quot;</span>
<span class="cp">#include &quot;xfs_attr.h&quot;</span>
<span class="cp">#include &quot;xfs_attr_leaf.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_attr_leaf.c</span>
<span class="cm"> *</span>
<span class="cm"> * Routines to implement leaf blocks of attributes as Btrees of hashed names.</span>
<span class="cm"> */</span>

<span class="cm">/*========================================================================</span>
<span class="cm"> * Function prototypes for the kernel.</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Routines used for growing the Btree.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_leaf_create</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">xfs_dablk_t</span> <span class="n">which_block</span><span class="p">,</span>
				    <span class="n">xfs_dabuf_t</span> <span class="o">**</span><span class="n">bpp</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_leaf_add_work</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">leaf_buffer</span><span class="p">,</span> <span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">freemap_index</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span> <span class="n">xfs_attr_leaf_compact</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">leaf_buffer</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">void</span> <span class="n">xfs_attr_leaf_rebalance</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
						   <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk1</span><span class="p">,</span>
						   <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk2</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_leaf_figure_balance</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					   <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">leaf_blk_1</span><span class="p">,</span>
					   <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">leaf_blk_2</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="o">*</span><span class="n">number_entries_in_blk1</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="o">*</span><span class="n">number_usedbytes_in_blk1</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Routines used for shrinking the Btree.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_node_inactive</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">**</span><span class="n">trans</span><span class="p">,</span> <span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
				  <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_leaf_inactive</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">**</span><span class="n">trans</span><span class="p">,</span> <span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
				  <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_leaf_freextent</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">**</span><span class="n">trans</span><span class="p">,</span> <span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
				   <span class="n">xfs_dablk_t</span> <span class="n">blkno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blkcnt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Utility routines.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span> <span class="n">xfs_attr_leaf_moveents</span><span class="p">(</span><span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">src_leaf</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">src_start</span><span class="p">,</span>
					 <span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">dst_leaf</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">dst_start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">move_count</span><span class="p">,</span>
					 <span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_attr_leaf_entsize</span><span class="p">(</span><span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>

<span class="cm">/*========================================================================</span>
<span class="cm"> * Namespace helper routines</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * If namespace bits don&#39;t match return 0.</span>
<span class="cm"> * If all match then return 1.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_namesp_match</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg_flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ondisk_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">XFS_ATTR_NSP_ONDISK</span><span class="p">(</span><span class="n">ondisk_flags</span><span class="p">)</span> <span class="o">==</span> <span class="n">XFS_ATTR_NSP_ARGS_TO_ONDISK</span><span class="p">(</span><span class="n">arg_flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*========================================================================</span>
<span class="cm"> * External routines when attribute fork size &lt; XFS_LITINO(mp).</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Query whether the requested number of additional bytes of extended</span>
<span class="cm"> * attribute space will be able to fit inline.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if not, else the di_forkoff fork offset to be used in the</span>
<span class="cm"> * literal area for attribute data once the new bytes have been added.</span>
<span class="cm"> *</span>
<span class="cm"> * di_forkoff must be 8 byte aligned, hence is stored as a &gt;&gt;3 value;</span>
<span class="cm"> * special case for dev/uuid inodes, they have fixed size data forks.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_shortform_bytesfit</span><span class="p">(</span><span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">minforkoff</span><span class="p">;</span>	<span class="cm">/* lower limit on valid forkoff locations */</span>
	<span class="kt">int</span> <span class="n">maxforkoff</span><span class="p">;</span>	<span class="cm">/* upper limit on valid forkoff locations */</span>
	<span class="kt">int</span> <span class="n">dsize</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">XFS_LITINO</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">-</span> <span class="n">bytes</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* rounded down */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_DINODE_FMT_DEV</span>:
		<span class="n">minforkoff</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_dev_t</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">minforkoff</span><span class="p">)</span> <span class="o">?</span> <span class="n">minforkoff</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_DINODE_FMT_UUID</span>:
		<span class="n">minforkoff</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uuid_t</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">minforkoff</span><span class="p">)</span> <span class="o">?</span> <span class="n">minforkoff</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the requested numbers of bytes is smaller or equal to the</span>
<span class="cm">	 * current attribute fork size we can always proceed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that if_bytes in the data fork might actually be larger than</span>
<span class="cm">	 * the current data fork size is due to delalloc extents. In that</span>
<span class="cm">	 * case either the extent count will go down when they are converted</span>
<span class="cm">	 * to real extents, or the delalloc conversion will take care of the</span>
<span class="cm">	 * literal area rebalancing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;=</span> <span class="n">XFS_IFORK_ASIZE</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_forkoff</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For attr2 we can try to move the forkoff if there is space in the</span>
<span class="cm">	 * literal area, but for the old format we are done if there is no</span>
<span class="cm">	 * space in the fixed attribute fork.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_ATTR2</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dsize</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_bytes</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span>:
		<span class="cm">/*</span>
<span class="cm">		 * If there is no attr fork and the data fork is extents, </span>
<span class="cm">		 * determine if creating the default attr fork will result</span>
<span class="cm">		 * in the extents form migrating to btree. If so, the</span>
<span class="cm">		 * minimum offset only needs to be the space required for</span>
<span class="cm">		 * the btree root.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_forkoff</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_bytes</span> <span class="o">&gt;</span>
		    <span class="n">xfs_default_attroffset</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span>
			<span class="n">dsize</span> <span class="o">=</span> <span class="n">XFS_BMDR_SPACE_CALC</span><span class="p">(</span><span class="n">MINDBTPTRS</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_DINODE_FMT_BTREE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * If we have a data btree then keep forkoff if we have one,</span>
<span class="cm">		 * otherwise we are adding a new attr, so then we set</span>
<span class="cm">		 * minforkoff to where the btree root can finish so we have</span>
<span class="cm">		 * plenty of room for attrs</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_forkoff</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_forkoff</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_forkoff</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dsize</span> <span class="o">=</span> <span class="n">XFS_BMAP_BROOT_SPACE</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_broot</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * A data fork btree root must have space for at least</span>
<span class="cm">	 * MINDBTPTRS key/ptr pairs if the data fork is small or empty.</span>
<span class="cm">	 */</span>
	<span class="n">minforkoff</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">dsize</span><span class="p">,</span> <span class="n">XFS_BMDR_SPACE_CALC</span><span class="p">(</span><span class="n">MINDBTPTRS</span><span class="p">));</span>
	<span class="n">minforkoff</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">minforkoff</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* attr fork btree root can have at least this many key/ptr pairs */</span>
	<span class="n">maxforkoff</span> <span class="o">=</span> <span class="n">XFS_LITINO</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">-</span> <span class="n">XFS_BMDR_SPACE_CALC</span><span class="p">(</span><span class="n">MINABTPTRS</span><span class="p">);</span>
	<span class="n">maxforkoff</span> <span class="o">=</span> <span class="n">maxforkoff</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* rounded down */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">maxforkoff</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">maxforkoff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">minforkoff</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Switch on the ATTR2 superblock bit (implies also FEATURES2)</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_sbversion_add_attr2</span><span class="p">(</span><span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_ATTR2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">xfs_sb_version_hasattr2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_sb_version_hasattr2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_sb_version_addattr2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
			<span class="n">xfs_mod_sb</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">XFS_SB_VERSIONNUM</span> <span class="o">|</span> <span class="n">XFS_SB_FEATURES2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create the initial contents of a shortform attribute list.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_attr_shortform_create</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_sf_hdr_t</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">xfs_ifork_t</span> <span class="o">*</span><span class="n">ifp</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_sf_create</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ifp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_afp</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">==</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XFS_IFEXTENTS</span><span class="p">;</span>	<span class="cm">/* just in case */</span>
		<span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">=</span> <span class="n">XFS_DINODE_FMT_LOCAL</span><span class="p">;</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">|=</span> <span class="n">XFS_IFINLINE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFINLINE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xfs_idata_realloc</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">),</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_sf_hdr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">totsize</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span> <span class="o">|</span> <span class="n">XFS_ILOG_ADATA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a name/value pair to the shortform attribute list.</span>
<span class="cm"> * Overflow from the inode has already been checked for.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_attr_shortform_add</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="n">forkoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="n">sf</span><span class="p">;</span>
	<span class="n">xfs_attr_sf_entry_t</span> <span class="o">*</span><span class="n">sfe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">xfs_ifork_t</span> <span class="o">*</span><span class="n">ifp</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_sf_add</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_forkoff</span> <span class="o">=</span> <span class="n">forkoff</span><span class="p">;</span>

	<span class="n">ifp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_afp</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFINLINE</span><span class="p">);</span>
	<span class="n">sf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">;</span>
	<span class="n">sfe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">sfe</span> <span class="o">=</span> <span class="n">XFS_ATTR_SF_NEXTENTRY</span><span class="p">(</span><span class="n">sfe</span><span class="p">),</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">!=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_attr_namesp_match</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sfe</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sf</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">XFS_ATTR_SF_ENTSIZE_BYNAME</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>
	<span class="n">xfs_idata_realloc</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="n">sf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">;</span>
	<span class="n">sfe</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_sf_entry_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sf</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">sfe</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
	<span class="n">sfe</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">;</span>
	<span class="n">sfe</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">XFS_ATTR_NSP_ARGS_TO_ONDISK</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">[</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">],</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>
	<span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">totsize</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span> <span class="o">|</span> <span class="n">XFS_ILOG_ADATA</span><span class="p">);</span>

	<span class="n">xfs_sbversion_add_attr2</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * After the last attribute is removed revert to original inode format,</span>
<span class="cm"> * making all literal area available to the data fork once more.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_attr_fork_reset</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_idestroy_fork</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_forkoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">=</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_anextents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_afp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove an attribute from the shortform attribute list structure.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_shortform_remove</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="n">sf</span><span class="p">;</span>
	<span class="n">xfs_attr_sf_entry_t</span> <span class="o">*</span><span class="n">sfe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">totsize</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_sf_remove</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">base</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_sf_hdr_t</span><span class="p">);</span>
	<span class="n">sf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="p">)</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_afp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">;</span>
	<span class="n">sfe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">sfe</span> <span class="o">=</span> <span class="n">XFS_ATTR_SF_NEXTENTRY</span><span class="p">(</span><span class="n">sfe</span><span class="p">),</span>
					<span class="n">base</span> <span class="o">+=</span> <span class="n">size</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">XFS_ATTR_SF_ENTSIZE</span><span class="p">(</span><span class="n">sfe</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">!=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_attr_namesp_match</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOATTR</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fix up the attribute fork data, covering the hole</span>
<span class="cm">	 */</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">totsize</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">totsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">!=</span> <span class="n">totsize</span><span class="p">)</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sf</span><span class="p">)[</span><span class="n">base</span><span class="p">],</span> <span class="o">&amp;</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sf</span><span class="p">)[</span><span class="n">end</span><span class="p">],</span> <span class="n">totsize</span> <span class="o">-</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">totsize</span><span class="p">,</span> <span class="o">-</span><span class="n">size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fix up the start offset of the attribute fork</span>
<span class="cm">	 */</span>
	<span class="n">totsize</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">totsize</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_sf_hdr_t</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_ATTR2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_BTREE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_ADDNAME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_attr_fork_reset</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xfs_idata_realloc</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="o">-</span><span class="n">size</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
		<span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_forkoff</span> <span class="o">=</span> <span class="n">xfs_attr_shortform_bytesfit</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">totsize</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_forkoff</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">totsize</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_sf_hdr_t</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_ADDNAME</span><span class="p">)</span> <span class="o">||</span>
				<span class="o">!</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_ATTR2</span><span class="p">)</span> <span class="o">||</span>
				<span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">==</span> <span class="n">XFS_DINODE_FMT_BTREE</span><span class="p">);</span>
		<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span>
					<span class="n">XFS_ILOG_CORE</span> <span class="o">|</span> <span class="n">XFS_ILOG_ADATA</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xfs_sbversion_add_attr2</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up a name in a shortform attribute list structure.</span>
<span class="cm"> */</span>
<span class="cm">/*ARGSUSED*/</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_shortform_lookup</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="n">sf</span><span class="p">;</span>
	<span class="n">xfs_attr_sf_entry_t</span> <span class="o">*</span><span class="n">sfe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_ifork_t</span> <span class="o">*</span><span class="n">ifp</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_sf_lookup</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">ifp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_afp</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFINLINE</span><span class="p">);</span>
	<span class="n">sf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">;</span>
	<span class="n">sfe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
				<span class="n">sfe</span> <span class="o">=</span> <span class="n">XFS_ATTR_SF_NEXTENTRY</span><span class="p">(</span><span class="n">sfe</span><span class="p">),</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">!=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_attr_namesp_match</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EEXIST</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOATTR</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up a name in a shortform attribute list structure.</span>
<span class="cm"> */</span>
<span class="cm">/*ARGSUSED*/</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_shortform_getvalue</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="n">sf</span><span class="p">;</span>
	<span class="n">xfs_attr_sf_entry_t</span> <span class="o">*</span><span class="n">sfe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">==</span> <span class="n">XFS_IFINLINE</span><span class="p">);</span>
	<span class="n">sf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_afp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">;</span>
	<span class="n">sfe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
				<span class="n">sfe</span> <span class="o">=</span> <span class="n">XFS_ATTR_SF_NEXTENTRY</span><span class="p">(</span><span class="n">sfe</span><span class="p">),</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">!=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_attr_namesp_match</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_KERNOVAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">;</span>
			<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EEXIST</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">&lt;</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">;</span>
			<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ERANGE</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">[</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">],</span>
						    <span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EEXIST</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOATTR</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert from using the shortform to the leaf.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_shortform_to_leaf</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="n">sf</span><span class="p">;</span>
	<span class="n">xfs_attr_sf_entry_t</span> <span class="o">*</span><span class="n">sfe</span><span class="p">;</span>
	<span class="n">xfs_da_args_t</span> <span class="n">nargs</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmpbuffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">xfs_dablk_t</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_ifork_t</span> <span class="o">*</span><span class="n">ifp</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_sf_to_leaf</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">ifp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_afp</span><span class="p">;</span>
	<span class="n">sf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">totsize</span><span class="p">);</span>
	<span class="n">tmpbuffer</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">tmpbuffer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">tmpbuffer</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">sf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="p">)</span><span class="n">tmpbuffer</span><span class="p">;</span>

	<span class="n">xfs_idata_realloc</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="o">-</span><span class="n">size</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_grow_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we hit an IO error middle of the transaction inside</span>
<span class="cm">		 * grow_inode(), we may have inconsistent data. Bail out.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">EIO</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">xfs_idata_realloc</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>	<span class="cm">/* try to put */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">,</span> <span class="n">tmpbuffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>	<span class="cm">/* it back */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">blkno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_create</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_shrink_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">xfs_idata_realloc</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>	<span class="cm">/* try to put */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">,</span> <span class="n">tmpbuffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>	<span class="cm">/* it back */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nargs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nargs</span><span class="p">));</span>
	<span class="n">nargs</span><span class="p">.</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dp</span><span class="p">;</span>
	<span class="n">nargs</span><span class="p">.</span><span class="n">firstblock</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">;</span>
	<span class="n">nargs</span><span class="p">.</span><span class="n">flist</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">;</span>
	<span class="n">nargs</span><span class="p">.</span><span class="n">total</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">total</span><span class="p">;</span>
	<span class="n">nargs</span><span class="p">.</span><span class="n">whichfork</span> <span class="o">=</span> <span class="n">XFS_ATTR_FORK</span><span class="p">;</span>
	<span class="n">nargs</span><span class="p">.</span><span class="n">trans</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">nargs</span><span class="p">.</span><span class="n">op_flags</span> <span class="o">=</span> <span class="n">XFS_DA_OP_OKNOENT</span><span class="p">;</span>

	<span class="n">sfe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nargs</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">;</span>
		<span class="n">nargs</span><span class="p">.</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
		<span class="n">nargs</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">[</span><span class="n">nargs</span><span class="p">.</span><span class="n">namelen</span><span class="p">];</span>
		<span class="n">nargs</span><span class="p">.</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">;</span>
		<span class="n">nargs</span><span class="p">.</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">xfs_da_hashname</span><span class="p">(</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">,</span>
						<span class="n">sfe</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
		<span class="n">nargs</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">XFS_ATTR_NSP_ONDISK_TO_ARGS</span><span class="p">(</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_lookup_int</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nargs</span><span class="p">);</span> <span class="cm">/* set a-&gt;index */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ENOATTR</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_add</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nargs</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">ENOSPC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">sfe</span> <span class="o">=</span> <span class="n">XFS_ATTR_SF_NEXTENTRY</span><span class="p">(</span><span class="n">sfe</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">tmpbuffer</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_shortform_compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_sf_sort_t</span> <span class="o">*</span><span class="n">sa</span><span class="p">,</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="n">sa</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_sf_sort_t</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">;</span>
	<span class="n">sb</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_sf_sort_t</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">&lt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">entno</span> <span class="o">-</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">entno</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cp">#define XFS_ISRESET_CURSOR(cursor) \</span>
<span class="cp">	(!((cursor)-&gt;initted) &amp;&amp; !((cursor)-&gt;hashval) &amp;&amp; \</span>
<span class="cp">	 !((cursor)-&gt;blkno) &amp;&amp; !((cursor)-&gt;offset))</span>
<span class="cm">/*</span>
<span class="cm"> * Copy out entries of shortform attribute lists for attr_list().</span>
<span class="cm"> * Shortform attribute lists are not stored in hashval sorted order.</span>
<span class="cm"> * If the output buffer is not large enough to hold them all, then we</span>
<span class="cm"> * we have to calculate each entries&#39; hashvalue and sort them before</span>
<span class="cm"> * we can begin returning them to the user.</span>
<span class="cm"> */</span>
<span class="cm">/*ARGSUSED*/</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_shortform_list</span><span class="p">(</span><span class="n">xfs_attr_list_context_t</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">attrlist_cursor_kern_t</span> <span class="o">*</span><span class="n">cursor</span><span class="p">;</span>
	<span class="n">xfs_attr_sf_sort_t</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">,</span> <span class="o">*</span><span class="n">sbp</span><span class="p">;</span>
	<span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="n">sf</span><span class="p">;</span>
	<span class="n">xfs_attr_sf_entry_t</span> <span class="o">*</span><span class="n">sfe</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sbsize</span><span class="p">,</span> <span class="n">nsbuf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">context</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_afp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">sf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="p">)</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_afp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">sf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cursor</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">cursor</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">cursor</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">trace_xfs_attr_list_sf</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the buffer is large enough and the cursor is at the start,</span>
<span class="cm">	 * do not bother with sorting since we will return everything in</span>
<span class="cm">	 * one buffer and another call using the cursor won&#39;t need to be</span>
<span class="cm">	 * made.</span>
<span class="cm">	 * Note the generous fudge factor of 16 overhead bytes per entry.</span>
<span class="cm">	 * If bufsize is zero then put_listent must be a search function</span>
<span class="cm">	 * and can just scan through what we have.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">bufsize</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">XFS_ISRESET_CURSOR</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
             <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_afp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">+</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span> <span class="o">*</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">bufsize</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sfe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">put_listent</span><span class="p">(</span><span class="n">context</span><span class="p">,</span>
					   <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
					   <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">,</span>
					   <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span>
					   <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">[</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">]);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Either search callback finished early or</span>
<span class="cm">			 * didn&#39;t fit it all in the buffer after all.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">seen_enough</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="n">sfe</span> <span class="o">=</span> <span class="n">XFS_ATTR_SF_NEXTENTRY</span><span class="p">(</span><span class="n">sfe</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">trace_xfs_attr_list_sf_all</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* do no more for a search callback */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">bufsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It didn&#39;t all fit, so we have to sort everything on hashval.</span>
<span class="cm">	 */</span>
	<span class="n">sbsize</span> <span class="o">=</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sbuf</span><span class="p">);</span>
	<span class="n">sbp</span> <span class="o">=</span> <span class="n">sbuf</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">sbsize</span><span class="p">,</span> <span class="n">KM_SLEEP</span> <span class="o">|</span> <span class="n">KM_NOFS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Scan the attribute list for the rest of the entries, storing</span>
<span class="cm">	 * the relevant info from only those that match into a buffer.</span>
<span class="cm">	 */</span>
	<span class="n">nsbuf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sfe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span>
		    <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sfe</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sf</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sfe</span> <span class="o">&gt;=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sf</span> <span class="o">+</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_afp</span><span class="o">-&gt;</span><span class="n">if_bytes</span><span class="p">))))</span> <span class="p">{</span>
			<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_attr_shortform_list&quot;</span><span class="p">,</span>
					     <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
					     <span class="n">context</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">sfe</span><span class="p">);</span>
			<span class="n">kmem_free</span><span class="p">(</span><span class="n">sbuf</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">entno</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">xfs_da_hashname</span><span class="p">(</span><span class="n">sfe</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">,</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
		<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">;</span>
		<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
		<span class="cm">/* These are bytes, and both on-disk, don&#39;t endian-flip */</span>
		<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">;</span>
		<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">sfe</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
		<span class="n">sfe</span> <span class="o">=</span> <span class="n">XFS_ATTR_SF_NEXTENTRY</span><span class="p">(</span><span class="n">sfe</span><span class="p">);</span>
		<span class="n">sbp</span><span class="o">++</span><span class="p">;</span>
		<span class="n">nsbuf</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sort the entries on hash then entno.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_sort</span><span class="p">(</span><span class="n">sbuf</span><span class="p">,</span> <span class="n">nsbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sbuf</span><span class="p">),</span> <span class="n">xfs_attr_shortform_compare</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Re-find our place IN THE SORTED LIST.</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cursor</span><span class="o">-&gt;</span><span class="n">initted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cursor</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sbp</span> <span class="o">=</span> <span class="n">sbuf</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsbuf</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">sbp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">==</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">==</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">&gt;</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">nsbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">sbuf</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Loop putting entries into the user buffer.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsbuf</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">sbp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">!=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cursor</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>
			<span class="n">cursor</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">put_listent</span><span class="p">(</span><span class="n">context</span><span class="p">,</span>
					<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
					<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span>
					<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">seen_enough</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cursor</span><span class="o">-&gt;</span><span class="n">offset</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kmem_free</span><span class="p">(</span><span class="n">sbuf</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check a leaf attribute block to see if all the entries would fit into</span>
<span class="cm"> * a shortform attribute list.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_shortform_allfit</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_name_local_t</span> <span class="o">*</span><span class="n">name_loc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_attr_sf_hdr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span> <span class="n">entry</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>		<span class="cm">/* don&#39;t copy partial entries */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">))</span>
			<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">name_loc</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_local</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">&gt;=</span> <span class="n">XFS_ATTR_SF_ENTSIZE_MAX</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">XFS_ATTR_SF_ENTSIZE_MAX</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">bytes</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_attr_sf_entry</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
				<span class="o">+</span> <span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">namelen</span>
				<span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_ATTR2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_BTREE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">bytes</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_attr_sf_hdr</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">xfs_attr_shortform_bytesfit</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">bytes</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert a leaf attribute list to shortform attribute list</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_leaf_to_shortform</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="n">forkoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_name_local_t</span> <span class="o">*</span><span class="n">name_loc</span><span class="p">;</span>
	<span class="n">xfs_da_args_t</span> <span class="n">nargs</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmpbuffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_leaf_to_sf</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">tmpbuffer</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">tmpbuffer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">tmpbuffer</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">));</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="p">)</span><span class="n">tmpbuffer</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clean out the prior contents of the attribute list.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_shrink_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">forkoff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">XFS_MOUNT_ATTR2</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_BTREE</span><span class="p">);</span>
		<span class="n">xfs_attr_fork_reset</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xfs_attr_shortform_create</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the attributes</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nargs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nargs</span><span class="p">));</span>
	<span class="n">nargs</span><span class="p">.</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dp</span><span class="p">;</span>
	<span class="n">nargs</span><span class="p">.</span><span class="n">firstblock</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">firstblock</span><span class="p">;</span>
	<span class="n">nargs</span><span class="p">.</span><span class="n">flist</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">;</span>
	<span class="n">nargs</span><span class="p">.</span><span class="n">total</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">total</span><span class="p">;</span>
	<span class="n">nargs</span><span class="p">.</span><span class="n">whichfork</span> <span class="o">=</span> <span class="n">XFS_ATTR_FORK</span><span class="p">;</span>
	<span class="n">nargs</span><span class="p">.</span><span class="n">trans</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">nargs</span><span class="p">.</span><span class="n">op_flags</span> <span class="o">=</span> <span class="n">XFS_DA_OP_OKNOENT</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span> <span class="n">entry</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* don&#39;t copy partial entries */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">);</span>
		<span class="n">name_loc</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_local</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">nargs</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">;</span>
		<span class="n">nargs</span><span class="p">.</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
		<span class="n">nargs</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">[</span><span class="n">nargs</span><span class="p">.</span><span class="n">namelen</span><span class="p">];</span>
		<span class="n">nargs</span><span class="p">.</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>
		<span class="n">nargs</span><span class="p">.</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>
		<span class="n">nargs</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">XFS_ATTR_NSP_ONDISK_TO_ARGS</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">xfs_attr_shortform_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nargs</span><span class="p">,</span> <span class="n">forkoff</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">tmpbuffer</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert from using a single leaf to a root node and a leaf.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_leaf_to_node</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp1</span><span class="p">,</span> <span class="o">*</span><span class="n">bp2</span><span class="p">;</span>
	<span class="n">xfs_dablk_t</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_leaf_to_node</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">bp1</span> <span class="o">=</span> <span class="n">bp2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_grow_inode</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp1</span><span class="p">,</span>
					     <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">bp2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_get_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp2</span><span class="p">,</span>
					    <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bp2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">bp1</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">));</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp1</span><span class="p">);</span>
	<span class="n">bp1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up the new root node.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_node_create</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp1</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">bp1</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="cm">/* both on-disk, don&#39;t endian-flip twice */</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hashval</span> <span class="o">=</span>
		<span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">].</span><span class="n">hashval</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">before</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">blkno</span><span class="p">);</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp1</span><span class="p">)</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp2</span><span class="p">)</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp2</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*========================================================================</span>
<span class="cm"> * Routines used for growing the Btree.</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Create the initial contents of a leaf attribute list</span>
<span class="cm"> * or a leaf in a node attribute list.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_leaf_create</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">xfs_dablk_t</span> <span class="n">blkno</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">**</span><span class="n">bpp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_hdr_t</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_leaf_create</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">dp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">dp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_get_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span>
					    <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">));</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span>
			<span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">)</span> <span class="o">-</span> <span class="n">XFS_ATTR_LEAF_NAME_ALIGN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_hdr_t</span><span class="p">));</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">)</span> <span class="o">-</span>
					   <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_hdr_t</span><span class="p">));</span>

	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Split the leaf node, rebalance, then add the new entry.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_leaf_split</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">oldblk</span><span class="p">,</span>
				   <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">newblk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_dablk_t</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_leaf_split</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate space for a new leaf node.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_grow_inode</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_create</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">newblk</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="n">newblk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Rebalance the entries across the two leaves.</span>
<span class="cm">	 * NOTE: rebalance() currently depends on the 2nd block being empty.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_attr_leaf_rebalance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">oldblk</span><span class="p">,</span> <span class="n">newblk</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_blk_link</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">oldblk</span><span class="p">,</span> <span class="n">newblk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save info on &quot;old&quot; attribute for &quot;atomic rename&quot; ops, leaf_add()</span>
<span class="cm">	 * modifies the index/blkno/rmtblk/rmtblkcnt fields to show the</span>
<span class="cm">	 * &quot;new&quot; attrs info.  Will need the &quot;old&quot; info to remove it later.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Insert the &quot;new&quot; entry in the correct block.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_xfs_attr_leaf_add_old</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_add</span><span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">trace_xfs_attr_leaf_add_new</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_add</span><span class="p">(</span><span class="n">newblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update last hashval in each block since we added the name.</span>
<span class="cm">	 */</span>
	<span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_lasthash</span><span class="p">(</span><span class="n">oldblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">newblk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_lasthash</span><span class="p">(</span><span class="n">newblk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a name to the leaf attribute list structure.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_leaf_add</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_hdr_t</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_map_t</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tablesize</span><span class="p">,</span> <span class="n">entsize</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_leaf_add</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)));</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">entsize</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_newentsize</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">,</span>
			   <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search through freemap for first-fit on new name length.</span>
<span class="cm">	 * (may need to figure in size of entry struct too)</span>
<span class="cm">	 */</span>
	<span class="n">tablesize</span> <span class="o">=</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
					<span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">)</span>
					<span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_hdr_t</span><span class="p">);</span>
	<span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="n">XFS_ATTR_LEAF_MAPSIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">XFS_ATTR_LEAF_MAPSIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">map</span><span class="o">--</span><span class="p">,</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tablesize</span> <span class="o">&gt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sum</span> <span class="o">+=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* no space in this map */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">entsize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">))</span>
			<span class="n">tmp</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_add_work</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are no holes in the address space of the block,</span>
<span class="cm">	 * and we don&#39;t have enough freespace, then compaction will do us</span>
<span class="cm">	 * no good and we should just give up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">holes</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">entsize</span><span class="p">))</span>
		<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSPC</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compact the entries to coalesce free space.</span>
<span class="cm">	 * This may change the hdr-&gt;count via dropping INCOMPLETE entries.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_attr_leaf_compact</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * After compaction, the block is guaranteed to have only one</span>
<span class="cm">	 * free region, in freemap[0].  If it is not big enough, give up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">)</span>
				<span class="o">&lt;</span> <span class="p">(</span><span class="n">entsize</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOSPC</span><span class="p">));</span>

	<span class="k">return</span><span class="p">(</span><span class="n">xfs_attr_leaf_add_work</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a name to a leaf attribute list structure.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_leaf_add_work</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mapindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_hdr_t</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_name_local_t</span> <span class="o">*</span><span class="n">name_loc</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_name_remote_t</span> <span class="o">*</span><span class="n">name_rmt</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_map_t</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">mapindex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mapindex</span> <span class="o">&lt;</span> <span class="n">XFS_ATTR_LEAF_MAPSIZE</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Force open some space in the entry array and fill it in.</span>
<span class="cm">	 */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span>  <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">*=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">);</span>
		<span class="n">memmove</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">entry</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">entry</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
		    <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)));</span>
	<span class="p">}</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate space for the new string (at the end of the run).</span>
<span class="cm">	 */</span>
	<span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="n">mapindex</span><span class="p">];</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span>
		<span class="n">xfs_attr_leaf_newentsize</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">,</span>
					 <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
		<span class="o">-</span><span class="n">xfs_attr_leaf_newentsize</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">,</span>
					  <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">));</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">+</span>
				     <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">?</span> <span class="n">XFS_ATTR_LOCAL</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_ATTR_NSP_ARGS_TO_ONDISK</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">op_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DA_OP_RENAME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno2</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span> <span class="o">&lt;=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
			  <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)));</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">be32_to_cpu</span><span class="p">((</span><span class="n">entry</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)));</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">be32_to_cpu</span><span class="p">((</span><span class="n">entry</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 * For &quot;remote&quot; attribute values, simply note that we need to</span>
<span class="cm">	 * allocate space for the &quot;remote&quot; value.  We can&#39;t actually</span>
<span class="cm">	 * allocate the extents in this transaction, and we can&#39;t decide</span>
<span class="cm">	 * which blocks they should be as we might allocate more blocks</span>
<span class="cm">	 * as part of this transaction (a split operation for example).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">name_loc</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_local</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
		<span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">[</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">],</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span>
				   <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">name_rmt</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_remote</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">;</span>
		<span class="cm">/* just in case */</span>
		<span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valueblk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
	     <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">xfs_attr_leaf_name</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">),</span>
				   <span class="n">xfs_attr_leaf_entsize</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the control info for this leaf node</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* both on-disk, don&#39;t endian-flip twice */</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">)</span> <span class="o">&gt;=</span>
	       <span class="p">((</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">))</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">)));</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">)</span>
					<span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_hdr_t</span><span class="p">);</span>
	<span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">XFS_ATTR_LEAF_MAPSIZE</span><span class="p">;</span> <span class="n">map</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">));</span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
				 <span class="o">-</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">)));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">usedbytes</span><span class="p">,</span> <span class="n">xfs_attr_leaf_entsize</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">));</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
		<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">)));</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Garbage collect a leaf attribute list block by copying it to a new buffer.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_attr_leaf_compact</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf_s</span><span class="p">,</span> <span class="o">*</span><span class="n">leaf_d</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_hdr_t</span> <span class="o">*</span><span class="n">hdr_s</span><span class="p">,</span> <span class="o">*</span><span class="n">hdr_d</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmpbuffer</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>
	<span class="n">tmpbuffer</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">tmpbuffer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">tmpbuffer</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy basic information</span>
<span class="cm">	 */</span>
	<span class="n">leaf_s</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="p">)</span><span class="n">tmpbuffer</span><span class="p">;</span>
	<span class="n">leaf_d</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">hdr_s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">hdr_d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf_d</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>	<span class="cm">/* struct copy */</span>
	<span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">firstused</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
	<span class="cm">/* handle truncation gracefully */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">firstused</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span>
				<span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">-</span> <span class="n">XFS_ATTR_LEAF_NAME_ALIGN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">usedbytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">holes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_hdr_t</span><span class="p">));</span>
	<span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">)</span> <span class="o">-</span>
					     <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_hdr_t</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy all entry&#39;s in the same (sorted) order,</span>
<span class="cm">	 * but allocate name/value pairs packed and in sequence.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_attr_leaf_moveents</span><span class="p">(</span><span class="n">leaf_s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">leaf_d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">),</span> <span class="n">mp</span><span class="p">);</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">kmem_free</span><span class="p">(</span><span class="n">tmpbuffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Redistribute the attribute list entries between two leaf nodes,</span>
<span class="cm"> * taking into account the size of the new entry.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: if new block is empty, then it will get the upper half of the</span>
<span class="cm"> * old block.  At present, all (one) callers pass in an empty second block.</span>
<span class="cm"> *</span>
<span class="cm"> * This code adjusts the args-&gt;index/blkno and args-&gt;index2/blkno2 fields</span>
<span class="cm"> * to match what it is doing in splitting the attribute leaf block.  Those</span>
<span class="cm"> * values are used in &quot;atomic rename&quot; operations on attributes.  Note that</span>
<span class="cm"> * the &quot;new&quot; and &quot;old&quot; values can end up in different blocks.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_attr_leaf_rebalance</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk1</span><span class="p">,</span>
				       <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
	<span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">tmp_blk</span><span class="p">;</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf1</span><span class="p">,</span> <span class="o">*</span><span class="n">leaf2</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_hdr_t</span> <span class="o">*</span><span class="n">hdr1</span><span class="p">,</span> <span class="o">*</span><span class="n">hdr2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">totallen</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">swap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up environment.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk1</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">blk2</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">);</span>
	<span class="n">leaf1</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">leaf2</span> <span class="o">=</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">args</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_leaf_rebalance</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check ordering of blocks, reverse if it makes things simpler.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: Given that all (current) callers pass in an empty</span>
<span class="cm">	 * second block, this code should never set &quot;swap&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">swap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_attr_leaf_order</span><span class="p">(</span><span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp_blk</span> <span class="o">=</span> <span class="n">blk1</span><span class="p">;</span>
		<span class="n">blk1</span> <span class="o">=</span> <span class="n">blk2</span><span class="p">;</span>
		<span class="n">blk2</span> <span class="o">=</span> <span class="n">tmp_blk</span><span class="p">;</span>
		<span class="n">leaf1</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">leaf2</span> <span class="o">=</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">swap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hdr1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">hdr2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Examine entries until we reduce the absolute difference in</span>
<span class="cm">	 * byte usage between the two blocks to a minimum.  Then get</span>
<span class="cm">	 * the direction to copy and the number of elements to move.</span>
<span class="cm">	 *</span>
<span class="cm">	 * &quot;inleaf&quot; is true if the new entry should be inserted into blk1.</span>
<span class="cm">	 * If &quot;swap&quot; is also true, then reverse the sense of &quot;inleaf&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_figure_balance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">blk1</span><span class="p">,</span> <span class="n">blk2</span><span class="p">,</span>
							    <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">totallen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swap</span><span class="p">)</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span> <span class="o">=</span> <span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Move any entries required from leaf to leaf:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr1</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Figure the total bytes to be added to the destination leaf.</span>
<span class="cm">		 */</span>
		<span class="cm">/* number entries being moved */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr1</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">space</span>  <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr1</span><span class="o">-&gt;</span><span class="n">usedbytes</span><span class="p">)</span> <span class="o">-</span> <span class="n">totallen</span><span class="p">;</span>
		<span class="n">space</span> <span class="o">+=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * leaf2 is the destination, compact it if it looks tight.</span>
<span class="cm">		 */</span>
		<span class="n">max</span>  <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr2</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">)</span>
						<span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_hdr_t</span><span class="p">);</span>
		<span class="n">max</span> <span class="o">-=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr2</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_attr_leaf_compact</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Move high entries from leaf1 to low end of leaf2.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_attr_leaf_moveents</span><span class="p">(</span><span class="n">leaf1</span><span class="p">,</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr1</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">count</span><span class="p">,</span>
				<span class="n">leaf2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">);</span>

		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr1</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * I assert that since all callers pass in an empty</span>
<span class="cm">		 * second buffer, this code should never execute.</span>
<span class="cm">		 */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Figure the total bytes to be added to the destination leaf.</span>
<span class="cm">		 */</span>
		<span class="cm">/* number entries being moved */</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr1</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
		<span class="n">space</span>  <span class="o">=</span> <span class="n">totallen</span> <span class="o">-</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr1</span><span class="o">-&gt;</span><span class="n">usedbytes</span><span class="p">);</span>
		<span class="n">space</span> <span class="o">+=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * leaf1 is the destination, compact it if it looks tight.</span>
<span class="cm">		 */</span>
		<span class="n">max</span>  <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr1</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">)</span>
						<span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_hdr_t</span><span class="p">);</span>
		<span class="n">max</span> <span class="o">-=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr1</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_attr_leaf_compact</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Move low entries from leaf2 to high end of leaf1.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_attr_leaf_moveents</span><span class="p">(</span><span class="n">leaf2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">leaf1</span><span class="p">,</span>
				<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr1</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">),</span> <span class="n">count</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">);</span>

		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy out last hashval in each block for B-tree code.</span>
<span class="cm">	 */</span>
	<span class="n">blk1</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span>
		<span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
	<span class="n">blk2</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span>
		<span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Adjust the expected index for insertion.</span>
<span class="cm">	 * NOTE: this code depends on the (current) situation that the</span>
<span class="cm">	 * second block was originally empty.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the insertion point moved to the 2nd block, we must adjust</span>
<span class="cm">	 * the index.  We must also track the entry just following the</span>
<span class="cm">	 * new entry for use in an &quot;atomic rename&quot; operation, that entry</span>
<span class="cm">	 * is always the &quot;old&quot; entry and the &quot;new&quot; entry is what we are</span>
<span class="cm">	 * inserting.  The index/blkno fields refer to the &quot;old&quot; entry,</span>
<span class="cm">	 * while the index2/blkno2 fields refer to the &quot;new&quot; entry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blk1</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">blk2</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">-</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span> <span class="o">=</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno2</span> <span class="o">=</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">blk1</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">;</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno2</span> <span class="o">=</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">blk2</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">index</span>
				    <span class="o">-</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span> <span class="o">=</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno2</span> <span class="o">=</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">inleaf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno2</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Examine entries until we reduce the absolute difference in</span>
<span class="cm"> * byte usage between the two blocks to a minimum.</span>
<span class="cm"> * GROT: Is this really necessary?  With other than a 512 byte blocksize,</span>
<span class="cm"> * GROT: there will always be enough room in either block for a new entry.</span>
<span class="cm"> * GROT: Do a double-split for this case?</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_leaf_figure_balance</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				    <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk1</span><span class="p">,</span>
				    <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk2</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="o">*</span><span class="n">countarg</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">usedbytesarg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf1</span><span class="p">,</span> <span class="o">*</span><span class="n">leaf2</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_hdr_t</span> <span class="o">*</span><span class="n">hdr1</span><span class="p">,</span> <span class="o">*</span><span class="n">hdr2</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">totallen</span><span class="p">,</span> <span class="n">half</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lastdelta</span><span class="p">,</span> <span class="n">foundit</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up environment.</span>
<span class="cm">	 */</span>
	<span class="n">leaf1</span> <span class="o">=</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">leaf2</span> <span class="o">=</span> <span class="n">blk2</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">hdr1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">hdr2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">foundit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">totallen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Examine entries until we reduce the absolute difference in</span>
<span class="cm">	 * byte usage between the two blocks to a minimum.</span>
<span class="cm">	 */</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr1</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr2</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">half</span>  <span class="o">=</span> <span class="p">(</span><span class="n">max</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">half</span> <span class="o">+=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr1</span><span class="o">-&gt;</span><span class="n">usedbytes</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr2</span><span class="o">-&gt;</span><span class="n">usedbytes</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">xfs_attr_leaf_newentsize</span><span class="p">(</span>
				<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span>
				<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">,</span>
				<span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">half</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">lastdelta</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="n">entry</span><span class="o">++</span><span class="p">,</span> <span class="n">index</span><span class="o">++</span><span class="p">,</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

<span class="cp">#define XFS_ATTR_ABS(A)	(((A) &lt; 0) ? -(A) : (A))</span>
		<span class="cm">/*</span>
<span class="cm">		 * The new entry is in the first block, account for it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">blk1</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">totallen</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">xfs_attr_leaf_newentsize</span><span class="p">(</span>
						<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span>
						<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">,</span>
						<span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">XFS_ATTR_ABS</span><span class="p">(</span><span class="n">half</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">lastdelta</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">lastdelta</span> <span class="o">=</span> <span class="n">XFS_ATTR_ABS</span><span class="p">(</span><span class="n">half</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">);</span>
			<span class="n">totallen</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">foundit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wrap around into the second block if necessary.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr1</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">leaf1</span> <span class="o">=</span> <span class="n">leaf2</span><span class="p">;</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Figure out if next leaf entry would be too much.</span>
<span class="cm">		 */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">totallen</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="o">+</span> <span class="n">xfs_attr_leaf_entsize</span><span class="p">(</span><span class="n">leaf1</span><span class="p">,</span>
									<span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">XFS_ATTR_ABS</span><span class="p">(</span><span class="n">half</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">lastdelta</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">lastdelta</span> <span class="o">=</span> <span class="n">XFS_ATTR_ABS</span><span class="p">(</span><span class="n">half</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="n">totallen</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="cp">#undef XFS_ATTR_ABS</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the number of usedbytes that will end up in lower block.</span>
<span class="cm">	 * If new entry not in lower block, fix up the count.</span>
<span class="cm">	 */</span>
	<span class="n">totallen</span> <span class="o">-=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">foundit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">totallen</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">xfs_attr_leaf_newentsize</span><span class="p">(</span>
						<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span>
						<span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">,</span>
						<span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">countarg</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="o">*</span><span class="n">usedbytesarg</span> <span class="o">=</span> <span class="n">totallen</span><span class="p">;</span>
	<span class="k">return</span><span class="p">(</span><span class="n">foundit</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*========================================================================</span>
<span class="cm"> * Routines used for shrinking the Btree.</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Check a leaf block and its neighbors to see if the block should be</span>
<span class="cm"> * collapsed into one or the other neighbor.  Always keep the block</span>
<span class="cm"> * with the smaller block number.</span>
<span class="cm"> * If the current block is over 50% full, don&#39;t try to join it, return 0.</span>
<span class="cm"> * If the block is empty, fill in the state structure and return 2.</span>
<span class="cm"> * If it can be collapsed, fill in the state structure and return 1.</span>
<span class="cm"> * If nothing can be done, return 0.</span>
<span class="cm"> *</span>
<span class="cm"> * GROT: allow for INCOMPLETE entries in calculation.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_leaf_toosmall</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">blk</span><span class="p">;</span>
	<span class="n">xfs_da_blkinfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_dablk_t</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for the degenerate case of the block being over 50% full.</span>
<span class="cm">	 * If so, it&#39;s not worth even looking to see if we might be able</span>
<span class="cm">	 * to coalesce with a sibling.</span>
<span class="cm">	 */</span>
	<span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">blk</span><span class="p">[</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">active</span><span class="o">-</span><span class="mi">1</span> <span class="p">];</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_hdr_t</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">usedbytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* blk over 50%, don&#39;t try to join */</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for the degenerate case of the block being empty.</span>
<span class="cm">	 * If the block is empty, we&#39;ll simply delete it, no need to</span>
<span class="cm">	 * coalesce it with a sibling block.  We choose (arbitrarily)</span>
<span class="cm">	 * to merge with the forward block unless it is NULL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make altpath point to the block we want to keep and</span>
<span class="cm">		 * path point to the block we want to drop (this one).</span>
<span class="cm">		 */</span>
		<span class="n">forward</span> <span class="o">=</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">forw</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">));</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_path_shift</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span>
						 <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Examine each sibling block to see if we can coalesce with</span>
<span class="cm">	 * at least 25% free space to spare.  We need to figure out</span>
<span class="cm">	 * whether to merge with the forward or the backward block.</span>
<span class="cm">	 * We prefer coalescing with the lower numbered sibling so as</span>
<span class="cm">	 * to shrink an attribute list over time.</span>
<span class="cm">	 */</span>
	<span class="cm">/* start with smaller blk num */</span>
	<span class="n">forward</span> <span class="o">=</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">forward</span> <span class="o">=</span> <span class="o">!</span><span class="n">forward</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">forward</span><span class="p">)</span>
			<span class="n">blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">forw</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">blkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span>
					<span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">leaf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
		<span class="n">count</span>  <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
		<span class="n">bytes</span>  <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">-</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">);</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">usedbytes</span><span class="p">);</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">usedbytes</span><span class="p">);</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">);</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_hdr_t</span><span class="p">);</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* fits with at least 25% to spare */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make altpath point to the block we want to keep (the lower</span>
<span class="cm">	 * numbered block) and path point to the block we want to drop.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blkno</span> <span class="o">&lt;</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_path_shift</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">altpath</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span>
						 <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_path_shift</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span>
						 <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a name from the leaf attribute list structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 1 if leaf is less than 37% full, 0 if &gt;= 37% full.</span>
<span class="cm"> * If two leaves are 37% full, when combined they will leave 25% free.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_leaf_remove</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_hdr_t</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_map_t</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">,</span> <span class="n">smallest</span><span class="p">,</span> <span class="n">entsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tablesize</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">)));</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">)</span> <span class="o">&gt;=</span>
	       <span class="p">((</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">))</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">)));</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Scan through free region table:</span>
<span class="cm">	 *    check for adjacency of free&#39;d entry with an existing one,</span>
<span class="cm">	 *    find smallest free region in case we need to replace it,</span>
<span class="cm">	 *    adjust any map that borders the entry table,</span>
<span class="cm">	 */</span>
	<span class="n">tablesize</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">)</span>
					<span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_hdr_t</span><span class="p">);</span>
	<span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">before</span> <span class="o">=</span> <span class="n">after</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">smallest</span> <span class="o">=</span> <span class="n">XFS_ATTR_LEAF_MAPSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">entsize</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_entsize</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">XFS_ATTR_LEAF_MAPSIZE</span><span class="p">;</span> <span class="n">map</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">==</span> <span class="n">tablesize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
				 <span class="o">-</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">)));</span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">+</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span>
				<span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">before</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span>
			<span class="o">==</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">)</span> <span class="o">+</span> <span class="n">entsize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">after</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">smallest</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Coalesce adjacent freemap regions,</span>
<span class="cm">	 * or replace the smallest region.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">before</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">after</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">before</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">after</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="n">before</span><span class="p">];</span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">entsize</span><span class="p">);</span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
				 <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="n">after</span><span class="p">].</span><span class="n">size</span><span class="p">));</span>
			<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="n">after</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="n">after</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">before</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="n">before</span><span class="p">];</span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">entsize</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="n">after</span><span class="p">];</span>
			<span class="cm">/* both on-disk, don&#39;t endian flip twice */</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">;</span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">entsize</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Replace smallest region (if it is smaller than free&#39;d entry)</span>
<span class="cm">		 */</span>
		<span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="n">smallest</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">entsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">));</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">entsize</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Did we remove the first entry?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">)</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">))</span>
		<span class="n">smallest</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">smallest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compress the remaining entries and zero out the removed stuff.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">xfs_attr_leaf_name</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">entsize</span><span class="p">);</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">usedbytes</span><span class="p">,</span> <span class="o">-</span><span class="n">entsize</span><span class="p">);</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
	     <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">xfs_attr_leaf_name</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">),</span>
				   <span class="n">entsize</span><span class="p">));</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span>
					<span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">);</span>
	<span class="n">memmove</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">entry</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">entry</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
	    <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)));</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)];</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">entry</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we removed the first entry, re-find the first used byte</span>
<span class="cm">	 * in the name area.  Note that if the entry was the &quot;firstused&quot;,</span>
<span class="cm">	 * then we don&#39;t have a &quot;hole&quot; in our block resulting from</span>
<span class="cm">	 * removing the name.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smallest</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">entry</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">)</span> <span class="o">&gt;=</span>
			       <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">));</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tmp</span><span class="p">)</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">firstused</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span>
					<span class="n">tmp</span> <span class="o">-</span> <span class="n">XFS_ATTR_LEAF_NAME_ALIGN</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">holes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* mark as needing compaction */</span>
	<span class="p">}</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
			  <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">)));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if leaf is less than 50% full, caller may want to</span>
<span class="cm">	 * &quot;join&quot; the leaf with a sibling if so.</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span>  <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_hdr_t</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">+=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">+=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">usedbytes</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_attr_magicpct</span><span class="p">);</span> <span class="cm">/* leaf is &lt; 37% full */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move all the attribute list entries from drop_leaf into save_leaf.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_attr_leaf_unbalance</span><span class="p">(</span><span class="n">xfs_da_state_t</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">drop_blk</span><span class="p">,</span>
				       <span class="n">xfs_da_state_blk_t</span> <span class="o">*</span><span class="n">save_blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">drop_leaf</span><span class="p">,</span> <span class="o">*</span><span class="n">save_leaf</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_leaf</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_hdr_t</span> <span class="o">*</span><span class="n">drop_hdr</span><span class="p">,</span> <span class="o">*</span><span class="n">save_hdr</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_hdr</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmpbuffer</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_leaf_unbalance</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up environment.</span>
<span class="cm">	 */</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">);</span>
	<span class="n">drop_leaf</span> <span class="o">=</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">save_leaf</span> <span class="o">=</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">drop_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">save_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">drop_hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">drop_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">save_hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">save_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save last hashval from dying block for later Btree fixup.</span>
<span class="cm">	 */</span>
	<span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span>
		<span class="n">drop_leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we need a temp buffer, or can we do it in place.</span>
<span class="cm">	 * Note that we don&#39;t check &quot;leaf&quot; for holes because we will</span>
<span class="cm">	 * always be dropping it, toosmall() decided that for us already.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">save_hdr</span><span class="o">-&gt;</span><span class="n">holes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * dest leaf has no holes, so we add there.  May need</span>
<span class="cm">		 * to make some room in the entry array.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfs_attr_leaf_order</span><span class="p">(</span><span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_attr_leaf_moveents</span><span class="p">(</span><span class="n">drop_leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">save_leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">),</span> <span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xfs_attr_leaf_moveents</span><span class="p">(</span><span class="n">drop_leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">save_leaf</span><span class="p">,</span>
				  <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">save_hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">),</span>
				  <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">),</span> <span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Destination has holes, so we make a temporary copy</span>
<span class="cm">		 * of the leaf and add them both to that.</span>
<span class="cm">		 */</span>
		<span class="n">tmpbuffer</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">,</span> <span class="n">KM_SLEEP</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">tmpbuffer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">tmpbuffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">);</span>
		<span class="n">tmp_leaf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="p">)</span><span class="n">tmpbuffer</span><span class="p">;</span>
		<span class="n">tmp_hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
		<span class="n">tmp_hdr</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="n">save_hdr</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>	<span class="cm">/* struct copy */</span>
		<span class="n">tmp_hdr</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tmp_hdr</span><span class="o">-&gt;</span><span class="n">firstused</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp_hdr</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp_hdr</span><span class="o">-&gt;</span><span class="n">firstused</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span>
				<span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">-</span> <span class="n">XFS_ATTR_LEAF_NAME_ALIGN</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">tmp_hdr</span><span class="o">-&gt;</span><span class="n">usedbytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfs_attr_leaf_order</span><span class="p">(</span><span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="n">drop_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_attr_leaf_moveents</span><span class="p">(</span><span class="n">drop_leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp_leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">),</span> <span class="n">mp</span><span class="p">);</span>
			<span class="n">xfs_attr_leaf_moveents</span><span class="p">(</span><span class="n">save_leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp_leaf</span><span class="p">,</span>
				  <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">tmp_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">),</span>
				  <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">save_hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">),</span> <span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xfs_attr_leaf_moveents</span><span class="p">(</span><span class="n">save_leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp_leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">save_hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">),</span> <span class="n">mp</span><span class="p">);</span>
			<span class="n">xfs_attr_leaf_moveents</span><span class="p">(</span><span class="n">drop_leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp_leaf</span><span class="p">,</span>
				<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">tmp_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">),</span>
				<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">drop_hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">),</span> <span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">save_leaf</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">tmp_leaf</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">);</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">tmpbuffer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">state</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy out last hashval in each block for B-tree code.</span>
<span class="cm">	 */</span>
	<span class="n">save_blk</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span>
		<span class="n">save_leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">save_leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*========================================================================</span>
<span class="cm"> * Routines used for finding things in the Btree.</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Look up a name in a leaf attribute list structure.</span>
<span class="cm"> * This is the internal routine, it uses the caller&#39;s buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that duplicate keys are allowed, but only check within the</span>
<span class="cm"> * current leaf node.  The Btree code must check in adjacent leaf nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * Return in args-&gt;index the index into the entry[] array of either</span>
<span class="cm"> * the found entry, or where the entry should have been (insert before</span>
<span class="cm"> * that entry).</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t change the args-&gt;value unless we find the attribute.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_leaf_lookup_int</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_name_local_t</span> <span class="o">*</span><span class="n">name_loc</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_name_remote_t</span> <span class="o">*</span><span class="n">name_rmt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">probe</span><span class="p">,</span> <span class="n">span</span><span class="p">;</span>
	<span class="n">xfs_dahash_t</span> <span class="n">hashval</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_leaf_lookup</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
					<span class="o">&lt;</span> <span class="p">(</span><span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Binary search.  (note: small blocks will skip this loop)</span>
<span class="cm">	 */</span>
	<span class="n">hashval</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">;</span>
	<span class="n">probe</span> <span class="o">=</span> <span class="n">span</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">probe</span><span class="p">];</span> <span class="n">span</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">;</span>
		   <span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">probe</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">span</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">hashval</span><span class="p">)</span>
			<span class="n">probe</span> <span class="o">+=</span> <span class="n">span</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">hashval</span><span class="p">)</span>
			<span class="n">probe</span> <span class="o">-=</span> <span class="n">span</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">probe</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="o">!</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span>
	       <span class="o">||</span> <span class="p">(</span><span class="n">probe</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))));</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">span</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">==</span> <span class="n">hashval</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we may have duplicate hashval&#39;s, find the first matching</span>
<span class="cm">	 * hashval in the leaf.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">probe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">hashval</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">--</span><span class="p">;</span>
		<span class="n">probe</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">probe</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">hashval</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">++</span><span class="p">;</span>
		<span class="n">probe</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">probe</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">!=</span> <span class="n">hashval</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">probe</span><span class="p">;</span>
		<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOATTR</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Duplicate keys may be present, so search all of them for a match.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span>  <span class="p">;</span> <span class="p">(</span><span class="n">probe</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">==</span> <span class="n">hashval</span><span class="p">);</span>
			<span class="n">entry</span><span class="o">++</span><span class="p">,</span> <span class="n">probe</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="cm">/*</span>
<span class="cm"> * GROT: Add code to remove incomplete entries.</span>
<span class="cm"> */</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we are looking for INCOMPLETE entries, show only those.</span>
<span class="cm">		 * If we are looking for complete entries, show only those.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">name_loc</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_local</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">probe</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">!=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_attr_namesp_match</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">probe</span><span class="p">;</span>
			<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EEXIST</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">name_rmt</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_remote</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">probe</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">!=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					     <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_attr_namesp_match</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">probe</span><span class="p">;</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valueblk</span><span class="p">);</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
						   <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">));</span>
			<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EEXIST</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">probe</span><span class="p">;</span>
	<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ENOATTR</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the value associated with an attribute name from a leaf attribute</span>
<span class="cm"> * list structure.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_leaf_getvalue</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">valuelen</span><span class="p">;</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_name_local_t</span> <span class="o">*</span><span class="n">name_loc</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_name_remote_t</span> <span class="o">*</span><span class="n">name_rmt</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
					<span class="o">&lt;</span> <span class="p">(</span><span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">));</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">name_loc</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_local</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">valuelen</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_KERNOVAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">valuelen</span><span class="p">;</span>
			<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">&lt;</span> <span class="n">valuelen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">valuelen</span><span class="p">;</span>
			<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ERANGE</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">valuelen</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">[</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">],</span> <span class="n">valuelen</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">name_rmt</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_remote</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">namelen</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">valuelen</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valueblk</span><span class="p">);</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkcnt</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATTR_KERNOVAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">valuelen</span><span class="p">;</span>
			<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">&lt;</span> <span class="n">valuelen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">valuelen</span><span class="p">;</span>
			<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">ERANGE</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">valuelen</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*========================================================================</span>
<span class="cm"> * Utility routines.</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Move the indicated entries from one leaf to another.</span>
<span class="cm"> * NOTE: this routine modifies both source and destination leaves.</span>
<span class="cm"> */</span>
<span class="cm">/*ARGSUSED*/</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_attr_leaf_moveents</span><span class="p">(</span><span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf_s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_s</span><span class="p">,</span>
			<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf_d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_d</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">xfs_mount_t</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leaf_hdr_t</span> <span class="o">*</span><span class="n">hdr_s</span><span class="p">,</span> <span class="o">*</span><span class="n">hdr_d</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_entry_t</span> <span class="o">*</span><span class="n">entry_s</span><span class="p">,</span> <span class="o">*</span><span class="n">entry_d</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">desti</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for nothing to do.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up environment.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf_d</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">hdr_s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">hdr_d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf_d</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">)));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">)</span> <span class="o">&gt;=</span>
		<span class="p">((</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
					<span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry_s</span><span class="p">))</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr_s</span><span class="p">)));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">)</span> <span class="o">&gt;=</span>
		<span class="p">((</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
					<span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry_d</span><span class="p">))</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr_d</span><span class="p">)));</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">start_s</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">start_d</span> <span class="o">&lt;=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Move the entries in the destination leaf up to make a hole?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_d</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span>  <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">start_d</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">*=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">);</span>
		<span class="n">entry_s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf_d</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">start_d</span><span class="p">];</span>
		<span class="n">entry_d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf_d</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">start_d</span> <span class="o">+</span> <span class="n">count</span><span class="p">];</span>
		<span class="n">memmove</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">entry_d</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">entry_s</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy all entry&#39;s in the same (sorted) order,</span>
<span class="cm">	 * but allocate attribute info packed and in sequence.</span>
<span class="cm">	 */</span>
	<span class="n">entry_s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">start_s</span><span class="p">];</span>
	<span class="n">entry_d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf_d</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">start_d</span><span class="p">];</span>
	<span class="n">desti</span> <span class="o">=</span> <span class="n">start_d</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">entry_s</span><span class="o">++</span><span class="p">,</span> <span class="n">entry_d</span><span class="o">++</span><span class="p">,</span> <span class="n">desti</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry_s</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">)</span>
				<span class="o">&gt;=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">));</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_entsize</span><span class="p">(</span><span class="n">leaf_s</span><span class="p">,</span> <span class="n">start_s</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="cp">#ifdef GROT</span>
		<span class="cm">/*</span>
<span class="cm">		 * Code to drop INCOMPLETE entries.  Difficult to use as we</span>
<span class="cm">		 * may also need to change the insertion index.  Code turned</span>
<span class="cm">		 * off for 6.2, should be revisited later.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry_s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* skip partials? */</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">xfs_attr_leaf_name</span><span class="p">(</span><span class="n">leaf_s</span><span class="p">,</span> <span class="n">start_s</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">usedbytes</span><span class="p">,</span> <span class="o">-</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">entry_d</span><span class="o">--</span><span class="p">;</span>	<span class="cm">/* to compensate for ++ in loop hdr */</span>
			<span class="n">desti</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">start_s</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">)</span>
				<span class="n">result</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* insertion index adjustment */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#endif </span><span class="cm">/* GROT */</span><span class="cp"></span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">,</span> <span class="o">-</span><span class="n">tmp</span><span class="p">);</span>
			<span class="cm">/* both on-disk, don&#39;t endian flip twice */</span>
			<span class="n">entry_d</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">entry_s</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">;</span>
			<span class="cm">/* both on-disk, don&#39;t endian flip twice */</span>
			<span class="n">entry_d</span><span class="o">-&gt;</span><span class="n">nameidx</span> <span class="o">=</span> <span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">;</span>
			<span class="n">entry_d</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">entry_s</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry_d</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">)</span> <span class="o">+</span> <span class="n">tmp</span>
							<span class="o">&lt;=</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
			<span class="n">memmove</span><span class="p">(</span><span class="n">xfs_attr_leaf_name</span><span class="p">(</span><span class="n">leaf_d</span><span class="p">,</span> <span class="n">desti</span><span class="p">),</span>
				<span class="n">xfs_attr_leaf_name</span><span class="p">(</span><span class="n">leaf_s</span><span class="p">,</span> <span class="n">start_s</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span> <span class="n">tmp</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry_s</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">)</span> <span class="o">+</span> <span class="n">tmp</span>
							<span class="o">&lt;=</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">xfs_attr_leaf_name</span><span class="p">(</span><span class="n">leaf_s</span><span class="p">,</span> <span class="n">start_s</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">usedbytes</span><span class="p">,</span> <span class="o">-</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">usedbytes</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
						<span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">)</span>
						<span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_hdr_t</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">tmp</span><span class="p">);</span>
<span class="cp">#ifdef GROT</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* GROT */</span><span class="cp"></span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Zero out the entries we just copied.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_s</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">);</span>
		<span class="n">entry_s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">start_s</span><span class="p">];</span>
		<span class="n">ASSERT</span><span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">entry_s</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">)</span> <span class="o">&lt;=</span>
		       <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">leaf_s</span> <span class="o">+</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)));</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">entry_s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Move the remaining entries down to fill the hole,</span>
<span class="cm">		 * then zero the entries at the top.</span>
<span class="cm">		 */</span>
		<span class="n">tmp</span>  <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">*=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">);</span>
		<span class="n">entry_s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">start_s</span> <span class="o">+</span> <span class="n">count</span><span class="p">];</span>
		<span class="n">entry_d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">start_s</span><span class="p">];</span>
		<span class="n">memmove</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">entry_d</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">entry_s</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">);</span>
		<span class="n">entry_s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf_s</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)];</span>
		<span class="n">ASSERT</span><span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">entry_s</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">)</span> <span class="o">&lt;=</span>
		       <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">leaf_s</span> <span class="o">+</span> <span class="n">XFS_LBSIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)));</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">entry_s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in the freemap information</span>
<span class="cm">	 */</span>
	<span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_hdr_t</span><span class="p">));</span>
	<span class="n">be16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">base</span><span class="p">,</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">*</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_leaf_entry_t</span><span class="p">));</span>
	<span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">firstused</span><span class="p">)</span>
			      <span class="o">-</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">base</span><span class="p">));</span>
	<span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hdr_d</span><span class="o">-&gt;</span><span class="n">freemap</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hdr_s</span><span class="o">-&gt;</span><span class="n">holes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* leaf may not be compact */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compare two leaf blocks &quot;order&quot;.</span>
<span class="cm"> * Return 0 unless leaf2 should go before leaf1.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_leaf_order</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">leaf1_bp</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">leaf2_bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf1</span><span class="p">,</span> <span class="o">*</span><span class="n">leaf2</span><span class="p">;</span>

	<span class="n">leaf1</span> <span class="o">=</span> <span class="n">leaf1_bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">leaf2</span> <span class="o">=</span> <span class="n">leaf2_bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">)));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span>
	      <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hashval</span><span class="p">))</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span>
			<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&lt;</span>
	      <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span>
			<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">))))</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pick up the last hashvalue from a leaf block.</span>
<span class="cm"> */</span>
<span class="n">xfs_dahash_t</span>
<span class="nf">xfs_attr_leaf_lasthash</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">hashval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the number of bytes used to store the indicated attribute</span>
<span class="cm"> * (whether local or remote only calculate bytes in this block).</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_leaf_entsize</span><span class="p">(</span><span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leaf_name_local_t</span> <span class="o">*</span><span class="n">name_loc</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_name_remote_t</span> <span class="o">*</span><span class="n">name_rmt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">name_loc</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_local</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_entsize_local</span><span class="p">(</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span>
						   <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">name_rmt</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_remote</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_entsize_remote</span><span class="p">(</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the number of bytes that would be required to store the new</span>
<span class="cm"> * attribute (whether local or remote only calculate bytes in this block).</span>
<span class="cm"> * This routine decides as a side effect whether the attribute will be</span>
<span class="cm"> * a &quot;local&quot; or a &quot;remote&quot; attribute.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_leaf_newentsize</span><span class="p">(</span><span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">valuelen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blocksize</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_entsize_local</span><span class="p">(</span><span class="n">namelen</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">xfs_attr_leaf_entsize_local_max</span><span class="p">(</span><span class="n">blocksize</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_entsize_remote</span><span class="p">(</span><span class="n">namelen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy out attribute list entries for attr_list(), for leaf attribute lists.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_leaf_list_int</span><span class="p">(</span><span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">xfs_attr_list_context_t</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">attrlist_cursor_kern_t</span> <span class="o">*</span><span class="n">cursor</span><span class="p">;</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">cursor</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">cursor</span><span class="p">;</span>
	<span class="n">cursor</span><span class="o">-&gt;</span><span class="n">initted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_list_leaf</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Re-find our place in the leaf block if this is a new syscall.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">resynch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span> <span class="n">entry</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">==</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">==</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">dupcnt</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">context</span><span class="o">-&gt;</span><span class="n">dupcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">context</span><span class="o">-&gt;</span><span class="n">dupcnt</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">&gt;</span>
					<span class="n">cursor</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">context</span><span class="o">-&gt;</span><span class="n">dupcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">trace_xfs_attr_list_notfound</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
			<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">context</span><span class="o">-&gt;</span><span class="n">resynch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have found our place, start copying out the new attributes.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span>  <span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">));</span> <span class="n">entry</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cursor</span><span class="o">-&gt;</span><span class="n">hashval</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>
			<span class="n">cursor</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>		<span class="cm">/* skip incomplete entries */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_attr_leaf_name_local_t</span> <span class="o">*</span><span class="n">name_loc</span> <span class="o">=</span>
				<span class="n">xfs_attr_leaf_name_local</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

			<span class="n">retval</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">put_listent</span><span class="p">(</span><span class="n">context</span><span class="p">,</span>
						<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
						<span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span>
						<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">),</span>
						<span class="o">&amp;</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">[</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xfs_attr_leaf_name_remote_t</span> <span class="o">*</span><span class="n">name_rmt</span> <span class="o">=</span>
				<span class="n">xfs_attr_leaf_name_remote</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

			<span class="kt">int</span> <span class="n">valuelen</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">put_value</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_da_args_t</span> <span class="n">args</span><span class="p">;</span>

				<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">));</span>
				<span class="n">args</span><span class="p">.</span><span class="n">dp</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">;</span>
				<span class="n">args</span><span class="p">.</span><span class="n">whichfork</span> <span class="o">=</span> <span class="n">XFS_ATTR_FORK</span><span class="p">;</span>
				<span class="n">args</span><span class="p">.</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">valuelen</span><span class="p">;</span>
				<span class="n">args</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">valuelen</span><span class="p">,</span> <span class="n">KM_SLEEP</span> <span class="o">|</span> <span class="n">KM_NOFS</span><span class="p">);</span>
				<span class="n">args</span><span class="p">.</span><span class="n">rmtblkno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valueblk</span><span class="p">);</span>
				<span class="n">args</span><span class="p">.</span><span class="n">rmtblkcnt</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">);</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">xfs_attr_rmtval_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">put_listent</span><span class="p">(</span><span class="n">context</span><span class="p">,</span>
						<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
						<span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span>
						<span class="n">valuelen</span><span class="p">,</span>
						<span class="n">args</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
				<span class="n">kmem_free</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">put_listent</span><span class="p">(</span><span class="n">context</span><span class="p">,</span>
						<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
						<span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span>
						<span class="n">valuelen</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">seen_enough</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cursor</span><span class="o">-&gt;</span><span class="n">offset</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">trace_xfs_attr_list_leaf_end</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*========================================================================</span>
<span class="cm"> * Manage the INCOMPLETE flag in a leaf entry</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Clear the INCOMPLETE flag on an entry in a leaf block.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_leaf_clearflag</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_name_remote_t</span> <span class="o">*</span><span class="n">name_rmt</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">xfs_attr_leaf_name_local_t</span> <span class="o">*</span><span class="n">name_loc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>

	<span class="n">trace_xfs_attr_leaf_clearflag</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set up the operation.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span>
					     <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="p">];</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">name_loc</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_local</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">namelen</span> <span class="o">=</span> <span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
		<span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">name_rmt</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_remote</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">namelen</span> <span class="o">=</span> <span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
		<span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">namelen</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">;</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
			 <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">((</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">name_rmt</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_remote</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valueblk</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span><span class="p">);</span>
		<span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
			 <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">name_rmt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">name_rmt</span><span class="p">)));</span>
	<span class="p">}</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Commit the flag value change and start the next trans in series.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the INCOMPLETE flag on an entry in a leaf block.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_leaf_setflag</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_name_remote_t</span> <span class="o">*</span><span class="n">name_rmt</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">trace_xfs_attr_leaf_setflag</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up the operation.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span>
					     <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="p">];</span>

	<span class="n">ASSERT</span><span class="p">((</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">;</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
			<span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">name_rmt</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_remote</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valueblk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span>
			 <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">name_rmt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">name_rmt</span><span class="p">)));</span>
	<span class="p">}</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Commit the flag value change and start the next trans in series.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * In a single transaction, clear the INCOMPLETE flag on the leaf entry</span>
<span class="cm"> * given by args-&gt;blkno/index and set the INCOMPLETE flag on the leaf</span>
<span class="cm"> * entry given by args-&gt;blkno2/index2.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that they could be in different blocks, or in the same block.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_leaf_flipflags</span><span class="p">(</span><span class="n">xfs_da_args_t</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf1</span><span class="p">,</span> <span class="o">*</span><span class="n">leaf2</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_entry_t</span> <span class="o">*</span><span class="n">entry1</span><span class="p">,</span> <span class="o">*</span><span class="n">entry2</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_name_remote_t</span> <span class="o">*</span><span class="n">name_rmt</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp1</span><span class="p">,</span> <span class="o">*</span><span class="n">bp2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">xfs_attr_leaf_name_local_t</span> <span class="o">*</span><span class="n">name_loc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">namelen1</span><span class="p">,</span> <span class="n">namelen2</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name1</span><span class="p">,</span> <span class="o">*</span><span class="n">name2</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>

	<span class="n">trace_xfs_attr_leaf_flipflags</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the block containing the &quot;old&quot; attr</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp1</span><span class="p">,</span>
					     <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the block containing the &quot;new&quot; attr, if it is different</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno2</span> <span class="o">!=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">blkno2</span><span class="p">,</span>
					<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp2</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bp2</span> <span class="o">=</span> <span class="n">bp1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">leaf1</span> <span class="o">=</span> <span class="n">bp1</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">entry1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf1</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span> <span class="p">];</span>

	<span class="n">leaf2</span> <span class="o">=</span> <span class="n">bp2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">entry2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf2</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span> <span class="p">];</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry1</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">name_loc</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_local</span><span class="p">(</span><span class="n">leaf1</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">namelen1</span> <span class="o">=</span> <span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
		<span class="n">name1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">name_rmt</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_remote</span><span class="p">(</span><span class="n">leaf1</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">namelen1</span> <span class="o">=</span> <span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
		<span class="n">name1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry2</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">name_loc</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_local</span><span class="p">(</span><span class="n">leaf2</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span><span class="p">);</span>
		<span class="n">namelen2</span> <span class="o">=</span> <span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
		<span class="n">name2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">name_loc</span><span class="o">-&gt;</span><span class="n">nameval</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">name_rmt</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_remote</span><span class="p">(</span><span class="n">leaf2</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span><span class="p">);</span>
		<span class="n">namelen2</span> <span class="o">=</span> <span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
		<span class="n">name2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry1</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">)</span> <span class="o">==</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">entry2</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">namelen1</span> <span class="o">==</span> <span class="n">namelen2</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">namelen1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">entry1</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">entry2</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">entry1</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">;</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp1</span><span class="p">,</span>
			  <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf1</span><span class="p">,</span> <span class="n">entry1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry1</span><span class="p">)));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">((</span><span class="n">entry1</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">name_rmt</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_remote</span><span class="p">(</span><span class="n">leaf1</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valueblk</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">rmtblkno</span><span class="p">);</span>
		<span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp1</span><span class="p">,</span>
			 <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf1</span><span class="p">,</span> <span class="n">name_rmt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">name_rmt</span><span class="p">)));</span>
	<span class="p">}</span>

	<span class="n">entry2</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_ATTR_INCOMPLETE</span><span class="p">;</span>
	<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span>
			  <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf2</span><span class="p">,</span> <span class="n">entry2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry2</span><span class="p">)));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">entry2</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">name_rmt</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_remote</span><span class="p">(</span><span class="n">leaf2</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">index2</span><span class="p">);</span>
		<span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valueblk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xfs_da_log_buf</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span>
			 <span class="n">XFS_DA_LOGRANGE</span><span class="p">(</span><span class="n">leaf2</span><span class="p">,</span> <span class="n">name_rmt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">name_rmt</span><span class="p">)));</span>
	<span class="p">}</span>
	<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp1</span> <span class="o">!=</span> <span class="n">bp2</span><span class="p">)</span>
		<span class="n">xfs_da_buf_done</span><span class="p">(</span><span class="n">bp2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Commit the flag value change and start the next trans in series.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">trans</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dp</span><span class="p">);</span>

	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*========================================================================</span>
<span class="cm"> * Indiscriminately delete the entire attribute fork</span>
<span class="cm"> *========================================================================*/</span>

<span class="cm">/*</span>
<span class="cm"> * Recurse (gasp!) through the attribute nodes until we find leaves.</span>
<span class="cm"> * We&#39;re doing a depth-first traversal in order to invalidate everything.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_attr_root_inactive</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">**</span><span class="n">trans</span><span class="p">,</span> <span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_blkinfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read block 0 to see what we have to work with.</span>
<span class="cm">	 * We only get here if we have extents, since we remove</span>
<span class="cm">	 * the extents in reverse order the extent containing</span>
<span class="cm">	 * block 0 must still be there.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">blkno</span> <span class="o">=</span> <span class="n">xfs_da_blkno</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Invalidate the tree, even if the &quot;tree&quot; is only a single leaf block.</span>
<span class="cm">	 * This is a depth-first traversal!</span>
<span class="cm">	 */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_node_inactive</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_inactive</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Invalidate the incore copy of the root block.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_get_buf</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">xfs_da_binval</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>	<span class="cm">/* remove from cache */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Commit the invalidate and start the next transaction.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Recurse (gasp!) through the attribute nodes until we find leaves.</span>
<span class="cm"> * We&#39;re doing a depth-first traversal in order to invalidate everything.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_node_inactive</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">**</span><span class="n">trans</span><span class="p">,</span> <span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_da_blkinfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="n">xfs_da_intnode_t</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">xfs_dablk_t</span> <span class="n">child_fsb</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span> <span class="n">parent_blkno</span><span class="p">,</span> <span class="n">child_blkno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">child_bp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since this code is recursive (gasp!) we must protect ourselves.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">XFS_DA_NODE_MAXDEPTH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>	<span class="cm">/* no locks for later trans */</span>
		<span class="k">return</span><span class="p">(</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">));</span>
	<span class="n">parent_blkno</span> <span class="o">=</span> <span class="n">xfs_da_blkno</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>	<span class="cm">/* save for re-read later */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">child_fsb</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">before</span><span class="p">);</span>
	<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>	<span class="cm">/* no locks for later trans */</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is the node level just above the leaves, simply loop</span>
<span class="cm">	 * over the leaves removing all of them.  If this is higher up</span>
<span class="cm">	 * in the tree, recurse downward.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Read the subsidiary block to see what we have to work with.</span>
<span class="cm">		 * Don&#39;t do this in a transaction.  This is a depth-first</span>
<span class="cm">		 * traversal of the tree so we may deal with many blocks</span>
<span class="cm">		 * before we come back to this one.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">child_fsb</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_bp</span><span class="p">,</span>
						<span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">child_bp</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* save for re-read later */</span>
			<span class="n">child_blkno</span> <span class="o">=</span> <span class="n">xfs_da_blkno</span><span class="p">(</span><span class="n">child_bp</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Invalidate the subtree, however we have to.</span>
<span class="cm">			 */</span>
			<span class="n">info</span> <span class="o">=</span> <span class="n">child_bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DA_NODE_MAGIC</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_node_inactive</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span>
						<span class="n">child_bp</span><span class="p">,</span> <span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_inactive</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span>
						<span class="n">child_bp</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
				<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">child_bp</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Remove the subsidiary block from the cache</span>
<span class="cm">			 * and from the log.</span>
<span class="cm">			 */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_get_buf</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">child_blkno</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">child_bp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
			<span class="n">xfs_da_binval</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">child_bp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we&#39;re not done, re-read the parent to get the next</span>
<span class="cm">		 * child block number.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_da_read_buf</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">parent_blkno</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
			<span class="n">child_fsb</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">btree</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">before</span><span class="p">);</span>
			<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Atomically commit the whole invalidate stuff.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Invalidate all of the &quot;remote&quot; value regions pointed to by a particular</span>
<span class="cm"> * leaf block.</span>
<span class="cm"> * Note that we must release the lock on the buffer so that we are not</span>
<span class="cm"> * caught holding something that the logging code wants to flush to disk.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_leaf_inactive</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">**</span><span class="n">trans</span><span class="p">,</span> <span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span> <span class="n">xfs_dabuf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_leafblock_t</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">xfs_attr_leaf_name_remote_t</span> <span class="o">*</span><span class="n">name_rmt</span><span class="p">;</span>
	<span class="n">xfs_attr_inactive_list_t</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_ATTR_LEAF_MAGIC</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Count the number of &quot;remote&quot; value extents.</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span> <span class="n">entry</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">name_rmt</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_remote</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valueblk</span><span class="p">)</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are no &quot;remote&quot; values, we&#39;re done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate storage for a list of all the &quot;remote&quot; value extents.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_attr_inactive_list_t</span><span class="p">);</span>
	<span class="n">list</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_inactive_list_t</span> <span class="o">*</span><span class="p">)</span><span class="n">kmem_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">KM_SLEEP</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Identify each of the &quot;remote&quot; value extents.</span>
<span class="cm">	 */</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">count</span><span class="p">);</span> <span class="n">entry</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">nameidx</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">XFS_ATTR_LOCAL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">name_rmt</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_name_remote</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valueblk</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">valueblk</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valueblk</span><span class="p">);</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">valuelen</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
						    <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">name_rmt</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">));</span>
				<span class="n">lp</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">xfs_da_brelse</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>	<span class="cm">/* unlock for trans. in freextent() */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Invalidate each of the &quot;remote&quot; value extents.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lp</span> <span class="o">=</span> <span class="n">list</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">lp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">xfs_attr_leaf_freextent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">valueblk</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">valuelen</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>	<span class="cm">/* save only the 1st errno */</span>
	<span class="p">}</span>

	<span class="n">kmem_free</span><span class="p">((</span><span class="n">xfs_caddr_t</span><span class="p">)</span><span class="n">list</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look at all the extents for this logical region,</span>
<span class="cm"> * invalidate any buffers that are incore/in transactions.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_attr_leaf_freextent</span><span class="p">(</span><span class="n">xfs_trans_t</span> <span class="o">**</span><span class="n">trans</span><span class="p">,</span> <span class="n">xfs_inode_t</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
				    <span class="n">xfs_dablk_t</span> <span class="n">blkno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blkcnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_bmbt_irec_t</span> <span class="n">map</span><span class="p">;</span>
	<span class="n">xfs_dablk_t</span> <span class="n">tblkno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tblkcnt</span><span class="p">,</span> <span class="n">dblkcnt</span><span class="p">,</span> <span class="n">nmap</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span> <span class="n">dblkno</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Roll through the &quot;value&quot;, invalidating the attribute value&#39;s</span>
<span class="cm">	 * blocks.</span>
<span class="cm">	 */</span>
	<span class="n">tblkno</span> <span class="o">=</span> <span class="n">blkno</span><span class="p">;</span>
	<span class="n">tblkcnt</span> <span class="o">=</span> <span class="n">blkcnt</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tblkcnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Try to remember where we decided to put the value.</span>
<span class="cm">		 */</span>
		<span class="n">nmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_fileoff_t</span><span class="p">)</span><span class="n">tblkno</span><span class="p">,</span> <span class="n">tblkcnt</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmap</span><span class="p">,</span> <span class="n">XFS_BMAPI_ATTRFORK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nmap</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If it&#39;s a hole, these are already unmapped</span>
<span class="cm">		 * so there&#39;s nothing to invalidate.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">HOLESTARTBLOCK</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">dblkno</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_DADDR</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
						  <span class="n">map</span><span class="p">.</span><span class="n">br_startblock</span><span class="p">);</span>
			<span class="n">dblkcnt</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_BB</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
						<span class="n">map</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">);</span>
			<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_trans_get_buf</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					<span class="n">dp</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span>
					<span class="n">dblkno</span><span class="p">,</span> <span class="n">dblkcnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">xfs_trans_binval</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Roll to next transaction.</span>
<span class="cm">			 */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_roll</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">tblkno</span> <span class="o">+=</span> <span class="n">map</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">;</span>
		<span class="n">tblkcnt</span> <span class="o">-=</span> <span class="n">map</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
