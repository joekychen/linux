<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_log_priv.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_log_priv.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2003,2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#ifndef	__XFS_LOG_PRIV_H__</span>
<span class="cp">#define __XFS_LOG_PRIV_H__</span>

<span class="k">struct</span> <span class="n">xfs_buf</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xlog</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xlog_ticket</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xfs_mount</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Macros, structures, prototypes for internal log manager use.</span>
<span class="cm"> */</span>

<span class="cp">#define XLOG_MIN_ICLOGS		2</span>
<span class="cp">#define XLOG_MAX_ICLOGS		8</span>
<span class="cp">#define XLOG_HEADER_MAGIC_NUM	0xFEEDbabe	</span><span class="cm">/* Invalid cycle number */</span><span class="cp"></span>
<span class="cp">#define XLOG_VERSION_1		1</span>
<span class="cp">#define XLOG_VERSION_2		2		</span><span class="cm">/* Large IClogs, Log sunit */</span><span class="cp"></span>
<span class="cp">#define XLOG_VERSION_OKBITS	(XLOG_VERSION_1 | XLOG_VERSION_2)</span>
<span class="cp">#define XLOG_MIN_RECORD_BSIZE	(16*1024)	</span><span class="cm">/* eventually 32k */</span><span class="cp"></span>
<span class="cp">#define XLOG_BIG_RECORD_BSIZE	(32*1024)	</span><span class="cm">/* 32k buffers */</span><span class="cp"></span>
<span class="cp">#define XLOG_MAX_RECORD_BSIZE	(256*1024)</span>
<span class="cp">#define XLOG_HEADER_CYCLE_SIZE	(32*1024)	</span><span class="cm">/* cycle data in header */</span><span class="cp"></span>
<span class="cp">#define XLOG_MIN_RECORD_BSHIFT	14		</span><span class="cm">/* 16384 == 1 &lt;&lt; 14 */</span><span class="cp"></span>
<span class="cp">#define XLOG_BIG_RECORD_BSHIFT	15		</span><span class="cm">/* 32k == 1 &lt;&lt; 15 */</span><span class="cp"></span>
<span class="cp">#define XLOG_MAX_RECORD_BSHIFT	18		</span><span class="cm">/* 256k == 1 &lt;&lt; 18 */</span><span class="cp"></span>
<span class="cp">#define XLOG_BTOLSUNIT(log, b)  (((b)+(log)-&gt;l_mp-&gt;m_sb.sb_logsunit-1) / \</span>
<span class="cp">                                 (log)-&gt;l_mp-&gt;m_sb.sb_logsunit)</span>
<span class="cp">#define XLOG_LSUNITTOB(log, su) ((su) * (log)-&gt;l_mp-&gt;m_sb.sb_logsunit)</span>

<span class="cp">#define XLOG_HEADER_SIZE	512</span>

<span class="cp">#define XLOG_REC_SHIFT(log) \</span>
<span class="cp">	BTOBB(1 &lt;&lt; (xfs_sb_version_haslogv2(&amp;log-&gt;l_mp-&gt;m_sb) ? \</span>
<span class="cp">	 XLOG_MAX_RECORD_BSHIFT : XLOG_BIG_RECORD_BSHIFT))</span>
<span class="cp">#define XLOG_TOTAL_REC_SHIFT(log) \</span>
<span class="cp">	BTOBB(XLOG_MAX_ICLOGS &lt;&lt; (xfs_sb_version_haslogv2(&amp;log-&gt;l_mp-&gt;m_sb) ? \</span>
<span class="cp">	 XLOG_MAX_RECORD_BSHIFT : XLOG_BIG_RECORD_BSHIFT))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">xfs_lsn_t</span> <span class="nf">xlog_assign_lsn</span><span class="p">(</span><span class="n">uint</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">uint</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">xfs_lsn_t</span><span class="p">)</span><span class="n">cycle</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">block</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">uint</span> <span class="nf">xlog_get_cycle</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">)</span> <span class="o">==</span> <span class="n">XLOG_HEADER_MAGIC_NUM</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define BLK_AVG(blk1, blk2)	((blk1+blk2) &gt;&gt; 1)</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/*</span>
<span class="cm"> * get client id from packed copy.</span>
<span class="cm"> *</span>
<span class="cm"> * this hack is here because the xlog_pack code copies four bytes</span>
<span class="cm"> * of xlog_op_header containing the fields oh_clientid, oh_flags</span>
<span class="cm"> * and oh_res2 into the packed copy.</span>
<span class="cm"> *</span>
<span class="cm"> * later on this four byte chunk is treated as an int and the</span>
<span class="cm"> * client id is pulled out.</span>
<span class="cm"> *</span>
<span class="cm"> * this has endian issues, of course.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">uint</span> <span class="nf">xlog_get_client_id</span><span class="p">(</span><span class="n">__be32</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * In core log state</span>
<span class="cm"> */</span>
<span class="cp">#define XLOG_STATE_ACTIVE    0x0001 </span><span class="cm">/* Current IC log being written to */</span><span class="cp"></span>
<span class="cp">#define XLOG_STATE_WANT_SYNC 0x0002 </span><span class="cm">/* Want to sync this iclog; no more writes */</span><span class="cp"></span>
<span class="cp">#define XLOG_STATE_SYNCING   0x0004 </span><span class="cm">/* This IC log is syncing */</span><span class="cp"></span>
<span class="cp">#define XLOG_STATE_DONE_SYNC 0x0008 </span><span class="cm">/* Done syncing to disk */</span><span class="cp"></span>
<span class="cp">#define XLOG_STATE_DO_CALLBACK \</span>
<span class="cp">			     0x0010 </span><span class="cm">/* Process callback functions */</span><span class="cp"></span>
<span class="cp">#define XLOG_STATE_CALLBACK  0x0020 </span><span class="cm">/* Callback functions now */</span><span class="cp"></span>
<span class="cp">#define XLOG_STATE_DIRTY     0x0040 </span><span class="cm">/* Dirty IC log, not ready for ACTIVE status*/</span><span class="cp"></span>
<span class="cp">#define XLOG_STATE_IOERROR   0x0080 </span><span class="cm">/* IO error happened in sync&#39;ing log */</span><span class="cp"></span>
<span class="cp">#define XLOG_STATE_ALL	     0x7FFF </span><span class="cm">/* All possible valid flags */</span><span class="cp"></span>
<span class="cp">#define XLOG_STATE_NOTUSED   0x8000 </span><span class="cm">/* This IC log not being used */</span><span class="cp"></span>
<span class="cp">#endif	</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Flags to log operation header</span>
<span class="cm"> *</span>
<span class="cm"> * The first write of a new transaction will be preceded with a start</span>
<span class="cm"> * record, XLOG_START_TRANS.  Once a transaction is committed, a commit</span>
<span class="cm"> * record is written, XLOG_COMMIT_TRANS.  If a single region can not fit into</span>
<span class="cm"> * the remainder of the current active in-core log, it is split up into</span>
<span class="cm"> * multiple regions.  Each partial region will be marked with a</span>
<span class="cm"> * XLOG_CONTINUE_TRANS until the last one, which gets marked with XLOG_END_TRANS.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define XLOG_START_TRANS	0x01	</span><span class="cm">/* Start a new transaction */</span><span class="cp"></span>
<span class="cp">#define XLOG_COMMIT_TRANS	0x02	</span><span class="cm">/* Commit this transaction */</span><span class="cp"></span>
<span class="cp">#define XLOG_CONTINUE_TRANS	0x04	</span><span class="cm">/* Cont this trans into new region */</span><span class="cp"></span>
<span class="cp">#define XLOG_WAS_CONT_TRANS	0x08	</span><span class="cm">/* Cont this trans into new region */</span><span class="cp"></span>
<span class="cp">#define XLOG_END_TRANS		0x10	</span><span class="cm">/* End a continued transaction */</span><span class="cp"></span>
<span class="cp">#define XLOG_UNMOUNT_TRANS	0x20	</span><span class="cm">/* Unmount a filesystem transaction */</span><span class="cp"></span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cm">/*</span>
<span class="cm"> * Flags to log ticket</span>
<span class="cm"> */</span>
<span class="cp">#define XLOG_TIC_INITED		0x1	</span><span class="cm">/* has been initialized */</span><span class="cp"></span>
<span class="cp">#define XLOG_TIC_PERM_RESERV	0x2	</span><span class="cm">/* permanent reservation */</span><span class="cp"></span>

<span class="cp">#define XLOG_TIC_FLAGS \</span>
<span class="cp">	{ XLOG_TIC_INITED,	&quot;XLOG_TIC_INITED&quot; }, \</span>
<span class="cp">	{ XLOG_TIC_PERM_RESERV,	&quot;XLOG_TIC_PERM_RESERV&quot; }</span>

<span class="cp">#endif	</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#define XLOG_UNMOUNT_TYPE	0x556e	</span><span class="cm">/* Un for Unmount */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Flags for log structure</span>
<span class="cm"> */</span>
<span class="cp">#define XLOG_CHKSUM_MISMATCH	0x1	</span><span class="cm">/* used only during recovery */</span><span class="cp"></span>
<span class="cp">#define XLOG_ACTIVE_RECOVERY	0x2	</span><span class="cm">/* in the middle of recovery */</span><span class="cp"></span>
<span class="cp">#define	XLOG_RECOVERY_NEEDED	0x4	</span><span class="cm">/* log was recovered */</span><span class="cp"></span>
<span class="cp">#define XLOG_IO_ERROR		0x8	</span><span class="cm">/* log hit an I/O error, and being</span>
<span class="cm">					   shutdown */</span><span class="cp"></span>
<span class="cp">#define XLOG_TAIL_WARN		0x10	</span><span class="cm">/* log tail verify warning issued */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="n">__uint32_t</span> <span class="n">xlog_tid_t</span><span class="p">;</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cm">/*</span>
<span class="cm"> * Below are states for covering allocation transactions.</span>
<span class="cm"> * By covering, we mean changing the h_tail_lsn in the last on-disk</span>
<span class="cm"> * log write such that no allocation transactions will be re-done during</span>
<span class="cm"> * recovery after a system crash. Recovery starts at the last on-disk</span>
<span class="cm"> * log write.</span>
<span class="cm"> *</span>
<span class="cm"> * These states are used to insert dummy log entries to cover</span>
<span class="cm"> * space allocation transactions which can undo non-transactional changes</span>
<span class="cm"> * after a crash. Writes to a file with space</span>
<span class="cm"> * already allocated do not result in any transactions. Allocations</span>
<span class="cm"> * might include space beyond the EOF. So if we just push the EOF a</span>
<span class="cm"> * little, the last transaction for the file could contain the wrong</span>
<span class="cm"> * size. If there is no file system activity, after an allocation</span>
<span class="cm"> * transaction, and the system crashes, the allocation transaction</span>
<span class="cm"> * will get replayed and the file will be truncated. This could</span>
<span class="cm"> * be hours/days/... after the allocation occurred.</span>
<span class="cm"> *</span>
<span class="cm"> * The fix for this is to do two dummy transactions when the</span>
<span class="cm"> * system is idle. We need two dummy transaction because the h_tail_lsn</span>
<span class="cm"> * in the log record header needs to point beyond the last possible</span>
<span class="cm"> * non-dummy transaction. The first dummy changes the h_tail_lsn to</span>
<span class="cm"> * the first transaction before the dummy. The second dummy causes</span>
<span class="cm"> * h_tail_lsn to point to the first dummy. Recovery starts at h_tail_lsn.</span>
<span class="cm"> *</span>
<span class="cm"> * These dummy transactions get committed when everything</span>
<span class="cm"> * is idle (after there has been some activity).</span>
<span class="cm"> *</span>
<span class="cm"> * There are 5 states used to control this.</span>
<span class="cm"> *</span>
<span class="cm"> *  IDLE -- no logging has been done on the file system or</span>
<span class="cm"> *		we are done covering previous transactions.</span>
<span class="cm"> *  NEED -- logging has occurred and we need a dummy transaction</span>
<span class="cm"> *		when the log becomes idle.</span>
<span class="cm"> *  DONE -- we were in the NEED state and have committed a dummy</span>
<span class="cm"> *		transaction.</span>
<span class="cm"> *  NEED2 -- we detected that a dummy transaction has gone to the</span>
<span class="cm"> *		on disk log with no other transactions.</span>
<span class="cm"> *  DONE2 -- we committed a dummy transaction when in the NEED2 state.</span>
<span class="cm"> *</span>
<span class="cm"> * There are two places where we switch states:</span>
<span class="cm"> *</span>
<span class="cm"> * 1.) In xfs_sync, when we detect an idle log and are in NEED or NEED2.</span>
<span class="cm"> *	We commit the dummy transaction and switch to DONE or DONE2,</span>
<span class="cm"> *	respectively. In all other states, we don&#39;t do anything.</span>
<span class="cm"> *</span>
<span class="cm"> * 2.) When we finish writing the on-disk log (xlog_state_clean_log).</span>
<span class="cm"> *</span>
<span class="cm"> *	No matter what state we are in, if this isn&#39;t the dummy</span>
<span class="cm"> *	transaction going out, the next state is NEED.</span>
<span class="cm"> *	So, if we aren&#39;t in the DONE or DONE2 states, the next state</span>
<span class="cm"> *	is NEED. We can&#39;t be finishing a write of the dummy record</span>
<span class="cm"> *	unless it was committed and the state switched to DONE or DONE2.</span>
<span class="cm"> *</span>
<span class="cm"> *	If we are in the DONE state and this was a write of the</span>
<span class="cm"> *		dummy transaction, we move to NEED2.</span>
<span class="cm"> *</span>
<span class="cm"> *	If we are in the DONE2 state and this was a write of the</span>
<span class="cm"> *		dummy transaction, we move to IDLE.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Writing only one dummy transaction can get appended to</span>
<span class="cm"> * one file space allocation. When this happens, the log recovery</span>
<span class="cm"> * code replays the space allocation and a file could be truncated.</span>
<span class="cm"> * This is why we have the NEED2 and DONE2 states before going idle.</span>
<span class="cm"> */</span>

<span class="cp">#define XLOG_STATE_COVER_IDLE	0</span>
<span class="cp">#define XLOG_STATE_COVER_NEED	1</span>
<span class="cp">#define XLOG_STATE_COVER_DONE	2</span>
<span class="cp">#define XLOG_STATE_COVER_NEED2	3</span>
<span class="cp">#define XLOG_STATE_COVER_DONE2	4</span>

<span class="cp">#define XLOG_COVER_OPS		5</span>


<span class="cm">/* Ticket reservation region accounting */</span> 
<span class="cp">#define XLOG_TIC_LEN_MAX	15</span>

<span class="cm">/*</span>
<span class="cm"> * Reservation region</span>
<span class="cm"> * As would be stored in xfs_log_iovec but without the i_addr which</span>
<span class="cm"> * we don&#39;t care about.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xlog_res</span> <span class="p">{</span>
	<span class="n">uint</span>	<span class="n">r_len</span><span class="p">;</span>	<span class="cm">/* region length		:4 */</span>
	<span class="n">uint</span>	<span class="n">r_type</span><span class="p">;</span>	<span class="cm">/* region&#39;s transaction type	:4 */</span>
<span class="p">}</span> <span class="n">xlog_res_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xlog_ticket</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>   <span class="n">t_queue</span><span class="p">;</span>	 <span class="cm">/* reserve/write queue */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t_task</span><span class="p">;</span>	 <span class="cm">/* task that owns this ticket */</span>
	<span class="n">xlog_tid_t</span>	   <span class="n">t_tid</span><span class="p">;</span>	 <span class="cm">/* transaction identifier	 : 4  */</span>
	<span class="n">atomic_t</span>	   <span class="n">t_ref</span><span class="p">;</span>	 <span class="cm">/* ticket reference count       : 4  */</span>
	<span class="kt">int</span>		   <span class="n">t_curr_res</span><span class="p">;</span>	 <span class="cm">/* current reservation in bytes : 4  */</span>
	<span class="kt">int</span>		   <span class="n">t_unit_res</span><span class="p">;</span>	 <span class="cm">/* unit reservation in bytes    : 4  */</span>
	<span class="kt">char</span>		   <span class="n">t_ocnt</span><span class="p">;</span>	 <span class="cm">/* original count		 : 1  */</span>
	<span class="kt">char</span>		   <span class="n">t_cnt</span><span class="p">;</span>	 <span class="cm">/* current count		 : 1  */</span>
	<span class="kt">char</span>		   <span class="n">t_clientid</span><span class="p">;</span>	 <span class="cm">/* who does this belong to;	 : 1  */</span>
	<span class="kt">char</span>		   <span class="n">t_flags</span><span class="p">;</span>	 <span class="cm">/* properties of reservation	 : 1  */</span>
	<span class="n">uint</span>		   <span class="n">t_trans_type</span><span class="p">;</span> <span class="cm">/* transaction type             : 4  */</span>

        <span class="cm">/* reservation array fields */</span>
	<span class="n">uint</span>		   <span class="n">t_res_num</span><span class="p">;</span>                    <span class="cm">/* num in array : 4 */</span>
	<span class="n">uint</span>		   <span class="n">t_res_num_ophdrs</span><span class="p">;</span>		 <span class="cm">/* num op hdrs  : 4 */</span>
	<span class="n">uint</span>		   <span class="n">t_res_arr_sum</span><span class="p">;</span>		 <span class="cm">/* array sum    : 4 */</span>
	<span class="n">uint</span>		   <span class="n">t_res_o_flow</span><span class="p">;</span>		 <span class="cm">/* sum overflow : 4 */</span>
	<span class="n">xlog_res_t</span>	   <span class="n">t_res_arr</span><span class="p">[</span><span class="n">XLOG_TIC_LEN_MAX</span><span class="p">];</span>  <span class="cm">/* array of res : 8 * 15 */</span> 
<span class="p">}</span> <span class="n">xlog_ticket_t</span><span class="p">;</span>

<span class="cp">#endif</span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xlog_op_header</span> <span class="p">{</span>
	<span class="n">__be32</span>	   <span class="n">oh_tid</span><span class="p">;</span>	<span class="cm">/* transaction id of operation	:  4 b */</span>
	<span class="n">__be32</span>	   <span class="n">oh_len</span><span class="p">;</span>	<span class="cm">/* bytes in data region		:  4 b */</span>
	<span class="n">__u8</span>	   <span class="n">oh_clientid</span><span class="p">;</span>	<span class="cm">/* who sent me this		:  1 b */</span>
	<span class="n">__u8</span>	   <span class="n">oh_flags</span><span class="p">;</span>	<span class="cm">/*				:  1 b */</span>
	<span class="n">__u16</span>	   <span class="n">oh_res2</span><span class="p">;</span>	<span class="cm">/* 32 bit align			:  2 b */</span>
<span class="p">}</span> <span class="n">xlog_op_header_t</span><span class="p">;</span>


<span class="cm">/* valid values for h_fmt */</span>
<span class="cp">#define XLOG_FMT_UNKNOWN  0</span>
<span class="cp">#define XLOG_FMT_LINUX_LE 1</span>
<span class="cp">#define XLOG_FMT_LINUX_BE 2</span>
<span class="cp">#define XLOG_FMT_IRIX_BE  3</span>

<span class="cm">/* our fmt */</span>
<span class="cp">#ifdef XFS_NATIVE_HOST</span>
<span class="cp">#define XLOG_FMT XLOG_FMT_LINUX_BE</span>
<span class="cp">#else</span>
<span class="cp">#define XLOG_FMT XLOG_FMT_LINUX_LE</span>
<span class="cp">#endif</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xlog_rec_header</span> <span class="p">{</span>
	<span class="n">__be32</span>	  <span class="n">h_magicno</span><span class="p">;</span>	<span class="cm">/* log record (LR) identifier		:  4 */</span>
	<span class="n">__be32</span>	  <span class="n">h_cycle</span><span class="p">;</span>	<span class="cm">/* write cycle of log			:  4 */</span>
	<span class="n">__be32</span>	  <span class="n">h_version</span><span class="p">;</span>	<span class="cm">/* LR version				:  4 */</span>
	<span class="n">__be32</span>	  <span class="n">h_len</span><span class="p">;</span>	<span class="cm">/* len in bytes; should be 64-bit aligned: 4 */</span>
	<span class="n">__be64</span>	  <span class="n">h_lsn</span><span class="p">;</span>	<span class="cm">/* lsn of this LR			:  8 */</span>
	<span class="n">__be64</span>	  <span class="n">h_tail_lsn</span><span class="p">;</span>	<span class="cm">/* lsn of 1st LR w/ buffers not committed: 8 */</span>
	<span class="n">__be32</span>	  <span class="n">h_chksum</span><span class="p">;</span>	<span class="cm">/* may not be used; non-zero if used	:  4 */</span>
	<span class="n">__be32</span>	  <span class="n">h_prev_block</span><span class="p">;</span> <span class="cm">/* block number to previous LR		:  4 */</span>
	<span class="n">__be32</span>	  <span class="n">h_num_logops</span><span class="p">;</span>	<span class="cm">/* number of log operations in this LR	:  4 */</span>
	<span class="n">__be32</span>	  <span class="n">h_cycle_data</span><span class="p">[</span><span class="n">XLOG_HEADER_CYCLE_SIZE</span> <span class="o">/</span> <span class="n">BBSIZE</span><span class="p">];</span>
	<span class="cm">/* new fields */</span>
	<span class="n">__be32</span>    <span class="n">h_fmt</span><span class="p">;</span>        <span class="cm">/* format of log record                 :  4 */</span>
	<span class="n">uuid_t</span>	  <span class="n">h_fs_uuid</span><span class="p">;</span>    <span class="cm">/* uuid of FS                           : 16 */</span>
	<span class="n">__be32</span>	  <span class="n">h_size</span><span class="p">;</span>	<span class="cm">/* iclog size				:  4 */</span>
<span class="p">}</span> <span class="n">xlog_rec_header_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xlog_rec_ext_header</span> <span class="p">{</span>
	<span class="n">__be32</span>	  <span class="n">xh_cycle</span><span class="p">;</span>	<span class="cm">/* write cycle of log			: 4 */</span>
	<span class="n">__be32</span>	  <span class="n">xh_cycle_data</span><span class="p">[</span><span class="n">XLOG_HEADER_CYCLE_SIZE</span> <span class="o">/</span> <span class="n">BBSIZE</span><span class="p">];</span> <span class="cm">/*	: 256 */</span>
<span class="p">}</span> <span class="n">xlog_rec_ext_header_t</span><span class="p">;</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/*</span>
<span class="cm"> * Quite misnamed, because this union lays out the actual on-disk log buffer.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">xlog_in_core2</span> <span class="p">{</span>
	<span class="n">xlog_rec_header_t</span>	<span class="n">hic_header</span><span class="p">;</span>
	<span class="n">xlog_rec_ext_header_t</span>	<span class="n">hic_xheader</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">hic_sector</span><span class="p">[</span><span class="n">XLOG_HEADER_SIZE</span><span class="p">];</span>
<span class="p">}</span> <span class="n">xlog_in_core_2_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * - A log record header is 512 bytes.  There is plenty of room to grow the</span>
<span class="cm"> *	xlog_rec_header_t into the reserved space.</span>
<span class="cm"> * - ic_data follows, so a write to disk can start at the beginning of</span>
<span class="cm"> *	the iclog.</span>
<span class="cm"> * - ic_forcewait is used to implement synchronous forcing of the iclog to disk.</span>
<span class="cm"> * - ic_next is the pointer to the next iclog in the ring.</span>
<span class="cm"> * - ic_bp is a pointer to the buffer used to write this incore log to disk.</span>
<span class="cm"> * - ic_log is a pointer back to the global log structure.</span>
<span class="cm"> * - ic_callback is a linked list of callback function/argument pairs to be</span>
<span class="cm"> *	called after an iclog finishes writing.</span>
<span class="cm"> * - ic_size is the full size of the header plus data.</span>
<span class="cm"> * - ic_offset is the current number of bytes written to in this iclog.</span>
<span class="cm"> * - ic_refcnt is bumped when someone is writing to the log.</span>
<span class="cm"> * - ic_state is the state of the iclog.</span>
<span class="cm"> *</span>
<span class="cm"> * Because of cacheline contention on large machines, we need to separate</span>
<span class="cm"> * various resources onto different cachelines. To start with, make the</span>
<span class="cm"> * structure cacheline aligned. The following fields can be contended on</span>
<span class="cm"> * by independent processes:</span>
<span class="cm"> *</span>
<span class="cm"> *	- ic_callback_*</span>
<span class="cm"> *	- ic_refcnt</span>
<span class="cm"> *	- fields protected by the global l_icloglock</span>
<span class="cm"> *</span>
<span class="cm"> * so we need to ensure that these fields are located in separate cachelines.</span>
<span class="cm"> * We&#39;ll put all the read-only and l_icloglock fields in the first cacheline,</span>
<span class="cm"> * and move everything else out to subsequent cachelines.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xlog_in_core</span> <span class="p">{</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">ic_force_wait</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">ic_write_wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">*</span><span class="n">ic_next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">*</span><span class="n">ic_prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">ic_bp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">ic_log</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ic_size</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ic_offset</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ic_bwritecnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">ic_state</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">ic_datap</span><span class="p">;</span>	<span class="cm">/* pointer to iclog data */</span>

	<span class="cm">/* Callback structures need their own cacheline */</span>
	<span class="n">spinlock_t</span>		<span class="n">ic_callback_lock</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="n">xfs_log_callback_t</span>	<span class="o">*</span><span class="n">ic_callback</span><span class="p">;</span>
	<span class="n">xfs_log_callback_t</span>	<span class="o">**</span><span class="n">ic_callback_tail</span><span class="p">;</span>

	<span class="cm">/* reference counts need their own cacheline */</span>
	<span class="n">atomic_t</span>		<span class="n">ic_refcnt</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="n">xlog_in_core_2_t</span>	<span class="o">*</span><span class="n">ic_data</span><span class="p">;</span>
<span class="cp">#define ic_header	ic_data-&gt;hic_header</span>
<span class="p">}</span> <span class="n">xlog_in_core_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The CIL context is used to aggregate per-transaction details as well be</span>
<span class="cm"> * passed to the iclog for checkpoint post-commit processing.  After being</span>
<span class="cm"> * passed to the iclog, another context needs to be allocated for tracking the</span>
<span class="cm"> * next set of transactions to be aggregated into a checkpoint.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfs_cil</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">xfs_cil_ctx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_cil</span>		<span class="o">*</span><span class="n">cil</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">sequence</span><span class="p">;</span>	<span class="cm">/* chkpt sequence # */</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">start_lsn</span><span class="p">;</span>	<span class="cm">/* first LSN of chkpt commit */</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">commit_lsn</span><span class="p">;</span>	<span class="cm">/* chkpt commit record lsn */</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">ticket</span><span class="p">;</span>	<span class="cm">/* chkpt ticket */</span>
	<span class="kt">int</span>			<span class="n">nvecs</span><span class="p">;</span>		<span class="cm">/* number of regions */</span>
	<span class="kt">int</span>			<span class="n">space_used</span><span class="p">;</span>	<span class="cm">/* aggregate size of regions */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">busy_extents</span><span class="p">;</span>	<span class="cm">/* busy extents in chkpt */</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">lv_chain</span><span class="p">;</span>	<span class="cm">/* logvecs being pushed */</span>
	<span class="n">xfs_log_callback_t</span>	<span class="n">log_cb</span><span class="p">;</span>		<span class="cm">/* completion callback hook. */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">committing</span><span class="p">;</span>	<span class="cm">/* ctx committing list */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Committed Item List structure</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used to track log items that have been committed but not</span>
<span class="cm"> * yet written into the log. It is used only when the delayed logging mount</span>
<span class="cm"> * option is enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure tracks the list of committing checkpoint contexts so</span>
<span class="cm"> * we can avoid the problem of having to hold out new transactions during a</span>
<span class="cm"> * flush until we have a the commit record LSN of the checkpoint. We can</span>
<span class="cm"> * traverse the list of committing contexts in xlog_cil_push_lsn() to find a</span>
<span class="cm"> * sequence match and extract the commit LSN directly from there. If the</span>
<span class="cm"> * checkpoint is still in the process of committing, we can block waiting for</span>
<span class="cm"> * the commit LSN to be determined as well. This should make synchronous</span>
<span class="cm"> * operations almost as efficient as the old logging methods.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xfs_cil</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">xc_log</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">xc_cil</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">xc_cil_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_cil_ctx</span>	<span class="o">*</span><span class="n">xc_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">xc_ctx_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">xc_committing</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">xc_commit_wait</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">xc_current_sequence</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">xc_push_work</span><span class="p">;</span>
	<span class="n">xfs_lsn_t</span>		<span class="n">xc_push_seq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The amount of log space we allow the CIL to aggregate is difficult to size.</span>
<span class="cm"> * Whatever we choose, we have to make sure we can get a reservation for the</span>
<span class="cm"> * log space effectively, that it is large enough to capture sufficient</span>
<span class="cm"> * relogging to reduce log buffer IO significantly, but it is not too large for</span>
<span class="cm"> * the log or induces too much latency when writing out through the iclogs. We</span>
<span class="cm"> * track both space consumed and the number of vectors in the checkpoint</span>
<span class="cm"> * context, so we need to decide which to use for limiting.</span>
<span class="cm"> *</span>
<span class="cm"> * Every log buffer we write out during a push needs a header reserved, which</span>
<span class="cm"> * is at least one sector and more for v2 logs. Hence we need a reservation of</span>
<span class="cm"> * at least 512 bytes per 32k of log space just for the LR headers. That means</span>
<span class="cm"> * 16KB of reservation per megabyte of delayed logging space we will consume,</span>
<span class="cm"> * plus various headers.  The number of headers will vary based on the num of</span>
<span class="cm"> * io vectors, so limiting on a specific number of vectors is going to result</span>
<span class="cm"> * in transactions of varying size. IOWs, it is more consistent to track and</span>
<span class="cm"> * limit space consumed in the log rather than by the number of objects being</span>
<span class="cm"> * logged in order to prevent checkpoint ticket overruns.</span>
<span class="cm"> *</span>
<span class="cm"> * Further, use of static reservations through the log grant mechanism is</span>
<span class="cm"> * problematic. It introduces a lot of complexity (e.g. reserve grant vs write</span>
<span class="cm"> * grant) and a significant deadlock potential because regranting write space</span>
<span class="cm"> * can block on log pushes. Hence if we have to regrant log space during a log</span>
<span class="cm"> * push, we can deadlock.</span>
<span class="cm"> *</span>
<span class="cm"> * However, we can avoid this by use of a dynamic &quot;reservation stealing&quot;</span>
<span class="cm"> * technique during transaction commit whereby unused reservation space in the</span>
<span class="cm"> * transaction ticket is transferred to the CIL ctx commit ticket to cover the</span>
<span class="cm"> * space needed by the checkpoint transaction. This means that we never need to</span>
<span class="cm"> * specifically reserve space for the CIL checkpoint transaction, nor do we</span>
<span class="cm"> * need to regrant space once the checkpoint completes. This also means the</span>
<span class="cm"> * checkpoint transaction ticket is specific to the checkpoint context, rather</span>
<span class="cm"> * than the CIL itself.</span>
<span class="cm"> *</span>
<span class="cm"> * With dynamic reservations, we can effectively make up arbitrary limits for</span>
<span class="cm"> * the checkpoint size so long as they don&#39;t violate any other size rules.</span>
<span class="cm"> * Recovery imposes a rule that no transaction exceed half the log, so we are</span>
<span class="cm"> * limited by that.  Furthermore, the log transaction reservation subsystem</span>
<span class="cm"> * tries to keep 25% of the log free, so we need to keep below that limit or we</span>
<span class="cm"> * risk running out of free log space to start any new transactions.</span>
<span class="cm"> *</span>
<span class="cm"> * In order to keep background CIL push efficient, we will set a lower</span>
<span class="cm"> * threshold at which background pushing is attempted without blocking current</span>
<span class="cm"> * transaction commits.  A separate, higher bound defines when CIL pushes are</span>
<span class="cm"> * enforced to ensure we stay within our maximum checkpoint size bounds.</span>
<span class="cm"> * threshold, yet give us plenty of space for aggregation on large logs.</span>
<span class="cm"> */</span>
<span class="cp">#define XLOG_CIL_SPACE_LIMIT(log)	(log-&gt;l_logsize &gt;&gt; 3)</span>
<span class="cp">#define XLOG_CIL_HARD_SPACE_LIMIT(log)	(3 * (log-&gt;l_logsize &gt;&gt; 4))</span>

<span class="cm">/*</span>
<span class="cm"> * ticket grant locks, queues and accounting have their own cachlines</span>
<span class="cm"> * as these are quite hot and can be operated on concurrently.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xlog_grant_head</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">waiters</span><span class="p">;</span>
	<span class="n">atomic64_t</span>		<span class="n">grant</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The reservation head lsn is not made up of a cycle number and block number.</span>
<span class="cm"> * Instead, it uses a cycle number and byte number.  Logs don&#39;t expect to</span>
<span class="cm"> * overflow 31 bits worth of byte offset, so using a byte number will mean</span>
<span class="cm"> * that round off problems won&#39;t occur when releasing partial reservations.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xlog</span> <span class="p">{</span>
	<span class="cm">/* The following fields don&#39;t need locking */</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">l_mp</span><span class="p">;</span>	        <span class="cm">/* mount point */</span>
	<span class="k">struct</span> <span class="n">xfs_ail</span>		<span class="o">*</span><span class="n">l_ailp</span><span class="p">;</span>	<span class="cm">/* AIL log is working with */</span>
	<span class="k">struct</span> <span class="n">xfs_cil</span>		<span class="o">*</span><span class="n">l_cilp</span><span class="p">;</span>	<span class="cm">/* CIL log is working with */</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">l_xbuf</span><span class="p">;</span>        <span class="cm">/* extra buffer for log</span>
<span class="cm">						 * wrapping */</span>
	<span class="k">struct</span> <span class="n">xfs_buftarg</span>	<span class="o">*</span><span class="n">l_targ</span><span class="p">;</span>        <span class="cm">/* buftarg of log */</span>
	<span class="n">uint</span>			<span class="n">l_flags</span><span class="p">;</span>
	<span class="n">uint</span>			<span class="n">l_quotaoffs_flag</span><span class="p">;</span> <span class="cm">/* XFS_DQ_*, for QUOTAOFFs */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">l_buf_cancel_table</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">l_iclog_hsize</span><span class="p">;</span>  <span class="cm">/* size of iclog header */</span>
	<span class="kt">int</span>			<span class="n">l_iclog_heads</span><span class="p">;</span>  <span class="cm">/* # of iclog header sectors */</span>
	<span class="n">uint</span>			<span class="n">l_sectBBsize</span><span class="p">;</span>   <span class="cm">/* sector size in BBs (2^n) */</span>
	<span class="kt">int</span>			<span class="n">l_iclog_size</span><span class="p">;</span>	<span class="cm">/* size of log in bytes */</span>
	<span class="kt">int</span>			<span class="n">l_iclog_size_log</span><span class="p">;</span> <span class="cm">/* log power size of log */</span>
	<span class="kt">int</span>			<span class="n">l_iclog_bufs</span><span class="p">;</span>	<span class="cm">/* number of iclog buffers */</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">l_logBBstart</span><span class="p">;</span>   <span class="cm">/* start block of log */</span>
	<span class="kt">int</span>			<span class="n">l_logsize</span><span class="p">;</span>      <span class="cm">/* size of log in bytes */</span>
	<span class="kt">int</span>			<span class="n">l_logBBsize</span><span class="p">;</span>    <span class="cm">/* size of log in BB chunks */</span>

	<span class="cm">/* The following block of fields are changed while holding icloglock */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">l_flush_wait</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
						<span class="cm">/* waiting for iclog flush */</span>
	<span class="kt">int</span>			<span class="n">l_covered_state</span><span class="p">;</span><span class="cm">/* state of &quot;covering disk</span>
<span class="cm">						 * log entries&quot; */</span>
	<span class="n">xlog_in_core_t</span>		<span class="o">*</span><span class="n">l_iclog</span><span class="p">;</span>       <span class="cm">/* head log queue	*/</span>
	<span class="n">spinlock_t</span>		<span class="n">l_icloglock</span><span class="p">;</span>    <span class="cm">/* grab to change iclog state */</span>
	<span class="kt">int</span>			<span class="n">l_curr_cycle</span><span class="p">;</span>   <span class="cm">/* Cycle number of log writes */</span>
	<span class="kt">int</span>			<span class="n">l_prev_cycle</span><span class="p">;</span>   <span class="cm">/* Cycle number before last</span>
<span class="cm">						 * block increment */</span>
	<span class="kt">int</span>			<span class="n">l_curr_block</span><span class="p">;</span>   <span class="cm">/* current logical log block */</span>
	<span class="kt">int</span>			<span class="n">l_prev_block</span><span class="p">;</span>   <span class="cm">/* previous logical log block */</span>

	<span class="cm">/*</span>
<span class="cm">	 * l_last_sync_lsn and l_tail_lsn are atomics so they can be set and</span>
<span class="cm">	 * read without needing to hold specific locks. To avoid operations</span>
<span class="cm">	 * contending with other hot objects, place each of them on a separate</span>
<span class="cm">	 * cacheline.</span>
<span class="cm">	 */</span>
	<span class="cm">/* lsn of last LR on disk */</span>
	<span class="n">atomic64_t</span>		<span class="n">l_last_sync_lsn</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="cm">/* lsn of 1st LR with unflushed * buffers */</span>
	<span class="n">atomic64_t</span>		<span class="n">l_tail_lsn</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">xlog_grant_head</span>	<span class="n">l_reserve_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xlog_grant_head</span>	<span class="n">l_write_head</span><span class="p">;</span>

	<span class="cm">/* The following field are used for debugging; need to hold icloglock */</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">l_iclog_bak</span><span class="p">[</span><span class="n">XLOG_MAX_ICLOGS</span><span class="p">];</span>
<span class="cp">#endif</span>

<span class="p">}</span> <span class="n">xlog_t</span><span class="p">;</span>

<span class="cp">#define XLOG_BUF_CANCEL_BUCKET(log, blkno) \</span>
<span class="cp">	((log)-&gt;l_buf_cancel_table + ((__uint64_t)blkno % XLOG_BC_TABLE_SIZE))</span>

<span class="cp">#define XLOG_FORCED_SHUTDOWN(log)	((log)-&gt;l_flags &amp; XLOG_IO_ERROR)</span>

<span class="cm">/* common routines */</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">xlog_recover</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="n">log</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">xlog_recover_finish</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="n">log</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	 <span class="n">xlog_pack_data</span><span class="p">(</span><span class="n">xlog_t</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="n">xlog_in_core_t</span> <span class="o">*</span><span class="n">iclog</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">kmem_zone_t</span> <span class="o">*</span><span class="n">xfs_log_ticket_zone</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xlog_ticket</span> <span class="o">*</span>
<span class="n">xlog_ticket_alloc</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>	<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">unit_bytes</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">count</span><span class="p">,</span>
	<span class="kt">char</span>		<span class="n">client</span><span class="p">,</span>
	<span class="n">bool</span>		<span class="n">permanent</span><span class="p">,</span>
	<span class="n">xfs_km_flags_t</span>	<span class="n">alloc_flags</span><span class="p">);</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xlog_write_adv_cnt</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">ptr</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="o">*</span><span class="n">len</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="o">*</span><span class="n">off</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>	<span class="n">xlog_print_tic_res</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_mount</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xlog_ticket</span> <span class="o">*</span><span class="n">ticket</span><span class="p">);</span>
<span class="kt">int</span>
<span class="n">xlog_write</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span>		<span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_log_vec</span>	<span class="o">*</span><span class="n">log_vector</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_ticket</span>	<span class="o">*</span><span class="n">tic</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span>		<span class="o">*</span><span class="n">start_lsn</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xlog_in_core</span>	<span class="o">**</span><span class="n">commit_iclog</span><span class="p">,</span>
	<span class="n">uint</span>			<span class="n">flags</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * When we crack an atomic LSN, we sample it first so that the value will not</span>
<span class="cm"> * change while we are cracking it into the component values. This means we</span>
<span class="cm"> * will always get consistent component values to work from. This should always</span>
<span class="cm"> * be used to sample and crack LSNs that are stored and updated in atomic</span>
<span class="cm"> * variables.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xlog_crack_atomic_lsn</span><span class="p">(</span><span class="n">atomic64_t</span> <span class="o">*</span><span class="n">lsn</span><span class="p">,</span> <span class="n">uint</span> <span class="o">*</span><span class="n">cycle</span><span class="p">,</span> <span class="n">uint</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_lsn_t</span> <span class="n">val</span> <span class="o">=</span> <span class="n">atomic64_read</span><span class="p">(</span><span class="n">lsn</span><span class="p">);</span>

	<span class="o">*</span><span class="n">cycle</span> <span class="o">=</span> <span class="n">CYCLE_LSN</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="n">BLOCK_LSN</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate and assign a value to an atomic LSN variable from component pieces.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xlog_assign_atomic_lsn</span><span class="p">(</span><span class="n">atomic64_t</span> <span class="o">*</span><span class="n">lsn</span><span class="p">,</span> <span class="n">uint</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">uint</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic64_set</span><span class="p">(</span><span class="n">lsn</span><span class="p">,</span> <span class="n">xlog_assign_lsn</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">block</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When we crack the grant head, we sample it first so that the value will not</span>
<span class="cm"> * change while we are cracking it into the component values. This means we</span>
<span class="cm"> * will always get consistent component values to work from.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xlog_crack_grant_head_val</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cycle</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">space</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">cycle</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="o">*</span><span class="n">space</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xlog_crack_grant_head</span><span class="p">(</span><span class="n">atomic64_t</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cycle</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">space</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_crack_grant_head_val</span><span class="p">(</span><span class="n">atomic64_read</span><span class="p">(</span><span class="n">head</span><span class="p">),</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">space</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int64_t</span>
<span class="nf">xlog_assign_grant_head_val</span><span class="p">(</span><span class="kt">int</span> <span class="n">cycle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">space</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">cycle</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">space</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xlog_assign_grant_head</span><span class="p">(</span><span class="n">atomic64_t</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cycle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">space</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic64_set</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">xlog_assign_grant_head_val</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">space</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Committed Item List interfaces</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xlog_cil_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">xlog</span> <span class="o">*</span><span class="n">log</span><span class="p">);</span>
<span class="kt">void</span>
<span class="n">xlog_cil_init_post_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">xlog</span> <span class="o">*</span><span class="n">log</span><span class="p">);</span>
<span class="kt">void</span>
<span class="n">xlog_cil_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">xlog</span> <span class="o">*</span><span class="n">log</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * CIL force routines</span>
<span class="cm"> */</span>
<span class="n">xfs_lsn_t</span>
<span class="n">xlog_cil_force_lsn</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xlog</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span>
	<span class="n">xfs_lsn_t</span> <span class="n">sequence</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xlog_cil_force</span><span class="p">(</span><span class="k">struct</span> <span class="n">xlog</span> <span class="o">*</span><span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xlog_cil_force_lsn</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">log</span><span class="o">-&gt;</span><span class="n">l_cilp</span><span class="o">-&gt;</span><span class="n">xc_current_sequence</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unmount record type is used as a pseudo transaction type for the ticket.</span>
<span class="cm"> * It&#39;s value must be outside the range of XFS_TRANS_* values.</span>
<span class="cm"> */</span>
<span class="cp">#define XLOG_UNMOUNT_REC_TYPE	(-1U)</span>

<span class="cm">/*</span>
<span class="cm"> * Wrapper function for waiting on a wait queue serialised against wakeups</span>
<span class="cm"> * by a spinlock. This matches the semantics of all the wait queues used in the</span>
<span class="cm"> * log code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">xlog_wait</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span> <span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">add_wait_queue_exclusive</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif	</span><span class="cm">/* __XFS_LOG_PRIV_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
