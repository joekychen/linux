<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_inode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_inode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2006 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>

<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_fs.h&quot;</span>
<span class="cp">#include &quot;xfs_types.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_inum.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_trans_priv.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_ialloc_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_attr_sf.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_buf_item.h&quot;</span>
<span class="cp">#include &quot;xfs_inode_item.h&quot;</span>
<span class="cp">#include &quot;xfs_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_ialloc.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_utils.h&quot;</span>
<span class="cp">#include &quot;xfs_quota.h&quot;</span>
<span class="cp">#include &quot;xfs_filestream.h&quot;</span>
<span class="cp">#include &quot;xfs_vnodeops.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>

<span class="n">kmem_zone_t</span> <span class="o">*</span><span class="n">xfs_ifork_zone</span><span class="p">;</span>
<span class="n">kmem_zone_t</span> <span class="o">*</span><span class="n">xfs_inode_zone</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Used in xfs_itruncate_extents().  This is the maximum number of extents</span>
<span class="cm"> * freed from a file in a single transaction.</span>
<span class="cm"> */</span>
<span class="cp">#define	XFS_ITRUNC_MAX_EXTENTS	2</span>

<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_iflush_int</span><span class="p">(</span><span class="n">xfs_inode_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_buf_t</span> <span class="o">*</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_iformat_local</span><span class="p">(</span><span class="n">xfs_inode_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_dinode_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_iformat_extents</span><span class="p">(</span><span class="n">xfs_inode_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_dinode_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">xfs_iformat_btree</span><span class="p">(</span><span class="n">xfs_inode_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">xfs_dinode_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * helper function to extract extent size hint from inode</span>
<span class="cm"> */</span>
<span class="n">xfs_extlen_t</span>
<span class="nf">xfs_get_extsz_hint</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_EXTSIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_extsize</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_extsize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_IS_REALTIME_INODE</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_rextsize</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cm">/*</span>
<span class="cm"> * Make sure that the extents in the given memory buffer</span>
<span class="cm"> * are valid.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_validate_extents</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>		<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">nrecs</span><span class="p">,</span>
	<span class="n">xfs_exntfmt_t</span>		<span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_bmbt_irec_t</span>		<span class="n">irec</span><span class="p">;</span>
	<span class="n">xfs_bmbt_rec_host_t</span>	<span class="n">rec</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nrecs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_bmbt_rec_host_t</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">xfs_iext_get_ext</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">rec</span><span class="p">.</span><span class="n">l0</span> <span class="o">=</span> <span class="n">get_unaligned</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">l0</span><span class="p">);</span>
		<span class="n">rec</span><span class="p">.</span><span class="n">l1</span> <span class="o">=</span> <span class="n">get_unaligned</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">l1</span><span class="p">);</span>
		<span class="n">xfs_bmbt_get_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span> <span class="o">==</span> <span class="n">XFS_EXTFMT_NOSTATE</span><span class="p">)</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">irec</span><span class="p">.</span><span class="n">br_state</span> <span class="o">==</span> <span class="n">XFS_EXT_NORM</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* DEBUG */</span><span class="cp"></span>
<span class="cp">#define xfs_validate_extents(ifp, nrecs, fmt)</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Check that none of the inode&#39;s in the buffer have a next</span>
<span class="cm"> * unlinked field of 0.</span>
<span class="cm"> */</span>
<span class="cp">#if defined(DEBUG)</span>
<span class="kt">void</span>
<span class="nf">xfs_inobp_check</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">j</span><span class="p">;</span>
	<span class="n">xfs_dinode_t</span>	<span class="o">*</span><span class="n">dip</span><span class="p">;</span>

	<span class="n">j</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_inode_cluster_size</span> <span class="o">&gt;&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodelog</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dip</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dinode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">xfs_buf_offset</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span>
					<span class="n">i</span> <span class="o">*</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodesize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_next_unlinked</span><span class="p">)</span>  <span class="p">{</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
	<span class="s">&quot;Detected bogus zero next_unlinked field in incore inode buffer 0x%p.&quot;</span><span class="p">,</span>
				<span class="n">bp</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_next_unlinked</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Find the buffer associated with the given inode map</span>
<span class="cm"> * We do basic validation checks on the buffer once it has been</span>
<span class="cm"> * retrieved from disk.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_imap_to_bp</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_imap</span>	<span class="o">*</span><span class="n">imap</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">bpp</span><span class="p">,</span>
	<span class="n">uint</span>		<span class="n">buf_flags</span><span class="p">,</span>
	<span class="n">uint</span>		<span class="n">iget_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">ni</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="n">buf_flags</span> <span class="o">|=</span> <span class="n">XBF_UNMAPPED</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_read_buf</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_blkno</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_len</span><span class="p">,</span> <span class="n">buf_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
				<span class="s">&quot;%s: xfs_trans_read_buf() returned error %d.&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">buf_flags</span> <span class="o">&amp;</span> <span class="n">XBF_TRYLOCK</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate the magic number and version of every inode in the buffer</span>
<span class="cm">	 * (if DEBUG kernel) or the first inode in the buffer, otherwise.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">ni</span> <span class="o">=</span> <span class="n">BBTOB</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_len</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodelog</span><span class="p">;</span>
<span class="cp">#else	</span><span class="cm">/* usual case */</span><span class="cp"></span>
	<span class="n">ni</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ni</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>		<span class="n">di_ok</span><span class="p">;</span>
		<span class="n">xfs_dinode_t</span>	<span class="o">*</span><span class="n">dip</span><span class="p">;</span>

		<span class="n">dip</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dinode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">xfs_buf_offset</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span>
					<span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodelog</span><span class="p">));</span>
		<span class="n">di_ok</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_magic</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DINODE_MAGIC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">XFS_DINODE_GOOD_VERSION</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_version</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">XFS_TEST_ERROR</span><span class="p">(</span><span class="o">!</span><span class="n">di_ok</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span>
						<span class="n">XFS_ERRTAG_ITOBP_INOTOBP</span><span class="p">,</span>
						<span class="n">XFS_RANDOM_ITOBP_INOTOBP</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iget_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IGET_UNTRUSTED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_imap_to_bp&quot;</span><span class="p">,</span>
						<span class="n">XFS_ERRLEVEL_HIGH</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">dip</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG</span>
			<span class="n">xfs_emerg</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
				<span class="s">&quot;bad inode magic/vsn daddr %lld #%d (magic=%x)&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">im_blkno</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_magic</span><span class="p">));</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">xfs_inobp_check</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine is called to map an inode number within a file</span>
<span class="cm"> * system to the buffer containing the on-disk version of the</span>
<span class="cm"> * inode.  It returns a pointer to the buffer containing the</span>
<span class="cm"> * on-disk inode in the bpp parameter, and in the dip parameter</span>
<span class="cm"> * it returns a pointer to the on-disk inode within that buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * If a non-zero error is returned, then the contents of bpp and</span>
<span class="cm"> * dipp are undefined.</span>
<span class="cm"> *</span>
<span class="cm"> * Use xfs_imap() to determine the size and location of the</span>
<span class="cm"> * buffer to read from disk.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_inotobp</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>
	<span class="n">xfs_ino_t</span>	<span class="n">ino</span><span class="p">,</span>
	<span class="n">xfs_dinode_t</span>	<span class="o">**</span><span class="n">dipp</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">bpp</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="o">*</span><span class="n">offset</span><span class="p">,</span>
	<span class="n">uint</span>		<span class="n">imap_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_imap</span>	<span class="n">imap</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">imap</span><span class="p">.</span><span class="n">im_blkno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_imap</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="n">imap_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_imap_to_bp</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">imap_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="o">*</span><span class="n">dipp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dinode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">xfs_buf_offset</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">imap</span><span class="p">.</span><span class="n">im_boffset</span><span class="p">);</span>
	<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">imap</span><span class="p">.</span><span class="n">im_boffset</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This routine is called to map an inode to the buffer containing</span>
<span class="cm"> * the on-disk version of the inode.  It returns a pointer to the</span>
<span class="cm"> * buffer containing the on-disk inode in the bpp parameter, and in</span>
<span class="cm"> * the dip parameter it returns a pointer to the on-disk inode within</span>
<span class="cm"> * that buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * If a non-zero error is returned, then the contents of bpp and</span>
<span class="cm"> * dipp are undefined.</span>
<span class="cm"> *</span>
<span class="cm"> * The inode is expected to already been mapped to its buffer and read</span>
<span class="cm"> * in once, thus we can use the mapping information stored in the inode</span>
<span class="cm"> * rather than calling xfs_imap().  This allows us to avoid the overhead</span>
<span class="cm"> * of looking at the inode btree for small block file systems</span>
<span class="cm"> * (see xfs_imap()).</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_itobp</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_dinode_t</span>	<span class="o">**</span><span class="n">dipp</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">bpp</span><span class="p">,</span>
	<span class="n">uint</span>		<span class="n">buf_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">.</span><span class="n">im_blkno</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_imap_to_bp</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">buf_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">buf_flags</span> <span class="o">&amp;</span> <span class="n">XBF_TRYLOCK</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">tp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">dipp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dinode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">xfs_buf_offset</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">.</span><span class="n">im_boffset</span><span class="p">);</span>
	<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move inode type and inode format specific information from the</span>
<span class="cm"> * on-disk inode to the in-core inode.  For fifos, devs, and sockets</span>
<span class="cm"> * this means set if_rdev to the proper value.  For files, directories,</span>
<span class="cm"> * and symlinks this means to bring in the in-line data or extent</span>
<span class="cm"> * pointers.  For a file in B-tree format, only the root is immediately</span>
<span class="cm"> * brought in-core.  The rest will be in-lined in if_extents when it</span>
<span class="cm"> * is first referenced (see xfs_iread_extents()).</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_iformat</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_dinode_t</span>		<span class="o">*</span><span class="n">dip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_attr_shortform_t</span>	<span class="o">*</span><span class="n">atp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xfs_fsize_t</span>             <span class="n">di_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_nextents</span><span class="p">)</span> <span class="o">+</span>
		     <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_anextents</span><span class="p">)</span> <span class="o">&gt;</span>
		     <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_nblocks</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
			<span class="s">&quot;corrupt dinode %Lu, extent total = %d, nblocks = %Lu.&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_nextents</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_anextents</span><span class="p">)),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				<span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_nblocks</span><span class="p">));</span>
		<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_iformat(1)&quot;</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
				     <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">dip</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_forkoff</span> <span class="o">&gt;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodesize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="s">&quot;corrupt dinode %Lu, forkoff = 0x%x.&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
			<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_forkoff</span><span class="p">);</span>
		<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_iformat(2)&quot;</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
				     <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">dip</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_REALTIME</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="o">-&gt;</span><span class="n">m_rtdev_targp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
			<span class="s">&quot;corrupt dinode %Lu, has realtime flag set.&quot;</span><span class="p">,</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_iformat(realtime)&quot;</span><span class="p">,</span>
				     <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">dip</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFIFO</span>:
	<span class="k">case</span> <span class="n">S_IFCHR</span>:
	<span class="k">case</span> <span class="n">S_IFBLK</span>:
	<span class="k">case</span> <span class="n">S_IFSOCK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_DEV</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_iformat(3)&quot;</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
					      <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">dip</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_rdev</span> <span class="o">=</span> <span class="n">xfs_dinode_get_rdev</span><span class="p">(</span><span class="n">dip</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">S_IFREG</span>:
	<span class="k">case</span> <span class="n">S_IFLNK</span>:
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_format</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">XFS_DINODE_FMT_LOCAL</span>:
			<span class="cm">/*</span>
<span class="cm">			 * no local regular files yet</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_mode</span><span class="p">))))</span> <span class="p">{</span>
				<span class="n">xfs_warn</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
			<span class="s">&quot;corrupt inode %Lu (local format for regular file).&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
				<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_iformat(4)&quot;</span><span class="p">,</span>
						     <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
						     <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">dip</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">di_size</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">di_size</span> <span class="o">&gt;</span> <span class="n">XFS_DFORK_DSIZE</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">xfs_warn</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
			<span class="s">&quot;corrupt inode %Lu (bad size %Ld for local inode).&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">di_size</span><span class="p">);</span>
				<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_iformat(5)&quot;</span><span class="p">,</span>
						     <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
						     <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">dip</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">di_size</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iformat_local</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iformat_extents</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XFS_DINODE_FMT_BTREE</span>:
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iformat_btree</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_iformat(6)&quot;</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
					 <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_iformat(7)&quot;</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XFS_DFORK_Q</span><span class="p">(</span><span class="n">dip</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_afp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_afp</span> <span class="o">=</span> <span class="n">kmem_zone_zalloc</span><span class="p">(</span><span class="n">xfs_ifork_zone</span><span class="p">,</span> <span class="n">KM_SLEEP</span> <span class="o">|</span> <span class="n">KM_NOFS</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_aformat</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_DINODE_FMT_LOCAL</span>:
		<span class="n">atp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_attr_shortform_t</span> <span class="o">*</span><span class="p">)</span><span class="n">XFS_DFORK_APTR</span><span class="p">(</span><span class="n">dip</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">atp</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">totsize</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_attr_sf_hdr</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
				<span class="s">&quot;corrupt inode %Lu (bad attr fork size %Ld).&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">size</span><span class="p">);</span>
			<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_iformat(8)&quot;</span><span class="p">,</span>
					     <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
					     <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">dip</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iformat_local</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iformat_extents</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XFS_DINODE_FMT_BTREE</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iformat_btree</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_zone_free</span><span class="p">(</span><span class="n">xfs_ifork_zone</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_afp</span><span class="p">);</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_afp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">xfs_idestroy_fork</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The file is in-lined in the on-disk inode.</span>
<span class="cm"> * If it fits into if_inline_data, then copy</span>
<span class="cm"> * it there, otherwise allocate a buffer for it</span>
<span class="cm"> * and copy the data there.  Either way, set</span>
<span class="cm"> * if_data to point at the data.</span>
<span class="cm"> * If we allocate a buffer for the data, make</span>
<span class="cm"> * sure that its size is a multiple of 4 and</span>
<span class="cm"> * record the real size in i_real_bytes.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_iformat_local</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_dinode_t</span>	<span class="o">*</span><span class="n">dip</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">whichfork</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">real_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the size is unreasonable, then something</span>
<span class="cm">	 * is wrong and we just bail out rather than crash in</span>
<span class="cm">	 * kmem_alloc() or memcpy() below.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">XFS_DFORK_SIZE</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
	<span class="s">&quot;corrupt inode %Lu (bad size %d for local fork, size = %d).&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
			<span class="n">XFS_DFORK_SIZE</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">));</span>
		<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_iformat_local&quot;</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
				     <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">dip</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ifp</span> <span class="o">=</span> <span class="n">XFS_IFORK_PTR</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="n">real_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_data</span><span class="p">))</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_data</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">real_size</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">real_size</span><span class="p">,</span> <span class="n">KM_SLEEP</span> <span class="o">|</span> <span class="n">KM_NOFS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">=</span> <span class="n">real_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">,</span> <span class="n">XFS_DFORK_PTR</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XFS_IFEXTENTS</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">|=</span> <span class="n">XFS_IFINLINE</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The file consists of a set of extents all</span>
<span class="cm"> * of which fit into the on-disk inode.</span>
<span class="cm"> * If there are few enough extents to fit into</span>
<span class="cm"> * the if_inline_ext, then copy them there.</span>
<span class="cm"> * Otherwise allocate a buffer for them and copy</span>
<span class="cm"> * them into it.  Either way, set if_extents</span>
<span class="cm"> * to point at the extents.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_iformat_extents</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_dinode_t</span>	<span class="o">*</span><span class="n">dip</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">whichfork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_bmbt_rec_t</span>	<span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">nex</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

	<span class="n">ifp</span> <span class="o">=</span> <span class="n">XFS_IFORK_PTR</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="n">nex</span> <span class="o">=</span> <span class="n">XFS_DFORK_NEXTENTS</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">nex</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the number of extents is unreasonable, then something</span>
<span class="cm">	 * is wrong and we just bail out rather than crash in</span>
<span class="cm">	 * kmem_alloc() or memcpy() below.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">XFS_DFORK_SIZE</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="s">&quot;corrupt inode %Lu ((a)extents = %d).&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">nex</span><span class="p">);</span>
		<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_iformat_extents(1)&quot;</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
				     <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">dip</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nex</span> <span class="o">&lt;=</span> <span class="n">XFS_INLINE_EXTS</span><span class="p">)</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">xfs_iext_add</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nex</span><span class="p">);</span>

	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_bmbt_rec_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">XFS_DFORK_PTR</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
		<span class="n">xfs_validate_extents</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">nex</span><span class="p">,</span> <span class="n">XFS_EXTFMT_INODE</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">dp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_bmbt_rec_host_t</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">xfs_iext_get_ext</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">l0</span> <span class="o">=</span> <span class="n">get_unaligned_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">l0</span><span class="p">);</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">l1</span> <span class="o">=</span> <span class="n">get_unaligned_be64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">l1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">XFS_BMAP_TRACE_EXLIST</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">nex</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">whichfork</span> <span class="o">!=</span> <span class="n">XFS_DATA_FORK</span> <span class="o">||</span>
			<span class="n">XFS_EXTFMT_INODE</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">==</span> <span class="n">XFS_EXTFMT_NOSTATE</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">xfs_check_nostate_extents</span><span class="p">(</span>
				    <span class="n">ifp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nex</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_iformat_extents(2)&quot;</span><span class="p">,</span>
							 <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
							 <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
				<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">|=</span> <span class="n">XFS_IFEXTENTS</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The file has too many extents to fit into</span>
<span class="cm"> * the inode, so they are in B-tree format.</span>
<span class="cm"> * Allocate a buffer for the root of the B-tree</span>
<span class="cm"> * and copy the root into it.  The i_extents</span>
<span class="cm"> * field will remain NULL until all of the</span>
<span class="cm"> * extents are read in (when they are needed).</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_iformat_btree</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_dinode_t</span>		<span class="o">*</span><span class="n">dip</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">whichfork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_bmdr_block_t</span>	<span class="o">*</span><span class="n">dfp</span><span class="p">;</span>
	<span class="n">xfs_ifork_t</span>		<span class="o">*</span><span class="n">ifp</span><span class="p">;</span>
	<span class="cm">/* REFERENCED */</span>
	<span class="kt">int</span>			<span class="n">nrecs</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">size</span><span class="p">;</span>

	<span class="n">ifp</span> <span class="o">=</span> <span class="n">XFS_IFORK_PTR</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="n">dfp</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_bmdr_block_t</span> <span class="o">*</span><span class="p">)</span><span class="n">XFS_DFORK_PTR</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">XFS_BMAP_BROOT_SPACE</span><span class="p">(</span><span class="n">dfp</span><span class="p">);</span>
	<span class="n">nrecs</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dfp</span><span class="o">-&gt;</span><span class="n">bb_numrecs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * blow out if -- fork has less extents than can fit in</span>
<span class="cm">	 * fork (fork shouldn&#39;t be a btree format), root btree</span>
<span class="cm">	 * block has more records than can fit into the fork,</span>
<span class="cm">	 * or the number of extents is greater than the number of</span>
<span class="cm">	 * blocks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">XFS_IFORK_NEXTENTS</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">)</span> <span class="o">&lt;=</span>
			<span class="n">XFS_IFORK_MAXEXT</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">)</span> <span class="o">||</span>
		     <span class="n">XFS_BMDR_SPACE_CALC</span><span class="p">(</span><span class="n">nrecs</span><span class="p">)</span> <span class="o">&gt;</span>
			<span class="n">XFS_DFORK_SIZE</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">)</span> <span class="o">||</span>
		     <span class="n">XFS_IFORK_NEXTENTS</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nblocks</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_warn</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="s">&quot;corrupt inode %Lu (btree).&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">XFS_CORRUPTION_ERROR</span><span class="p">(</span><span class="s">&quot;xfs_iformat_btree&quot;</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
				 <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">dip</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">KM_SLEEP</span> <span class="o">|</span> <span class="n">KM_NOFS</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy and convert from the on-disk structure</span>
<span class="cm">	 * to the in-memory structure.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_bmdr_to_bmbt</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">dfp</span><span class="p">,</span>
			 <span class="n">XFS_DFORK_SIZE</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">),</span>
			 <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XFS_IFEXTENTS</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">|=</span> <span class="n">XFS_IFBROOT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_dinode_from_disk</span><span class="p">(</span>
	<span class="n">xfs_icdinode_t</span>		<span class="o">*</span><span class="n">to</span><span class="p">,</span>
	<span class="n">xfs_dinode_t</span>		<span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_magic</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_magic</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_mode</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_mode</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_version</span> <span class="o">=</span> <span class="n">from</span> <span class="o">-&gt;</span><span class="n">di_version</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_format</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">di_format</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_onlink</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_onlink</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_uid</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_uid</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_gid</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_gid</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_nlink</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_nlink</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_projid_lo</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_projid_lo</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_projid_hi</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_projid_hi</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">di_pad</span><span class="p">,</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">di_pad</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">di_pad</span><span class="p">));</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_flushiter</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_flushiter</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_atime</span><span class="p">.</span><span class="n">t_sec</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_atime</span><span class="p">.</span><span class="n">t_sec</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_atime</span><span class="p">.</span><span class="n">t_nsec</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_atime</span><span class="p">.</span><span class="n">t_nsec</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_sec</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_sec</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_nsec</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_nsec</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">t_sec</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">t_sec</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">t_nsec</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">t_nsec</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_size</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_size</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_nblocks</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_nblocks</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_extsize</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_extsize</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_nextents</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_nextents</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_anextents</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_anextents</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_forkoff</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">di_forkoff</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_aformat</span>	<span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">di_aformat</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_dmevmask</span>	<span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_dmevmask</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_dmstate</span>	<span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_dmstate</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_flags</span>	<span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_flags</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_gen</span>	<span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_gen</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_dinode_to_disk</span><span class="p">(</span>
	<span class="n">xfs_dinode_t</span>		<span class="o">*</span><span class="n">to</span><span class="p">,</span>
	<span class="n">xfs_icdinode_t</span>		<span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_magic</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_magic</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_mode</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_mode</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_version</span> <span class="o">=</span> <span class="n">from</span> <span class="o">-&gt;</span><span class="n">di_version</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_format</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">di_format</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_onlink</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_onlink</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_uid</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_uid</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_gid</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_gid</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_nlink</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_nlink</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_projid_lo</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_projid_lo</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_projid_hi</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_projid_hi</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">di_pad</span><span class="p">,</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">di_pad</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">di_pad</span><span class="p">));</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_flushiter</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_flushiter</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_atime</span><span class="p">.</span><span class="n">t_sec</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_atime</span><span class="p">.</span><span class="n">t_sec</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_atime</span><span class="p">.</span><span class="n">t_nsec</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_atime</span><span class="p">.</span><span class="n">t_nsec</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_sec</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_sec</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_nsec</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_nsec</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">t_sec</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">t_sec</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">t_nsec</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_ctime</span><span class="p">.</span><span class="n">t_nsec</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_size</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_size</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_nblocks</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_nblocks</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_extsize</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_extsize</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_nextents</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_nextents</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_anextents</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_anextents</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_forkoff</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">di_forkoff</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_aformat</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">di_aformat</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_dmevmask</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_dmevmask</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_dmstate</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_dmstate</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_flags</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_flags</span><span class="p">);</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">di_gen</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">di_gen</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="n">uint</span>
<span class="nf">_xfs_dic2xflags</span><span class="p">(</span>
	<span class="n">__uint16_t</span>		<span class="n">di_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uint</span>			<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_ANY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_REALTIME</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_XFLAG_REALTIME</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_PREALLOC</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_XFLAG_PREALLOC</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_IMMUTABLE</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_XFLAG_IMMUTABLE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_APPEND</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_XFLAG_APPEND</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_SYNC</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_XFLAG_SYNC</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_NOATIME</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_XFLAG_NOATIME</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_NODUMP</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_XFLAG_NODUMP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_RTINHERIT</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_XFLAG_RTINHERIT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_PROJINHERIT</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_XFLAG_PROJINHERIT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_NOSYMLINKS</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_XFLAG_NOSYMLINKS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_EXTSIZE</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_XFLAG_EXTSIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_EXTSZINHERIT</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_XFLAG_EXTSZINHERIT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_NODEFRAG</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_XFLAG_NODEFRAG</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_FILESTREAM</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_XFLAG_FILESTREAM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">uint</span>
<span class="nf">xfs_ip2xflags</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_icdinode_t</span>		<span class="o">*</span><span class="n">dic</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">_xfs_dic2xflags</span><span class="p">(</span><span class="n">dic</span><span class="o">-&gt;</span><span class="n">di_flags</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">XFS_IFORK_Q</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">?</span> <span class="n">XFS_XFLAG_HASATTR</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">uint</span>
<span class="nf">xfs_dic2xflags</span><span class="p">(</span>
	<span class="n">xfs_dinode_t</span>		<span class="o">*</span><span class="n">dip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_xfs_dic2xflags</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_flags</span><span class="p">))</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">XFS_DFORK_Q</span><span class="p">(</span><span class="n">dip</span><span class="p">)</span> <span class="o">?</span> <span class="n">XFS_XFLAG_HASATTR</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read the disk inode attributes into the in-core inode structure.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_iread</span><span class="p">(</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">,</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">uint</span>		<span class="n">iget_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_dinode_t</span>	<span class="o">*</span><span class="n">dip</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in the location information in the in-core inode.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_imap</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">,</span> <span class="n">iget_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get pointers to the on-disk inode and the buffer containing it.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_imap_to_bp</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iget_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">dip</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dinode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">xfs_buf_offset</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">.</span><span class="n">im_boffset</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we got something that isn&#39;t an inode it means someone</span>
<span class="cm">	 * (nfs or dmi) has a stale handle.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_magic</span> <span class="o">!=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DINODE_MAGIC</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
			<span class="s">&quot;%s: dip-&gt;di_magic (0x%x) != XFS_DINODE_MAGIC (0x%x)&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_magic</span><span class="p">),</span> <span class="n">XFS_DINODE_MAGIC</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_brelse</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the on-disk inode is already linked to a directory</span>
<span class="cm">	 * entry, copy all of the inode into the in-core inode.</span>
<span class="cm">	 * xfs_iformat() handles copying in the inode format</span>
<span class="cm">	 * specific information.</span>
<span class="cm">	 * Otherwise, just get the truly permanent information.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_dinode_from_disk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">,</span> <span class="n">dip</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iformat</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">dip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>  <span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: xfs_iformat() returned error %d&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>
			<span class="k">goto</span> <span class="n">out_brelse</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_magic</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_magic</span><span class="p">);</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_version</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_version</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_gen</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_gen</span><span class="p">);</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flushiter</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_flushiter</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make sure to pull in the mode here as well in</span>
<span class="cm">		 * case the inode is released without being used.</span>
<span class="cm">		 * This ensures that xfs_inactive() will see that</span>
<span class="cm">		 * the inode is already free and not try to mess</span>
<span class="cm">		 * with the uninitialized part of it.</span>
<span class="cm">		 */</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The inode format changed when we moved the link count and</span>
<span class="cm">	 * made it 32 bits long.  If this is an old format inode,</span>
<span class="cm">	 * convert it in memory to look like a new one.  If it gets</span>
<span class="cm">	 * flushed to disk we will convert back before flushing or</span>
<span class="cm">	 * logging it.  We zero out the new projid field and the old link</span>
<span class="cm">	 * count field.  We&#39;ll handle clearing the pad field (the remains</span>
<span class="cm">	 * of the old uuid field) when we actually convert the inode to</span>
<span class="cm">	 * the new format. We don&#39;t change the version number so that we</span>
<span class="cm">	 * can distinguish this from a real new format inode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_onlink</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_onlink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xfs_set_projid</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_delayed_blks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mark the buffer containing the inode as something to keep</span>
<span class="cm">	 * around for a while.  This helps to keep recently accessed</span>
<span class="cm">	 * meta-data in-core longer.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_buf_set_ref</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">XFS_INO_REF</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use xfs_trans_brelse() to release the buffer containing the</span>
<span class="cm">	 * on-disk inode, because it was acquired with xfs_trans_read_buf()</span>
<span class="cm">	 * in xfs_itobp() above.  If tp is NULL, this is just a normal</span>
<span class="cm">	 * brelse().  If we&#39;re within a transaction, then xfs_trans_brelse()</span>
<span class="cm">	 * will only release the buffer if it is not dirty within the</span>
<span class="cm">	 * transaction.  It will be OK to release the buffer in this case,</span>
<span class="cm">	 * because inodes on disk are never destroyed and we will be</span>
<span class="cm">	 * locking the new in-core inode before putting it in the hash</span>
<span class="cm">	 * table where other processes can find it.  Thus we don&#39;t have</span>
<span class="cm">	 * to worry about the inode being changed just because we released</span>
<span class="cm">	 * the buffer.</span>
<span class="cm">	 */</span>
 <span class="nl">out_brelse:</span>
	<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read in extents from a btree-format inode.</span>
<span class="cm"> * Allocate and fill in if_extents.  Real work is done in xfs_bmap.c.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_iread_extents</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">whichfork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">;</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">nextents</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">XFS_IFORK_FORMAT</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">)</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_BTREE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">XFS_ERROR_REPORT</span><span class="p">(</span><span class="s">&quot;xfs_iread_extents&quot;</span><span class="p">,</span> <span class="n">XFS_ERRLEVEL_LOW</span><span class="p">,</span>
				 <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">nextents</span> <span class="o">=</span> <span class="n">XFS_IFORK_NEXTENTS</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="n">ifp</span> <span class="o">=</span> <span class="n">XFS_IFORK_PTR</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We know that the size is valid (it&#39;s checked in iformat_btree)</span>
<span class="cm">	 */</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">|=</span> <span class="n">XFS_IFEXTENTS</span><span class="p">;</span>
	<span class="n">xfs_iext_add</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nextents</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_read_extents</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_destroy</span><span class="p">(</span><span class="n">ifp</span><span class="p">);</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XFS_IFEXTENTS</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_validate_extents</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">nextents</span><span class="p">,</span> <span class="n">XFS_EXTFMT_INODE</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate an inode on disk and return a copy of its in-core version.</span>
<span class="cm"> * The in-core inode is locked exclusively.  Set mode, nlink, and rdev</span>
<span class="cm"> * appropriately within the inode.  The uid and gid for the inode are</span>
<span class="cm"> * set according to the contents of the given cred structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Use xfs_dialloc() to allocate the on-disk inode. If xfs_dialloc()</span>
<span class="cm"> * has a free inode available, call xfs_iget()</span>
<span class="cm"> * to obtain the in-core version of the allocated inode.  Finally,</span>
<span class="cm"> * fill in the inode and log its initial contents.  In this case,</span>
<span class="cm"> * ialloc_context would be set to NULL and call_again set to false.</span>
<span class="cm"> *</span>
<span class="cm"> * If xfs_dialloc() does not have an available inode,</span>
<span class="cm"> * it will replenish its supply by doing an allocation. Since we can</span>
<span class="cm"> * only do one allocation within a transaction without deadlocks, we</span>
<span class="cm"> * must commit the current transaction before returning the inode itself.</span>
<span class="cm"> * In this case, therefore, we will set call_again to true and return.</span>
<span class="cm"> * The caller should then commit the current transaction, start a new</span>
<span class="cm"> * transaction, and call xfs_ialloc() again to actually get the inode.</span>
<span class="cm"> *</span>
<span class="cm"> * To ensure that some other process does not grab the inode that</span>
<span class="cm"> * was allocated during the first call to xfs_ialloc(), this routine</span>
<span class="cm"> * also returns the [locked] bp pointing to the head of the freelist</span>
<span class="cm"> * as ialloc_context.  The caller should hold this buffer across</span>
<span class="cm"> * the commit and pass it back into this routine on the second call.</span>
<span class="cm"> *</span>
<span class="cm"> * If we are allocating quota inodes, we do not have a parent inode</span>
<span class="cm"> * to attach to or associate with (i.e. pip == NULL) because they</span>
<span class="cm"> * are not linked into the directory structure - they are attached</span>
<span class="cm"> * directly to the superblock - and so have no parent.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_ialloc</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">pip</span><span class="p">,</span>
	<span class="n">umode_t</span>		<span class="n">mode</span><span class="p">,</span>
	<span class="n">xfs_nlink_t</span>	<span class="n">nlink</span><span class="p">,</span>
	<span class="n">xfs_dev_t</span>	<span class="n">rdev</span><span class="p">,</span>
	<span class="n">prid_t</span>		<span class="n">prid</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">okalloc</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>	<span class="o">**</span><span class="n">ialloc_context</span><span class="p">,</span>
	<span class="n">boolean_t</span>	<span class="o">*</span><span class="n">call_again</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">**</span><span class="n">ipp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_ino_t</span>	<span class="n">ino</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="n">uint</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="n">timespec_t</span>	<span class="n">tv</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">filestreams</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call the space management code to pick</span>
<span class="cm">	 * the on-disk inode to be allocated.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_dialloc</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">pip</span> <span class="o">?</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">okalloc</span><span class="p">,</span>
			    <span class="n">ialloc_context</span><span class="p">,</span> <span class="n">call_again</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">call_again</span> <span class="o">||</span> <span class="n">ino</span> <span class="o">==</span> <span class="n">NULLFSINO</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ipp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">*</span><span class="n">ialloc_context</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the in-core inode with the lock held exclusively.</span>
<span class="cm">	 * This is because we&#39;re setting fields here we need</span>
<span class="cm">	 * to prevent others from looking at until we&#39;re done.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iget</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">XFS_IGET_CREATE</span><span class="p">,</span>
			 <span class="n">XFS_ILOCK_EXCL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_onlink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">=</span> <span class="n">nlink</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">==</span> <span class="n">nlink</span><span class="p">);</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_uid</span> <span class="o">=</span> <span class="n">current_fsuid</span><span class="p">();</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_gid</span> <span class="o">=</span> <span class="n">current_fsgid</span><span class="p">();</span>
	<span class="n">xfs_set_projid</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">prid</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_pad</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_pad</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the superblock version is up to where we support new format</span>
<span class="cm">	 * inodes and this is currently an old format inode, then change</span>
<span class="cm">	 * the inode version number now.  This way we only do the conversion</span>
<span class="cm">	 * here rather than here and in the flush/logging code.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_sb_version_hasnlink</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;ve already zeroed the old link count, the projid field,</span>
<span class="cm">		 * and the pad field.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Project ids won&#39;t be stored on disk if we are using a version 1 inode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">prid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">xfs_bump_ino_vers2</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pip</span> <span class="o">&amp;&amp;</span> <span class="n">XFS_INHERIT_GID</span><span class="p">(</span><span class="n">pip</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_gid</span> <span class="o">=</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_gid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">&amp;</span> <span class="n">S_ISGID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">|=</span> <span class="n">S_ISGID</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the group ID of the new file does not match the effective group</span>
<span class="cm">	 * ID or one of the supplementary group IDs, the S_ISGID bit is cleared</span>
<span class="cm">	 * (and only if the irix_sgid_inherit compatibility variable is set).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">irix_sgid_inherit</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">&amp;</span> <span class="n">S_ISGID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">in_group_p</span><span class="p">((</span><span class="n">gid_t</span><span class="p">)</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_gid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_ISGID</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nextents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nblocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">nanotime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_sec</span> <span class="o">=</span> <span class="p">(</span><span class="n">__int32_t</span><span class="p">)</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mtime</span><span class="p">.</span><span class="n">t_nsec</span> <span class="o">=</span> <span class="p">(</span><span class="n">__int32_t</span><span class="p">)</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_atime</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mtime</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_ctime</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mtime</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * di_gen will have been taken care of in xfs_iread.</span>
<span class="cm">	 */</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_extsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_dmevmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_dmstate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">XFS_ILOG_CORE</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFIFO</span>:
	<span class="k">case</span> <span class="n">S_IFCHR</span>:
	<span class="k">case</span> <span class="n">S_IFBLK</span>:
	<span class="k">case</span> <span class="n">S_IFSOCK</span>:
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">=</span> <span class="n">XFS_DINODE_FMT_DEV</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_rdev</span> <span class="o">=</span> <span class="n">rdev</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">XFS_ILOG_DEV</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFREG</span>:
		<span class="cm">/*</span>
<span class="cm">		 * we can&#39;t set up filestreams until after the VFS inode</span>
<span class="cm">		 * is set up properly.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pip</span> <span class="o">&amp;&amp;</span> <span class="n">xfs_inode_is_filestream</span><span class="p">(</span><span class="n">pip</span><span class="p">))</span>
			<span class="n">filestreams</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">pip</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_ANY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">uint</span>	<span class="n">di_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_RTINHERIT</span><span class="p">)</span>
					<span class="n">di_flags</span> <span class="o">|=</span> <span class="n">XFS_DIFLAG_RTINHERIT</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_EXTSZINHERIT</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">di_flags</span> <span class="o">|=</span> <span class="n">XFS_DIFLAG_EXTSZINHERIT</span><span class="p">;</span>
					<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_extsize</span> <span class="o">=</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_extsize</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_RTINHERIT</span><span class="p">)</span>
					<span class="n">di_flags</span> <span class="o">|=</span> <span class="n">XFS_DIFLAG_REALTIME</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_EXTSZINHERIT</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">di_flags</span> <span class="o">|=</span> <span class="n">XFS_DIFLAG_EXTSIZE</span><span class="p">;</span>
					<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_extsize</span> <span class="o">=</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_extsize</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_NOATIME</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">xfs_inherit_noatime</span><span class="p">)</span>
				<span class="n">di_flags</span> <span class="o">|=</span> <span class="n">XFS_DIFLAG_NOATIME</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_NODUMP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">xfs_inherit_nodump</span><span class="p">)</span>
				<span class="n">di_flags</span> <span class="o">|=</span> <span class="n">XFS_DIFLAG_NODUMP</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_SYNC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">xfs_inherit_sync</span><span class="p">)</span>
				<span class="n">di_flags</span> <span class="o">|=</span> <span class="n">XFS_DIFLAG_SYNC</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_NOSYMLINKS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">xfs_inherit_nosymlinks</span><span class="p">)</span>
				<span class="n">di_flags</span> <span class="o">|=</span> <span class="n">XFS_DIFLAG_NOSYMLINKS</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_PROJINHERIT</span><span class="p">)</span>
				<span class="n">di_flags</span> <span class="o">|=</span> <span class="n">XFS_DIFLAG_PROJINHERIT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_NODEFRAG</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">xfs_inherit_nodefrag</span><span class="p">)</span>
				<span class="n">di_flags</span> <span class="o">|=</span> <span class="n">XFS_DIFLAG_NODEFRAG</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">&amp;</span> <span class="n">XFS_DIFLAG_FILESTREAM</span><span class="p">)</span>
				<span class="n">di_flags</span> <span class="o">|=</span> <span class="n">XFS_DIFLAG_FILESTREAM</span><span class="p">;</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">|=</span> <span class="n">di_flags</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FALLTHROUGH */</span>
	<span class="k">case</span> <span class="n">S_IFLNK</span>:
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">=</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_flags</span> <span class="o">=</span> <span class="n">XFS_IFEXTENTS</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_bytes</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_real_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Attribute fork settings for new inode.</span>
<span class="cm">	 */</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">=</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_anextents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Log the new values stuffed into the inode.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* now that we have an i_mode we can setup inode ops and unlock */</span>
	<span class="n">xfs_setup_inode</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="cm">/* now we have set up the vfs inode we can associate the filestream */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filestreams</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_filestream_associate</span><span class="p">(</span><span class="n">pip</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="n">xfs_iflags_set</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IFILESTREAM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">ipp</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free up the underlying blocks past new_size.  The new size must be smaller</span>
<span class="cm"> * than the current size.  This routine can be used both for the attribute and</span>
<span class="cm"> * data fork, and does not modify the inode size, which is left to the caller.</span>
<span class="cm"> *</span>
<span class="cm"> * The transaction passed to this routine must have made a permanent log</span>
<span class="cm"> * reservation of at least XFS_ITRUNCATE_LOG_RES.  This routine may commit the</span>
<span class="cm"> * given transaction and start new ones, so make sure everything involved in</span>
<span class="cm"> * the transaction is tidy before calling here.  Some transaction will be</span>
<span class="cm"> * returned to the caller to be committed.  The incoming transaction must</span>
<span class="cm"> * already include the inode, and both inode locks must be held exclusively.</span>
<span class="cm"> * The inode must also be &quot;held&quot; within the transaction.  On return the inode</span>
<span class="cm"> * will be &quot;held&quot; within the returned transaction.  This routine does NOT</span>
<span class="cm"> * require any disk space to be reserved for it within the transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * If we get an error, we must return with the inode locked and linked into the</span>
<span class="cm"> * current transaction. This keeps things simple for the higher level code,</span>
<span class="cm"> * because it always knows that the inode is locked and held in the transaction</span>
<span class="cm"> * that returns to it whether errors occur or not.  We don&#39;t mark the inode</span>
<span class="cm"> * dirty on error so that transactions can be easily aborted if possible.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_itruncate_extents</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">**</span><span class="n">tpp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">whichfork</span><span class="p">,</span>
	<span class="n">xfs_fsize_t</span>		<span class="n">new_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">*</span><span class="n">tpp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">ntp</span><span class="p">;</span>
	<span class="n">xfs_bmap_free_t</span>		<span class="n">free_list</span><span class="p">;</span>
	<span class="n">xfs_fsblock_t</span>		<span class="n">first_block</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">first_unmap_block</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">last_block</span><span class="p">;</span>
	<span class="n">xfs_filblks_t</span>		<span class="n">unmap_len</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">committed</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_isilocked</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="o">|</span><span class="n">XFS_IOLOCK_EXCL</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">new_size</span> <span class="o">&lt;=</span> <span class="n">XFS_ISIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_itemp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_itemp</span><span class="o">-&gt;</span><span class="n">ili_lock_flags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">XFS_NOT_DQATTACHED</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="p">));</span>

	<span class="n">trace_xfs_itruncate_extents_start</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since it is possible for space to become allocated beyond</span>
<span class="cm">	 * the end of the file (in a crash where the space is allocated</span>
<span class="cm">	 * but the inode size is not yet updated), simply remove any</span>
<span class="cm">	 * blocks which show up between the new EOF and the maximum</span>
<span class="cm">	 * possible file size.  If the first block to be removed is</span>
<span class="cm">	 * beyond the maximum file size (ie it is the same as last_block),</span>
<span class="cm">	 * then there is nothing to do.</span>
<span class="cm">	 */</span>
	<span class="n">first_unmap_block</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_ufsize_t</span><span class="p">)</span><span class="n">new_size</span><span class="p">);</span>
	<span class="n">last_block</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_ufsize_t</span><span class="p">)</span><span class="n">XFS_MAXIOFFSET</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_unmap_block</span> <span class="o">==</span> <span class="n">last_block</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">first_unmap_block</span> <span class="o">&lt;</span> <span class="n">last_block</span><span class="p">);</span>
	<span class="n">unmap_len</span> <span class="o">=</span> <span class="n">last_block</span> <span class="o">-</span> <span class="n">first_unmap_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_bmap_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_block</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bunmapi</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span>
				    <span class="n">first_unmap_block</span><span class="p">,</span> <span class="n">unmap_len</span><span class="p">,</span>
				    <span class="n">xfs_bmapi_aflag</span><span class="p">(</span><span class="n">whichfork</span><span class="p">),</span>
				    <span class="n">XFS_ITRUNC_MAX_EXTENTS</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">first_block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_bmap_cancel</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Duplicate the transaction that has the permanent</span>
<span class="cm">		 * reservation and commit the old transaction.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">committed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">committed</span><span class="p">)</span>
			<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_bmap_cancel</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">committed</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Mark the inode dirty so it will be logged and</span>
<span class="cm">			 * moved forward in the log as part of every commit.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ntp</span> <span class="o">=</span> <span class="n">xfs_trans_dup</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="n">ntp</span><span class="p">;</span>

		<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Transaction commit worked ok so we can drop the extra ticket</span>
<span class="cm">		 * reference that we gained in xfs_trans_dup()</span>
<span class="cm">		 */</span>
		<span class="n">xfs_log_ticket_put</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_ticket</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">XFS_ITRUNCATE_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">XFS_TRANS_PERM_LOG_RES</span><span class="p">,</span>
					<span class="n">XFS_ITRUNCATE_LOG_COUNT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Always re-log the inode so that our permanent transaction can keep</span>
<span class="cm">	 * on rolling it forward in the log.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>

	<span class="n">trace_xfs_itruncate_extents_end</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="o">*</span><span class="n">tpp</span> <span class="o">=</span> <span class="n">tp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_bmap_cancel:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the bunmapi call encounters an error, return to the caller where</span>
<span class="cm">	 * the transaction can be properly aborted.  We just need to make sure</span>
<span class="cm">	 * we&#39;re not holding any resources that we were not when we came in.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_bmap_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called when the inode&#39;s link count goes to 0.</span>
<span class="cm"> * We place the on-disk inode on a list in the AGI.  It</span>
<span class="cm"> * will be pulled from this list when the inode is freed.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_iunlink</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_agi_t</span>	<span class="o">*</span><span class="n">agi</span><span class="p">;</span>
	<span class="n">xfs_dinode_t</span>	<span class="o">*</span><span class="n">dip</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agibp</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">ibp</span><span class="p">;</span>
	<span class="n">xfs_agino_t</span>	<span class="n">agino</span><span class="p">;</span>
	<span class="kt">short</span>		<span class="n">bucket_index</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the agi buffer first.  It ensures lock ordering</span>
<span class="cm">	 * on the list.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_read_agi</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">XFS_INO_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">agibp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">agi</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGI</span><span class="p">(</span><span class="n">agibp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the index into the agi hash table for the</span>
<span class="cm">	 * list this inode will go on.</span>
<span class="cm">	 */</span>
	<span class="n">agino</span> <span class="o">=</span> <span class="n">XFS_INO_TO_AGINO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">agino</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bucket_index</span> <span class="o">=</span> <span class="n">agino</span> <span class="o">%</span> <span class="n">XFS_AGI_UNLINKED_BUCKETS</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_unlinked</span><span class="p">[</span><span class="n">bucket_index</span><span class="p">]);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_unlinked</span><span class="p">[</span><span class="n">bucket_index</span><span class="p">])</span> <span class="o">!=</span> <span class="n">agino</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_unlinked</span><span class="p">[</span><span class="n">bucket_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NULLAGINO</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * There is already another inode in the bucket we need</span>
<span class="cm">		 * to add ourselves to.  Add us at the front of the list.</span>
<span class="cm">		 * Here we put the head pointer into our next pointer,</span>
<span class="cm">		 * and then we fall through to point the head at us.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_itobp</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ibp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_next_unlinked</span> <span class="o">==</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NULLAGINO</span><span class="p">));</span>
		<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_next_unlinked</span> <span class="o">=</span> <span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_unlinked</span><span class="p">[</span><span class="n">bucket_index</span><span class="p">];</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">.</span><span class="n">im_boffset</span> <span class="o">+</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_dinode_t</span><span class="p">,</span> <span class="n">di_next_unlinked</span><span class="p">);</span>
		<span class="n">xfs_trans_inode_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ibp</span><span class="p">);</span>
		<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ibp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_agino_t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">xfs_inobp_check</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ibp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Point the bucket head pointer at the inode being inserted.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">agino</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_unlinked</span><span class="p">[</span><span class="n">bucket_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">agino</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">,</span> <span class="n">agi_unlinked</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_agino_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">bucket_index</span><span class="p">);</span>
	<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agibp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_agino_t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pull the on-disk inode from the AGI unlinked list.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_iunlink_remove</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_ino_t</span>	<span class="n">next_ino</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>	<span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">xfs_agi_t</span>	<span class="o">*</span><span class="n">agi</span><span class="p">;</span>
	<span class="n">xfs_dinode_t</span>	<span class="o">*</span><span class="n">dip</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">agibp</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">ibp</span><span class="p">;</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">agno</span><span class="p">;</span>
	<span class="n">xfs_agino_t</span>	<span class="n">agino</span><span class="p">;</span>
	<span class="n">xfs_agino_t</span>	<span class="n">next_agino</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">last_ibp</span><span class="p">;</span>
	<span class="n">xfs_dinode_t</span>	<span class="o">*</span><span class="n">last_dip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">short</span>		<span class="n">bucket_index</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">offset</span><span class="p">,</span> <span class="n">last_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_mountp</span><span class="p">;</span>
	<span class="n">agno</span> <span class="o">=</span> <span class="n">XFS_INO_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the agi buffer first.  It ensures lock ordering</span>
<span class="cm">	 * on the list.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_read_agi</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">agibp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">agi</span> <span class="o">=</span> <span class="n">XFS_BUF_TO_AGI</span><span class="p">(</span><span class="n">agibp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the index into the agi hash table for the</span>
<span class="cm">	 * list this inode will go on.</span>
<span class="cm">	 */</span>
	<span class="n">agino</span> <span class="o">=</span> <span class="n">XFS_INO_TO_AGINO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">agino</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bucket_index</span> <span class="o">=</span> <span class="n">agino</span> <span class="o">%</span> <span class="n">XFS_AGI_UNLINKED_BUCKETS</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_unlinked</span><span class="p">[</span><span class="n">bucket_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NULLAGINO</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_unlinked</span><span class="p">[</span><span class="n">bucket_index</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_unlinked</span><span class="p">[</span><span class="n">bucket_index</span><span class="p">])</span> <span class="o">==</span> <span class="n">agino</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re at the head of the list.  Get the inode&#39;s</span>
<span class="cm">		 * on-disk buffer to see if there is anyone after us</span>
<span class="cm">		 * on the list.  Only modify our next pointer if it</span>
<span class="cm">		 * is not already NULLAGINO.  This saves us the overhead</span>
<span class="cm">		 * of dealing with the buffer when there is no need to</span>
<span class="cm">		 * change it.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_itobp</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ibp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: xfs_itobp() returned error %d.&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">next_agino</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_next_unlinked</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">next_agino</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_agino</span> <span class="o">!=</span> <span class="n">NULLAGINO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_next_unlinked</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NULLAGINO</span><span class="p">);</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">.</span><span class="n">im_boffset</span> <span class="o">+</span>
				<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_dinode_t</span><span class="p">,</span> <span class="n">di_next_unlinked</span><span class="p">);</span>
			<span class="n">xfs_trans_inode_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ibp</span><span class="p">);</span>
			<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ibp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					  <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_agino_t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
			<span class="n">xfs_inobp_check</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ibp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ibp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Point the bucket head pointer at the next inode.</span>
<span class="cm">		 */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">next_agino</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">next_agino</span> <span class="o">!=</span> <span class="n">agino</span><span class="p">);</span>
		<span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_unlinked</span><span class="p">[</span><span class="n">bucket_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">next_agino</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_agi_t</span><span class="p">,</span> <span class="n">agi_unlinked</span><span class="p">)</span> <span class="o">+</span>
			<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_agino_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">bucket_index</span><span class="p">);</span>
		<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">agibp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_agino_t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need to search the list for the inode being freed.</span>
<span class="cm">		 */</span>
		<span class="n">next_agino</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">agi</span><span class="o">-&gt;</span><span class="n">agi_unlinked</span><span class="p">[</span><span class="n">bucket_index</span><span class="p">]);</span>
		<span class="n">last_ibp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">next_agino</span> <span class="o">!=</span> <span class="n">agino</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the last inode wasn&#39;t the one pointing to</span>
<span class="cm">			 * us, then release its buffer since we&#39;re not</span>
<span class="cm">			 * going to do anything with it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last_ibp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">last_ibp</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">next_ino</span> <span class="o">=</span> <span class="n">XFS_AGINO_TO_INO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">agno</span><span class="p">,</span> <span class="n">next_agino</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_inotobp</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">next_ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_dip</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">last_ibp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span>
					<span class="s">&quot;%s: xfs_inotobp() returned error %d.&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">next_agino</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">last_dip</span><span class="o">-&gt;</span><span class="n">di_next_unlinked</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">next_agino</span> <span class="o">!=</span> <span class="n">NULLAGINO</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">next_agino</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Now last_ibp points to the buffer previous to us on</span>
<span class="cm">		 * the unlinked list.  Pull us from the list.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_itobp</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ibp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_warn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="s">&quot;%s: xfs_itobp(2) returned error %d.&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">next_agino</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_next_unlinked</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">next_agino</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">next_agino</span> <span class="o">!=</span> <span class="n">agino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_agino</span> <span class="o">!=</span> <span class="n">NULLAGINO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_next_unlinked</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NULLAGINO</span><span class="p">);</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">.</span><span class="n">im_boffset</span> <span class="o">+</span>
				<span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_dinode_t</span><span class="p">,</span> <span class="n">di_next_unlinked</span><span class="p">);</span>
			<span class="n">xfs_trans_inode_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ibp</span><span class="p">);</span>
			<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ibp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					  <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_agino_t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
			<span class="n">xfs_inobp_check</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ibp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xfs_trans_brelse</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ibp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Point the previous inode on the list to the next inode.</span>
<span class="cm">		 */</span>
		<span class="n">last_dip</span><span class="o">-&gt;</span><span class="n">di_next_unlinked</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">next_agino</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">next_agino</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">last_offset</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">xfs_dinode_t</span><span class="p">,</span> <span class="n">di_next_unlinked</span><span class="p">);</span>
		<span class="n">xfs_trans_inode_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">last_ibp</span><span class="p">);</span>
		<span class="n">xfs_trans_log_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">last_ibp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_agino_t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">xfs_inobp_check</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">last_ibp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A big issue when freeing the inode cluster is is that we _cannot_ skip any</span>
<span class="cm"> * inodes that are in memory - they all must be marked stale and attached to</span>
<span class="cm"> * the cluster buffer.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_ifree_cluster</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">free_ip</span><span class="p">,</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>
	<span class="n">xfs_ino_t</span>	<span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">free_ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">blks_per_cluster</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nbufs</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ninodes</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">blkno</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="n">xfs_inode_log_item_t</span>	<span class="o">*</span><span class="n">iip</span><span class="p">;</span>
	<span class="n">xfs_log_item_t</span>		<span class="o">*</span><span class="n">lip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span>	<span class="o">*</span><span class="n">pag</span><span class="p">;</span>

	<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_INO_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">inum</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span> <span class="o">&gt;=</span> <span class="n">XFS_INODE_CLUSTER_SIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">blks_per_cluster</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ninodes</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inopblock</span><span class="p">;</span>
		<span class="n">nbufs</span> <span class="o">=</span> <span class="n">XFS_IALLOC_BLOCKS</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">blks_per_cluster</span> <span class="o">=</span> <span class="n">XFS_INODE_CLUSTER_SIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">/</span>
					<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_blocksize</span><span class="p">;</span>
		<span class="n">ninodes</span> <span class="o">=</span> <span class="n">blks_per_cluster</span> <span class="o">*</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inopblock</span><span class="p">;</span>
		<span class="n">nbufs</span> <span class="o">=</span> <span class="n">XFS_IALLOC_BLOCKS</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">/</span> <span class="n">blks_per_cluster</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nbufs</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">inum</span> <span class="o">+=</span> <span class="n">ninodes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blkno</span> <span class="o">=</span> <span class="n">XFS_AGB_TO_DADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_INO_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">inum</span><span class="p">),</span>
					 <span class="n">XFS_INO_TO_AGBNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">inum</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * We obtain and lock the backing buffer first in the process</span>
<span class="cm">		 * here, as we have to ensure that any dirty inode that we</span>
<span class="cm">		 * can&#39;t get the flush lock on is attached to the buffer.</span>
<span class="cm">		 * If we scan the in-memory inodes first, then buffer IO can</span>
<span class="cm">		 * complete before we get a lock on it, and hence we may fail</span>
<span class="cm">		 * to mark all the active inodes on the buffer stale.</span>
<span class="cm">		 */</span>
		<span class="n">bp</span> <span class="o">=</span> <span class="n">xfs_trans_get_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="p">,</span> <span class="n">blkno</span><span class="p">,</span>
					<span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_bsize</span> <span class="o">*</span> <span class="n">blks_per_cluster</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Walk the inodes already attached to the buffer and mark them</span>
<span class="cm">		 * stale. These will all have the flush locks held, so an</span>
<span class="cm">		 * in-memory inode walk can&#39;t lock them. By marking them all</span>
<span class="cm">		 * stale first, we will not attempt to lock them in the loop</span>
<span class="cm">		 * below as the XFS_ISTALE flag will be set.</span>
<span class="cm">		 */</span>
		<span class="n">lip</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_fspriv</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">lip</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_type</span> <span class="o">==</span> <span class="n">XFS_LI_INODE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iip</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_inode_log_item_t</span> <span class="o">*</span><span class="p">)</span><span class="n">lip</span><span class="p">;</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_logged</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_cb</span> <span class="o">=</span> <span class="n">xfs_istale_done</span><span class="p">;</span>
				<span class="n">xfs_trans_ail_copy_lsn</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ail</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_flush_lsn</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_item</span><span class="p">.</span><span class="n">li_lsn</span><span class="p">);</span>
				<span class="n">xfs_iflags_set</span><span class="p">(</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_inode</span><span class="p">,</span> <span class="n">XFS_ISTALE</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">lip</span> <span class="o">=</span> <span class="n">lip</span><span class="o">-&gt;</span><span class="n">li_bio_list</span><span class="p">;</span>
		<span class="p">}</span>


		<span class="cm">/*</span>
<span class="cm">		 * For each inode in memory attempt to add it to the inode</span>
<span class="cm">		 * buffer and set it up for being staled on buffer IO</span>
<span class="cm">		 * completion.  This is safe as we&#39;ve locked out tail pushing</span>
<span class="cm">		 * and flushing by locking the buffer.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We have already marked every inode that was part of a</span>
<span class="cm">		 * transaction stale above, which means there is no point in</span>
<span class="cm">		 * even trying to lock them.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ninodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">retry:</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="n">ip</span> <span class="o">=</span> <span class="n">radix_tree_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_ici_root</span><span class="p">,</span>
					<span class="n">XFS_INO_TO_AGINO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="n">inum</span> <span class="o">+</span> <span class="n">i</span><span class="p">)));</span>

			<span class="cm">/* Inode not in memory, nothing to do */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ip</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rcu_read_unlock</span><span class="p">();</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * because this is an RCU protected lookup, we could</span>
<span class="cm">			 * find a recently freed or even reallocated inode</span>
<span class="cm">			 * during the lookup. We need to check under the</span>
<span class="cm">			 * i_flags_lock for a valid inode here. Skip it if it</span>
<span class="cm">			 * is not valid, the wrong inode or stale.</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_flags_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">!=</span> <span class="n">inum</span> <span class="o">+</span> <span class="n">i</span> <span class="o">||</span>
			    <span class="n">__xfs_iflags_test</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ISTALE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_flags_lock</span><span class="p">);</span>
				<span class="n">rcu_read_unlock</span><span class="p">();</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_flags_lock</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Don&#39;t try to lock/unlock the current inode, but we</span>
<span class="cm">			 * _cannot_ skip the other inodes that we did not find</span>
<span class="cm">			 * in the list attached to the buffer and are not</span>
<span class="cm">			 * already marked stale. If we can&#39;t lock it, back off</span>
<span class="cm">			 * and retry.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">!=</span> <span class="n">free_ip</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">xfs_ilock_nowait</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">rcu_read_unlock</span><span class="p">();</span>
				<span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>

			<span class="n">xfs_iflock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
			<span class="n">xfs_iflags_set</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ISTALE</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * we don&#39;t need to attach clean inodes or those only</span>
<span class="cm">			 * with unlogged changes (which we throw away, anyway).</span>
<span class="cm">			 */</span>
			<span class="n">iip</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_itemp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iip</span> <span class="o">||</span> <span class="n">xfs_inode_clean</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span> <span class="o">!=</span> <span class="n">free_ip</span><span class="p">);</span>
				<span class="n">xfs_ifunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
				<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_last_fields</span> <span class="o">=</span> <span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_fields</span><span class="p">;</span>
			<span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_fields</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_logged</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">xfs_trans_ail_copy_lsn</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ail</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_flush_lsn</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_item</span><span class="p">.</span><span class="n">li_lsn</span><span class="p">);</span>

			<span class="n">xfs_buf_attach_iodone</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">xfs_istale_done</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_item</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">!=</span> <span class="n">free_ip</span><span class="p">)</span>
				<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">xfs_trans_stale_inode_buf</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
		<span class="n">xfs_trans_binval</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called to return an inode to the inode free list.</span>
<span class="cm"> * The inode should already be truncated to 0 length and have</span>
<span class="cm"> * no pages associated with it.  This routine also assumes that</span>
<span class="cm"> * the inode is already a part of the transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * The on-disk copy of the inode will have been added to the list</span>
<span class="cm"> * of unlinked inodes in the AGI. We need to remove the inode from</span>
<span class="cm"> * that list atomically with respect to freeing it here.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_ifree</span><span class="p">(</span>
	<span class="n">xfs_trans_t</span>	<span class="o">*</span><span class="n">tp</span><span class="p">,</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_bmap_free_t</span>	<span class="o">*</span><span class="n">flist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">delete</span><span class="p">;</span>
	<span class="n">xfs_ino_t</span>		<span class="n">first_ino</span><span class="p">;</span>
	<span class="n">xfs_dinode_t</span>    	<span class="o">*</span><span class="n">dip</span><span class="p">;</span>
	<span class="n">xfs_buf_t</span>       	<span class="o">*</span><span class="n">ibp</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_isilocked</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nextents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_anextents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nblocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pull the on-disk inode from the AGI unlinked list.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iunlink_remove</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_difree</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">flist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delete</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* mark incore inode as free */</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_dmevmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_forkoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* mark the attr fork not in use */</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">=</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_aformat</span> <span class="o">=</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Bump the generation count so no one will be confused</span>
<span class="cm">	 * by reincarnations of this inode.</span>
<span class="cm">	 */</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_gen</span><span class="o">++</span><span class="p">;</span>

	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_itobp</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ibp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">	* Clear the on-disk di_mode. This is to prevent xfs_bulkstat</span>
<span class="cm">	* from picking up this inode when it is reclaimed (its incore state</span>
<span class="cm">	* initialzed but not flushed to disk yet). The in-core di_mode is</span>
<span class="cm">	* already cleared  and a corresponding transaction logged.</span>
<span class="cm">	* The hack here just synchronizes the in-core to on-disk</span>
<span class="cm">	* di_mode value in advance before the actual inode sync to disk.</span>
<span class="cm">	* This is OK because the inode is already unlinked and would never</span>
<span class="cm">	* change its di_mode again for this inode generation.</span>
<span class="cm">	* This is a temporary hack that would require a proper fix</span>
<span class="cm">	* in the future.</span>
<span class="cm">	*/</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_ifree_cluster</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">first_ino</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reallocate the space for if_broot based on the number of records</span>
<span class="cm"> * being added or deleted as indicated in rec_diff.  Move the records</span>
<span class="cm"> * and pointers in if_broot to fit the new size.  When shrinking this</span>
<span class="cm"> * will eliminate holes between the records and pointers created by</span>
<span class="cm"> * the caller.  When growing this will create holes to be filled in</span>
<span class="cm"> * by the caller.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must not request to add more records than would fit in</span>
<span class="cm"> * the on-disk inode root.  If the if_broot is currently NULL, then</span>
<span class="cm"> * if we adding records one will be allocated.  The caller must also</span>
<span class="cm"> * not request that the number of records go below zero, although</span>
<span class="cm"> * it can go to zero.</span>
<span class="cm"> *</span>
<span class="cm"> * ip -- the inode whose if_broot area is changing</span>
<span class="cm"> * ext_diff -- the change in the number of records, positive or negative,</span>
<span class="cm"> *	 requested for the if_broot array.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_iroot_realloc</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">rec_diff</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">whichfork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cur_max</span><span class="p">;</span>
	<span class="n">xfs_ifork_t</span>		<span class="o">*</span><span class="n">ifp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_btree_block</span>	<span class="o">*</span><span class="n">new_broot</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">new_max</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">new_size</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Handle the degenerate case quietly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rec_diff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ifp</span> <span class="o">=</span> <span class="n">XFS_IFORK_PTR</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rec_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there wasn&#39;t any memory allocated before, just</span>
<span class="cm">		 * allocate it now and get out.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">XFS_BMAP_BROOT_SPACE_CALC</span><span class="p">(</span><span class="n">rec_diff</span><span class="p">);</span>
			<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="n">KM_SLEEP</span> <span class="o">|</span> <span class="n">KM_NOFS</span><span class="p">);</span>
			<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">new_size</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If there is already an existing if_broot, then we need</span>
<span class="cm">		 * to realloc() it and shift the pointers to their new</span>
<span class="cm">		 * location.  The records don&#39;t change location because</span>
<span class="cm">		 * they are kept butted up against the btree block header.</span>
<span class="cm">		 */</span>
		<span class="n">cur_max</span> <span class="o">=</span> <span class="n">xfs_bmbt_maxrecs</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">new_max</span> <span class="o">=</span> <span class="n">cur_max</span> <span class="o">+</span> <span class="n">rec_diff</span><span class="p">;</span>
		<span class="n">new_size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">XFS_BMAP_BROOT_SPACE_CALC</span><span class="p">(</span><span class="n">new_max</span><span class="p">);</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span> <span class="o">=</span> <span class="n">kmem_realloc</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">XFS_BMAP_BROOT_SPACE_CALC</span><span class="p">(</span><span class="n">cur_max</span><span class="p">),</span> <span class="cm">/* old size */</span>
				<span class="n">KM_SLEEP</span> <span class="o">|</span> <span class="n">KM_NOFS</span><span class="p">);</span>
		<span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">XFS_BMAP_BROOT_PTR_ADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						     <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span><span class="p">);</span>
		<span class="n">np</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">XFS_BMAP_BROOT_PTR_ADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">new_size</span><span class="p">);</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">new_size</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span> <span class="o">&lt;=</span>
			<span class="n">XFS_IFORK_SIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">)</span> <span class="o">+</span> <span class="n">XFS_BROOT_SIZE_ADJ</span><span class="p">);</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">cur_max</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_dfsbno_t</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * rec_diff is less than 0.  In this case, we are shrinking the</span>
<span class="cm">	 * if_broot buffer.  It must already exist.  If we go to zero</span>
<span class="cm">	 * records, just get rid of the root and clear the status bit.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">cur_max</span> <span class="o">=</span> <span class="n">xfs_bmbt_maxrecs</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">new_max</span> <span class="o">=</span> <span class="n">cur_max</span> <span class="o">+</span> <span class="n">rec_diff</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">new_max</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">new_size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">XFS_BMAP_BROOT_SPACE_CALC</span><span class="p">(</span><span class="n">new_max</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">new_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_broot</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="n">KM_SLEEP</span> <span class="o">|</span> <span class="n">KM_NOFS</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * First copy over the btree block header.</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">new_broot</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span><span class="p">,</span> <span class="n">XFS_BTREE_LBLOCK_LEN</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">new_broot</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XFS_IFBROOT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only copy the records and pointers if there are any.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * First copy the records.</span>
<span class="cm">		 */</span>
		<span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">XFS_BMBT_REC_ADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">np</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">XFS_BMBT_REC_ADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">new_broot</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">new_max</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Then copy the pointers.</span>
<span class="cm">		 */</span>
		<span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">XFS_BMAP_BROOT_PTR_ADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						     <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span><span class="p">);</span>
		<span class="n">np</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">XFS_BMAP_BROOT_PTR_ADDR</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">new_broot</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						     <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">new_size</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">new_max</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_dfsbno_t</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span><span class="p">);</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span> <span class="o">=</span> <span class="n">new_broot</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">new_size</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span> <span class="o">&lt;=</span>
		<span class="n">XFS_IFORK_SIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">)</span> <span class="o">+</span> <span class="n">XFS_BROOT_SIZE_ADJ</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This is called when the amount of space needed for if_data</span>
<span class="cm"> * is increased or decreased.  The change in size is indicated by</span>
<span class="cm"> * the number of bytes that need to be added or deleted in the</span>
<span class="cm"> * byte_diff parameter.</span>
<span class="cm"> *</span>
<span class="cm"> * If the amount of space needed has decreased below the size of the</span>
<span class="cm"> * inline buffer, then switch to using the inline buffer.  Otherwise,</span>
<span class="cm"> * use kmem_realloc() or kmem_alloc() to adjust the size of the buffer</span>
<span class="cm"> * to what is needed.</span>
<span class="cm"> *</span>
<span class="cm"> * ip -- the inode whose if_data area is changing</span>
<span class="cm"> * byte_diff -- the change in the number of bytes, positive or negative,</span>
<span class="cm"> *	 requested for the if_data array.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_idata_realloc</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">byte_diff</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">whichfork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">new_size</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">real_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">byte_diff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ifp</span> <span class="o">=</span> <span class="n">XFS_IFORK_PTR</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="n">new_size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">+</span> <span class="n">byte_diff</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">new_size</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">!=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kmem_free</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">real_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_data</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the valid extents/data can fit in if_inline_ext/data,</span>
<span class="cm">		 * copy them from the malloc&#39;d vector and free it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_data</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">!=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_data</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">,</span>
			      <span class="n">new_size</span><span class="p">);</span>
			<span class="n">kmem_free</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">);</span>
			<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_data</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">real_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Stuck with malloc/realloc.</span>
<span class="cm">		 * For inline data, the underlying buffer must be</span>
<span class="cm">		 * a multiple of 4 bytes in size so that it can be</span>
<span class="cm">		 * logged and stay on word boundaries.  We enforce</span>
<span class="cm">		 * that here.</span>
<span class="cm">		 */</span>
		<span class="n">real_size</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">real_size</span><span class="p">,</span>
							<span class="n">KM_SLEEP</span> <span class="o">|</span> <span class="n">KM_NOFS</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">!=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Only do the realloc if the underlying size</span>
<span class="cm">			 * is really changing.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">!=</span> <span class="n">real_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">=</span>
					<span class="n">kmem_realloc</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">,</span>
							<span class="n">real_size</span><span class="p">,</span>
							<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span><span class="p">,</span>
							<span class="n">KM_SLEEP</span> <span class="o">|</span> <span class="n">KM_NOFS</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">real_size</span><span class="p">,</span>
							<span class="n">KM_SLEEP</span> <span class="o">|</span> <span class="n">KM_NOFS</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_data</span><span class="p">,</span>
				<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">=</span> <span class="n">real_size</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">&lt;=</span> <span class="n">XFS_IFORK_SIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_idestroy_fork</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="kt">int</span>		<span class="n">whichfork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">;</span>

	<span class="n">ifp</span> <span class="o">=</span> <span class="n">XFS_IFORK_PTR</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span><span class="p">);</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the format is local, then we can&#39;t have an extents</span>
<span class="cm">	 * array so just look for an inline data array.  If we&#39;re</span>
<span class="cm">	 * not local then we may or may not have an extents list,</span>
<span class="cm">	 * so check and free it up if we do.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_IFORK_FORMAT</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">)</span> <span class="o">==</span> <span class="n">XFS_DINODE_FMT_LOCAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">!=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_data</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">kmem_free</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">);</span>
			<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">((</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span> <span class="o">!=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">xfs_iext_destroy</span><span class="p">(</span><span class="n">ifp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
	       <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span> <span class="o">==</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">whichfork</span> <span class="o">==</span> <span class="n">XFS_ATTR_FORK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_zone_free</span><span class="p">(</span><span class="n">xfs_ifork_zone</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_afp</span><span class="p">);</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_afp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called to unpin an inode.  The caller must have the inode locked</span>
<span class="cm"> * in at least shared mode so that the buffer cannot be subsequently pinned</span>
<span class="cm"> * once someone is waiting for it to be unpinned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">xfs_iunpin</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_isilocked</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="o">|</span><span class="n">XFS_ILOCK_SHARED</span><span class="p">));</span>

	<span class="n">trace_xfs_inode_unpin_nowait</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="cm">/* Give the log a push to start the unpinning I/O */</span>
	<span class="n">xfs_log_force_lsn</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_itemp</span><span class="o">-&gt;</span><span class="n">ili_last_lsn</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__xfs_iunpin_wait</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wq</span> <span class="o">=</span> <span class="n">bit_waitqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">,</span> <span class="n">__XFS_IPINNED_BIT</span><span class="p">);</span>
	<span class="n">DEFINE_WAIT_BIT</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">,</span> <span class="n">__XFS_IPINNED_BIT</span><span class="p">);</span>

	<span class="n">xfs_iunpin</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">.</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfs_ipincount</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
			<span class="n">io_schedule</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">xfs_ipincount</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">.</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">xfs_iunpin_wait</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_ipincount</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
		<span class="n">__xfs_iunpin_wait</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xfs_iextents_copy()</span>
<span class="cm"> *</span>
<span class="cm"> * This is called to copy the REAL extents (as opposed to the delayed</span>
<span class="cm"> * allocation extents) from the inode into the given buffer.  It</span>
<span class="cm"> * returns the number of bytes copied into the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * If there are no delayed allocation extents, then we can just</span>
<span class="cm"> * memcpy() the extents into the buffer.  Otherwise, we need to</span>
<span class="cm"> * examine each extent in turn and skip those which are delayed.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_iextents_copy</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_bmbt_rec_t</span>		<span class="o">*</span><span class="n">dp</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">whichfork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">copied</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>
	<span class="n">xfs_ifork_t</span>		<span class="o">*</span><span class="n">ifp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nrecs</span><span class="p">;</span>
	<span class="n">xfs_fsblock_t</span>		<span class="n">start_block</span><span class="p">;</span>

	<span class="n">ifp</span> <span class="o">=</span> <span class="n">XFS_IFORK_PTR</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_isilocked</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="o">|</span><span class="n">XFS_ILOCK_SHARED</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">nrecs</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">/</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>
	<span class="n">XFS_BMAP_TRACE_EXLIST</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">nrecs</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">nrecs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * There are some delayed allocation extents in the</span>
<span class="cm">	 * inode, so copy the extents one at a time and skip</span>
<span class="cm">	 * the delayed ones.  There must be at least one</span>
<span class="cm">	 * non-delayed extent.</span>
<span class="cm">	 */</span>
	<span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nrecs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_bmbt_rec_host_t</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">xfs_iext_get_ext</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">start_block</span> <span class="o">=</span> <span class="n">xfs_bmbt_get_startblock</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isnullstartblock</span><span class="p">(</span><span class="n">start_block</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * It&#39;s a delayed allocation extent, so skip it.</span>
<span class="cm">			 */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Translate to on disk format */</span>
		<span class="n">put_unaligned</span><span class="p">(</span><span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">l0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">l0</span><span class="p">);</span>
		<span class="n">put_unaligned</span><span class="p">(</span><span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">l1</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">l1</span><span class="p">);</span>
		<span class="n">dp</span><span class="o">++</span><span class="p">;</span>
		<span class="n">copied</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">copied</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">xfs_validate_extents</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">XFS_EXTFMT_INODE</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">copied</span> <span class="o">*</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Each of the following cases stores data into the same region</span>
<span class="cm"> * of the on-disk inode, so only one of them can be valid at</span>
<span class="cm"> * any given time. While it is possible to have conflicting formats</span>
<span class="cm"> * and log flags, e.g. having XFS_ILOG_?DATA set when the fork is</span>
<span class="cm"> * in EXTENTS format, this can only happen when the fork has</span>
<span class="cm"> * changed formats after being modified but before being flushed.</span>
<span class="cm"> * In these cases, the format always takes precedence, because the</span>
<span class="cm"> * format indicates the current state of the fork.</span>
<span class="cm"> */</span>
<span class="cm">/*ARGSUSED*/</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_iflush_fork</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_dinode_t</span>		<span class="o">*</span><span class="n">dip</span><span class="p">,</span>
	<span class="n">xfs_inode_log_item_t</span>	<span class="o">*</span><span class="n">iip</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">whichfork</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="n">xfs_ifork_t</span>		<span class="o">*</span><span class="n">ifp</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>
<span class="cp">#ifdef XFS_TRANS_DEBUG</span>
	<span class="kt">int</span>			<span class="n">first</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">short</span>	<span class="n">brootflag</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
		<span class="p">{</span> <span class="n">XFS_ILOG_DBROOT</span><span class="p">,</span> <span class="n">XFS_ILOG_ABROOT</span> <span class="p">};</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">short</span>	<span class="n">dataflag</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
		<span class="p">{</span> <span class="n">XFS_ILOG_DDATA</span><span class="p">,</span> <span class="n">XFS_ILOG_ADATA</span> <span class="p">};</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">short</span>	<span class="n">extflag</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
		<span class="p">{</span> <span class="n">XFS_ILOG_DEXT</span><span class="p">,</span> <span class="n">XFS_ILOG_AEXT</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iip</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ifp</span> <span class="o">=</span> <span class="n">XFS_IFORK_PTR</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This can happen if we gave up in iformat in an error path,</span>
<span class="cm">	 * for the attribute fork.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ifp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">whichfork</span> <span class="o">==</span> <span class="n">XFS_ATTR_FORK</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">XFS_DFORK_PTR</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">);</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">XFS_IFORK_FORMAT</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XFS_DINODE_FMT_LOCAL</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_fields</span> <span class="o">&amp;</span> <span class="n">dataflag</span><span class="p">[</span><span class="n">whichfork</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">&lt;=</span> <span class="n">XFS_IFORK_SIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">));</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_data</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span>:
		<span class="n">ASSERT</span><span class="p">((</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTENTS</span><span class="p">)</span> <span class="o">||</span>
		       <span class="o">!</span><span class="p">(</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_fields</span> <span class="o">&amp;</span> <span class="n">extflag</span><span class="p">[</span><span class="n">whichfork</span><span class="p">]));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_fields</span> <span class="o">&amp;</span> <span class="n">extflag</span><span class="p">[</span><span class="n">whichfork</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_iext_get_ext</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">XFS_IFORK_NEXTENTS</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">xfs_iextents_copy</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_bmbt_rec_t</span> <span class="o">*</span><span class="p">)</span><span class="n">cp</span><span class="p">,</span>
				<span class="n">whichfork</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">XFS_DINODE_FMT_BTREE</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_fields</span> <span class="o">&amp;</span> <span class="n">brootflag</span><span class="p">[</span><span class="n">whichfork</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span> <span class="o">&lt;=</span>
			       <span class="p">(</span><span class="n">XFS_IFORK_SIZE</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">XFS_BROOT_SIZE_ADJ</span><span class="p">));</span>
			<span class="n">xfs_bmbt_to_bmdr</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_broot_bytes</span><span class="p">,</span>
				<span class="p">(</span><span class="n">xfs_bmdr_block_t</span> <span class="o">*</span><span class="p">)</span><span class="n">cp</span><span class="p">,</span>
				<span class="n">XFS_DFORK_SIZE</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">whichfork</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">XFS_DINODE_FMT_DEV</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_fields</span> <span class="o">&amp;</span> <span class="n">XFS_ILOG_DEV</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">whichfork</span> <span class="o">==</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
			<span class="n">xfs_dinode_put_rdev</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_rdev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">XFS_DINODE_FMT_UUID</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_fields</span> <span class="o">&amp;</span> <span class="n">XFS_ILOG_UUID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">whichfork</span> <span class="o">==</span> <span class="n">XFS_DATA_FORK</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">XFS_DFORK_DPTR</span><span class="p">(</span><span class="n">dip</span><span class="p">),</span>
			       <span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_uuid</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="n">uuid_t</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_iflush_cluster</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_perag</span>	<span class="o">*</span><span class="n">pag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">first_index</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">inodes_per_cluster</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ilist_size</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span>		<span class="o">**</span><span class="n">ilist</span><span class="p">;</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">iq</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nr_found</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">clcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">bufwasdelwri</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="n">pag</span> <span class="o">=</span> <span class="n">xfs_perag_get</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_INO_TO_AGNO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">));</span>

	<span class="n">inodes_per_cluster</span> <span class="o">=</span> <span class="n">XFS_INODE_CLUSTER_SIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodelog</span><span class="p">;</span>
	<span class="n">ilist_size</span> <span class="o">=</span> <span class="n">inodes_per_cluster</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_inode_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">ilist</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">ilist_size</span><span class="p">,</span> <span class="n">KM_MAYFAIL</span><span class="o">|</span><span class="n">KM_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ilist</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(((</span><span class="n">XFS_INODE_CLUSTER_SIZE</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodelog</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">first_index</span> <span class="o">=</span> <span class="n">XFS_INO_TO_AGINO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="cm">/* really need a gang lookup range call here */</span>
	<span class="n">nr_found</span> <span class="o">=</span> <span class="n">radix_tree_gang_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pag</span><span class="o">-&gt;</span><span class="n">pag_ici_root</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="n">ilist</span><span class="p">,</span>
					<span class="n">first_index</span><span class="p">,</span> <span class="n">inodes_per_cluster</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_found</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_found</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iq</span> <span class="o">=</span> <span class="n">ilist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iq</span> <span class="o">==</span> <span class="n">ip</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * because this is an RCU protected lookup, we could find a</span>
<span class="cm">		 * recently freed or even reallocated inode during the lookup.</span>
<span class="cm">		 * We need to check under the i_flags_lock for a valid inode</span>
<span class="cm">		 * here. Skip it if it is not valid or the wrong inode.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_flags_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">XFS_INO_TO_AGINO</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">iq</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">first_index</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_flags_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_flags_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do an un-protected check to see if the inode is dirty and</span>
<span class="cm">		 * is a candidate for flushing.  These checks will be repeated</span>
<span class="cm">		 * later after the appropriate locks are acquired.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfs_inode_clean</span><span class="p">(</span><span class="n">iq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">xfs_ipincount</span><span class="p">(</span><span class="n">iq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Try to get locks.  If any are unavailable or it is pinned,</span>
<span class="cm">		 * then this inode cannot be flushed and is skipped.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_ilock_nowait</span><span class="p">(</span><span class="n">iq</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_iflock_nowait</span><span class="p">(</span><span class="n">iq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">iq</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfs_ipincount</span><span class="p">(</span><span class="n">iq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_ifunlock</span><span class="p">(</span><span class="n">iq</span><span class="p">);</span>
			<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">iq</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * arriving here means that this inode can be flushed.  First</span>
<span class="cm">		 * re-check that it&#39;s dirty before flushing.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_inode_clean</span><span class="p">(</span><span class="n">iq</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span>	<span class="n">error</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iflush_int</span><span class="p">(</span><span class="n">iq</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">iq</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">cluster_corrupt_out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">clcount</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xfs_ifunlock</span><span class="p">(</span><span class="n">iq</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">iq</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clcount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_icluster_flushcnt</span><span class="p">);</span>
		<span class="n">XFS_STATS_ADD</span><span class="p">(</span><span class="n">xs_icluster_flushinode</span><span class="p">,</span> <span class="n">clcount</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out_free:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">ilist</span><span class="p">);</span>
<span class="nl">out_put:</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>


<span class="nl">cluster_corrupt_out:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Corruption detected in the clustering loop.  Invalidate the</span>
<span class="cm">	 * inode buffer and shut down the filesystem.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clean up the buffer.  If it was delwri, just release it --</span>
<span class="cm">	 * brelse can handle it with no problems.  If not, shut down the</span>
<span class="cm">	 * filesystem before releasing the buffer.</span>
<span class="cm">	 */</span>
	<span class="n">bufwasdelwri</span> <span class="o">=</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_flags</span> <span class="o">&amp;</span> <span class="n">_XBF_DELWRI_Q</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bufwasdelwri</span><span class="p">)</span>
		<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="n">xfs_force_shutdown</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">SHUTDOWN_CORRUPT_INCORE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bufwasdelwri</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Just like incore_relse: if we have b_iodone functions,</span>
<span class="cm">		 * mark the buffer as an error and call them.  Otherwise</span>
<span class="cm">		 * mark it as stale and brelse.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">XFS_BUF_UNDONE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">xfs_buf_stale</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">xfs_buf_ioerror</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">EIO</span><span class="p">);</span>
			<span class="n">xfs_buf_ioend</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xfs_buf_stale</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
			<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unlocks the flush lock</span>
<span class="cm">	 */</span>
	<span class="n">xfs_iflush_abort</span><span class="p">(</span><span class="n">iq</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">ilist</span><span class="p">);</span>
	<span class="n">xfs_perag_put</span><span class="p">(</span><span class="n">pag</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush dirty inode metadata into the backing buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have the inode lock and the inode flush lock held.  The</span>
<span class="cm"> * inode lock will still be held upon return to the caller, and the inode</span>
<span class="cm"> * flush lock will be released after the inode has reached the disk.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must write out the buffer returned in *bpp and release it.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xfs_iflush</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">**</span><span class="n">bpp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_buf</span>		<span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_dinode</span>	<span class="o">*</span><span class="n">dip</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">XFS_STATS_INC</span><span class="p">(</span><span class="n">xs_iflush_count</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_isilocked</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="o">|</span><span class="n">XFS_ILOCK_SHARED</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_isiflocked</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_BTREE</span> <span class="o">||</span>
	       <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nextents</span> <span class="o">&gt;</span> <span class="n">XFS_IFORK_MAXEXT</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">));</span>

	<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">xfs_iunpin_wait</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For stale inodes we cannot rely on the backing buffer remaining</span>
<span class="cm">	 * stale in cache for the remaining life of the stale inode and so</span>
<span class="cm">	 * xfs_itobp() below may give us a buffer that no longer contains</span>
<span class="cm">	 * inodes below. We have to check this after ensuring the inode is</span>
<span class="cm">	 * unpinned so that it is safe to reclaim the stale inode after the</span>
<span class="cm">	 * flush call.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_iflags_test</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ISTALE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_ifunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This may have been unpinned because the filesystem is shutting</span>
<span class="cm">	 * down forcibly. If that&#39;s the case we must not write this inode</span>
<span class="cm">	 * to disk, because the log record didn&#39;t make it to disk.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We also have to remove the log item from the AIL in this case,</span>
<span class="cm">	 * as we wait for an empty AIL as part of the unmount process.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">abort_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the buffer containing the on-disk inode.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_itobp</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="p">,</span> <span class="n">XBF_TRYLOCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">||</span> <span class="o">!</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_ifunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * First flush out the inode that xfs_iflush was called with.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iflush_int</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">corrupt_out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the buffer is pinned then push on the log now so we won&#39;t</span>
<span class="cm">	 * get stuck waiting in the write for too long.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfs_buf_ispinned</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
		<span class="n">xfs_log_force</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * inode clustering:</span>
<span class="cm">	 * see if other inodes can be gathered into this write</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iflush_cluster</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cluster_corrupt_out</span><span class="p">;</span>

	<span class="o">*</span><span class="n">bpp</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">corrupt_out:</span>
	<span class="n">xfs_buf_relse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_force_shutdown</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">SHUTDOWN_CORRUPT_INCORE</span><span class="p">);</span>
<span class="nl">cluster_corrupt_out:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
<span class="nl">abort_out:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Unlocks the flush lock</span>
<span class="cm">	 */</span>
	<span class="n">xfs_iflush_abort</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_iflush_int</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>		<span class="o">*</span><span class="n">ip</span><span class="p">,</span>
	<span class="n">xfs_buf_t</span>		<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_inode_log_item_t</span>	<span class="o">*</span><span class="n">iip</span><span class="p">;</span>
	<span class="n">xfs_dinode_t</span>		<span class="o">*</span><span class="n">dip</span><span class="p">;</span>
	<span class="n">xfs_mount_t</span>		<span class="o">*</span><span class="n">mp</span><span class="p">;</span>
<span class="cp">#ifdef XFS_TRANS_DEBUG</span>
	<span class="kt">int</span>			<span class="n">first</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_isilocked</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="o">|</span><span class="n">XFS_ILOCK_SHARED</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_isiflocked</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_BTREE</span> <span class="o">||</span>
	       <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nextents</span> <span class="o">&gt;</span> <span class="n">XFS_IFORK_MAXEXT</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">));</span>

	<span class="n">iip</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_itemp</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>

	<span class="cm">/* set *dip = inode&#39;s place in the buffer */</span>
	<span class="n">dip</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_dinode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">xfs_buf_offset</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_imap</span><span class="p">.</span><span class="n">im_boffset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_TEST_ERROR</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_magic</span> <span class="o">!=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">XFS_DINODE_MAGIC</span><span class="p">),</span>
			       <span class="n">mp</span><span class="p">,</span> <span class="n">XFS_ERRTAG_IFLUSH_1</span><span class="p">,</span> <span class="n">XFS_RANDOM_IFLUSH_1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_alert_tag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_PTAG_IFLUSH</span><span class="p">,</span>
			<span class="s">&quot;%s: Bad inode %Lu magic number 0x%x, ptr 0x%p&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_magic</span><span class="p">),</span> <span class="n">dip</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">corrupt_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_TEST_ERROR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_magic</span> <span class="o">!=</span> <span class="n">XFS_DINODE_MAGIC</span><span class="p">,</span>
				<span class="n">mp</span><span class="p">,</span> <span class="n">XFS_ERRTAG_IFLUSH_2</span><span class="p">,</span> <span class="n">XFS_RANDOM_IFLUSH_2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_alert_tag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_PTAG_IFLUSH</span><span class="p">,</span>
			<span class="s">&quot;%s: Bad inode %Lu, ptr 0x%p, magic number 0x%x&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_magic</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">corrupt_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">XFS_TEST_ERROR</span><span class="p">(</span>
		    <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_BTREE</span><span class="p">),</span>
		    <span class="n">mp</span><span class="p">,</span> <span class="n">XFS_ERRTAG_IFLUSH_3</span><span class="p">,</span> <span class="n">XFS_RANDOM_IFLUSH_3</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_alert_tag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_PTAG_IFLUSH</span><span class="p">,</span>
				<span class="s">&quot;%s: Bad regular inode %Lu, ptr 0x%p&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">corrupt_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">XFS_TEST_ERROR</span><span class="p">(</span>
		    <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_EXTENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_BTREE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_LOCAL</span><span class="p">),</span>
		    <span class="n">mp</span><span class="p">,</span> <span class="n">XFS_ERRTAG_IFLUSH_4</span><span class="p">,</span> <span class="n">XFS_RANDOM_IFLUSH_4</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_alert_tag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_PTAG_IFLUSH</span><span class="p">,</span>
				<span class="s">&quot;%s: Bad directory inode %Lu, ptr 0x%p&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">corrupt_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_TEST_ERROR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nextents</span> <span class="o">+</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_anextents</span> <span class="o">&gt;</span>
				<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nblocks</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">XFS_ERRTAG_IFLUSH_5</span><span class="p">,</span>
				<span class="n">XFS_RANDOM_IFLUSH_5</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_alert_tag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_PTAG_IFLUSH</span><span class="p">,</span>
			<span class="s">&quot;%s: detected corrupt incore inode %Lu, &quot;</span>
			<span class="s">&quot;total extents = %d, nblocks = %Ld, ptr 0x%p&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nextents</span> <span class="o">+</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_anextents</span><span class="p">,</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nblocks</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">corrupt_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_TEST_ERROR</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_forkoff</span> <span class="o">&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">.</span><span class="n">sb_inodesize</span><span class="p">,</span>
				<span class="n">mp</span><span class="p">,</span> <span class="n">XFS_ERRTAG_IFLUSH_6</span><span class="p">,</span> <span class="n">XFS_RANDOM_IFLUSH_6</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_alert_tag</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_PTAG_IFLUSH</span><span class="p">,</span>
			<span class="s">&quot;%s: bad inode %Lu, forkoff 0x%x, ptr 0x%p&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_forkoff</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">corrupt_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * bump the flush iteration count, used to detect flushes which</span>
<span class="cm">	 * postdate a log record during recovery.</span>
<span class="cm">	 */</span>

	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flushiter</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the dirty parts of the inode into the on-disk</span>
<span class="cm">	 * inode.  We always copy out the core of the inode,</span>
<span class="cm">	 * because if the inode is dirty at all the core must</span>
<span class="cm">	 * be.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_dinode_to_disk</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">);</span>

	<span class="cm">/* Wrap, we never let the log put out DI_MAX_FLUSH */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flushiter</span> <span class="o">==</span> <span class="n">DI_MAX_FLUSH</span><span class="p">)</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_flushiter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is really an old format inode and the superblock version</span>
<span class="cm">	 * has not been updated to support only new format inodes, then</span>
<span class="cm">	 * convert back to the old inode format.  If the superblock version</span>
<span class="cm">	 * has been updated, then make the conversion permanent.</span>
<span class="cm">	 */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_version</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">xfs_sb_version_hasnlink</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_sb_version_hasnlink</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Convert it back.</span>
<span class="cm">			 */</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span> <span class="o">&lt;=</span> <span class="n">XFS_MAXLINK_1</span><span class="p">);</span>
			<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_onlink</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_nlink</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The superblock version has already been bumped,</span>
<span class="cm">			 * so just make the conversion to the new inode</span>
<span class="cm">			 * format permanent.</span>
<span class="cm">			 */</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_onlink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_onlink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_pad</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_pad</span><span class="p">));</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_pad</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">di_pad</span><span class="p">));</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">xfs_get_projid</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">xfs_iflush_fork</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">iip</span><span class="p">,</span> <span class="n">XFS_DATA_FORK</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_IFORK_Q</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
		<span class="n">xfs_iflush_fork</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">iip</span><span class="p">,</span> <span class="n">XFS_ATTR_FORK</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
	<span class="n">xfs_inobp_check</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ve recorded everything logged in the inode, so we&#39;d like to clear</span>
<span class="cm">	 * the ili_fields bits so we don&#39;t log and flush things unnecessarily.</span>
<span class="cm">	 * However, we can&#39;t stop logging all this information until the data</span>
<span class="cm">	 * we&#39;ve copied into the disk buffer is written to disk.  If we did we</span>
<span class="cm">	 * might overwrite the copy of the inode in the log with all the data</span>
<span class="cm">	 * after re-logging only part of it, and in the face of a crash we</span>
<span class="cm">	 * wouldn&#39;t have all the data we need to recover.</span>
<span class="cm">	 *</span>
<span class="cm">	 * What we do is move the bits to the ili_last_fields field.  When</span>
<span class="cm">	 * logging the inode, these bits are moved back to the ili_fields field.</span>
<span class="cm">	 * In the xfs_iflush_done() routine we clear ili_last_fields, since we</span>
<span class="cm">	 * know that the information those bits represent is permanently on</span>
<span class="cm">	 * disk.  As long as the flush completes before the inode is logged</span>
<span class="cm">	 * again, then both ili_fields and ili_last_fields will be cleared.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We can play with the ili_fields bits here, because the inode lock</span>
<span class="cm">	 * must be held exclusively in order to set bits there and the flush</span>
<span class="cm">	 * lock protects the ili_last_fields bits.  Set ili_logged so the flush</span>
<span class="cm">	 * done routine can tell whether or not to look in the AIL.  Also, store</span>
<span class="cm">	 * the current LSN of the inode so that we can tell whether the item has</span>
<span class="cm">	 * moved in the AIL from xfs_iflush_done().  In order to read the lsn we</span>
<span class="cm">	 * need the AIL lock, because it is a 64 bit value that cannot be read</span>
<span class="cm">	 * atomically.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iip</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_fields</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_last_fields</span> <span class="o">=</span> <span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_fields</span><span class="p">;</span>
		<span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_fields</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_logged</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">xfs_trans_ail_copy_lsn</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ail</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_flush_lsn</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_item</span><span class="p">.</span><span class="n">li_lsn</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Attach the function xfs_iflush_done to the inode&#39;s</span>
<span class="cm">		 * buffer.  This will remove the inode from the AIL</span>
<span class="cm">		 * and unlock the inode&#39;s flush lock when the inode is</span>
<span class="cm">		 * completely written to disk.</span>
<span class="cm">		 */</span>
		<span class="n">xfs_buf_attach_iodone</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">xfs_iflush_done</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_item</span><span class="p">);</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_fspriv</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">b_iodone</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re flushing an inode which is not in the AIL and has</span>
<span class="cm">		 * not been logged.  For this case we can immediately drop</span>
<span class="cm">		 * the inode flush lock because we can avoid the whole</span>
<span class="cm">		 * AIL state thing.  It&#39;s OK to drop the flush lock now,</span>
<span class="cm">		 * because we&#39;ve already locked the buffer and to do anything</span>
<span class="cm">		 * you really need both.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iip</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_logged</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_last_fields</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">((</span><span class="n">iip</span><span class="o">-&gt;</span><span class="n">ili_item</span><span class="p">.</span><span class="n">li_flags</span> <span class="o">&amp;</span> <span class="n">XFS_LI_IN_AIL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">xfs_ifunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">corrupt_out:</span>
	<span class="k">return</span> <span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EFSCORRUPTED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a pointer to the extent record at file index idx.</span>
<span class="cm"> */</span>
<span class="n">xfs_bmbt_rec_host_t</span> <span class="o">*</span>
<span class="nf">xfs_iext_get_ext</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">idx</span><span class="p">)</span>		<span class="cm">/* index of target extent */</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_ext_irec_t</span>	<span class="o">*</span><span class="n">erp</span><span class="p">;</span>		<span class="cm">/* irec pointer */</span>
		<span class="kt">int</span>		<span class="n">erp_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* irec index */</span>
		<span class="n">xfs_extnum_t</span>	<span class="n">page_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>	<span class="cm">/* ext index in target list */</span>

		<span class="n">erp</span> <span class="o">=</span> <span class="n">xfs_iext_idx_to_irec</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">erp_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">[</span><span class="n">page_idx</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Insert new item(s) into the extent records for incore inode</span>
<span class="cm"> * fork &#39;ifp&#39;.  &#39;count&#39; new items are inserted at index &#39;idx&#39;.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_iext_insert</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>		<span class="cm">/* incore inode pointer */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">idx</span><span class="p">,</span>		<span class="cm">/* starting index of new items */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">count</span><span class="p">,</span>		<span class="cm">/* number of inserted items */</span>
	<span class="n">xfs_bmbt_irec_t</span>	<span class="o">*</span><span class="n">new</span><span class="p">,</span>		<span class="cm">/* items to insert */</span>
	<span class="kt">int</span>		<span class="n">state</span><span class="p">)</span>		<span class="cm">/* type of extent conversion */</span>
<span class="p">{</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">BMAP_ATTRFORK</span><span class="p">)</span> <span class="o">?</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_afp</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">;</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">i</span><span class="p">;</span>		<span class="cm">/* extent record index */</span>

	<span class="n">trace_xfs_iext_insert</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTENTS</span><span class="p">);</span>
	<span class="n">xfs_iext_add</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">new</span><span class="o">++</span><span class="p">)</span>
		<span class="n">xfs_bmbt_set_all</span><span class="p">(</span><span class="n">xfs_iext_get_ext</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">new</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called when the amount of space required for incore file</span>
<span class="cm"> * extents needs to be increased. The ext_diff parameter stores the</span>
<span class="cm"> * number of new extents being added and the idx parameter contains</span>
<span class="cm"> * the extent index where the new extents will be added. If the new</span>
<span class="cm"> * extents are being appended, then we just need to (re)allocate and</span>
<span class="cm"> * initialize the space. Otherwise, if the new extents are being</span>
<span class="cm"> * inserted into the middle of the existing entries, a bit more work</span>
<span class="cm"> * is required to make room for the new extents to be inserted. The</span>
<span class="cm"> * caller is responsible for filling in the new extent entries upon</span>
<span class="cm"> * return.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_iext_add</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">idx</span><span class="p">,</span>		<span class="cm">/* index to begin adding exts */</span>
	<span class="kt">int</span>		<span class="n">ext_diff</span><span class="p">)</span>	<span class="cm">/* number of extents to add */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">byte_diff</span><span class="p">;</span>	<span class="cm">/* new bytes being added */</span>
	<span class="kt">int</span>		<span class="n">new_size</span><span class="p">;</span>	<span class="cm">/* size of extents after adding */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">nextents</span><span class="p">;</span>	<span class="cm">/* number of extents in file */</span>

	<span class="n">nextents</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">/</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">nextents</span><span class="p">));</span>
	<span class="n">byte_diff</span> <span class="o">=</span> <span class="n">ext_diff</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>
	<span class="n">new_size</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">+</span> <span class="n">byte_diff</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the new number of extents (nextents + ext_diff)</span>
<span class="cm">	 * fits inside the inode, then continue to use the inline</span>
<span class="cm">	 * extent buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nextents</span> <span class="o">+</span> <span class="n">ext_diff</span> <span class="o">&lt;=</span> <span class="n">XFS_INLINE_EXTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">nextents</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="n">ext_diff</span><span class="p">],</span>
				<span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
				<span class="p">(</span><span class="n">nextents</span> <span class="o">-</span> <span class="n">idx</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">byte_diff</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">;</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Otherwise use a linear (direct) extent list.</span>
<span class="cm">	 * If the extents are currently inside the inode,</span>
<span class="cm">	 * xfs_iext_realloc_direct will switch us from</span>
<span class="cm">	 * inline to direct extent allocation mode.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nextents</span> <span class="o">+</span> <span class="n">ext_diff</span> <span class="o">&lt;=</span> <span class="n">XFS_LINEAR_EXTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_realloc_direct</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">nextents</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="n">ext_diff</span><span class="p">],</span>
				<span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
				<span class="p">(</span><span class="n">nextents</span> <span class="o">-</span> <span class="n">idx</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">byte_diff</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Indirection array */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">xfs_ext_irec_t</span>	<span class="o">*</span><span class="n">erp</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">erp_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">page_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nextents</span> <span class="o">+</span> <span class="n">ext_diff</span> <span class="o">&gt;</span> <span class="n">XFS_LINEAR_EXTS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">erp</span> <span class="o">=</span> <span class="n">xfs_iext_idx_to_irec</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">erp_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xfs_iext_irec_init</span><span class="p">(</span><span class="n">ifp</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">);</span>
			<span class="n">erp</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Extents fit in target extent page */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">erp</span> <span class="o">&amp;&amp;</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">+</span> <span class="n">ext_diff</span> <span class="o">&lt;=</span> <span class="n">XFS_LINEAR_EXTS</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_idx</span> <span class="o">&lt;</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">[</span><span class="n">page_idx</span> <span class="o">+</span> <span class="n">ext_diff</span><span class="p">],</span>
					<span class="o">&amp;</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">[</span><span class="n">page_idx</span><span class="p">],</span>
					<span class="p">(</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">-</span> <span class="n">page_idx</span><span class="p">)</span> <span class="o">*</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
				<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">[</span><span class="n">page_idx</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">byte_diff</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">+=</span> <span class="n">ext_diff</span><span class="p">;</span>
			<span class="n">xfs_iext_irec_update_extoffs</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">erp_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ext_diff</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Insert a new extent page */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">erp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_iext_add_indirect_multi</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span>
				<span class="n">erp_idx</span><span class="p">,</span> <span class="n">page_idx</span><span class="p">,</span> <span class="n">ext_diff</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If extent(s) are being appended to the last page in</span>
<span class="cm">		 * the indirection array and the new extent(s) don&#39;t fit</span>
<span class="cm">		 * in the page, then erp is NULL and erp_idx is set to</span>
<span class="cm">		 * the next index needed in the indirection array.</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span>	<span class="n">count</span> <span class="o">=</span> <span class="n">ext_diff</span><span class="p">;</span>

			<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">erp</span> <span class="o">=</span> <span class="n">xfs_iext_irec_new</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">erp_idx</span><span class="p">);</span>
				<span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
				<span class="n">count</span> <span class="o">-=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">XFS_LINEAR_EXTS</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">erp_idx</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called when incore extents are being added to the indirection</span>
<span class="cm"> * array and the new extents do not fit in the target extent list. The</span>
<span class="cm"> * erp_idx parameter contains the irec index for the target extent list</span>
<span class="cm"> * in the indirection array, and the idx parameter contains the extent</span>
<span class="cm"> * index within the list. The number of extents being added is stored</span>
<span class="cm"> * in the count parameter.</span>
<span class="cm"> *</span>
<span class="cm"> *    |-------|   |-------|</span>
<span class="cm"> *    |       |   |       |    idx - number of extents before idx</span>
<span class="cm"> *    |  idx  |   | count |</span>
<span class="cm"> *    |       |   |       |    count - number of extents being inserted at idx</span>
<span class="cm"> *    |-------|   |-------|</span>
<span class="cm"> *    | count |   | nex2  |    nex2 - number of extents after idx + count</span>
<span class="cm"> *    |-------|   |-------|</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_iext_add_indirect_multi</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>			<span class="cm">/* inode fork pointer */</span>
	<span class="kt">int</span>		<span class="n">erp_idx</span><span class="p">,</span>		<span class="cm">/* target extent irec index */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">idx</span><span class="p">,</span>			<span class="cm">/* index within target list */</span>
	<span class="kt">int</span>		<span class="n">count</span><span class="p">)</span>			<span class="cm">/* new extents being added */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">byte_diff</span><span class="p">;</span>		<span class="cm">/* new bytes being added */</span>
	<span class="n">xfs_ext_irec_t</span>	<span class="o">*</span><span class="n">erp</span><span class="p">;</span>			<span class="cm">/* pointer to irec entry */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">ext_diff</span><span class="p">;</span>		<span class="cm">/* number of extents to add */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">ext_cnt</span><span class="p">;</span>		<span class="cm">/* new extents still needed */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">nex2</span><span class="p">;</span>			<span class="cm">/* extents after idx + count */</span>
	<span class="n">xfs_bmbt_rec_t</span>	<span class="o">*</span><span class="n">nex2_ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* temp list for nex2 extents */</span>
	<span class="kt">int</span>		<span class="n">nlists</span><span class="p">;</span>			<span class="cm">/* number of irec&#39;s (lists) */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">);</span>
	<span class="n">erp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">[</span><span class="n">erp_idx</span><span class="p">];</span>
	<span class="n">nex2</span> <span class="o">=</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">-</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">nlists</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">/</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save second part of target extent list</span>
<span class="cm">	 * (all extents past */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nex2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">byte_diff</span> <span class="o">=</span> <span class="n">nex2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>
		<span class="n">nex2_ep</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_bmbt_rec_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">byte_diff</span><span class="p">,</span> <span class="n">KM_NOFS</span><span class="p">);</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">nex2_ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">byte_diff</span><span class="p">);</span>
		<span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">-=</span> <span class="n">nex2</span><span class="p">;</span>
		<span class="n">xfs_iext_irec_update_extoffs</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">erp_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">nex2</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">byte_diff</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add the new extents to the end of the target</span>
<span class="cm">	 * list, then allocate new irec record(s) and</span>
<span class="cm">	 * extent buffer(s) as needed to store the rest</span>
<span class="cm">	 * of the new extents.</span>
<span class="cm">	 */</span>
	<span class="n">ext_cnt</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">ext_diff</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">ext_cnt</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">XFS_LINEAR_EXTS</span> <span class="o">-</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext_diff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">+=</span> <span class="n">ext_diff</span><span class="p">;</span>
		<span class="n">xfs_iext_irec_update_extoffs</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">erp_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ext_diff</span><span class="p">);</span>
		<span class="n">ext_cnt</span> <span class="o">-=</span> <span class="n">ext_diff</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ext_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">erp_idx</span><span class="o">++</span><span class="p">;</span>
		<span class="n">erp</span> <span class="o">=</span> <span class="n">xfs_iext_irec_new</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">erp_idx</span><span class="p">);</span>
		<span class="n">ext_diff</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">ext_cnt</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">XFS_LINEAR_EXTS</span><span class="p">);</span>
		<span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">=</span> <span class="n">ext_diff</span><span class="p">;</span>
		<span class="n">xfs_iext_irec_update_extoffs</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">erp_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ext_diff</span><span class="p">);</span>
		<span class="n">ext_cnt</span> <span class="o">-=</span> <span class="n">ext_diff</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Add nex2 extents back to indirection array */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nex2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_extnum_t</span>	<span class="n">ext_avail</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

		<span class="n">byte_diff</span> <span class="o">=</span> <span class="n">nex2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>
		<span class="n">ext_avail</span> <span class="o">=</span> <span class="n">XFS_LINEAR_EXTS</span> <span class="o">-</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If nex2 extents fit in the current page, append</span>
<span class="cm">		 * nex2_ep after the new extents.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nex2</span> <span class="o">&lt;=</span> <span class="n">ext_avail</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Otherwise, check if space is available in the</span>
<span class="cm">		 * next page.</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">erp_idx</span> <span class="o">&lt;</span> <span class="n">nlists</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			 <span class="p">(</span><span class="n">nex2</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">ext_avail</span> <span class="o">=</span> <span class="n">XFS_LINEAR_EXTS</span> <span class="o">-</span>
			  <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">[</span><span class="n">erp_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">er_extcount</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">erp_idx</span><span class="o">++</span><span class="p">;</span>
			<span class="n">erp</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* Create a hole for nex2 extents */</span>
			<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">[</span><span class="n">nex2</span><span class="p">],</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">,</span>
				<span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Final choice, create a new extent page for</span>
<span class="cm">		 * nex2 extents.</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">erp_idx</span><span class="o">++</span><span class="p">;</span>
			<span class="n">erp</span> <span class="o">=</span> <span class="n">xfs_iext_irec_new</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">erp_idx</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nex2_ep</span><span class="p">,</span> <span class="n">byte_diff</span><span class="p">);</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">nex2_ep</span><span class="p">);</span>
		<span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">+=</span> <span class="n">nex2</span><span class="p">;</span>
		<span class="n">xfs_iext_irec_update_extoffs</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">erp_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nex2</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called when the amount of space required for incore file</span>
<span class="cm"> * extents needs to be decreased. The ext_diff parameter stores the</span>
<span class="cm"> * number of extents to be removed and the idx parameter contains</span>
<span class="cm"> * the extent index where the extents will be removed from.</span>
<span class="cm"> *</span>
<span class="cm"> * If the amount of space needed has decreased below the linear</span>
<span class="cm"> * limit, XFS_IEXT_BUFSZ, then switch to using the contiguous</span>
<span class="cm"> * extent array.  Otherwise, use kmem_realloc() to adjust the</span>
<span class="cm"> * size to what is needed.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_iext_remove</span><span class="p">(</span>
	<span class="n">xfs_inode_t</span>	<span class="o">*</span><span class="n">ip</span><span class="p">,</span>		<span class="cm">/* incore inode pointer */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">idx</span><span class="p">,</span>		<span class="cm">/* index to begin removing exts */</span>
	<span class="kt">int</span>		<span class="n">ext_diff</span><span class="p">,</span>	<span class="cm">/* number of extents to remove */</span>
	<span class="kt">int</span>		<span class="n">state</span><span class="p">)</span>		<span class="cm">/* type of extent conversion */</span>
<span class="p">{</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">BMAP_ATTRFORK</span><span class="p">)</span> <span class="o">?</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_afp</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">;</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">nextents</span><span class="p">;</span>	<span class="cm">/* number of extents in file */</span>
	<span class="kt">int</span>		<span class="n">new_size</span><span class="p">;</span>	<span class="cm">/* size of extents after removal */</span>

	<span class="n">trace_xfs_iext_remove</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ext_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">nextents</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">/</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>
	<span class="n">new_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextents</span> <span class="o">-</span> <span class="n">ext_diff</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_destroy</span><span class="p">(</span><span class="n">ifp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_remove_indirect</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ext_diff</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_remove_direct</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ext_diff</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xfs_iext_remove_inline</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ext_diff</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This removes ext_diff extents from the inline buffer, beginning</span>
<span class="cm"> * at extent index idx.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_iext_remove_inline</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">idx</span><span class="p">,</span>		<span class="cm">/* index to begin removing exts */</span>
	<span class="kt">int</span>		<span class="n">ext_diff</span><span class="p">)</span>	<span class="cm">/* number of extents to remove */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">nextents</span><span class="p">;</span>	<span class="cm">/* number of extents in file */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">XFS_INLINE_EXTS</span><span class="p">);</span>
	<span class="n">nextents</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">/</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(((</span><span class="n">nextents</span> <span class="o">-</span> <span class="n">ext_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">nextents</span> <span class="o">-</span> <span class="n">ext_diff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">XFS_INLINE_EXTS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">ext_diff</span> <span class="o">&lt;</span> <span class="n">nextents</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
			<span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="n">ext_diff</span><span class="p">],</span>
			<span class="p">(</span><span class="n">nextents</span> <span class="o">-</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">ext_diff</span><span class="p">))</span> <span class="o">*</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">[</span><span class="n">nextents</span> <span class="o">-</span> <span class="n">ext_diff</span><span class="p">],</span>
			<span class="mi">0</span><span class="p">,</span> <span class="n">ext_diff</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">ext_diff</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This removes ext_diff extents from a linear (direct) extent list,</span>
<span class="cm"> * beginning at extent index idx. If the extents are being removed</span>
<span class="cm"> * from the end of the list (ie. truncate) then we just need to re-</span>
<span class="cm"> * allocate the list to remove the extra space. Otherwise, if the</span>
<span class="cm"> * extents are being removed from the middle of the existing extent</span>
<span class="cm"> * entries, then we first need to move the extent records beginning</span>
<span class="cm"> * at idx + ext_diff up in the list to overwrite the records being</span>
<span class="cm"> * removed, then remove the extra space via kmem_realloc.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_iext_remove_direct</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">idx</span><span class="p">,</span>		<span class="cm">/* index to begin removing exts */</span>
	<span class="kt">int</span>		<span class="n">ext_diff</span><span class="p">)</span>	<span class="cm">/* number of extents to remove */</span>
<span class="p">{</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">nextents</span><span class="p">;</span>	<span class="cm">/* number of extents in file */</span>
	<span class="kt">int</span>		<span class="n">new_size</span><span class="p">;</span>	<span class="cm">/* size of extents after removal */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">));</span>
	<span class="n">new_size</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">-</span>
		<span class="p">(</span><span class="n">ext_diff</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
	<span class="n">nextents</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">/</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_destroy</span><span class="p">(</span><span class="n">ifp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Move extents up in the list (if needed) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">ext_diff</span> <span class="o">&lt;</span> <span class="n">nextents</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
			<span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="n">ext_diff</span><span class="p">],</span>
			<span class="p">(</span><span class="n">nextents</span> <span class="o">-</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">ext_diff</span><span class="p">))</span> <span class="o">*</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">[</span><span class="n">nextents</span> <span class="o">-</span> <span class="n">ext_diff</span><span class="p">],</span>
		<span class="mi">0</span><span class="p">,</span> <span class="n">ext_diff</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Reallocate the direct extent list. If the extents</span>
<span class="cm">	 * will fit inside the inode then xfs_iext_realloc_direct</span>
<span class="cm">	 * will switch from direct to inline extent allocation</span>
<span class="cm">	 * mode for us.</span>
<span class="cm">	 */</span>
	<span class="n">xfs_iext_realloc_direct</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called when incore extents are being removed from the</span>
<span class="cm"> * indirection array and the extents being removed span multiple extent</span>
<span class="cm"> * buffers. The idx parameter contains the file extent index where we</span>
<span class="cm"> * want to begin removing extents, and the count parameter contains</span>
<span class="cm"> * how many extents need to be removed.</span>
<span class="cm"> *</span>
<span class="cm"> *    |-------|   |-------|</span>
<span class="cm"> *    | nex1  |   |       |    nex1 - number of extents before idx</span>
<span class="cm"> *    |-------|   | count |</span>
<span class="cm"> *    |       |   |       |    count - number of extents being removed at idx</span>
<span class="cm"> *    | count |   |-------|</span>
<span class="cm"> *    |       |   | nex2  |    nex2 - number of extents after idx + count</span>
<span class="cm"> *    |-------|   |-------|</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_iext_remove_indirect</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">idx</span><span class="p">,</span>		<span class="cm">/* index to begin removing extents */</span>
	<span class="kt">int</span>		<span class="n">count</span><span class="p">)</span>		<span class="cm">/* number of extents to remove */</span>
<span class="p">{</span>
	<span class="n">xfs_ext_irec_t</span>	<span class="o">*</span><span class="n">erp</span><span class="p">;</span>		<span class="cm">/* indirection array pointer */</span>
	<span class="kt">int</span>		<span class="n">erp_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* indirection array index */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">ext_cnt</span><span class="p">;</span>	<span class="cm">/* extents left to remove */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">ext_diff</span><span class="p">;</span>	<span class="cm">/* extents to remove in current list */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">nex1</span><span class="p">;</span>		<span class="cm">/* number of extents before idx */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">nex2</span><span class="p">;</span>		<span class="cm">/* extents after idx + count */</span>
	<span class="kt">int</span>		<span class="n">page_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>	<span class="cm">/* index in target extent list */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">);</span>
	<span class="n">erp</span> <span class="o">=</span> <span class="n">xfs_iext_idx_to_irec</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">page_idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">erp_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">erp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">nex1</span> <span class="o">=</span> <span class="n">page_idx</span><span class="p">;</span>
	<span class="n">ext_cnt</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ext_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nex2</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">((</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">-</span> <span class="p">(</span><span class="n">nex1</span> <span class="o">+</span> <span class="n">ext_cnt</span><span class="p">)),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ext_diff</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">ext_cnt</span><span class="p">,</span> <span class="p">(</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">-</span> <span class="n">nex1</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check for deletion of entire list;</span>
<span class="cm">		 * xfs_iext_irec_remove() updates extent offsets.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext_diff</span> <span class="o">==</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_iext_irec_remove</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">erp_idx</span><span class="p">);</span>
			<span class="n">ext_cnt</span> <span class="o">-=</span> <span class="n">ext_diff</span><span class="p">;</span>
			<span class="n">nex1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ext_cnt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">erp_idx</span> <span class="o">&lt;</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">/</span>
					<span class="n">XFS_IEXT_BUFSZ</span><span class="p">);</span>
				<span class="n">erp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">[</span><span class="n">erp_idx</span><span class="p">];</span>
				<span class="n">nex1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Move extents up (if needed) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nex2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">[</span><span class="n">nex1</span><span class="p">],</span>
				<span class="o">&amp;</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">[</span><span class="n">nex1</span> <span class="o">+</span> <span class="n">ext_diff</span><span class="p">],</span>
				<span class="n">nex2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="cm">/* Zero out rest of page */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">[</span><span class="n">nex1</span> <span class="o">+</span> <span class="n">nex2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">XFS_IEXT_BUFSZ</span> <span class="o">-</span>
			<span class="p">((</span><span class="n">nex1</span> <span class="o">+</span> <span class="n">nex2</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">))));</span>
		<span class="cm">/* Update remaining counters */</span>
		<span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">-=</span> <span class="n">ext_diff</span><span class="p">;</span>
		<span class="n">xfs_iext_irec_update_extoffs</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">erp_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">ext_diff</span><span class="p">);</span>
		<span class="n">ext_cnt</span> <span class="o">-=</span> <span class="n">ext_diff</span><span class="p">;</span>
		<span class="n">nex1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">erp_idx</span><span class="o">++</span><span class="p">;</span>
		<span class="n">erp</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">-=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>
	<span class="n">xfs_iext_irec_compact</span><span class="p">(</span><span class="n">ifp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create, destroy, or resize a linear (direct) block of extents.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_iext_realloc_direct</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="kt">int</span>		<span class="n">new_size</span><span class="p">)</span>	<span class="cm">/* new size of extents */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">rnew_size</span><span class="p">;</span>	<span class="cm">/* real new size of extents */</span>

	<span class="n">rnew_size</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">((</span><span class="n">new_size</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&lt;=</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="p">(</span><span class="n">new_size</span> <span class="o">!=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span><span class="p">)));</span>

	<span class="cm">/* Free extent records */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_destroy</span><span class="p">(</span><span class="n">ifp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Resize direct extent list and zero any new bytes */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check if extents will fit inside the inode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&lt;=</span> <span class="n">XFS_INLINE_EXTS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_iext_direct_to_inline</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">new_size</span> <span class="o">/</span>
				<span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
			<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">new_size</span><span class="p">)){</span>
			<span class="n">rnew_size</span> <span class="o">=</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">new_size</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rnew_size</span> <span class="o">!=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span> <span class="o">=</span>
				<span class="n">kmem_realloc</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">,</span>
						<span class="n">rnew_size</span><span class="p">,</span>
						<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span><span class="p">,</span> <span class="n">KM_NOFS</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rnew_size</span> <span class="o">&gt;</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">[</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">/</span>
				<span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">)],</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">rnew_size</span> <span class="o">-</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Switch from the inline extent buffer to a direct</span>
<span class="cm">	 * extent list. Be sure to include the inline extent</span>
<span class="cm">	 * bytes in new_size.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">new_size</span> <span class="o">+=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">new_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rnew_size</span> <span class="o">=</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">new_size</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">xfs_iext_inline_to_direct</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">rnew_size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">=</span> <span class="n">rnew_size</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Switch from linear (direct) extent records to inline buffer.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_iext_direct_to_inline</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">nextents</span><span class="p">)</span>	<span class="cm">/* number of extents in file */</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTENTS</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">nextents</span> <span class="o">&lt;=</span> <span class="n">XFS_INLINE_EXTS</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The inline buffer was zeroed when we switched</span>
<span class="cm">	 * from inline to direct extent allocation mode,</span>
<span class="cm">	 * so we don&#39;t need to clear it here.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">,</span>
		<span class="n">nextents</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">);</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Switch from inline buffer to linear (direct) extent records.</span>
<span class="cm"> * new_size should already be rounded up to the next power of 2</span>
<span class="cm"> * by the caller (when appropriate), so use new_size as it is.</span>
<span class="cm"> * However, since new_size may be rounded up, we can&#39;t update</span>
<span class="cm"> * if_bytes here. It is the caller&#39;s responsibility to update</span>
<span class="cm"> * if_bytes upon return.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_iext_inline_to_direct</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="kt">int</span>		<span class="n">new_size</span><span class="p">)</span>	<span class="cm">/* number of extents in file */</span>
<span class="p">{</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="n">KM_NOFS</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">,</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">,</span>
			<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_INLINE_EXTS</span> <span class="o">*</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Resize an extent indirection array to new_size bytes.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_iext_realloc_indirect</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="kt">int</span>		<span class="n">new_size</span><span class="p">)</span>	<span class="cm">/* new indirection array size */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">nlists</span><span class="p">;</span>		<span class="cm">/* number of irec&#39;s (ex lists) */</span>
	<span class="kt">int</span>		<span class="n">size</span><span class="p">;</span>		<span class="cm">/* current indirection array size */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">);</span>
	<span class="n">nlists</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">/</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">nlists</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_ext_irec_t</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">((</span><span class="n">new_size</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">!=</span> <span class="n">size</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_destroy</span><span class="p">(</span><span class="n">ifp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_ext_irec_t</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">kmem_realloc</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">,</span>
				<span class="n">new_size</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">KM_NOFS</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Switch from indirection array to linear (direct) extent allocations.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_iext_indirect_to_direct</span><span class="p">(</span>
	 <span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">)</span>		<span class="cm">/* inode fork pointer */</span>
<span class="p">{</span>
	<span class="n">xfs_bmbt_rec_host_t</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>	<span class="cm">/* extent record pointer */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">nextents</span><span class="p">;</span>	<span class="cm">/* number of extents in file */</span>
	<span class="kt">int</span>		<span class="n">size</span><span class="p">;</span>		<span class="cm">/* size of file extents */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">);</span>
	<span class="n">nextents</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">/</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">nextents</span> <span class="o">&lt;=</span> <span class="n">XFS_LINEAR_EXTS</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">nextents</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>

	<span class="n">xfs_iext_irec_compact_pages</span><span class="p">(</span><span class="n">ifp</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">==</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">);</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">;</span>
	<span class="n">kmem_free</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">);</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XFS_IFEXTIREC</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nextents</span> <span class="o">&lt;</span> <span class="n">XFS_LINEAR_EXTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_realloc_direct</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free incore file extents.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xfs_iext_destroy</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">)</span>		<span class="cm">/* inode fork pointer */</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">erp_idx</span><span class="p">;</span>
		<span class="kt">int</span>	<span class="n">nlists</span><span class="p">;</span>

		<span class="n">nlists</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">/</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">erp_idx</span> <span class="o">=</span> <span class="n">nlists</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">erp_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">erp_idx</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xfs_iext_irec_remove</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">erp_idx</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XFS_IFEXTIREC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u2</span><span class="p">.</span><span class="n">if_inline_ext</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_INLINE_EXTS</span> <span class="o">*</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a pointer to the extent record for file system block bno.</span>
<span class="cm"> */</span>
<span class="n">xfs_bmbt_rec_host_t</span> <span class="o">*</span>			<span class="cm">/* pointer to found extent record */</span>
<span class="n">xfs_iext_bno_to_ext</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="n">xfs_fileoff_t</span>	<span class="n">bno</span><span class="p">,</span>		<span class="cm">/* block number to search for */</span>
	<span class="n">xfs_extnum_t</span>	<span class="o">*</span><span class="n">idxp</span><span class="p">)</span>		<span class="cm">/* index of target extent */</span>
<span class="p">{</span>
	<span class="n">xfs_bmbt_rec_host_t</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>	<span class="cm">/* pointer to first extent */</span>
	<span class="n">xfs_filblks_t</span>	<span class="n">blockcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* number of blocks in extent */</span>
	<span class="n">xfs_bmbt_rec_host_t</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* pointer to target extent */</span>
	<span class="n">xfs_ext_irec_t</span>	<span class="o">*</span><span class="n">erp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* indirection array pointer */</span>
	<span class="kt">int</span>		<span class="n">high</span><span class="p">;</span>		<span class="cm">/* upper boundary in search */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* index of target extent */</span>
	<span class="kt">int</span>		<span class="n">low</span><span class="p">;</span>		<span class="cm">/* lower boundary in search */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">nextents</span><span class="p">;</span>	<span class="cm">/* number of file extents */</span>
	<span class="n">xfs_fileoff_t</span>	<span class="n">startoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* start offset of extent */</span>

	<span class="n">nextents</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">/</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nextents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">idxp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Find target extent list */</span>
		<span class="kt">int</span>	<span class="n">erp_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">erp</span> <span class="o">=</span> <span class="n">xfs_iext_bno_to_irec</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">bno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">erp_idx</span><span class="p">);</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">;</span>
		<span class="n">high</span> <span class="o">=</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">;</span>
		<span class="n">high</span> <span class="o">=</span> <span class="n">nextents</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Binary search extent records */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">idx</span><span class="p">;</span>
		<span class="n">startoff</span> <span class="o">=</span> <span class="n">xfs_bmbt_get_startoff</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">blockcount</span> <span class="o">=</span> <span class="n">xfs_bmbt_get_blockcount</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bno</span> <span class="o">&lt;</span> <span class="n">startoff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">high</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bno</span> <span class="o">&gt;=</span> <span class="n">startoff</span> <span class="o">+</span> <span class="n">blockcount</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">low</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Convert back to file-based extent index */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">idx</span> <span class="o">+=</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extoff</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="o">*</span><span class="n">idxp</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ep</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Convert back to file-based extent index */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">+=</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extoff</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bno</span> <span class="o">&gt;=</span> <span class="n">startoff</span> <span class="o">+</span> <span class="n">blockcount</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">idx</span> <span class="o">==</span> <span class="n">nextents</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="n">xfs_iext_get_ext</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">idxp</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ep</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a pointer to the indirection array entry containing the</span>
<span class="cm"> * extent record for filesystem block bno. Store the index of the</span>
<span class="cm"> * target irec in *erp_idxp.</span>
<span class="cm"> */</span>
<span class="n">xfs_ext_irec_t</span> <span class="o">*</span>			<span class="cm">/* pointer to found extent record */</span>
<span class="n">xfs_iext_bno_to_irec</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="n">xfs_fileoff_t</span>	<span class="n">bno</span><span class="p">,</span>		<span class="cm">/* block number to search for */</span>
	<span class="kt">int</span>		<span class="o">*</span><span class="n">erp_idxp</span><span class="p">)</span>	<span class="cm">/* irec index of target ext list */</span>
<span class="p">{</span>
	<span class="n">xfs_ext_irec_t</span>	<span class="o">*</span><span class="n">erp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* indirection array pointer */</span>
	<span class="n">xfs_ext_irec_t</span>	<span class="o">*</span><span class="n">erp_next</span><span class="p">;</span>	<span class="cm">/* next indirection array entry */</span>
	<span class="kt">int</span>		<span class="n">erp_idx</span><span class="p">;</span>	<span class="cm">/* indirection array index */</span>
	<span class="kt">int</span>		<span class="n">nlists</span><span class="p">;</span>		<span class="cm">/* number of extent irec&#39;s (lists) */</span>
	<span class="kt">int</span>		<span class="n">high</span><span class="p">;</span>		<span class="cm">/* binary search upper limit */</span>
	<span class="kt">int</span>		<span class="n">low</span><span class="p">;</span>		<span class="cm">/* binary search lower limit */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">);</span>
	<span class="n">nlists</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">/</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">;</span>
	<span class="n">erp_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">high</span> <span class="o">=</span> <span class="n">nlists</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">erp_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">erp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">[</span><span class="n">erp_idx</span><span class="p">];</span>
		<span class="n">erp_next</span> <span class="o">=</span> <span class="n">erp_idx</span> <span class="o">&lt;</span> <span class="n">nlists</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">erp</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bno</span> <span class="o">&lt;</span> <span class="n">xfs_bmbt_get_startoff</span><span class="p">(</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">high</span> <span class="o">=</span> <span class="n">erp_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">erp_next</span> <span class="o">&amp;&amp;</span> <span class="n">bno</span> <span class="o">&gt;=</span>
			   <span class="n">xfs_bmbt_get_startoff</span><span class="p">(</span><span class="n">erp_next</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">low</span> <span class="o">=</span> <span class="n">erp_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">erp_idxp</span> <span class="o">=</span> <span class="n">erp_idx</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">erp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a pointer to the indirection array entry containing the</span>
<span class="cm"> * extent record at file extent index *idxp. Store the index of the</span>
<span class="cm"> * target irec in *erp_idxp and store the page index of the target</span>
<span class="cm"> * extent record in *idxp.</span>
<span class="cm"> */</span>
<span class="n">xfs_ext_irec_t</span> <span class="o">*</span>
<span class="n">xfs_iext_idx_to_irec</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="n">xfs_extnum_t</span>	<span class="o">*</span><span class="n">idxp</span><span class="p">,</span>		<span class="cm">/* extent index (file -&gt; page) */</span>
	<span class="kt">int</span>		<span class="o">*</span><span class="n">erp_idxp</span><span class="p">,</span>	<span class="cm">/* pointer to target irec */</span>
	<span class="kt">int</span>		<span class="n">realloc</span><span class="p">)</span>	<span class="cm">/* new bytes were just added */</span>
<span class="p">{</span>
	<span class="n">xfs_ext_irec_t</span>	<span class="o">*</span><span class="n">prev</span><span class="p">;</span>		<span class="cm">/* pointer to previous irec */</span>
	<span class="n">xfs_ext_irec_t</span>	<span class="o">*</span><span class="n">erp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* pointer to current irec */</span>
	<span class="kt">int</span>		<span class="n">erp_idx</span><span class="p">;</span>	<span class="cm">/* indirection array index */</span>
	<span class="kt">int</span>		<span class="n">nlists</span><span class="p">;</span>		<span class="cm">/* number of irec&#39;s (ex lists) */</span>
	<span class="kt">int</span>		<span class="n">high</span><span class="p">;</span>		<span class="cm">/* binary search upper limit */</span>
	<span class="kt">int</span>		<span class="n">low</span><span class="p">;</span>		<span class="cm">/* binary search lower limit */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">page_idx</span> <span class="o">=</span> <span class="o">*</span><span class="n">idxp</span><span class="p">;</span> <span class="cm">/* extent index in target list */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">page_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">page_idx</span> <span class="o">&lt;=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">page_idx</span> <span class="o">&lt;</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">)</span> <span class="o">||</span> <span class="n">realloc</span><span class="p">);</span>

	<span class="n">nlists</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">/</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">;</span>
	<span class="n">erp_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">high</span> <span class="o">=</span> <span class="n">nlists</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Binary search extent irec&#39;s */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">erp_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">erp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">[</span><span class="n">erp_idx</span><span class="p">];</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">erp_idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">erp</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_idx</span> <span class="o">&lt;</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extoff</span> <span class="o">||</span> <span class="p">(</span><span class="n">page_idx</span> <span class="o">==</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extoff</span> <span class="o">&amp;&amp;</span>
		     <span class="n">realloc</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">&lt;</span> <span class="n">XFS_LINEAR_EXTS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">high</span> <span class="o">=</span> <span class="n">erp_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page_idx</span> <span class="o">&gt;</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extoff</span> <span class="o">+</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">||</span>
			   <span class="p">(</span><span class="n">page_idx</span> <span class="o">==</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extoff</span> <span class="o">+</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">realloc</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">low</span> <span class="o">=</span> <span class="n">erp_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page_idx</span> <span class="o">==</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extoff</span> <span class="o">+</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">&amp;&amp;</span>
			   <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">==</span> <span class="n">XFS_LINEAR_EXTS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">realloc</span><span class="p">);</span>
			<span class="n">page_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">erp_idx</span><span class="o">++</span><span class="p">;</span>
			<span class="n">erp</span> <span class="o">=</span> <span class="n">erp_idx</span> <span class="o">&lt;</span> <span class="n">nlists</span> <span class="o">?</span> <span class="n">erp</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">page_idx</span> <span class="o">-=</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extoff</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">idxp</span> <span class="o">=</span> <span class="n">page_idx</span><span class="p">;</span>
	<span class="o">*</span><span class="n">erp_idxp</span> <span class="o">=</span> <span class="n">erp_idx</span><span class="p">;</span>
	<span class="k">return</span><span class="p">(</span><span class="n">erp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate and initialize an indirection array once the space needed</span>
<span class="cm"> * for incore extents increases above XFS_IEXT_BUFSZ.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="n">xfs_iext_irec_init</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">)</span>		<span class="cm">/* inode fork pointer */</span>
<span class="p">{</span>
	<span class="n">xfs_ext_irec_t</span>	<span class="o">*</span><span class="n">erp</span><span class="p">;</span>		<span class="cm">/* indirection array pointer */</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">nextents</span><span class="p">;</span>	<span class="cm">/* number of extents in file */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">));</span>
	<span class="n">nextents</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">/</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">nextents</span> <span class="o">&lt;=</span> <span class="n">XFS_LINEAR_EXTS</span><span class="p">);</span>

	<span class="n">erp</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_ext_irec_t</span><span class="p">),</span> <span class="n">KM_NOFS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nextents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">XFS_IEXT_BUFSZ</span><span class="p">,</span> <span class="n">KM_NOFS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_inline_to_direct</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">&lt;</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_realloc_direct</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_extents</span><span class="p">;</span>
	<span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">=</span> <span class="n">nextents</span><span class="p">;</span>
	<span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">|=</span> <span class="n">XFS_IFEXTIREC</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">=</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">=</span> <span class="n">nextents</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span> <span class="o">=</span> <span class="n">erp</span><span class="p">;</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate and initialize a new entry in the indirection array.</span>
<span class="cm"> */</span>
<span class="n">xfs_ext_irec_t</span> <span class="o">*</span>
<span class="n">xfs_iext_irec_new</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="kt">int</span>		<span class="n">erp_idx</span><span class="p">)</span>	<span class="cm">/* index for new irec */</span>
<span class="p">{</span>
	<span class="n">xfs_ext_irec_t</span>	<span class="o">*</span><span class="n">erp</span><span class="p">;</span>		<span class="cm">/* indirection array pointer */</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>		<span class="cm">/* loop counter */</span>
	<span class="kt">int</span>		<span class="n">nlists</span><span class="p">;</span>		<span class="cm">/* number of irec&#39;s (ex lists) */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">);</span>
	<span class="n">nlists</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">/</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">;</span>

	<span class="cm">/* Resize indirection array */</span>
	<span class="n">xfs_iext_realloc_indirect</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="o">++</span><span class="n">nlists</span> <span class="o">*</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_ext_irec_t</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Move records down in the array so the</span>
<span class="cm">	 * new page can use erp_idx.</span>
<span class="cm">	 */</span>
	<span class="n">erp</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">nlists</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">erp_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">erp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">erp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_ext_irec_t</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">erp_idx</span><span class="p">);</span>

	<span class="cm">/* Initialize new extent record */</span>
	<span class="n">erp</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">;</span>
	<span class="n">erp</span><span class="p">[</span><span class="n">erp_idx</span><span class="p">].</span><span class="n">er_extbuf</span> <span class="o">=</span> <span class="n">kmem_alloc</span><span class="p">(</span><span class="n">XFS_IEXT_BUFSZ</span><span class="p">,</span> <span class="n">KM_NOFS</span><span class="p">);</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">=</span> <span class="n">nlists</span> <span class="o">*</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">erp</span><span class="p">[</span><span class="n">erp_idx</span><span class="p">].</span><span class="n">er_extbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">);</span>
	<span class="n">erp</span><span class="p">[</span><span class="n">erp_idx</span><span class="p">].</span><span class="n">er_extcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">erp</span><span class="p">[</span><span class="n">erp_idx</span><span class="p">].</span><span class="n">er_extoff</span> <span class="o">=</span> <span class="n">erp_idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span>
		<span class="n">erp</span><span class="p">[</span><span class="n">erp_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">er_extoff</span> <span class="o">+</span> <span class="n">erp</span><span class="p">[</span><span class="n">erp_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">er_extcount</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">erp</span><span class="p">[</span><span class="n">erp_idx</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a record from the indirection array.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="n">xfs_iext_irec_remove</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="kt">int</span>		<span class="n">erp_idx</span><span class="p">)</span>	<span class="cm">/* irec index to remove */</span>
<span class="p">{</span>
	<span class="n">xfs_ext_irec_t</span>	<span class="o">*</span><span class="n">erp</span><span class="p">;</span>		<span class="cm">/* indirection array pointer */</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>		<span class="cm">/* loop counter */</span>
	<span class="kt">int</span>		<span class="n">nlists</span><span class="p">;</span>		<span class="cm">/* number of irec&#39;s (ex lists) */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">);</span>
	<span class="n">nlists</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">/</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">;</span>
	<span class="n">erp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">[</span><span class="n">erp_idx</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_irec_update_extoffs</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">erp_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			<span class="o">-</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span><span class="p">);</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Compact extent records */</span>
	<span class="n">erp</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">erp_idx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nlists</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">erp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">erp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_ext_irec_t</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Manually free the last extent record from the indirection</span>
<span class="cm">	 * array.  A call to xfs_iext_realloc_indirect() with a size</span>
<span class="cm">	 * of zero would result in a call to xfs_iext_destroy() which</span>
<span class="cm">	 * would in turn call this function again, creating a nasty</span>
<span class="cm">	 * infinite loop.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">nlists</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_realloc_indirect</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span>
			<span class="n">nlists</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_ext_irec_t</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kmem_free</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">=</span> <span class="n">nlists</span> <span class="o">*</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called to clean up large amounts of unused memory allocated</span>
<span class="cm"> * by the indirection array.  Before compacting anything though, verify</span>
<span class="cm"> * that the indirection array is still needed and switch back to the</span>
<span class="cm"> * linear extent list (or even the inline buffer) if possible.  The</span>
<span class="cm"> * compaction policy is as follows:</span>
<span class="cm"> *</span>
<span class="cm"> *    Full Compaction: Extents fit into a single page (or inline buffer)</span>
<span class="cm"> * Partial Compaction: Extents occupy less than 50% of allocated space</span>
<span class="cm"> *      No Compaction: Extents occupy at least 50% of allocated space</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="n">xfs_iext_irec_compact</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">)</span>		<span class="cm">/* inode fork pointer */</span>
<span class="p">{</span>
	<span class="n">xfs_extnum_t</span>	<span class="n">nextents</span><span class="p">;</span>	<span class="cm">/* number of extents in file */</span>
	<span class="kt">int</span>		<span class="n">nlists</span><span class="p">;</span>		<span class="cm">/* number of irec&#39;s (ex lists) */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">);</span>
	<span class="n">nlists</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">/</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">;</span>
	<span class="n">nextents</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_bytes</span> <span class="o">/</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nextents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_destroy</span><span class="p">(</span><span class="n">ifp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nextents</span> <span class="o">&lt;=</span> <span class="n">XFS_INLINE_EXTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_indirect_to_direct</span><span class="p">(</span><span class="n">ifp</span><span class="p">);</span>
		<span class="n">xfs_iext_direct_to_inline</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">nextents</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nextents</span> <span class="o">&lt;=</span> <span class="n">XFS_LINEAR_EXTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_indirect_to_direct</span><span class="p">(</span><span class="n">ifp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nextents</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">nlists</span> <span class="o">*</span> <span class="n">XFS_LINEAR_EXTS</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iext_irec_compact_pages</span><span class="p">(</span><span class="n">ifp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Combine extents from neighboring extent pages.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="n">xfs_iext_irec_compact_pages</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">)</span>		<span class="cm">/* inode fork pointer */</span>
<span class="p">{</span>
	<span class="n">xfs_ext_irec_t</span>	<span class="o">*</span><span class="n">erp</span><span class="p">,</span> <span class="o">*</span><span class="n">erp_next</span><span class="p">;</span><span class="cm">/* pointers to irec entries */</span>
	<span class="kt">int</span>		<span class="n">erp_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* indirection array index */</span>
	<span class="kt">int</span>		<span class="n">nlists</span><span class="p">;</span>		<span class="cm">/* number of irec&#39;s (ex lists) */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">);</span>
	<span class="n">nlists</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">/</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">erp_idx</span> <span class="o">&lt;</span> <span class="n">nlists</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">erp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">[</span><span class="n">erp_idx</span><span class="p">];</span>
		<span class="n">erp_next</span> <span class="o">=</span> <span class="n">erp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">erp_next</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">&lt;=</span>
		    <span class="p">(</span><span class="n">XFS_LINEAR_EXTS</span> <span class="o">-</span> <span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">[</span><span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span><span class="p">],</span>
				<span class="n">erp_next</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">,</span> <span class="n">erp_next</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">*</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">xfs_bmbt_rec_t</span><span class="p">));</span>
			<span class="n">erp</span><span class="o">-&gt;</span><span class="n">er_extcount</span> <span class="o">+=</span> <span class="n">erp_next</span><span class="o">-&gt;</span><span class="n">er_extcount</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Free page before removing extent record</span>
<span class="cm">			 * so er_extoffs don&#39;t get modified in</span>
<span class="cm">			 * xfs_iext_irec_remove.</span>
<span class="cm">			 */</span>
			<span class="n">kmem_free</span><span class="p">(</span><span class="n">erp_next</span><span class="o">-&gt;</span><span class="n">er_extbuf</span><span class="p">);</span>
			<span class="n">erp_next</span><span class="o">-&gt;</span><span class="n">er_extbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">xfs_iext_irec_remove</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">erp_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">nlists</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">/</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">erp_idx</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called to update the er_extoff field in the indirection</span>
<span class="cm"> * array when extents have been added or removed from one of the</span>
<span class="cm"> * extent lists. erp_idx contains the irec index to begin updating</span>
<span class="cm"> * at and ext_diff contains the number of extents that were added</span>
<span class="cm"> * or removed.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="n">xfs_iext_irec_update_extoffs</span><span class="p">(</span>
	<span class="n">xfs_ifork_t</span>	<span class="o">*</span><span class="n">ifp</span><span class="p">,</span>		<span class="cm">/* inode fork pointer */</span>
	<span class="kt">int</span>		<span class="n">erp_idx</span><span class="p">,</span>	<span class="cm">/* irec index to update */</span>
	<span class="kt">int</span>		<span class="n">ext_diff</span><span class="p">)</span>	<span class="cm">/* number of new extents */</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>		<span class="cm">/* loop counter */</span>
	<span class="kt">int</span>		<span class="n">nlists</span><span class="p">;</span>		<span class="cm">/* number of irec&#39;s (ex lists */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTIREC</span><span class="p">);</span>
	<span class="n">nlists</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_real_bytes</span> <span class="o">/</span> <span class="n">XFS_IEXT_BUFSZ</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">erp_idx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nlists</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">if_u1</span><span class="p">.</span><span class="n">if_ext_irec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">er_extoff</span> <span class="o">+=</span> <span class="n">ext_diff</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
