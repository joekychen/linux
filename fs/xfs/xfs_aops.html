<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_aops.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_aops.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;xfs.h&quot;</span>
<span class="cp">#include &quot;xfs_log.h&quot;</span>
<span class="cp">#include &quot;xfs_sb.h&quot;</span>
<span class="cp">#include &quot;xfs_ag.h&quot;</span>
<span class="cp">#include &quot;xfs_trans.h&quot;</span>
<span class="cp">#include &quot;xfs_mount.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap_btree.h&quot;</span>
<span class="cp">#include &quot;xfs_dinode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode.h&quot;</span>
<span class="cp">#include &quot;xfs_inode_item.h&quot;</span>
<span class="cp">#include &quot;xfs_alloc.h&quot;</span>
<span class="cp">#include &quot;xfs_error.h&quot;</span>
<span class="cp">#include &quot;xfs_iomap.h&quot;</span>
<span class="cp">#include &quot;xfs_vnodeops.h&quot;</span>
<span class="cp">#include &quot;xfs_trace.h&quot;</span>
<span class="cp">#include &quot;xfs_bmap.h&quot;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/mpage.h&gt;</span>
<span class="cp">#include &lt;linux/pagevec.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>

<span class="kt">void</span>
<span class="nf">xfs_count_page_state</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">delalloc</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">unwritten</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="o">*</span><span class="n">delalloc</span> <span class="o">=</span> <span class="o">*</span><span class="n">unwritten</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="p">(</span><span class="o">*</span><span class="n">unwritten</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="p">(</span><span class="o">*</span><span class="n">delalloc</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span>
<span class="nf">xfs_find_bdev_for_inode</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_IS_REALTIME_INODE</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_rtdev_targp</span><span class="o">-&gt;</span><span class="n">bt_bdev</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_ddev_targp</span><span class="o">-&gt;</span><span class="n">bt_bdev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We&#39;re now finished for good with this ioend structure.</span>
<span class="cm"> * Update the page state via the associated buffer_heads,</span>
<span class="cm"> * release holds on the inode and bio, and finally free</span>
<span class="cm"> * up memory.  Do not use the ioend after this.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_destroy_ioend</span><span class="p">(</span>
	<span class="n">xfs_ioend_t</span>		<span class="o">*</span><span class="n">ioend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_buffer_head</span><span class="p">;</span> <span class="n">bh</span><span class="p">;</span> <span class="n">bh</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="o">!</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_iocb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_isasync</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">aio_complete</span><span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_iocb</span><span class="p">,</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_error</span> <span class="o">?</span>
					<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_error</span> <span class="o">:</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_result</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">inode_dio_done</span><span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">ioend</span><span class="p">,</span> <span class="n">xfs_ioend_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fast and loose check if this write could update the on-disk inode size.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">xfs_ioend_is_append</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_ioend</span> <span class="o">*</span><span class="n">ioend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_offset</span> <span class="o">+</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_size</span> <span class="o">&gt;</span>
		<span class="n">XFS_I</span><span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_setfilesize_trans_alloc</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ioend</span>	<span class="o">*</span><span class="n">ioend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">xfs_trans_alloc</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">XFS_TRANS_FSYNC_TS</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_trans_reserve</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XFS_FSYNC_TS_LOG_RES</span><span class="p">(</span><span class="n">mp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_append_trans</span> <span class="o">=</span> <span class="n">tp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We hand off the transaction to the completion thread now, so</span>
<span class="cm">	 * clear the flag here.</span>
<span class="cm">	 */</span>
	<span class="n">current_restore_flags_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_pflags</span><span class="p">,</span> <span class="n">PF_FSTRANS</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update on-disk file size now that data has been written to disk.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_setfilesize</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ioend</span>	<span class="o">*</span><span class="n">ioend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_trans</span>	<span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_append_trans</span><span class="p">;</span>
	<span class="n">xfs_fsize_t</span>		<span class="n">isize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The transaction was allocated in the I/O submission thread,</span>
<span class="cm">	 * thus we need to mark ourselves as beeing in a transaction</span>
<span class="cm">	 * manually.</span>
<span class="cm">	 */</span>
	<span class="n">current_set_flags_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">t_pflags</span><span class="p">,</span> <span class="n">PF_FSTRANS</span><span class="p">);</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="n">isize</span> <span class="o">=</span> <span class="n">xfs_new_eof</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_offset</span> <span class="o">+</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_xfs_setfilesize</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_offset</span><span class="p">,</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_size</span><span class="p">);</span>

	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span> <span class="o">=</span> <span class="n">isize</span><span class="p">;</span>
	<span class="n">xfs_trans_ijoin</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="n">xfs_trans_log_inode</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOG_CORE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">xfs_trans_commit</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Schedule IO completion handling on the final put of an ioend.</span>
<span class="cm"> *</span>
<span class="cm"> * If there is no work to do we might as well call it a day and free the</span>
<span class="cm"> * ioend right now.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_finish_ioend</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ioend</span>	<span class="o">*</span><span class="n">ioend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_remaining</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_type</span> <span class="o">==</span> <span class="n">IO_UNWRITTEN</span><span class="p">)</span>
			<span class="n">queue_work</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_unwritten_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_work</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_append_trans</span><span class="p">)</span>
			<span class="n">queue_work</span><span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_data_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_work</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">xfs_destroy_ioend</span><span class="p">(</span><span class="n">ioend</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * IO write completion.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_end_io</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_ioend_t</span>	<span class="o">*</span><span class="n">ioend</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">xfs_ioend_t</span><span class="p">,</span> <span class="n">io_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_inode</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For unwritten extents we need to issue transactions to convert a</span>
<span class="cm">	 * range to normal written extens after the data I/O has finished.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_type</span> <span class="o">==</span> <span class="n">IO_UNWRITTEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For buffered I/O we never preallocate a transaction when</span>
<span class="cm">		 * doing the unwritten extent conversion, but for direct I/O</span>
<span class="cm">		 * we do not know if we are converting an unwritten extent</span>
<span class="cm">		 * or not at the point where we preallocate the transaction.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_append_trans</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_isdirect</span><span class="p">);</span>

			<span class="n">current_set_flags_nested</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_append_trans</span><span class="o">-&gt;</span><span class="n">t_pflags</span><span class="p">,</span> <span class="n">PF_FSTRANS</span><span class="p">);</span>
			<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_append_trans</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iomap_write_unwritten</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_offset</span><span class="p">,</span>
						 <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_error</span> <span class="o">=</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_append_trans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_setfilesize</span><span class="p">(</span><span class="n">ioend</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_error</span> <span class="o">=</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">xfs_ioend_is_append</span><span class="p">(</span><span class="n">ioend</span><span class="p">));</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">xfs_destroy_ioend</span><span class="p">(</span><span class="n">ioend</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Call IO completion handling in caller context on the final put of an ioend.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_finish_ioend_sync</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">xfs_ioend</span>	<span class="o">*</span><span class="n">ioend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_remaining</span><span class="p">))</span>
		<span class="n">xfs_end_io</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate and initialise an IO completion structure.</span>
<span class="cm"> * We need to track unwritten extent write completion here initially.</span>
<span class="cm"> * We&#39;ll need to extend this for updating the ondisk inode size later</span>
<span class="cm"> * (vs. incore size).</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="n">xfs_ioend_t</span> <span class="o">*</span>
<span class="nf">xfs_alloc_ioend</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_ioend_t</span>		<span class="o">*</span><span class="n">ioend</span><span class="p">;</span>

	<span class="n">ioend</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">xfs_ioend_pool</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the count to 1 initially, which will prevent an I/O</span>
<span class="cm">	 * completion callback from happening before we have started</span>
<span class="cm">	 * all the I/O from calling the completion routine too early.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_remaining</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_isasync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_isdirect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_buffer_head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_buffer_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_iocb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_append_trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_work</span><span class="p">,</span> <span class="n">xfs_end_io</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ioend</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_map_blocks</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">offset</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_bmbt_irec</span>	<span class="o">*</span><span class="n">imap</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">type</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">nonblocking</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">offset_fsb</span><span class="p">,</span> <span class="n">end_fsb</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">bmapi_flags</span> <span class="o">=</span> <span class="n">XFS_BMAPI_ENTIRE</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nimaps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">IO_UNWRITTEN</span><span class="p">)</span>
		<span class="n">bmapi_flags</span> <span class="o">|=</span> <span class="n">XFS_BMAPI_IGSTATE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_ilock_nowait</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nonblocking</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EAGAIN</span><span class="p">);</span>
		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_format</span> <span class="o">!=</span> <span class="n">XFS_DINODE_FMT_BTREE</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_df</span><span class="p">.</span><span class="n">if_flags</span> <span class="o">&amp;</span> <span class="n">XFS_IFEXTENTS</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxioffset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxioffset</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxioffset</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">end_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_ufsize_t</span><span class="p">)</span><span class="n">offset</span> <span class="o">+</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">offset_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSBT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">offset_fsb</span><span class="p">,</span> <span class="n">end_fsb</span> <span class="o">-</span> <span class="n">offset_fsb</span><span class="p">,</span>
				<span class="n">imap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nimaps</span><span class="p">,</span> <span class="n">bmapi_flags</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_SHARED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">IO_DELALLOC</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">nimaps</span> <span class="o">||</span> <span class="n">isnullstartblock</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">br_startblock</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iomap_write_allocate</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">imap</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="n">trace_xfs_map_blocks_alloc</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">imap</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">IO_UNWRITTEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nimaps</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">HOLESTARTBLOCK</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nimaps</span><span class="p">)</span>
		<span class="n">trace_xfs_map_blocks_found</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">imap</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_imap_valid</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_bmbt_irec</span>	<span class="o">*</span><span class="n">imap</span><span class="p">,</span>
	<span class="n">xfs_off_t</span>		<span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">offset</span> <span class="o">&gt;&gt;=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">br_startoff</span> <span class="o">&amp;&amp;</span>
		<span class="n">offset</span> <span class="o">&lt;</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">br_startoff</span> <span class="o">+</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">br_blockcount</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * BIO completion handler for buffered IO.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_end_bio</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">bio</span>		<span class="o">*</span><span class="n">bio</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_ioend_t</span>		<span class="o">*</span><span class="n">ioend</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_cnt</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_error</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">BIO_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* Toss bio and pass work off to an xfsdatad thread */</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

	<span class="n">xfs_finish_ioend</span><span class="p">(</span><span class="n">ioend</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_submit_ioend_bio</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">,</span>
	<span class="n">xfs_ioend_t</span>		<span class="o">*</span><span class="n">ioend</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">bio</span>		<span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_remaining</span><span class="p">);</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">ioend</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">xfs_end_bio</span><span class="p">;</span>
	<span class="n">submit_bio</span><span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span> <span class="o">?</span> <span class="n">WRITE_SYNC</span> <span class="o">:</span> <span class="n">WRITE</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span>
<span class="nf">xfs_alloc_ioend_bio</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">nvecs</span> <span class="o">=</span> <span class="n">bio_get_nr_vecs</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bio</span>		<span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">GFP_NOIO</span><span class="p">,</span> <span class="n">nvecs</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">*</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_start_buffer_writeback</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>

	<span class="n">mark_buffer_async_write</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_start_page_writeback</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">clear_dirty</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">buffers</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clear_dirty</span><span class="p">)</span>
		<span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">set_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="cm">/* If no buffers on the page are to be written, finish it here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffers</span><span class="p">)</span>
		<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bio_add_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bio_add_page</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">,</span> <span class="n">bh_offset</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Submit all of the bios for all of the ioends we have saved up, covering the</span>
<span class="cm"> * initial writepage page and also any probed pages.</span>
<span class="cm"> *</span>
<span class="cm"> * Because we may have multiple ioends spanning a page, we need to start</span>
<span class="cm"> * writeback on all the buffers before we submit them for I/O. If we mark the</span>
<span class="cm"> * buffers as we got, then we can end up with a page that only has buffers</span>
<span class="cm"> * marked async write and I/O complete on can occur before we mark the other</span>
<span class="cm"> * buffers async write.</span>
<span class="cm"> *</span>
<span class="cm"> * The end result of this is that we trip a bug in end_page_writeback() because</span>
<span class="cm"> * we call it twice for the one page as the code in end_buffer_async_write()</span>
<span class="cm"> * assumes that all buffers on the page are started at the same time.</span>
<span class="cm"> *</span>
<span class="cm"> * The fix is two passes across the ioend list - one to start writeback on the</span>
<span class="cm"> * buffer_heads, and then submit them for I/O on the second pass.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_submit_ioend</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">,</span>
	<span class="n">xfs_ioend_t</span>		<span class="o">*</span><span class="n">ioend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_ioend_t</span>		<span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">ioend</span><span class="p">;</span>
	<span class="n">xfs_ioend_t</span>		<span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span>		<span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="n">sector_t</span>		<span class="n">lastblock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Pass 1 - start writeback */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_list</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_buffer_head</span><span class="p">;</span> <span class="n">bh</span><span class="p">;</span> <span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">)</span>
			<span class="n">xfs_start_buffer_writeback</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">ioend</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Pass 2 - submit I/O */</span>
	<span class="n">ioend</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_list</span><span class="p">;</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_buffer_head</span><span class="p">;</span> <span class="n">bh</span><span class="p">;</span> <span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
 <span class="nl">retry:</span>
				<span class="n">bio</span> <span class="o">=</span> <span class="n">xfs_alloc_ioend_bio</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">!=</span> <span class="n">lastblock</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_submit_ioend_bio</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">ioend</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bio_add_buffer</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">bh</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xfs_submit_ioend_bio</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">ioend</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">lastblock</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span>
			<span class="n">xfs_submit_ioend_bio</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">ioend</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="n">xfs_finish_ioend</span><span class="p">(</span><span class="n">ioend</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">ioend</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cancel submission of all buffer_heads so far in this endio.</span>
<span class="cm"> * Toss the endio too.  Only ever called for the initial page</span>
<span class="cm"> * in a writepage request, so only ever one page.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_cancel_ioend</span><span class="p">(</span>
	<span class="n">xfs_ioend_t</span>		<span class="o">*</span><span class="n">ioend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_ioend_t</span>		<span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">next_bh</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_list</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_buffer_head</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">next_bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">;</span>
			<span class="n">clear_buffer_async_write</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">next_bh</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">mempool_free</span><span class="p">(</span><span class="n">ioend</span><span class="p">,</span> <span class="n">xfs_ioend_pool</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">ioend</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Test to see if we&#39;ve been building up a completion structure for</span>
<span class="cm"> * earlier buffers -- if so, we try to append to this ioend if we</span>
<span class="cm"> * can, otherwise we finish off any current ioend and start another.</span>
<span class="cm"> * Return true if we&#39;ve finished the given ioend.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_add_to_ioend</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">,</span>
	<span class="n">xfs_off_t</span>		<span class="n">offset</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">type</span><span class="p">,</span>
	<span class="n">xfs_ioend_t</span>		<span class="o">**</span><span class="n">result</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">need_ioend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_ioend_t</span>		<span class="o">*</span><span class="n">ioend</span> <span class="o">=</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioend</span> <span class="o">||</span> <span class="n">need_ioend</span> <span class="o">||</span> <span class="n">type</span> <span class="o">!=</span> <span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_ioend_t</span>	<span class="o">*</span><span class="n">previous</span> <span class="o">=</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

		<span class="n">ioend</span> <span class="o">=</span> <span class="n">xfs_alloc_ioend</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_buffer_head</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_buffer_tail</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">previous</span><span class="p">)</span>
			<span class="n">previous</span><span class="o">-&gt;</span><span class="n">io_list</span> <span class="o">=</span> <span class="n">ioend</span><span class="p">;</span>
		<span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">ioend</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_buffer_tail</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_buffer_tail</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_size</span> <span class="o">+=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_map_buffer</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_bmbt_irec</span>	<span class="o">*</span><span class="n">imap</span><span class="p">,</span>
	<span class="n">xfs_off_t</span>		<span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span>		<span class="n">bn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">xfs_off_t</span>		<span class="n">iomap_offset</span> <span class="o">=</span> <span class="n">XFS_FSB_TO_B</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">br_startoff</span><span class="p">);</span>
	<span class="n">xfs_daddr_t</span>		<span class="n">iomap_bn</span> <span class="o">=</span> <span class="n">xfs_fsb_to_db</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">imap</span><span class="o">-&gt;</span><span class="n">br_startblock</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">HOLESTARTBLOCK</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">);</span>

	<span class="n">bn</span> <span class="o">=</span> <span class="p">(</span><span class="n">iomap_bn</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span> <span class="o">-</span> <span class="n">BBSHIFT</span><span class="p">))</span> <span class="o">+</span>
	      <span class="p">((</span><span class="n">offset</span> <span class="o">-</span> <span class="n">iomap_offset</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bn</span> <span class="o">||</span> <span class="n">XFS_IS_REALTIME_INODE</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)));</span>

	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="n">bn</span><span class="p">;</span>
	<span class="n">set_buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_map_at_offset</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_bmbt_irec</span>	<span class="o">*</span><span class="n">imap</span><span class="p">,</span>
	<span class="n">xfs_off_t</span>		<span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">HOLESTARTBLOCK</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">imap</span><span class="o">-&gt;</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">);</span>

	<span class="n">xfs_map_buffer</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">imap</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">set_buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Test if a given page is suitable for writing as part of an unwritten</span>
<span class="cm"> * or delayed allocate extent.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_check_page_type</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
		<span class="kt">int</span>			<span class="n">acceptable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="n">acceptable</span> <span class="o">+=</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">IO_UNWRITTEN</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="n">acceptable</span> <span class="o">+=</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">IO_DELALLOC</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="n">acceptable</span> <span class="o">+=</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">IO_OVERWRITE</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">acceptable</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate &amp; map buffers for page given the extent map. Write it out.</span>
<span class="cm"> * except for the original page of a writepage, this is called on</span>
<span class="cm"> * delalloc/unwritten pages only, for the original page it is possible</span>
<span class="cm"> * that the page has no mapping at all.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_convert_page</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">tindex</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_bmbt_irec</span>	<span class="o">*</span><span class="n">imap</span><span class="p">,</span>
	<span class="n">xfs_ioend_t</span>		<span class="o">**</span><span class="n">ioendp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="n">xfs_off_t</span>		<span class="n">end_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">p_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">len</span><span class="p">,</span> <span class="n">page_dirty</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uptodate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 	<span class="n">xfs_off_t</span>		<span class="n">offset</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">tindex</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_unlock_page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_unlock_page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_check_page_type</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">ioendp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_type</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_unlock_page</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * page_dirty is initially a count of buffers on the page before</span>
<span class="cm">	 * EOF and is decremented as we move each into a cleanable state.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Derivation:</span>
<span class="cm">	 *</span>
<span class="cm">	 * End offset is the highest offset that this page should represent.</span>
<span class="cm">	 * If we are on the last page, (end_offset &amp; (PAGE_CACHE_SIZE - 1))</span>
<span class="cm">	 * will evaluate non-zero and be less than PAGE_CACHE_SIZE and</span>
<span class="cm">	 * hence give us the correct page_dirty count. On any other page,</span>
<span class="cm">	 * it will be zero and in that case we need page_dirty to be the</span>
<span class="cm">	 * count of buffers on the page.</span>
<span class="cm">	 */</span>
	<span class="n">end_offset</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">,</span>
			<span class="p">(</span><span class="n">xfs_off_t</span><span class="p">)(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span>
			<span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>

	<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="n">p_offset</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">end_offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
					<span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="n">p_offset</span> <span class="o">=</span> <span class="n">p_offset</span> <span class="o">?</span> <span class="n">roundup</span><span class="p">(</span><span class="n">p_offset</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">:</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
	<span class="n">page_dirty</span> <span class="o">=</span> <span class="n">p_offset</span> <span class="o">/</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">end_offset</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">uptodate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">IO_UNWRITTEN</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">IO_DELALLOC</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">IO_OVERWRITE</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_imap_valid</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">imap</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IO_OVERWRITE</span><span class="p">)</span>
				<span class="n">xfs_map_at_offset</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">imap</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="n">xfs_add_to_ioend</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
					 <span class="n">ioendp</span><span class="p">,</span> <span class="n">done</span><span class="p">);</span>

			<span class="n">page_dirty</span><span class="o">--</span><span class="p">;</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uptodate</span> <span class="o">&amp;&amp;</span> <span class="n">bh</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_NONE</span><span class="p">)</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xfs_start_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">!</span><span class="n">page_dirty</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">done</span><span class="p">;</span>
 <span class="nl">fail_unlock_page:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
 <span class="nl">fail:</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert &amp; write out a cluster of pages in the same extent as defined</span>
<span class="cm"> * by mp and following the start page.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_cluster_write</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="n">pgoff_t</span>			<span class="n">tindex</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">xfs_bmbt_irec</span>	<span class="o">*</span><span class="n">imap</span><span class="p">,</span>
	<span class="n">xfs_ioend_t</span>		<span class="o">**</span><span class="n">ioendp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">,</span>
	<span class="n">pgoff_t</span>			<span class="n">tlast</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pagevec</span>		<span class="n">pvec</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span> <span class="o">&amp;&amp;</span> <span class="n">tindex</span> <span class="o">&lt;=</span> <span class="n">tlast</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">pgoff_t</span><span class="p">,</span> <span class="n">PAGEVEC_SIZE</span><span class="p">,</span> <span class="n">tlast</span> <span class="o">-</span> <span class="n">tindex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pagevec_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">tindex</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pagevec_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">done</span> <span class="o">=</span> <span class="n">xfs_convert_page</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tindex</span><span class="o">++</span><span class="p">,</span>
					<span class="n">imap</span><span class="p">,</span> <span class="n">ioendp</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_vm_invalidatepage</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_xfs_invalidatepage</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">block_invalidatepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If the page has delalloc buffers on it, we need to punch them out before we</span>
<span class="cm"> * invalidate the page. If we don&#39;t, we leave a stale delalloc mapping on the</span>
<span class="cm"> * inode that can trip a BUG() in xfs_get_blocks() later on if a direct IO read</span>
<span class="cm"> * is done on that same region - the delalloc extent is returned when none is</span>
<span class="cm"> * supposed to be there.</span>
<span class="cm"> *</span>
<span class="cm"> * We prevent this by truncating away the delalloc regions on the page before</span>
<span class="cm"> * invalidating it. Because they are delalloc, we can do this without needing a</span>
<span class="cm"> * transaction. Indeed - if we get ENOSPC errors, we have to be able to do this</span>
<span class="cm"> * truncation without a transaction as there is no space left for block</span>
<span class="cm"> * reservation (typically why we see a ENOSPC in writeback).</span>
<span class="cm"> *</span>
<span class="cm"> * This is not a performance critical path, so for now just do the punching a</span>
<span class="cm"> * buffer head at a time.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_aops_discard_page</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">offset</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xfs_check_page_type</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">IO_DELALLOC</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_invalidate</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_invalidate</span><span class="p">;</span>

	<span class="n">xfs_alert</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
		<span class="s">&quot;page discard on page %p, inode 0x%llx, offset %llu.&quot;</span><span class="p">,</span>
			<span class="n">page</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
		<span class="n">xfs_fileoff_t</span>	<span class="n">start_fsb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">next_buffer</span><span class="p">;</span>

		<span class="n">start_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSBT</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_punch_delalloc_range</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">start_fsb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* something screwed, just bail */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">xfs_alert</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
			<span class="s">&quot;page discard unable to remove delalloc mapping.&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">next_buffer:</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
<span class="nl">out_invalidate:</span>
	<span class="n">xfs_vm_invalidatepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write out a dirty page.</span>
<span class="cm"> *</span>
<span class="cm"> * For delalloc space on the page we need to allocate space and flush it.</span>
<span class="cm"> * For unwritten space on the page we need to start the conversion to</span>
<span class="cm"> * regular allocated space.</span>
<span class="cm"> * For any other dirty buffer heads on the page we should flush them.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vm_writepage</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_bmbt_irec</span>	<span class="n">imap</span><span class="p">;</span>
	<span class="n">xfs_ioend_t</span>		<span class="o">*</span><span class="n">ioend</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">iohead</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">type</span><span class="p">;</span>
	<span class="n">__uint64_t</span>              <span class="n">end_offset</span><span class="p">;</span>
	<span class="n">pgoff_t</span>                 <span class="n">end_index</span><span class="p">,</span> <span class="n">last_index</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">err</span><span class="p">,</span> <span class="n">imap_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uptodate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nonblocking</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">trace_xfs_writepage</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Refuse to write the page out if we are called from reclaim context.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This avoids stack overflows when called from deeply used stacks in</span>
<span class="cm">	 * random callers for direct reclaim or memcg reclaim.  We explicitly</span>
<span class="cm">	 * allow reclaim from kswapd as the stack usage there is relatively low.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This should never happen except in the case of a VM regression so</span>
<span class="cm">	 * warn about it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PF_MEMALLOC</span><span class="o">|</span><span class="n">PF_KSWAPD</span><span class="p">))</span> <span class="o">==</span>
			<span class="n">PF_MEMALLOC</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">redirty</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Given that we do not allow direct reclaim to call us, we should</span>
<span class="cm">	 * never be called while in a filesystem transaction.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_FSTRANS</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">redirty</span><span class="p">;</span>

	<span class="cm">/* Is this page beyond the end of the file? */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">end_index</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">last_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">end_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">end_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">end_offset</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">,</span>
			<span class="p">(</span><span class="n">xfs_off_t</span><span class="p">)(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span>
			<span class="n">offset</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">IO_OVERWRITE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_NONE</span><span class="p">)</span>
		<span class="n">nonblocking</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">new_ioend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">end_offset</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">uptodate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * set_page_dirty dirties all buffers in a page, independent</span>
<span class="cm">		 * of their state.  The dirty state however is entirely</span>
<span class="cm">		 * meaningless for holes (!mapped &amp;&amp; uptodate), so skip</span>
<span class="cm">		 * buffers covering holes here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">imap_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IO_UNWRITTEN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">IO_UNWRITTEN</span><span class="p">;</span>
				<span class="n">imap_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IO_DELALLOC</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">IO_DELALLOC</span><span class="p">;</span>
				<span class="n">imap_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IO_OVERWRITE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">type</span> <span class="o">=</span> <span class="n">IO_OVERWRITE</span><span class="p">;</span>
				<span class="n">imap_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
			<span class="cm">/*</span>
<span class="cm">			 * This buffer is not uptodate and will not be</span>
<span class="cm">			 * written to disk.  Ensure that we will put any</span>
<span class="cm">			 * subsequent writeable buffers into a new</span>
<span class="cm">			 * ioend.</span>
<span class="cm">			 */</span>
			<span class="n">imap_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">imap_valid</span><span class="p">)</span>
			<span class="n">imap_valid</span> <span class="o">=</span> <span class="n">xfs_imap_valid</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">imap_valid</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we didn&#39;t have a valid mapping then we need to</span>
<span class="cm">			 * put the new mapping into a separate ioend structure.</span>
<span class="cm">			 * This ensures non-contiguous extents always have</span>
<span class="cm">			 * separate ioends, which is particularly important</span>
<span class="cm">			 * for unwritten extent conversion at I/O completion</span>
<span class="cm">			 * time.</span>
<span class="cm">			 */</span>
			<span class="n">new_ioend</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">xfs_map_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
					     <span class="n">nonblocking</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="n">imap_valid</span> <span class="o">=</span> <span class="n">xfs_imap_valid</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">imap_valid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IO_OVERWRITE</span><span class="p">)</span>
				<span class="n">xfs_map_at_offset</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="n">xfs_add_to_ioend</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioend</span><span class="p">,</span>
					 <span class="n">new_ioend</span><span class="p">);</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iohead</span><span class="p">)</span>
			<span class="n">iohead</span> <span class="o">=</span> <span class="n">ioend</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">,</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uptodate</span> <span class="o">&amp;&amp;</span> <span class="n">bh</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">xfs_start_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ioend</span> <span class="o">&amp;&amp;</span> <span class="n">imap_valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfs_off_t</span>		<span class="n">end_index</span><span class="p">;</span>

		<span class="n">end_index</span> <span class="o">=</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_startoff</span> <span class="o">+</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_blockcount</span><span class="p">;</span>

		<span class="cm">/* to bytes */</span>
		<span class="n">end_index</span> <span class="o">&lt;&lt;=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

		<span class="cm">/* to pages */</span>
		<span class="n">end_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>

		<span class="cm">/* check against file size */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end_index</span> <span class="o">&gt;</span> <span class="n">last_index</span><span class="p">)</span>
			<span class="n">end_index</span> <span class="o">=</span> <span class="n">last_index</span><span class="p">;</span>

		<span class="n">xfs_cluster_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioend</span><span class="p">,</span>
				  <span class="n">wbc</span><span class="p">,</span> <span class="n">end_index</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iohead</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Reserve log space if we might write beyond the on-disk</span>
<span class="cm">		 * inode size.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_type</span> <span class="o">!=</span> <span class="n">IO_UNWRITTEN</span> <span class="o">&amp;&amp;</span>
		    <span class="n">xfs_ioend_is_append</span><span class="p">(</span><span class="n">ioend</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">xfs_setfilesize_trans_alloc</span><span class="p">(</span><span class="n">ioend</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">xfs_submit_ioend</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">iohead</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iohead</span><span class="p">)</span>
		<span class="n">xfs_cancel_ioend</span><span class="p">(</span><span class="n">iohead</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">redirty</span><span class="p">;</span>

	<span class="n">xfs_aops_discard_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ClearPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">redirty:</span>
	<span class="n">redirty_page_for_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vm_writepages</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xfs_iflags_clear</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span> <span class="n">XFS_ITRUNCATED</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">generic_writepages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called to move a page into cleanable state - and from there</span>
<span class="cm"> * to be released. The page should already be clean. We always</span>
<span class="cm"> * have buffer heads in this call.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if the page is ok to release, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vm_releasepage</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="n">gfp_t</span>			<span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">delalloc</span><span class="p">,</span> <span class="n">unwritten</span><span class="p">;</span>

	<span class="n">trace_xfs_releasepage</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">xfs_count_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delalloc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unwritten</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">delalloc</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">unwritten</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">try_to_free_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">__xfs_get_blocks</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="n">sector_t</span>		<span class="n">iblock</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh_result</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">create</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">direct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span>	<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">offset_fsb</span><span class="p">,</span> <span class="n">end_fsb</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">lockmode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_bmbt_irec</span>	<span class="n">imap</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nimaps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">xfs_off_t</span>		<span class="n">offset</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">new</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">mp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">XFS_ERROR</span><span class="p">(</span><span class="n">EIO</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfs_off_t</span><span class="p">)</span><span class="n">iblock</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">));</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">create</span> <span class="o">&amp;&amp;</span> <span class="n">direct</span> <span class="o">&amp;&amp;</span> <span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Direct I/O is usually done on preallocated files, so try getting</span>
<span class="cm">	 * a block mapping without an exclusive lock first.  For buffered</span>
<span class="cm">	 * writes we already have the exclusive iolock anyway, so avoiding</span>
<span class="cm">	 * a lock roundtrip here by taking the ilock exclusive from the</span>
<span class="cm">	 * beginning is a useful micro optimization.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">create</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">direct</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lockmode</span> <span class="o">=</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">;</span>
		<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">lockmode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lockmode</span> <span class="o">=</span> <span class="n">xfs_ilock_map_shared</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxioffset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxioffset</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">m_maxioffset</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">end_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_ufsize_t</span><span class="p">)</span><span class="n">offset</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">offset_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSBT</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmapi_read</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">offset_fsb</span><span class="p">,</span> <span class="n">end_fsb</span> <span class="o">-</span> <span class="n">offset_fsb</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nimaps</span><span class="p">,</span> <span class="n">XFS_BMAPI_ENTIRE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">create</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">nimaps</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">==</span> <span class="n">HOLESTARTBLOCK</span> <span class="o">||</span>
	      <span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">==</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">direct</span> <span class="o">||</span> <span class="n">xfs_get_extsz_hint</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Drop the ilock in preparation for starting the block</span>
<span class="cm">			 * allocation transaction.  It will be retaken</span>
<span class="cm">			 * exclusively inside xfs_iomap_write_direct for the</span>
<span class="cm">			 * actual allocation.</span>
<span class="cm">			 */</span>
			<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">lockmode</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iomap_write_direct</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="n">nimaps</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
			<span class="n">new</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Delalloc reservations do not require a transaction,</span>
<span class="cm">			 * we can go on without dropping the lock here. If we</span>
<span class="cm">			 * are allocating a new delalloc block, make sure that</span>
<span class="cm">			 * we set the new flag so that we mark the buffer new so</span>
<span class="cm">			 * that we know that it is newly allocated if the write</span>
<span class="cm">			 * fails.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nimaps</span> <span class="o">&amp;&amp;</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">==</span> <span class="n">HOLESTARTBLOCK</span><span class="p">)</span>
				<span class="n">new</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_iomap_write_delay</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

			<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">lockmode</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">trace_xfs_get_blocks_alloc</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nimaps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_xfs_get_blocks_found</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="p">);</span>
		<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">lockmode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">trace_xfs_get_blocks_notfound</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">HOLESTARTBLOCK</span> <span class="o">&amp;&amp;</span>
	    <span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">!=</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For unwritten extents do not report a disk address on</span>
<span class="cm">		 * the read case (treat as if we&#39;re reading into a hole).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">create</span> <span class="o">||</span> <span class="o">!</span><span class="n">ISUNWRITTEN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imap</span><span class="p">))</span>
			<span class="n">xfs_map_buffer</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bh_result</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imap</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">create</span> <span class="o">&amp;&amp;</span> <span class="n">ISUNWRITTEN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imap</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">direct</span><span class="p">)</span>
				<span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
			<span class="n">set_buffer_unwritten</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a realtime file, data may be on a different device.</span>
<span class="cm">	 * to that pointed to from the buffer_head b_bdev currently.</span>
<span class="cm">	 */</span>
	<span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_bdev</span> <span class="o">=</span> <span class="n">xfs_find_bdev_for_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we previously allocated a block out beyond eof and we are now</span>
<span class="cm">	 * coming back to use it then we will need to flag it as new even if it</span>
<span class="cm">	 * has a disk address.</span>
<span class="cm">	 *</span>
<span class="cm">	 * With sub-block writes into unwritten extents we also need to mark</span>
<span class="cm">	 * the buffer as new so that the unwritten parts of the buffer gets</span>
<span class="cm">	 * correctly zeroed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">create</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh_result</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh_result</span><span class="p">))</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">new</span> <span class="o">||</span> <span class="n">ISUNWRITTEN</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imap</span><span class="p">))))</span>
		<span class="n">set_buffer_new</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">imap</span><span class="p">.</span><span class="n">br_startblock</span> <span class="o">==</span> <span class="n">DELAYSTARTBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">direct</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">create</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
			<span class="n">set_buffer_mapped</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
			<span class="n">set_buffer_delay</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is O_DIRECT or the mpage code calling tell them how large</span>
<span class="cm">	 * the mapping is, so that we can avoid repeated get_blocks calls.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">direct</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfs_off_t</span>		<span class="n">mapping_size</span><span class="p">;</span>

		<span class="n">mapping_size</span> <span class="o">=</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_startoff</span> <span class="o">+</span> <span class="n">imap</span><span class="p">.</span><span class="n">br_blockcount</span> <span class="o">-</span> <span class="n">iblock</span><span class="p">;</span>
		<span class="n">mapping_size</span> <span class="o">&lt;&lt;=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

		<span class="n">ASSERT</span><span class="p">(</span><span class="n">mapping_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mapping_size</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
			<span class="n">mapping_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mapping_size</span> <span class="o">&gt;</span> <span class="n">LONG_MAX</span><span class="p">)</span>
			<span class="n">mapping_size</span> <span class="o">=</span> <span class="n">LONG_MAX</span><span class="p">;</span>

		<span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="n">mapping_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">lockmode</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">xfs_get_blocks</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="n">sector_t</span>		<span class="n">iblock</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh_result</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__xfs_get_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">bh_result</span><span class="p">,</span> <span class="n">create</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_get_blocks_direct</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="n">sector_t</span>		<span class="n">iblock</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh_result</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__xfs_get_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">bh_result</span><span class="p">,</span> <span class="n">create</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Complete a direct I/O write request.</span>
<span class="cm"> *</span>
<span class="cm"> * If the private argument is non-NULL __xfs_get_blocks signals us that we</span>
<span class="cm"> * need to issue a transaction to convert the range from unwritten to written</span>
<span class="cm"> * extents.  In case this is regular synchronous I/O we just call xfs_end_io</span>
<span class="cm"> * to do this and we are done.  But in case this was a successful AIO</span>
<span class="cm"> * request this handler is called from interrupt context, from which we</span>
<span class="cm"> * can&#39;t start transactions.  In that case offload the I/O completion to</span>
<span class="cm"> * the workqueues we also use for buffered I/O completion.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_end_io_direct_write</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">kiocb</span>		<span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">offset</span><span class="p">,</span>
	<span class="kt">ssize_t</span>			<span class="n">size</span><span class="p">,</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">private</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">ret</span><span class="p">,</span>
	<span class="n">bool</span>			<span class="n">is_async</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_ioend</span>	<span class="o">*</span><span class="n">ioend</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * While the generic direct I/O code updates the inode size, it does</span>
<span class="cm">	 * so only after the end_io handler is called, which means our</span>
<span class="cm">	 * end_io handler thinks the on-disk size is outside the in-core</span>
<span class="cm">	 * size.  To prevent this just update it a little bit earlier here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_inode</span><span class="p">))</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_inode</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * blockdev_direct_IO can return an error even after the I/O</span>
<span class="cm">	 * completion handler was called.  Thus we need to protect</span>
<span class="cm">	 * against double-freeing.</span>
<span class="cm">	 */</span>
	<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_iocb</span> <span class="o">=</span> <span class="n">iocb</span><span class="p">;</span>
	<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_result</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">private</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_type</span> <span class="o">=</span> <span class="n">IO_UNWRITTEN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_async</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_isasync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">xfs_finish_ioend</span><span class="p">(</span><span class="n">ioend</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xfs_finish_ioend_sync</span><span class="p">(</span><span class="n">ioend</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">ssize_t</span>
<span class="nf">xfs_vm_direct_IO</span><span class="p">(</span>
	<span class="kt">int</span>			<span class="n">rw</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">kiocb</span>		<span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span>	<span class="o">*</span><span class="n">iov</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">offset</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">nr_segs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span>	<span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">xfs_find_bdev_for_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xfs_ioend</span>	<span class="o">*</span><span class="n">ioend</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need to preallocate a transaction for a size update</span>
<span class="cm">		 * here.  In the case that this write both updates the size</span>
<span class="cm">		 * and converts at least on unwritten extent we will cancel</span>
<span class="cm">		 * the still clean transaction after the I/O has finished.</span>
<span class="cm">		 */</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">ioend</span> <span class="o">=</span> <span class="n">xfs_alloc_ioend</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">IO_DIRECT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_d</span><span class="p">.</span><span class="n">di_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">xfs_setfilesize_trans_alloc</span><span class="p">(</span><span class="n">ioend</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_destroy_ioend</span><span class="p">;</span>
			<span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_isdirect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">__blockdev_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bdev</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span>
					    <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span>
					    <span class="n">xfs_get_blocks_direct</span><span class="p">,</span>
					    <span class="n">xfs_end_io_direct_write</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span> <span class="o">&amp;&amp;</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_trans_cancel</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__blockdev_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bdev</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span>
					    <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span>
					    <span class="n">xfs_get_blocks_direct</span><span class="p">,</span>
					    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">out_trans_cancel:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_append_trans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_set_flags_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_append_trans</span><span class="o">-&gt;</span><span class="n">t_pflags</span><span class="p">,</span>
					 <span class="n">PF_FSTRANS</span><span class="p">);</span>
		<span class="n">xfs_trans_cancel</span><span class="p">(</span><span class="n">ioend</span><span class="o">-&gt;</span><span class="n">io_append_trans</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_destroy_ioend:</span>
	<span class="n">xfs_destroy_ioend</span><span class="p">(</span><span class="n">ioend</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Punch out the delalloc blocks we have already allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t bother with xfs_setattr given that nothing can have made it to disk yet</span>
<span class="cm"> * as the page is still locked at this point.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_vm_kill_delalloc_range</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">start</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">start_fsb</span><span class="p">;</span>
	<span class="n">xfs_fileoff_t</span>		<span class="n">end_fsb</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">start_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">end_fsb</span> <span class="o">=</span> <span class="n">XFS_B_TO_FSB</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end_fsb</span> <span class="o">&lt;=</span> <span class="n">start_fsb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">xfs_bmap_punch_delalloc_range</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">start_fsb</span><span class="p">,</span>
						<span class="n">end_fsb</span> <span class="o">-</span> <span class="n">start_fsb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* something screwed, just bail */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XFS_FORCED_SHUTDOWN</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xfs_alert</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_mount</span><span class="p">,</span>
		<span class="s">&quot;xfs_vm_write_failed: unable to clean up ino %lld&quot;</span><span class="p">,</span>
					<span class="n">ip</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_ILOCK_EXCL</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">void</span>
<span class="nf">xfs_vm_write_failed</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">pos</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span>			<span class="n">block_offset</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">block_start</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">block_end</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">from</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">loff_t</span>			<span class="n">to</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">block_offset</span> <span class="o">+</span> <span class="n">from</span> <span class="o">==</span> <span class="n">pos</span><span class="p">);</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">block_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span> <span class="o">||</span> <span class="o">!</span><span class="n">block_start</span><span class="p">;</span>
	     <span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">,</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">,</span>
				   <span class="n">block_offset</span> <span class="o">+=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span> <span class="o">+</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>

		<span class="cm">/* skip buffers before the write */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_end</span> <span class="o">&lt;=</span> <span class="n">from</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* if the buffer is after the write, we&#39;re done */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_start</span> <span class="o">&gt;=</span> <span class="n">to</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">block_offset</span> <span class="o">&lt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">xfs_vm_kill_delalloc_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block_offset</span><span class="p">,</span>
					   <span class="n">block_offset</span> <span class="o">+</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This used to call block_write_begin(), but it unlocks and releases the page</span>
<span class="cm"> * on error, and we need that page to be able to punch stale delalloc blocks out</span>
<span class="cm"> * on failure. hence we copy-n-waste it here and call xfs_vm_write_failed() at</span>
<span class="cm"> * the appropriate point.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vm_write_begin</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">file</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">pos</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">len</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">flags</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">**</span><span class="n">pagep</span><span class="p">,</span>
	<span class="kt">void</span>			<span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span>			<span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
					   <span class="n">flags</span> <span class="o">|</span> <span class="n">AOP_FLAG_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">xfs_get_blocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

		<span class="n">xfs_vm_write_failed</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="n">truncate_pagecache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>

		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * On failure, we only need to kill delalloc blocks beyond EOF because they</span>
<span class="cm"> * will never be written. For blocks within EOF, generic_write_end() zeros them</span>
<span class="cm"> * so they are safe to leave alone and be written with all the other valid data.</span>
<span class="cm"> */</span>
<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vm_write_end</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">file</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
	<span class="n">loff_t</span>			<span class="n">pos</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">len</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">copied</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">ret</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">generic_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
		<span class="kt">size_t</span>		<span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">loff_t</span>		<span class="n">to</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">to</span> <span class="o">&gt;</span> <span class="n">isize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">truncate_pagecache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">isize</span><span class="p">);</span>
			<span class="n">xfs_vm_kill_delalloc_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">isize</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="n">sector_t</span>
<span class="nf">xfs_vm_bmap</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
	<span class="n">sector_t</span>		<span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">)</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xfs_inode</span>	<span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">trace_xfs_vm_bmap</span><span class="p">(</span><span class="n">XFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="n">xfs_ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_SHARED</span><span class="p">);</span>
	<span class="n">xfs_flush_pages</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="n">xfs_off_t</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FI_REMAPF</span><span class="p">);</span>
	<span class="n">xfs_iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">XFS_IOLOCK_SHARED</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">generic_block_bmap</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">xfs_get_blocks</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vm_readpage</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">unused</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mpage_readpage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">xfs_get_blocks</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kt">int</span>
<span class="nf">xfs_vm_readpages</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">unused</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">pages</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mpage_readpages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">xfs_get_blocks</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">xfs_address_space_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span>		<span class="o">=</span> <span class="n">xfs_vm_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span>		<span class="o">=</span> <span class="n">xfs_vm_readpages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span>		<span class="o">=</span> <span class="n">xfs_vm_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepages</span>		<span class="o">=</span> <span class="n">xfs_vm_writepages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">releasepage</span>		<span class="o">=</span> <span class="n">xfs_vm_releasepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidatepage</span>		<span class="o">=</span> <span class="n">xfs_vm_invalidatepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span>		<span class="o">=</span> <span class="n">xfs_vm_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span>		<span class="o">=</span> <span class="n">xfs_vm_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmap</span>			<span class="o">=</span> <span class="n">xfs_vm_bmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">direct_IO</span>		<span class="o">=</span> <span class="n">xfs_vm_direct_IO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">migratepage</span>		<span class="o">=</span> <span class="n">buffer_migrate_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_partially_uptodate</span>  <span class="o">=</span> <span class="n">block_is_partially_uptodate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_remove_page</span>	<span class="o">=</span> <span class="n">generic_error_remove_page</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
