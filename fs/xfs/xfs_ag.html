<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › xfs › xfs_ag.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xfs_ag.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2000-2003,2005 Silicon Graphics, Inc.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write the Free Software Foundation,</span>
<span class="cm"> * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __XFS_AG_H__</span>
<span class="cp">#define	__XFS_AG_H__</span>

<span class="cm">/*</span>
<span class="cm"> * Allocation group header</span>
<span class="cm"> * This is divided into three structures, placed in sequential 512-byte</span>
<span class="cm"> * buffers after a copy of the superblock (also in a 512-byte buffer).</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">xfs_buf</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xfs_mount</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xfs_trans</span><span class="p">;</span>

<span class="cp">#define	XFS_AGF_MAGIC	0x58414746	</span><span class="cm">/* &#39;XAGF&#39; */</span><span class="cp"></span>
<span class="cp">#define	XFS_AGI_MAGIC	0x58414749	</span><span class="cm">/* &#39;XAGI&#39; */</span><span class="cp"></span>
<span class="cp">#define	XFS_AGF_VERSION	1</span>
<span class="cp">#define	XFS_AGI_VERSION	1</span>

<span class="cp">#define	XFS_AGF_GOOD_VERSION(v)	((v) == XFS_AGF_VERSION)</span>
<span class="cp">#define	XFS_AGI_GOOD_VERSION(v)	((v) == XFS_AGI_VERSION)</span>

<span class="cm">/*</span>
<span class="cm"> * Btree number 0 is bno, 1 is cnt.  This value gives the size of the</span>
<span class="cm"> * arrays below.</span>
<span class="cm"> */</span>
<span class="cp">#define	XFS_BTNUM_AGF	((int)XFS_BTNUM_CNTi + 1)</span>

<span class="cm">/*</span>
<span class="cm"> * The second word of agf_levels in the first a.g. overlaps the EFS</span>
<span class="cm"> * superblock&#39;s magic number.  Since the magic numbers valid for EFS</span>
<span class="cm"> * are &gt; 64k, our value cannot be confused for an EFS superblock&#39;s.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_agf</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Common allocation group header information</span>
<span class="cm">	 */</span>
	<span class="n">__be32</span>		<span class="n">agf_magicnum</span><span class="p">;</span>	<span class="cm">/* magic number == XFS_AGF_MAGIC */</span>
	<span class="n">__be32</span>		<span class="n">agf_versionnum</span><span class="p">;</span>	<span class="cm">/* header version == XFS_AGF_VERSION */</span>
	<span class="n">__be32</span>		<span class="n">agf_seqno</span><span class="p">;</span>	<span class="cm">/* sequence # starting from 0 */</span>
	<span class="n">__be32</span>		<span class="n">agf_length</span><span class="p">;</span>	<span class="cm">/* size in blocks of a.g. */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Freespace information</span>
<span class="cm">	 */</span>
	<span class="n">__be32</span>		<span class="n">agf_roots</span><span class="p">[</span><span class="n">XFS_BTNUM_AGF</span><span class="p">];</span>	<span class="cm">/* root blocks */</span>
	<span class="n">__be32</span>		<span class="n">agf_spare0</span><span class="p">;</span>	<span class="cm">/* spare field */</span>
	<span class="n">__be32</span>		<span class="n">agf_levels</span><span class="p">[</span><span class="n">XFS_BTNUM_AGF</span><span class="p">];</span>	<span class="cm">/* btree levels */</span>
	<span class="n">__be32</span>		<span class="n">agf_spare1</span><span class="p">;</span>	<span class="cm">/* spare field */</span>
	<span class="n">__be32</span>		<span class="n">agf_flfirst</span><span class="p">;</span>	<span class="cm">/* first freelist block&#39;s index */</span>
	<span class="n">__be32</span>		<span class="n">agf_fllast</span><span class="p">;</span>	<span class="cm">/* last freelist block&#39;s index */</span>
	<span class="n">__be32</span>		<span class="n">agf_flcount</span><span class="p">;</span>	<span class="cm">/* count of blocks in freelist */</span>
	<span class="n">__be32</span>		<span class="n">agf_freeblks</span><span class="p">;</span>	<span class="cm">/* total free blocks */</span>
	<span class="n">__be32</span>		<span class="n">agf_longest</span><span class="p">;</span>	<span class="cm">/* longest free space */</span>
	<span class="n">__be32</span>		<span class="n">agf_btreeblks</span><span class="p">;</span>	<span class="cm">/* # of blocks held in AGF btrees */</span>
<span class="p">}</span> <span class="n">xfs_agf_t</span><span class="p">;</span>

<span class="cp">#define	XFS_AGF_MAGICNUM	0x00000001</span>
<span class="cp">#define	XFS_AGF_VERSIONNUM	0x00000002</span>
<span class="cp">#define	XFS_AGF_SEQNO		0x00000004</span>
<span class="cp">#define	XFS_AGF_LENGTH		0x00000008</span>
<span class="cp">#define	XFS_AGF_ROOTS		0x00000010</span>
<span class="cp">#define	XFS_AGF_LEVELS		0x00000020</span>
<span class="cp">#define	XFS_AGF_FLFIRST		0x00000040</span>
<span class="cp">#define	XFS_AGF_FLLAST		0x00000080</span>
<span class="cp">#define	XFS_AGF_FLCOUNT		0x00000100</span>
<span class="cp">#define	XFS_AGF_FREEBLKS	0x00000200</span>
<span class="cp">#define	XFS_AGF_LONGEST		0x00000400</span>
<span class="cp">#define	XFS_AGF_BTREEBLKS	0x00000800</span>
<span class="cp">#define	XFS_AGF_NUM_BITS	12</span>
<span class="cp">#define	XFS_AGF_ALL_BITS	((1 &lt;&lt; XFS_AGF_NUM_BITS) - 1)</span>

<span class="cp">#define XFS_AGF_FLAGS \</span>
<span class="cp">	{ XFS_AGF_MAGICNUM,	&quot;MAGICNUM&quot; }, \</span>
<span class="cp">	{ XFS_AGF_VERSIONNUM,	&quot;VERSIONNUM&quot; }, \</span>
<span class="cp">	{ XFS_AGF_SEQNO,	&quot;SEQNO&quot; }, \</span>
<span class="cp">	{ XFS_AGF_LENGTH,	&quot;LENGTH&quot; }, \</span>
<span class="cp">	{ XFS_AGF_ROOTS,	&quot;ROOTS&quot; }, \</span>
<span class="cp">	{ XFS_AGF_LEVELS,	&quot;LEVELS&quot; }, \</span>
<span class="cp">	{ XFS_AGF_FLFIRST,	&quot;FLFIRST&quot; }, \</span>
<span class="cp">	{ XFS_AGF_FLLAST,	&quot;FLLAST&quot; }, \</span>
<span class="cp">	{ XFS_AGF_FLCOUNT,	&quot;FLCOUNT&quot; }, \</span>
<span class="cp">	{ XFS_AGF_FREEBLKS,	&quot;FREEBLKS&quot; }, \</span>
<span class="cp">	{ XFS_AGF_LONGEST,	&quot;LONGEST&quot; }, \</span>
<span class="cp">	{ XFS_AGF_BTREEBLKS,	&quot;BTREEBLKS&quot; }</span>

<span class="cm">/* disk block (xfs_daddr_t) in the AG */</span>
<span class="cp">#define XFS_AGF_DADDR(mp)	((xfs_daddr_t)(1 &lt;&lt; (mp)-&gt;m_sectbb_log))</span>
<span class="cp">#define	XFS_AGF_BLOCK(mp)	XFS_HDR_BLOCK(mp, XFS_AGF_DADDR(mp))</span>
<span class="cp">#define	XFS_BUF_TO_AGF(bp)	((xfs_agf_t *)((bp)-&gt;b_addr))</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfs_read_agf</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_mount</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_trans</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span>
			<span class="n">xfs_agnumber_t</span> <span class="n">agno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_buf</span> <span class="o">**</span><span class="n">bpp</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Size of the unlinked inode hash table in the agi.</span>
<span class="cm"> */</span>
<span class="cp">#define	XFS_AGI_UNLINKED_BUCKETS	64</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_agi</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Common allocation group header information</span>
<span class="cm">	 */</span>
	<span class="n">__be32</span>		<span class="n">agi_magicnum</span><span class="p">;</span>	<span class="cm">/* magic number == XFS_AGI_MAGIC */</span>
	<span class="n">__be32</span>		<span class="n">agi_versionnum</span><span class="p">;</span>	<span class="cm">/* header version == XFS_AGI_VERSION */</span>
	<span class="n">__be32</span>		<span class="n">agi_seqno</span><span class="p">;</span>	<span class="cm">/* sequence # starting from 0 */</span>
	<span class="n">__be32</span>		<span class="n">agi_length</span><span class="p">;</span>	<span class="cm">/* size in blocks of a.g. */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Inode information</span>
<span class="cm">	 * Inodes are mapped by interpreting the inode number, so no</span>
<span class="cm">	 * mapping data is needed here.</span>
<span class="cm">	 */</span>
	<span class="n">__be32</span>		<span class="n">agi_count</span><span class="p">;</span>	<span class="cm">/* count of allocated inodes */</span>
	<span class="n">__be32</span>		<span class="n">agi_root</span><span class="p">;</span>	<span class="cm">/* root of inode btree */</span>
	<span class="n">__be32</span>		<span class="n">agi_level</span><span class="p">;</span>	<span class="cm">/* levels in inode btree */</span>
	<span class="n">__be32</span>		<span class="n">agi_freecount</span><span class="p">;</span>	<span class="cm">/* number of free inodes */</span>
	<span class="n">__be32</span>		<span class="n">agi_newino</span><span class="p">;</span>	<span class="cm">/* new inode just allocated */</span>
	<span class="n">__be32</span>		<span class="n">agi_dirino</span><span class="p">;</span>	<span class="cm">/* last directory inode chunk */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Hash table of inodes which have been unlinked but are</span>
<span class="cm">	 * still being referenced.</span>
<span class="cm">	 */</span>
	<span class="n">__be32</span>		<span class="n">agi_unlinked</span><span class="p">[</span><span class="n">XFS_AGI_UNLINKED_BUCKETS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">xfs_agi_t</span><span class="p">;</span>

<span class="cp">#define	XFS_AGI_MAGICNUM	0x00000001</span>
<span class="cp">#define	XFS_AGI_VERSIONNUM	0x00000002</span>
<span class="cp">#define	XFS_AGI_SEQNO		0x00000004</span>
<span class="cp">#define	XFS_AGI_LENGTH		0x00000008</span>
<span class="cp">#define	XFS_AGI_COUNT		0x00000010</span>
<span class="cp">#define	XFS_AGI_ROOT		0x00000020</span>
<span class="cp">#define	XFS_AGI_LEVEL		0x00000040</span>
<span class="cp">#define	XFS_AGI_FREECOUNT	0x00000080</span>
<span class="cp">#define	XFS_AGI_NEWINO		0x00000100</span>
<span class="cp">#define	XFS_AGI_DIRINO		0x00000200</span>
<span class="cp">#define	XFS_AGI_UNLINKED	0x00000400</span>
<span class="cp">#define	XFS_AGI_NUM_BITS	11</span>
<span class="cp">#define	XFS_AGI_ALL_BITS	((1 &lt;&lt; XFS_AGI_NUM_BITS) - 1)</span>

<span class="cm">/* disk block (xfs_daddr_t) in the AG */</span>
<span class="cp">#define XFS_AGI_DADDR(mp)	((xfs_daddr_t)(2 &lt;&lt; (mp)-&gt;m_sectbb_log))</span>
<span class="cp">#define	XFS_AGI_BLOCK(mp)	XFS_HDR_BLOCK(mp, XFS_AGI_DADDR(mp))</span>
<span class="cp">#define	XFS_BUF_TO_AGI(bp)	((xfs_agi_t *)((bp)-&gt;b_addr))</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">xfs_read_agi</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfs_mount</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_trans</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span>
				<span class="n">xfs_agnumber_t</span> <span class="n">agno</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfs_buf</span> <span class="o">**</span><span class="n">bpp</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The third a.g. block contains the a.g. freelist, an array</span>
<span class="cm"> * of block pointers to blocks owned by the allocation btree code.</span>
<span class="cm"> */</span>
<span class="cp">#define XFS_AGFL_DADDR(mp)	((xfs_daddr_t)(3 &lt;&lt; (mp)-&gt;m_sectbb_log))</span>
<span class="cp">#define	XFS_AGFL_BLOCK(mp)	XFS_HDR_BLOCK(mp, XFS_AGFL_DADDR(mp))</span>
<span class="cp">#define XFS_AGFL_SIZE(mp)	((mp)-&gt;m_sb.sb_sectsize / sizeof(xfs_agblock_t))</span>
<span class="cp">#define	XFS_BUF_TO_AGFL(bp)	((xfs_agfl_t *)((bp)-&gt;b_addr))</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_agfl</span> <span class="p">{</span>
	<span class="n">__be32</span>		<span class="n">agfl_bno</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* actually XFS_AGFL_SIZE(mp) */</span>
<span class="p">}</span> <span class="n">xfs_agfl_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Per-ag incore structure, copies of information in agf and agi,</span>
<span class="cm"> * to improve the performance of allocation group selection.</span>
<span class="cm"> */</span>
<span class="cp">#define XFS_PAGB_NUM_SLOTS	128</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">xfs_perag</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xfs_mount</span> <span class="o">*</span><span class="n">pag_mount</span><span class="p">;</span>	<span class="cm">/* owner filesystem */</span>
	<span class="n">xfs_agnumber_t</span>	<span class="n">pag_agno</span><span class="p">;</span>	<span class="cm">/* AG this structure belongs to */</span>
	<span class="n">atomic_t</span>	<span class="n">pag_ref</span><span class="p">;</span>	<span class="cm">/* perag reference count */</span>
	<span class="kt">char</span>		<span class="n">pagf_init</span><span class="p">;</span>	<span class="cm">/* this agf&#39;s entry is initialized */</span>
	<span class="kt">char</span>		<span class="n">pagi_init</span><span class="p">;</span>	<span class="cm">/* this agi&#39;s entry is initialized */</span>
	<span class="kt">char</span>		<span class="n">pagf_metadata</span><span class="p">;</span>	<span class="cm">/* the agf is preferred to be metadata */</span>
	<span class="kt">char</span>		<span class="n">pagi_inodeok</span><span class="p">;</span>	<span class="cm">/* The agi is ok for inodes */</span>
	<span class="n">__uint8_t</span>	<span class="n">pagf_levels</span><span class="p">[</span><span class="n">XFS_BTNUM_AGF</span><span class="p">];</span>
					<span class="cm">/* # of levels in bno &amp; cnt btree */</span>
	<span class="n">__uint32_t</span>	<span class="n">pagf_flcount</span><span class="p">;</span>	<span class="cm">/* count of blocks in freelist */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">pagf_freeblks</span><span class="p">;</span>	<span class="cm">/* total free blocks */</span>
	<span class="n">xfs_extlen_t</span>	<span class="n">pagf_longest</span><span class="p">;</span>	<span class="cm">/* longest free space */</span>
	<span class="n">__uint32_t</span>	<span class="n">pagf_btreeblks</span><span class="p">;</span>	<span class="cm">/* # of blocks held in AGF btrees */</span>
	<span class="n">xfs_agino_t</span>	<span class="n">pagi_freecount</span><span class="p">;</span>	<span class="cm">/* number of free inodes */</span>
	<span class="n">xfs_agino_t</span>	<span class="n">pagi_count</span><span class="p">;</span>	<span class="cm">/* number of allocated inodes */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Inode allocation search lookup optimisation.</span>
<span class="cm">	 * If the pagino matches, the search for new inodes</span>
<span class="cm">	 * doesn&#39;t need to search the near ones again straight away</span>
<span class="cm">	 */</span>
	<span class="n">xfs_agino_t</span>	<span class="n">pagl_pagino</span><span class="p">;</span>
	<span class="n">xfs_agino_t</span>	<span class="n">pagl_leftrec</span><span class="p">;</span>
	<span class="n">xfs_agino_t</span>	<span class="n">pagl_rightrec</span><span class="p">;</span>
<span class="cp">#ifdef __KERNEL__</span>
	<span class="n">spinlock_t</span>	<span class="n">pagb_lock</span><span class="p">;</span>	<span class="cm">/* lock for pagb_tree */</span>
	<span class="k">struct</span> <span class="n">rb_root</span>	<span class="n">pagb_tree</span><span class="p">;</span>	<span class="cm">/* ordered tree of busy extents */</span>

	<span class="n">atomic_t</span>        <span class="n">pagf_fstrms</span><span class="p">;</span>    <span class="cm">/* # of filestreams active in this AG */</span>

	<span class="n">spinlock_t</span>	<span class="n">pag_ici_lock</span><span class="p">;</span>	<span class="cm">/* incore inode cache lock */</span>
	<span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="n">pag_ici_root</span><span class="p">;</span>	<span class="cm">/* incore inode cache root */</span>
	<span class="kt">int</span>		<span class="n">pag_ici_reclaimable</span><span class="p">;</span>	<span class="cm">/* reclaimable inodes */</span>
	<span class="k">struct</span> <span class="n">mutex</span>	<span class="n">pag_ici_reclaim_lock</span><span class="p">;</span>	<span class="cm">/* serialisation point */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">pag_ici_reclaim_cursor</span><span class="p">;</span>	<span class="cm">/* reclaim restart point */</span>

	<span class="cm">/* buffer cache index */</span>
	<span class="n">spinlock_t</span>	<span class="n">pag_buf_lock</span><span class="p">;</span>	<span class="cm">/* lock for pag_buf_tree */</span>
	<span class="k">struct</span> <span class="n">rb_root</span>	<span class="n">pag_buf_tree</span><span class="p">;</span>	<span class="cm">/* ordered tree of active buffers */</span>

	<span class="cm">/* for rcu-safe freeing */</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>	<span class="n">rcu_head</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int</span>		<span class="n">pagb_count</span><span class="p">;</span>	<span class="cm">/* pagb slots in use */</span>
<span class="p">}</span> <span class="n">xfs_perag_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * tags for inode radix tree</span>
<span class="cm"> */</span>
<span class="cp">#define XFS_ICI_NO_TAG		(-1)	</span><span class="cm">/* special flag for an untagged lookup</span>
<span class="cm">					   in xfs_inode_ag_iterator */</span><span class="cp"></span>
<span class="cp">#define XFS_ICI_RECLAIM_TAG	0	</span><span class="cm">/* inode is to be reclaimed */</span><span class="cp"></span>

<span class="cp">#define	XFS_AG_MAXLEVELS(mp)		((mp)-&gt;m_ag_maxlevels)</span>
<span class="cp">#define	XFS_MIN_FREELIST_RAW(bl,cl,mp)	\</span>
<span class="cp">	(MIN(bl + 1, XFS_AG_MAXLEVELS(mp)) + MIN(cl + 1, XFS_AG_MAXLEVELS(mp)))</span>
<span class="cp">#define	XFS_MIN_FREELIST(a,mp)		\</span>
<span class="cp">	(XFS_MIN_FREELIST_RAW(		\</span>
<span class="cp">		be32_to_cpu((a)-&gt;agf_levels[XFS_BTNUM_BNOi]), \</span>
<span class="cp">		be32_to_cpu((a)-&gt;agf_levels[XFS_BTNUM_CNTi]), mp))</span>
<span class="cp">#define	XFS_MIN_FREELIST_PAG(pag,mp)	\</span>
<span class="cp">	(XFS_MIN_FREELIST_RAW(		\</span>
<span class="cp">		(unsigned int)(pag)-&gt;pagf_levels[XFS_BTNUM_BNOi], \</span>
<span class="cp">		(unsigned int)(pag)-&gt;pagf_levels[XFS_BTNUM_CNTi], mp))</span>

<span class="cp">#define XFS_AGB_TO_FSB(mp,agno,agbno)	\</span>
<span class="cp">	(((xfs_fsblock_t)(agno) &lt;&lt; (mp)-&gt;m_sb.sb_agblklog) | (agbno))</span>
<span class="cp">#define	XFS_FSB_TO_AGNO(mp,fsbno)	\</span>
<span class="cp">	((xfs_agnumber_t)((fsbno) &gt;&gt; (mp)-&gt;m_sb.sb_agblklog))</span>
<span class="cp">#define	XFS_FSB_TO_AGBNO(mp,fsbno)	\</span>
<span class="cp">	((xfs_agblock_t)((fsbno) &amp; xfs_mask32lo((mp)-&gt;m_sb.sb_agblklog)))</span>
<span class="cp">#define	XFS_AGB_TO_DADDR(mp,agno,agbno)	\</span>
<span class="cp">	((xfs_daddr_t)XFS_FSB_TO_BB(mp, \</span>
<span class="cp">		(xfs_fsblock_t)(agno) * (mp)-&gt;m_sb.sb_agblocks + (agbno)))</span>
<span class="cp">#define	XFS_AG_DADDR(mp,agno,d)		(XFS_AGB_TO_DADDR(mp, agno, 0) + (d))</span>

<span class="cm">/*</span>
<span class="cm"> * For checking for bad ranges of xfs_daddr_t&#39;s, covering multiple</span>
<span class="cm"> * allocation groups or a single xfs_daddr_t that&#39;s a superblock copy.</span>
<span class="cm"> */</span>
<span class="cp">#define	XFS_AG_CHECK_DADDR(mp,d,len)	\</span>
<span class="cp">	((len) == 1 ? \</span>
<span class="cp">	    ASSERT((d) == XFS_SB_DADDR || \</span>
<span class="cp">		   xfs_daddr_to_agbno(mp, d) != XFS_SB_DADDR) : \</span>
<span class="cp">	    ASSERT(xfs_daddr_to_agno(mp, d) == \</span>
<span class="cp">		   xfs_daddr_to_agno(mp, (d) + (len) - 1)))</span>

<span class="cp">#endif	</span><span class="cm">/* __XFS_AG_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
