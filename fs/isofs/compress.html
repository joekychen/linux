<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › isofs › compress.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>compress.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- linux-c -*- ------------------------------------------------------- *</span>
<span class="cm"> *   </span>
<span class="cm"> *   Copyright 2001 H. Peter Anvin - All Rights Reserved</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,</span>
<span class="cm"> *   USA; either version 2 of the License, or (at your option) any later</span>
<span class="cm"> *   version; incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> * ----------------------------------------------------------------------- */</span>

<span class="cm">/*</span>
<span class="cm"> * linux/fs/isofs/compress.c</span>
<span class="cm"> *</span>
<span class="cm"> * Transparent decompression of files on an iso9660 filesystem</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>

<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/zlib.h&gt;</span>

<span class="cp">#include &quot;isofs.h&quot;</span>
<span class="cp">#include &quot;zisofs.h&quot;</span>

<span class="cm">/* This should probably be global. */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">zisofs_sink_page</span><span class="p">[</span><span class="n">PAGE_CACHE_SIZE</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * This contains the zlib memory allocation and the mutex for the</span>
<span class="cm"> * allocation; this avoids failures at block-decompression time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">zisofs_zlib_workspace</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">zisofs_zlib_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Read data of @inode from @block_start to @block_end and uncompress</span>
<span class="cm"> * to one zisofs block. Store the data in the @pages array with @pcount</span>
<span class="cm"> * entries. Start storing at offset @poffset of the first page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">loff_t</span> <span class="nf">zisofs_uncompress_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">block_start</span><span class="p">,</span>
				      <span class="n">loff_t</span> <span class="n">block_end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pcount</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">poffset</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="o">*</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">zisofs_block_shift</span> <span class="o">=</span> <span class="n">ISOFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_format_parm</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="n">ISOFS_BUFFER_SIZE</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufshift</span> <span class="o">=</span> <span class="n">ISOFS_BUFFER_BITS</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufmask</span> <span class="o">=</span> <span class="n">bufsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">block_end</span> <span class="o">-</span> <span class="n">block_start</span><span class="p">;</span>
	<span class="n">z_stream</span> <span class="n">stream</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">total_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
			    <span class="p">.</span><span class="n">avail_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
			    <span class="p">.</span><span class="n">avail_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">zerr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">needblocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_size</span> <span class="o">+</span> <span class="p">(</span><span class="n">block_start</span> <span class="o">&amp;</span> <span class="n">bufmask</span><span class="p">)</span> <span class="o">+</span> <span class="n">bufmask</span><span class="p">)</span>
				<span class="o">&gt;&gt;</span> <span class="n">bufshift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">haveblocks</span><span class="p">;</span>
	<span class="n">blkcnt_t</span> <span class="n">blocknum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bhs</span><span class="p">[</span><span class="n">needblocks</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">curbh</span><span class="p">,</span> <span class="n">curpage</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block_size</span> <span class="o">&gt;</span> <span class="n">deflateBound</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">zisofs_block_shift</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Empty block? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pcount</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span><span class="n">pcount</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Because zlib is not thread-safe, do all the I/O at the top. */</span>
	<span class="n">blocknum</span> <span class="o">=</span> <span class="n">block_start</span> <span class="o">&gt;&gt;</span> <span class="n">bufshift</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bhs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">needblocks</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">));</span>
	<span class="n">haveblocks</span> <span class="o">=</span> <span class="n">isofs_get_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">blocknum</span><span class="p">,</span> <span class="n">bhs</span><span class="p">,</span> <span class="n">needblocks</span><span class="p">);</span>
	<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">haveblocks</span><span class="p">,</span> <span class="n">bhs</span><span class="p">);</span>

	<span class="n">curbh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">curpage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * First block is special since it may be fractional.  We also wait for</span>
<span class="cm">	 * it before grabbing the zlib mutex; odds are that the subsequent</span>
<span class="cm">	 * blocks are going to come in in short order so we don&#39;t hold the zlib</span>
<span class="cm">	 * mutex longer than necessary.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bhs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">goto</span> <span class="n">b_eio</span><span class="p">;</span>

	<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">b_eio</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">stream</span><span class="p">.</span><span class="n">workspace</span> <span class="o">=</span> <span class="n">zisofs_zlib_workspace</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zisofs_zlib_lock</span><span class="p">);</span>
		
	<span class="n">zerr</span> <span class="o">=</span> <span class="n">zlib_inflateInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zerr</span> <span class="o">!=</span> <span class="n">Z_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zerr</span> <span class="o">==</span> <span class="n">Z_MEM_ERROR</span><span class="p">)</span>
			<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;zisofs: zisofs_inflateInit returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">zerr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">z_eio</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">curpage</span> <span class="o">&lt;</span> <span class="n">pcount</span> <span class="o">&amp;&amp;</span> <span class="n">curbh</span> <span class="o">&lt;</span> <span class="n">haveblocks</span> <span class="o">&amp;&amp;</span>
	       <span class="n">zerr</span> <span class="o">!=</span> <span class="n">Z_STREAM_END</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stream</span><span class="p">.</span><span class="n">avail_out</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">curpage</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">stream</span><span class="p">.</span><span class="n">next_out</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">curpage</span><span class="p">])</span>
						<span class="o">+</span> <span class="n">poffset</span><span class="p">;</span>
				<span class="n">stream</span><span class="p">.</span><span class="n">avail_out</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">poffset</span><span class="p">;</span>
				<span class="n">poffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">stream</span><span class="p">.</span><span class="n">next_out</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">zisofs_sink_page</span><span class="p">;</span>
				<span class="n">stream</span><span class="p">.</span><span class="n">avail_out</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stream</span><span class="p">.</span><span class="n">avail_in</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bhs</span><span class="p">[</span><span class="n">curbh</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bhs</span><span class="p">[</span><span class="n">curbh</span><span class="p">]))</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">stream</span><span class="p">.</span><span class="n">next_in</span>  <span class="o">=</span> <span class="n">bhs</span><span class="p">[</span><span class="n">curbh</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span>
						<span class="p">(</span><span class="n">block_start</span> <span class="o">&amp;</span> <span class="n">bufmask</span><span class="p">);</span>
			<span class="n">stream</span><span class="p">.</span><span class="n">avail_in</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">bufsize</span> <span class="o">-</span>
						<span class="p">(</span><span class="n">block_start</span> <span class="o">&amp;</span> <span class="n">bufmask</span><span class="p">),</span>
						<span class="n">block_size</span><span class="p">);</span>
			<span class="n">block_size</span> <span class="o">-=</span> <span class="n">stream</span><span class="p">.</span><span class="n">avail_in</span><span class="p">;</span>
			<span class="n">block_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">avail_out</span> <span class="o">&amp;&amp;</span> <span class="n">stream</span><span class="p">.</span><span class="n">avail_in</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">zerr</span> <span class="o">=</span> <span class="n">zlib_inflate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">,</span> <span class="n">Z_SYNC_FLUSH</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">zerr</span> <span class="o">==</span> <span class="n">Z_BUF_ERROR</span> <span class="o">&amp;&amp;</span> <span class="n">stream</span><span class="p">.</span><span class="n">avail_in</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">zerr</span> <span class="o">==</span> <span class="n">Z_STREAM_END</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">zerr</span> <span class="o">!=</span> <span class="n">Z_OK</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* EOF, error, or trying to read beyond end of input */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">zerr</span> <span class="o">==</span> <span class="n">Z_MEM_ERROR</span><span class="p">)</span>
					<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
					       <span class="s">&quot;zisofs: zisofs_inflate returned&quot;</span>
					       <span class="s">&quot; %d, inode = %lu,&quot;</span>
					       <span class="s">&quot; page idx = %d, bh idx = %d,&quot;</span>
					       <span class="s">&quot; avail_in = %d,&quot;</span>
					       <span class="s">&quot; avail_out = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">zerr</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">curpage</span><span class="p">,</span>
					       <span class="n">curbh</span><span class="p">,</span> <span class="n">stream</span><span class="p">.</span><span class="n">avail_in</span><span class="p">,</span>
					       <span class="n">stream</span><span class="p">.</span><span class="n">avail_out</span><span class="p">);</span>
					<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">goto</span> <span class="n">inflate_out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stream</span><span class="p">.</span><span class="n">avail_out</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This page completed */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">curpage</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">curpage</span><span class="p">]);</span>
				<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">curpage</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="n">curpage</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stream</span><span class="p">.</span><span class="n">avail_in</span><span class="p">)</span>
			<span class="n">curbh</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">inflate_out:</span>
	<span class="n">zlib_inflateEnd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">);</span>

<span class="nl">z_eio:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zisofs_zlib_lock</span><span class="p">);</span>

<span class="nl">b_eio:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">haveblocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">stream</span><span class="p">.</span><span class="n">total_out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Uncompress data so that pages[full_page] is fully uptodate and possibly</span>
<span class="cm"> * fills in other pages if we have data for them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">zisofs_fill_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">full_page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pcount</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">start_off</span><span class="p">,</span> <span class="n">end_off</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header_size</span> <span class="o">=</span> <span class="n">ISOFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_format_parm</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">zisofs_block_shift</span> <span class="o">=</span> <span class="n">ISOFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_format_parm</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blockptr</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">poffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">blkcnt_t</span> <span class="n">cstart_block</span><span class="p">,</span> <span class="n">cend_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blkbits</span> <span class="o">=</span> <span class="n">ISOFS_BUFFER_BITS</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blksize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">[</span><span class="n">full_page</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We want to read at least &#39;full_page&#39; page. Because we have to</span>
<span class="cm">	 * uncompress the whole compression block anyway, fill the surrounding</span>
<span class="cm">	 * pages with the data we have anyway...</span>
<span class="cm">	 */</span>
	<span class="n">start_off</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">full_page</span><span class="p">]);</span>
	<span class="n">end_off</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">loff_t</span><span class="p">,</span> <span class="n">start_off</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>

	<span class="n">cstart_block</span> <span class="o">=</span> <span class="n">start_off</span> <span class="o">&gt;&gt;</span> <span class="n">zisofs_block_shift</span><span class="p">;</span>
	<span class="n">cend_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_off</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">zisofs_block_shift</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">&gt;&gt;</span> <span class="n">zisofs_block_shift</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">start_off</span> <span class="o">-</span> <span class="p">(</span><span class="n">full_page</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">!=</span>
		<span class="p">((</span><span class="n">cstart_block</span> <span class="o">&lt;&lt;</span> <span class="n">zisofs_block_shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_CACHE_MASK</span><span class="p">));</span>

	<span class="cm">/* Find the pointer to this specific chunk */</span>
	<span class="cm">/* Note: we&#39;re not using isonum_731() here because the data is known aligned */</span>
	<span class="cm">/* Note: header_size is in 32-bit words (4 bytes) */</span>
	<span class="n">blockptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">header_size</span> <span class="o">+</span> <span class="n">cstart_block</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">isofs_bread</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">blockptr</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">block_start</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span>
				<span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="p">(</span><span class="n">blockptr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))));</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cstart_block</span> <span class="o">&lt;</span> <span class="n">cend_block</span> <span class="o">&amp;&amp;</span> <span class="n">pcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Load end of the compressed block in the file */</span>
		<span class="n">blockptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* Traversed to next block? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">blockptr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

			<span class="n">bh</span> <span class="o">=</span> <span class="n">isofs_bread</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">blockptr</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">block_end</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span>
				<span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="p">(</span><span class="n">blockptr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_start</span> <span class="o">&gt;</span> <span class="n">block_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">zisofs_uncompress_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">,</span>
					      <span class="n">pcount</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">poffset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
		<span class="n">poffset</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">pages</span> <span class="o">+=</span> <span class="n">poffset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">pcount</span> <span class="o">-=</span> <span class="n">poffset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">full_page</span> <span class="o">-=</span> <span class="n">poffset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">poffset</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Did we finish reading the page we really wanted</span>
<span class="cm">			 * to read?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">full_page</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
		<span class="n">cstart_block</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">poffset</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="o">*</span><span class="n">pages</span><span class="p">)</span> <span class="o">+</span> <span class="n">poffset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">poffset</span><span class="p">);</span>
		<span class="n">flush_dcache_page</span><span class="p">(</span><span class="o">*</span><span class="n">pages</span><span class="p">);</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="o">*</span><span class="n">pages</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When decompressing, we typically obtain more than one page</span>
<span class="cm"> * per reference.  We inject the additional pages into the page</span>
<span class="cm"> * cache as a form of readahead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">zisofs_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">pcount</span><span class="p">,</span> <span class="n">full_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">zisofs_block_shift</span> <span class="o">=</span> <span class="n">ISOFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_format_parm</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">zisofs_pages_per_cblock</span> <span class="o">=</span>
		<span class="n">PAGE_CACHE_SHIFT</span> <span class="o">&lt;=</span> <span class="n">zisofs_block_shift</span> <span class="o">?</span>
		<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">zisofs_block_shift</span> <span class="o">-</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">))</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">[</span><span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">zisofs_pages_per_cblock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)];</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">;</span>

	<span class="n">end_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this page is wholly outside i_size we just return zero;</span>
<span class="cm">	 * do_generic_file_read() will handle this for us</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">end_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">&lt;=</span> <span class="n">zisofs_block_shift</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We have already been given one page, this is the one</span>
<span class="cm">		   we must do. */</span>
		<span class="n">full_page</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">zisofs_pages_per_cblock</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">pcount</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">zisofs_pages_per_cblock</span><span class="p">,</span>
			<span class="n">end_index</span> <span class="o">-</span> <span class="p">(</span><span class="n">index</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">zisofs_pages_per_cblock</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
		<span class="n">index</span> <span class="o">-=</span> <span class="n">full_page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">full_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pages</span><span class="p">[</span><span class="n">full_page</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pcount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">full_page</span><span class="p">)</span>
			<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">grab_cache_page_nowait</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">ClearPageError</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">kmap</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">zisofs_fill_pages</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">full_page</span><span class="p">,</span> <span class="n">pcount</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>

	<span class="cm">/* Release any residual pages, do not SetPageUptodate */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pcount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">full_page</span> <span class="o">&amp;&amp;</span> <span class="n">err</span><span class="p">)</span>
				<span class="n">SetPageError</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">full_page</span><span class="p">)</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>			

	<span class="cm">/* At this point, err contains 0 or -EIO depending on the &quot;critical&quot; page */</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">zisofs_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span> <span class="o">=</span> <span class="n">zisofs_readpage</span><span class="p">,</span>
	<span class="cm">/* No sync_page operation supported? */</span>
	<span class="cm">/* No bmap operation supported */</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">zisofs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">zisofs_zlib_workspace</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">zlib_inflate_workspacesize</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">zisofs_zlib_workspace</span> <span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">zisofs_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">zisofs_zlib_workspace</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
