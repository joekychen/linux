<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › eventpoll.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>eventpoll.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  fs/eventpoll.c (Efficient event retrieval implementation)</span>
<span class="cm"> *  Copyright (C) 2001,...,2009	 Davide Libenzi</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  Davide Libenzi &lt;davidel@xmailserver.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/eventpoll.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/anon_inodes.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/mman.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * There are three level of locking required by epoll :</span>
<span class="cm"> *</span>
<span class="cm"> * 1) epmutex (mutex)</span>
<span class="cm"> * 2) ep-&gt;mtx (mutex)</span>
<span class="cm"> * 3) ep-&gt;lock (spinlock)</span>
<span class="cm"> *</span>
<span class="cm"> * The acquire order is the one listed above, from 1 to 3.</span>
<span class="cm"> * We need a spinlock (ep-&gt;lock) because we manipulate objects</span>
<span class="cm"> * from inside the poll callback, that might be triggered from</span>
<span class="cm"> * a wake_up() that in turn might be called from IRQ context.</span>
<span class="cm"> * So we can&#39;t sleep inside the poll callback and hence we need</span>
<span class="cm"> * a spinlock. During the event transfer loop (from kernel to</span>
<span class="cm"> * user space) we could end up sleeping due a copy_to_user(), so</span>
<span class="cm"> * we need a lock that will allow us to sleep. This lock is a</span>
<span class="cm"> * mutex (ep-&gt;mtx). It is acquired during the event transfer loop,</span>
<span class="cm"> * during epoll_ctl(EPOLL_CTL_DEL) and during eventpoll_release_file().</span>
<span class="cm"> * Then we also need a global mutex to serialize eventpoll_release_file()</span>
<span class="cm"> * and ep_free().</span>
<span class="cm"> * This mutex is acquired by ep_free() during the epoll file</span>
<span class="cm"> * cleanup path and it is also acquired by eventpoll_release_file()</span>
<span class="cm"> * if a file has been pushed inside an epoll set and it is then</span>
<span class="cm"> * close()d without a previous call to epoll_ctl(EPOLL_CTL_DEL).</span>
<span class="cm"> * It is also acquired when inserting an epoll fd onto another epoll</span>
<span class="cm"> * fd. We do this so that we walk the epoll tree and ensure that this</span>
<span class="cm"> * insertion does not create a cycle of epoll file descriptors, which</span>
<span class="cm"> * could lead to deadlock. We need a global mutex to prevent two</span>
<span class="cm"> * simultaneous inserts (A into B and B into A) from racing and</span>
<span class="cm"> * constructing a cycle without either insert observing that it is</span>
<span class="cm"> * going to.</span>
<span class="cm"> * It is necessary to acquire multiple &quot;ep-&gt;mtx&quot;es at once in the</span>
<span class="cm"> * case when one epoll fd is added to another. In this case, we</span>
<span class="cm"> * always acquire the locks in the order of nesting (i.e. after</span>
<span class="cm"> * epoll_ctl(e1, EPOLL_CTL_ADD, e2), e1-&gt;mtx will always be acquired</span>
<span class="cm"> * before e2-&gt;mtx). Since we disallow cycles of epoll file</span>
<span class="cm"> * descriptors, this ensures that the mutexes are well-ordered. In</span>
<span class="cm"> * order to communicate this nesting to lockdep, when walking a tree</span>
<span class="cm"> * of epoll file descriptors, we use the current recursion depth as</span>
<span class="cm"> * the lockdep subkey.</span>
<span class="cm"> * It is possible to drop the &quot;ep-&gt;mtx&quot; and to use the global</span>
<span class="cm"> * mutex &quot;epmutex&quot; (together with &quot;ep-&gt;lock&quot;) to have it working,</span>
<span class="cm"> * but having &quot;ep-&gt;mtx&quot; will make the interface more scalable.</span>
<span class="cm"> * Events that require holding &quot;epmutex&quot; are very rare, while for</span>
<span class="cm"> * normal operations the epoll private &quot;ep-&gt;mtx&quot; will guarantee</span>
<span class="cm"> * a better scalability.</span>
<span class="cm"> */</span>

<span class="cm">/* Epoll private bits inside the event mask */</span>
<span class="cp">#define EP_PRIVATE_BITS (EPOLLWAKEUP | EPOLLONESHOT | EPOLLET)</span>

<span class="cm">/* Maximum number of nesting allowed inside epoll sets */</span>
<span class="cp">#define EP_MAX_NESTS 4</span>

<span class="cp">#define EP_MAX_EVENTS (INT_MAX / sizeof(struct epoll_event))</span>

<span class="cp">#define EP_UNACTIVE_PTR ((void *) -1L)</span>

<span class="cp">#define EP_ITEM_COST (sizeof(struct epitem) + sizeof(struct eppoll_entry))</span>

<span class="k">struct</span> <span class="n">epoll_filefd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Structure used to track possible nested calls, for too deep recursions</span>
<span class="cm"> * and loop cycles.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nested_call_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">llink</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is used as collector for nested calls, to check for</span>
<span class="cm"> * maximum recursion dept and loop cycles.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nested_calls</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tasks_call_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Each file descriptor added to the eventpoll interface will</span>
<span class="cm"> * have an entry of this type linked to the &quot;rbr&quot; RB tree.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">epitem</span> <span class="p">{</span>
	<span class="cm">/* RB tree node used to link this structure to the eventpoll RB tree */</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rbn</span><span class="p">;</span>

	<span class="cm">/* List header used to link this structure to the eventpoll ready list */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rdllink</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span>
<span class="cm">	 * single linked chain of items.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* The file descriptor information this item refers to */</span>
	<span class="k">struct</span> <span class="n">epoll_filefd</span> <span class="n">ffd</span><span class="p">;</span>

	<span class="cm">/* Number of active wait queue attached to poll operations */</span>
	<span class="kt">int</span> <span class="n">nwait</span><span class="p">;</span>

	<span class="cm">/* List containing poll wait queues */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pwqlist</span><span class="p">;</span>

	<span class="cm">/* The &quot;container&quot; of this item */</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="cm">/* List header used to link this item to the &quot;struct file&quot; items list */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fllink</span><span class="p">;</span>

	<span class="cm">/* wakeup_source used when EPOLLWAKEUP is set */</span>
	<span class="k">struct</span> <span class="n">wakeup_source</span> <span class="o">*</span><span class="n">ws</span><span class="p">;</span>

	<span class="cm">/* The structure that describe the interested events and the source fd */</span>
	<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is stored inside the &quot;private_data&quot; member of the file</span>
<span class="cm"> * structure and represents the main data structure for the eventpoll</span>
<span class="cm"> * interface.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">eventpoll</span> <span class="p">{</span>
	<span class="cm">/* Protect the access to this structure */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This mutex is used to ensure that files are not removed</span>
<span class="cm">	 * while epoll is using them. This is held during the event</span>
<span class="cm">	 * collection loop, the file cleanup path, the epoll file exit</span>
<span class="cm">	 * code and the ctl operations.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>

	<span class="cm">/* Wait queue used by sys_epoll_wait() */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wq</span><span class="p">;</span>

	<span class="cm">/* Wait queue used by file-&gt;poll() */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">poll_wait</span><span class="p">;</span>

	<span class="cm">/* List of ready file descriptors */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rdllist</span><span class="p">;</span>

	<span class="cm">/* RB tree root used to store monitored fd structs */</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">rbr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a single linked list that chains all the &quot;struct epitem&quot; that</span>
<span class="cm">	 * happened while transferring ready events to userspace w/out</span>
<span class="cm">	 * holding -&gt;lock.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">ovflist</span><span class="p">;</span>

	<span class="cm">/* wakeup_source used when ep_scan_ready_list is running */</span>
	<span class="k">struct</span> <span class="n">wakeup_source</span> <span class="o">*</span><span class="n">ws</span><span class="p">;</span>

	<span class="cm">/* The user that created the eventpoll descriptor */</span>
	<span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

	<span class="cm">/* used to optimize loop detection check */</span>
	<span class="kt">int</span> <span class="n">visited</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">visited_list_link</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Wait structure used by the poll hooks */</span>
<span class="k">struct</span> <span class="n">eppoll_entry</span> <span class="p">{</span>
	<span class="cm">/* List header used to link this structure to the &quot;struct epitem&quot; */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">llink</span><span class="p">;</span>

	<span class="cm">/* The &quot;base&quot; pointer is set to the container &quot;struct epitem&quot; */</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait queue item that will be linked to the target file wait</span>
<span class="cm">	 * queue head.</span>
<span class="cm">	 */</span>
	<span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span>

	<span class="cm">/* The wait queue head that linked the &quot;wait&quot; wait queue item */</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">whead</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Wrapper struct used by poll queueing */</span>
<span class="k">struct</span> <span class="n">ep_pqueue</span> <span class="p">{</span>
	<span class="n">poll_table</span> <span class="n">pt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Used by the ep_send_events() function as callback private data */</span>
<span class="k">struct</span> <span class="n">ep_send_events_data</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">maxevents</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">events</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Configuration options available inside /proc/sys/fs/epoll/</span>
<span class="cm"> */</span>
<span class="cm">/* Maximum number of epoll watched descriptors, per user */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">max_user_watches</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This mutex is used to serialize ep_free() and eventpoll_release_file().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">epmutex</span><span class="p">);</span>

<span class="cm">/* Used to check for epoll file descriptor inclusion loops */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nested_calls</span> <span class="n">poll_loop_ncalls</span><span class="p">;</span>

<span class="cm">/* Used for safe wake up implementation */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nested_calls</span> <span class="n">poll_safewake_ncalls</span><span class="p">;</span>

<span class="cm">/* Used to call file&#39;s f_op-&gt;poll() under the nested calls boundaries */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nested_calls</span> <span class="n">poll_readywalk_ncalls</span><span class="p">;</span>

<span class="cm">/* Slab cache used to allocate &quot;struct epitem&quot; */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">epi_cache</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* Slab cache used to allocate &quot;struct eppoll_entry&quot; */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">pwq_cache</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* Visited nodes during ep_loop_check(), so we can unset them when we finish */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">visited_list</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * List of files with newly added links, where we may need to limit the number</span>
<span class="cm"> * of emanating paths. Protected by the epmutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tfile_check_list</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SYSCTL</span>

<span class="cp">#include &lt;linux/sysctl.h&gt;</span>

<span class="k">static</span> <span class="kt">long</span> <span class="n">zero</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">long_max</span> <span class="o">=</span> <span class="n">LONG_MAX</span><span class="p">;</span>

<span class="n">ctl_table</span> <span class="n">epoll_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">procname</span>	<span class="o">=</span> <span class="s">&quot;max_user_watches&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">max_user_watches</span><span class="p">,</span>
		<span class="p">.</span><span class="n">maxlen</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">max_user_watches</span><span class="p">),</span>
		<span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="p">.</span><span class="n">proc_handler</span>	<span class="o">=</span> <span class="n">proc_doulongvec_minmax</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra1</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">zero</span><span class="p">,</span>
		<span class="p">.</span><span class="n">extra2</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">long_max</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSCTL */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">eventpoll_fops</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_file_epoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">eventpoll_fops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Setup the structure that is used as key for the RB tree */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ep_set_ffd</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_filefd</span> <span class="o">*</span><span class="n">ffd</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ffd</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="n">ffd</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Compare RB tree keys */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ep_cmp_ffd</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_filefd</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">epoll_filefd</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">&gt;</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">?</span> <span class="o">+</span><span class="mi">1</span><span class="o">:</span>
	        <span class="p">(</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">-</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Tells us if the item is currently linked */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ep_is_linked</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">eppoll_entry</span> <span class="o">*</span><span class="nf">ep_pwq_from_wait</span><span class="p">(</span><span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">eppoll_entry</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Get the &quot;struct epitem&quot; from a wait queue pointer */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="nf">ep_item_from_wait</span><span class="p">(</span><span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">eppoll_entry</span><span class="p">,</span> <span class="n">wait</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get the &quot;struct epitem&quot; from an epoll queue wrapper */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="nf">ep_item_from_epqueue</span><span class="p">(</span><span class="n">poll_table</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ep_pqueue</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">epi</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Tells if the epoll_ctl(2) operation needs an event copy from userspace */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ep_op_has_event</span><span class="p">(</span><span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">op</span> <span class="o">!=</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize the poll safe wake up structure */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep_nested_calls_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">nested_calls</span> <span class="o">*</span><span class="n">ncalls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncalls</span><span class="o">-&gt;</span><span class="n">tasks_call_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncalls</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep_events_available - Checks if ready events might be available.</span>
<span class="cm"> *</span>
<span class="cm"> * @ep: Pointer to the eventpoll context.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: Returns a value different than zero if ready events are available,</span>
<span class="cm"> *          or zero otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ep_events_available</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">)</span> <span class="o">||</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">!=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep_call_nested - Perform a bound (possibly) nested call, by checking</span>
<span class="cm"> *                  that the recursion limit is not exceeded, and that</span>
<span class="cm"> *                  the same nested call (by the meaning of same cookie) is</span>
<span class="cm"> *                  no re-entered.</span>
<span class="cm"> *</span>
<span class="cm"> * @ncalls: Pointer to the nested_calls structure to be used for this call.</span>
<span class="cm"> * @max_nests: Maximum number of allowed nesting calls.</span>
<span class="cm"> * @nproc: Nested call core function pointer.</span>
<span class="cm"> * @priv: Opaque data to be passed to the @nproc callback.</span>
<span class="cm"> * @cookie: Cookie to be used to identify this nested call.</span>
<span class="cm"> * @ctx: This instance context.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: Returns the code returned by the @nproc callback, or -1 if</span>
<span class="cm"> *          the maximum recursion limit has been exceeded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_call_nested</span><span class="p">(</span><span class="k">struct</span> <span class="n">nested_calls</span> <span class="o">*</span><span class="n">ncalls</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_nests</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nproc</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">call_nests</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lsthead</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ncalls</span><span class="o">-&gt;</span><span class="n">tasks_call_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nested_call_node</span> <span class="o">*</span><span class="n">tncur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nested_call_node</span> <span class="n">tnode</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncalls</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to see if the current task is already inside this wakeup call.</span>
<span class="cm">	 * We use a list here, since the population inside this set is always</span>
<span class="cm">	 * very much limited.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tncur</span><span class="p">,</span> <span class="n">lsthead</span><span class="p">,</span> <span class="n">llink</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tncur</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">ctx</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">tncur</span><span class="o">-&gt;</span><span class="n">cookie</span> <span class="o">==</span> <span class="n">cookie</span> <span class="o">||</span> <span class="o">++</span><span class="n">call_nests</span> <span class="o">&gt;</span> <span class="n">max_nests</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Ops ... loop detected or maximum nest level reached.</span>
<span class="cm">			 * We abort this wake by breaking the cycle itself.</span>
<span class="cm">			 */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Add the current task and cookie to the list */</span>
	<span class="n">tnode</span><span class="p">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="n">tnode</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tnode</span><span class="p">.</span><span class="n">llink</span><span class="p">,</span> <span class="n">lsthead</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncalls</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Call the nested function */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">nproc</span><span class="p">)(</span><span class="n">priv</span><span class="p">,</span> <span class="n">cookie</span><span class="p">,</span> <span class="n">call_nests</span><span class="p">);</span>

	<span class="cm">/* Remove the current task from the list */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncalls</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tnode</span><span class="p">.</span><span class="n">llink</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncalls</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * As described in commit 0ccf831cb lockdep: annotate epoll</span>
<span class="cm"> * the use of wait queues used by epoll is done in a very controlled</span>
<span class="cm"> * manner. Wake ups can nest inside each other, but are never done</span>
<span class="cm"> * with the same locking. For example:</span>
<span class="cm"> *</span>
<span class="cm"> *   dfd = socket(...);</span>
<span class="cm"> *   efd1 = epoll_create();</span>
<span class="cm"> *   efd2 = epoll_create();</span>
<span class="cm"> *   epoll_ctl(efd1, EPOLL_CTL_ADD, dfd, ...);</span>
<span class="cm"> *   epoll_ctl(efd2, EPOLL_CTL_ADD, efd1, ...);</span>
<span class="cm"> *</span>
<span class="cm"> * When a packet arrives to the device underneath &quot;dfd&quot;, the net code will</span>
<span class="cm"> * issue a wake_up() on its poll wake list. Epoll (efd1) has installed a</span>
<span class="cm"> * callback wakeup entry on that queue, and the wake_up() performed by the</span>
<span class="cm"> * &quot;dfd&quot; net code will end up in ep_poll_callback(). At this point epoll</span>
<span class="cm"> * (efd1) notices that it may have some event ready, so it needs to wake up</span>
<span class="cm"> * the waiters on its poll wait list (efd2). So it calls ep_poll_safewake()</span>
<span class="cm"> * that ends up in another wake_up(), after having checked about the</span>
<span class="cm"> * recursion constraints. That are, no more than EP_MAX_POLLWAKE_NESTS, to</span>
<span class="cm"> * avoid stack blasting.</span>
<span class="cm"> *</span>
<span class="cm"> * When CONFIG_DEBUG_LOCK_ALLOC is enabled, make sure lockdep can handle</span>
<span class="cm"> * this special case of epoll.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ep_wake_up_nested</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wqueue</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">subclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wqueue</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">subclass</span><span class="p">);</span>
	<span class="n">wake_up_locked_poll</span><span class="p">(</span><span class="n">wqueue</span><span class="p">,</span> <span class="n">events</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wqueue</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ep_wake_up_nested</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wqueue</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">subclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wake_up_poll</span><span class="p">(</span><span class="n">wqueue</span><span class="p">,</span> <span class="n">events</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_poll_wakeup_proc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="kt">int</span> <span class="n">call_nests</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ep_wake_up_nested</span><span class="p">((</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">cookie</span><span class="p">,</span> <span class="n">POLLIN</span><span class="p">,</span>
			  <span class="mi">1</span> <span class="o">+</span> <span class="n">call_nests</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform a safe wake up of the poll wait list. The problem is that</span>
<span class="cm"> * with the new callback&#39;d wake up system, it is possible that the</span>
<span class="cm"> * poll callback is reentered from inside the call to wake_up() done</span>
<span class="cm"> * on the poll wait queue head. The rule is that we cannot reenter the</span>
<span class="cm"> * wake up code from the same task more than EP_MAX_NESTS times,</span>
<span class="cm"> * and we cannot reenter the same wait queue head at all. This will</span>
<span class="cm"> * enable to have a hierarchy of epoll file descriptor of no more than</span>
<span class="cm"> * EP_MAX_NESTS deep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep_poll_safewake</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>

	<span class="n">ep_call_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_safewake_ncalls</span><span class="p">,</span> <span class="n">EP_MAX_NESTS</span><span class="p">,</span>
		       <span class="n">ep_poll_wakeup_proc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">wq</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">this_cpu</span><span class="p">);</span>

	<span class="n">put_cpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep_remove_wait_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">eppoll_entry</span> <span class="o">*</span><span class="n">pwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">whead</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="cm">/* If it is cleared by POLLFREE, it should be rcu-safe */</span>
	<span class="n">whead</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">whead</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">whead</span><span class="p">)</span>
		<span class="n">remove_wait_queue</span><span class="p">(</span><span class="n">whead</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function unregisters poll callbacks from the associated file</span>
<span class="cm"> * descriptor.  Must be called with &quot;mtx&quot; held (or &quot;epmutex&quot; if called from</span>
<span class="cm"> * ep_free).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep_unregister_pollwait</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lsthead</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">pwqlist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eppoll_entry</span> <span class="o">*</span><span class="n">pwq</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">lsthead</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pwq</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">lsthead</span><span class="p">,</span> <span class="k">struct</span> <span class="n">eppoll_entry</span><span class="p">,</span> <span class="n">llink</span><span class="p">);</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">llink</span><span class="p">);</span>
		<span class="n">ep_remove_wait_queue</span><span class="p">(</span><span class="n">pwq</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">pwq_cache</span><span class="p">,</span> <span class="n">pwq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep_scan_ready_list - Scans the ready list in a way that makes possible for</span>
<span class="cm"> *                      the scan code, to call f_op-&gt;poll(). Also allows for</span>
<span class="cm"> *                      O(NumReady) performance.</span>
<span class="cm"> *</span>
<span class="cm"> * @ep: Pointer to the epoll private data structure.</span>
<span class="cm"> * @sproc: Pointer to the scan callback.</span>
<span class="cm"> * @priv: Private opaque data passed to the @sproc callback.</span>
<span class="cm"> * @depth: The current depth of recursive f_op-&gt;poll calls.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: The same integer error code returned by the @sproc callback.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_scan_ready_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sproc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">,</span> <span class="o">*</span><span class="n">nepi</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">txlist</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to lock this because we could be hit by</span>
<span class="cm">	 * eventpoll_release_file() and epoll_ctl().</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Steal the ready list, and re-init the original one to the</span>
<span class="cm">	 * empty list. Also, set ep-&gt;ovflist to NULL so that events</span>
<span class="cm">	 * happening while looping w/out locks, are not lost. We cannot</span>
<span class="cm">	 * have the poll callback to queue directly on ep-&gt;rdllist,</span>
<span class="cm">	 * because we want the &quot;sproc&quot; callback to be able to do it</span>
<span class="cm">	 * in a lockless way.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txlist</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now call the callback function.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">sproc</span><span class="p">)(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txlist</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * During the time we spent inside the &quot;sproc&quot; callback, some</span>
<span class="cm">	 * other events might have been queued by the poll callback.</span>
<span class="cm">	 * We re-insert them inside the main ready-list here.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">nepi</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span><span class="p">;</span> <span class="p">(</span><span class="n">epi</span> <span class="o">=</span> <span class="n">nepi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	     <span class="n">nepi</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We need to check if the item is already in the list.</span>
<span class="cm">		 * During the &quot;sproc&quot; callback execution time, items are</span>
<span class="cm">		 * queued into -&gt;ovflist but the &quot;txlist&quot; might already</span>
<span class="cm">		 * contain them, and the list_splice() below takes care of them.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
			<span class="n">__pm_stay_awake</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We need to set back ep-&gt;ovflist to EP_UNACTIVE_PTR, so that after</span>
<span class="cm">	 * releasing the lock, events will be queued in the normal way inside</span>
<span class="cm">	 * ep-&gt;rdllist.</span>
<span class="cm">	 */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Quickly re-inject items left on &quot;txlist&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
	<span class="n">__pm_relax</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Wake up (if active) both the eventpoll wait list and</span>
<span class="cm">		 * the -&gt;poll() wait list (delayed after we release the lock).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
			<span class="n">wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span>
			<span class="n">pwake</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

	<span class="cm">/* We have to call this outside the lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pwake</span><span class="p">)</span>
		<span class="n">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Removes a &quot;struct epitem&quot; from the eventpoll RB tree and deallocates</span>
<span class="cm"> * all the associated resources. Must be called with &quot;mtx&quot; held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Removes poll wait queue hooks. We _have_ to do this without holding</span>
<span class="cm">	 * the &quot;ep-&gt;lock&quot; otherwise a deadlock might occur. This because of the</span>
<span class="cm">	 * sequence of the lock acquisition. Here we do &quot;ep-&gt;lock&quot; then the wait</span>
<span class="cm">	 * queue head lock when unregistering the wait queue. The wakeup callback</span>
<span class="cm">	 * will run by holding the wait queue head lock and will call our callback</span>
<span class="cm">	 * that will try to get &quot;ep-&gt;lock&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">ep_unregister_pollwait</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>

	<span class="cm">/* Remove the current item from the list of epoll hooks */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>

	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rbn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rbr</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">wakeup_source_unregister</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>

	<span class="cm">/* At this point it is safe to free the eventpoll item */</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">epi_cache</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>

	<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">epoll_watches</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rbp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>

	<span class="cm">/* We need to release all tasks waiting for these file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span>
		<span class="n">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to lock this because we could be hit by</span>
<span class="cm">	 * eventpoll_release_file() while we&#39;re freeing the &quot;struct eventpoll&quot;.</span>
<span class="cm">	 * We do not need to hold &quot;ep-&gt;mtx&quot; here because the epoll file</span>
<span class="cm">	 * is on the way to be removed and no one has references to it</span>
<span class="cm">	 * anymore. The only hit might come from eventpoll_release_file() but</span>
<span class="cm">	 * holding &quot;epmutex&quot; is sufficient here.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epmutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Walks through the whole tree by unregistering poll callbacks.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rbp</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rbr</span><span class="p">);</span> <span class="n">rbp</span><span class="p">;</span> <span class="n">rbp</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">rbp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">epi</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rbp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span><span class="p">,</span> <span class="n">rbn</span><span class="p">);</span>

		<span class="n">ep_unregister_pollwait</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Walks through the whole tree by freeing each &quot;struct epitem&quot;. At this</span>
<span class="cm">	 * point we are sure no poll callbacks will be lingering around, and also by</span>
<span class="cm">	 * holding &quot;epmutex&quot; we can be sure that no file cleanup code will hit</span>
<span class="cm">	 * us during this operation. So we can avoid the lock on &quot;ep-&gt;lock&quot;.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">rbp</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rbr</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">epi</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rbp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span><span class="p">,</span> <span class="n">rbn</span><span class="p">);</span>
		<span class="n">ep_remove</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epmutex</span><span class="p">);</span>
	<span class="n">mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">free_uid</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">);</span>
	<span class="n">wakeup_source_unregister</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_eventpoll_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="p">)</span>
		<span class="n">ep_free</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_read_events_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">poll_table</span> <span class="n">pt</span><span class="p">;</span>

	<span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">epi</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">rdllink</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pt</span><span class="p">.</span><span class="n">_key</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt</span><span class="p">)</span> <span class="o">&amp;</span>
		    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Item has been dropped into the ready list by the poll</span>
<span class="cm">			 * callback, but it&#39;s not actually ready, as far as</span>
<span class="cm">			 * caller requested events goes. We can remove it here.</span>
<span class="cm">			 */</span>
			<span class="n">__pm_relax</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_poll_readyevents_proc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="kt">int</span> <span class="n">call_nests</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ep_scan_ready_list</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">ep_read_events_proc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">call_nests</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ep_eventpoll_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pollflags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="cm">/* Insert inside our poll wait queue */</span>
	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Proceed to find out if wanted events are really available inside</span>
<span class="cm">	 * the ready list. This need to be done under ep_call_nested()</span>
<span class="cm">	 * supervision, since the call to f_op-&gt;poll() done on listed files</span>
<span class="cm">	 * could re-enter here.</span>
<span class="cm">	 */</span>
	<span class="n">pollflags</span> <span class="o">=</span> <span class="n">ep_call_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_readywalk_ncalls</span><span class="p">,</span> <span class="n">EP_MAX_NESTS</span><span class="p">,</span>
				   <span class="n">ep_poll_readyevents_proc</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pollflags</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="n">pollflags</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* File callbacks that implement the eventpoll file behaviour */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">eventpoll_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">ep_eventpoll_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">ep_eventpoll_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This is called from eventpoll_release() to unlink files from the eventpoll</span>
<span class="cm"> * interface. We need to have this facility to cleanup correctly files that are</span>
<span class="cm"> * closed without being removed from the eventpoll interface.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">eventpoll_release_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lsthead</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_ep_links</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want to get &quot;file-&gt;f_lock&quot; because it is not</span>
<span class="cm">	 * necessary. It is not necessary because we&#39;re in the &quot;struct file&quot;</span>
<span class="cm">	 * cleanup path, and this means that no one is using this file anymore.</span>
<span class="cm">	 * So, for example, epoll_ctl() cannot hit here since if we reach this</span>
<span class="cm">	 * point, the file counter already went to zero and fget() would fail.</span>
<span class="cm">	 * The only hit might come from ep_free() but by holding the mutex</span>
<span class="cm">	 * will correctly serialize the operation. We do need to acquire</span>
<span class="cm">	 * &quot;ep-&gt;mtx&quot; after &quot;epmutex&quot; because ep_remove() requires it when called</span>
<span class="cm">	 * from anywhere but ep_free().</span>
<span class="cm">	 *</span>
<span class="cm">	 * Besides, ep_remove() acquires the lock, so we can&#39;t hold it here.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epmutex</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">lsthead</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">epi</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">lsthead</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span><span class="p">,</span> <span class="n">fllink</span><span class="p">);</span>

		<span class="n">ep</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">);</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ep_remove</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epmutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">**</span><span class="n">pep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">user</span> <span class="o">=</span> <span class="n">get_current_user</span><span class="p">();</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ep</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">free_uid</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">rbr</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span><span class="p">;</span>

	<span class="o">*</span><span class="n">pep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">free_uid:</span>
	<span class="n">free_uid</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Search the file inside the eventpoll tree. The RB tree operations</span>
<span class="cm"> * are protected by the &quot;mtx&quot; mutex, and ep_find() must be called with</span>
<span class="cm"> * &quot;mtx&quot; held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="nf">ep_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">kcmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rbp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">,</span> <span class="o">*</span><span class="n">epir</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epoll_filefd</span> <span class="n">ffd</span><span class="p">;</span>

	<span class="n">ep_set_ffd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffd</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rbp</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">rbr</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span> <span class="n">rbp</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">epi</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rbp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span><span class="p">,</span> <span class="n">rbn</span><span class="p">);</span>
		<span class="n">kcmp</span> <span class="o">=</span> <span class="n">ep_cmp_ffd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ffd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kcmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">rbp</span> <span class="o">=</span> <span class="n">rbp</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">kcmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">rbp</span> <span class="o">=</span> <span class="n">rbp</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">epir</span> <span class="o">=</span> <span class="n">epi</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">epir</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the callback that is passed to the wait queue wakeup</span>
<span class="cm"> * mechanism. It is called by the stored file descriptors when they</span>
<span class="cm"> * have events to report.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_poll_callback</span><span class="p">(</span><span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">wait</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span> <span class="o">=</span> <span class="n">ep_item_from_wait</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">key</span> <span class="o">&amp;</span> <span class="n">POLLFREE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_pwq_from_wait</span><span class="p">(</span><span class="n">wait</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">whead</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * whead = NULL above can race with ep_remove_wait_queue()</span>
<span class="cm">		 * which can do another remove_wait_queue() after us, so we</span>
<span class="cm">		 * can&#39;t use __remove_wait_queue(). whead-&gt;lock is held by</span>
<span class="cm">		 * the caller.</span>
<span class="cm">		 */</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the event mask does not contain any poll(2) event, we consider the</span>
<span class="cm">	 * descriptor to be disabled. This condition is likely the effect of the</span>
<span class="cm">	 * EPOLLONESHOT bit that disables the descriptor when an event is received,</span>
<span class="cm">	 * until the next EPOLL_CTL_MOD will be issued.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EP_PRIVATE_BITS</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check the events coming with the callback. At this stage, not</span>
<span class="cm">	 * every device reports the events in the &quot;key&quot; parameter of the</span>
<span class="cm">	 * callback. We need to be able to handle both cases here, hence the</span>
<span class="cm">	 * test for &quot;key&quot; != NULL before the event match test.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">key</span> <span class="o">&amp;</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are transferring events to userspace, we can hold no locks</span>
<span class="cm">	 * (because we&#39;re accessing user memory, and because of linux f_op-&gt;poll()</span>
<span class="cm">	 * semantics). All the events that happen during that period of time are</span>
<span class="cm">	 * chained in ep-&gt;ovflist and requeued later on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">!=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span><span class="p">;</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">=</span> <span class="n">epi</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Activate ep-&gt;ws since epi-&gt;ws may get</span>
<span class="cm">				 * deactivated at any time.</span>
<span class="cm">				 */</span>
				<span class="n">__pm_stay_awake</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>
			<span class="p">}</span>

		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If this file is already in the ready list we exit soon */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
		<span class="n">__pm_stay_awake</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()</span>
<span class="cm">	 * wait list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
		<span class="n">wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span>
		<span class="n">pwake</span><span class="o">++</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* We have to call this outside the lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pwake</span><span class="p">)</span>
		<span class="n">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the callback that is used to add our wait queue to the</span>
<span class="cm"> * target file wakeup lists.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep_ptable_queue_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">whead</span><span class="p">,</span>
				 <span class="n">poll_table</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span> <span class="o">=</span> <span class="n">ep_item_from_epqueue</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">eppoll_entry</span> <span class="o">*</span><span class="n">pwq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pwq</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">pwq_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">init_waitqueue_func_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">ep_poll_callback</span><span class="p">);</span>
		<span class="n">pwq</span><span class="o">-&gt;</span><span class="n">whead</span> <span class="o">=</span> <span class="n">whead</span><span class="p">;</span>
		<span class="n">pwq</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">epi</span><span class="p">;</span>
		<span class="n">add_wait_queue</span><span class="p">(</span><span class="n">whead</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">llink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">pwqlist</span><span class="p">);</span>
		<span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We have to signal that an error occurred */</span>
		<span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep_rbtree_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">kcmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rbr</span><span class="p">.</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epic</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">epic</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span><span class="p">,</span> <span class="n">rbn</span><span class="p">);</span>
		<span class="n">kcmp</span> <span class="o">=</span> <span class="n">ep_cmp_ffd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epic</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kcmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rbn</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rbn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rbr</span><span class="p">);</span>
<span class="p">}</span>



<span class="cp">#define PATH_ARR_SIZE 5</span>
<span class="cm">/*</span>
<span class="cm"> * These are the number paths of length 1 to 5, that we are allowing to emanate</span>
<span class="cm"> * from a single file of interest. For example, we allow 1000 paths of length</span>
<span class="cm"> * 1, to emanate from each file of interest. This essentially represents the</span>
<span class="cm"> * potential wakeup paths, which need to be limited in order to avoid massive</span>
<span class="cm"> * uncontrolled wakeup storms. The common use case should be a single ep which</span>
<span class="cm"> * is connected to n file sources. In this case each file source has 1 path</span>
<span class="cm"> * of length 1. Thus, the numbers below should be more than sufficient. These</span>
<span class="cm"> * path limits are enforced during an EPOLL_CTL_ADD operation, since a modify</span>
<span class="cm"> * and delete can&#39;t add additional paths. Protected by the epmutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">path_limits</span><span class="p">[</span><span class="n">PATH_ARR_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">path_count</span><span class="p">[</span><span class="n">PATH_ARR_SIZE</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">path_count_inc</span><span class="p">(</span><span class="kt">int</span> <span class="n">nests</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Allow an arbitrary number of depth 1 paths */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nests</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">path_count</span><span class="p">[</span><span class="n">nests</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">path_limits</span><span class="p">[</span><span class="n">nests</span><span class="p">])</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">path_count_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PATH_ARR_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">path_count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">reverse_path_check_proc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="kt">int</span> <span class="n">call_nests</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">child_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">epi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_ep_links</span><span class="p">,</span> <span class="n">fllink</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">child_file</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_file_epoll</span><span class="p">(</span><span class="n">child_file</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_file</span><span class="o">-&gt;</span><span class="n">f_ep_links</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">path_count_inc</span><span class="p">(</span><span class="n">call_nests</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">ep_call_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_loop_ncalls</span><span class="p">,</span>
							<span class="n">EP_MAX_NESTS</span><span class="p">,</span>
							<span class="n">reverse_path_check_proc</span><span class="p">,</span>
							<span class="n">child_file</span><span class="p">,</span> <span class="n">child_file</span><span class="p">,</span>
							<span class="n">current</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;reverse_path_check_proc: &quot;</span>
				<span class="s">&quot;file is not an ep!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * reverse_path_check - The tfile_check_list is list of file *, which have</span>
<span class="cm"> *                      links that are proposed to be newly added. We need to</span>
<span class="cm"> *                      make sure that those added links don&#39;t add too many</span>
<span class="cm"> *                      paths such that we will spend all our time waking up</span>
<span class="cm"> *                      eventpoll objects.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: Returns zero if the proposed links don&#39;t create too many paths,</span>
<span class="cm"> *	    -1 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reverse_path_check</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">current_file</span><span class="p">;</span>

	<span class="cm">/* let&#39;s call this for all tfiles */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">current_file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tfile_check_list</span><span class="p">,</span> <span class="n">f_tfile_llink</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path_count_init</span><span class="p">();</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ep_call_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_loop_ncalls</span><span class="p">,</span> <span class="n">EP_MAX_NESTS</span><span class="p">,</span>
					<span class="n">reverse_path_check_proc</span><span class="p">,</span> <span class="n">current_file</span><span class="p">,</span>
					<span class="n">current_file</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_create_wakeup_source</span><span class="p">(</span><span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ws</span> <span class="o">=</span> <span class="n">wakeup_source_register</span><span class="p">(</span><span class="s">&quot;eventpoll&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span> <span class="o">=</span> <span class="n">wakeup_source_register</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep_destroy_wakeup_source</span><span class="p">(</span><span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wakeup_source_unregister</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>
	<span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Must be called with &quot;mtx&quot; held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">tfile</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">revents</span><span class="p">,</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">user_watches</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ep_pqueue</span> <span class="n">epq</span><span class="p">;</span>

	<span class="n">user_watches</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">epoll_watches</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">user_watches</span> <span class="o">&gt;=</span> <span class="n">max_user_watches</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epi</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">epi_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Item initialization follow here ... */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">pwqlist</span><span class="p">);</span>
	<span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
	<span class="n">ep_set_ffd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">,</span> <span class="n">tfile</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
	<span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">=</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLWAKEUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ep_create_wakeup_source</span><span class="p">(</span><span class="n">epi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_create_wakeup_source</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the poll table using the queue callback */</span>
	<span class="n">epq</span><span class="p">.</span><span class="n">epi</span> <span class="o">=</span> <span class="n">epi</span><span class="p">;</span>
	<span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">,</span> <span class="n">ep_ptable_queue_proc</span><span class="p">);</span>
	<span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">.</span><span class="n">_key</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Attach the item to the poll hooks and get current event bits.</span>
<span class="cm">	 * We can safely use the file* here because its usage count has</span>
<span class="cm">	 * been increased by the caller of this function. Note that after</span>
<span class="cm">	 * this operation completes, the poll callback can start hitting</span>
<span class="cm">	 * the new item.</span>
<span class="cm">	 */</span>
	<span class="n">revents</span> <span class="o">=</span> <span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">tfile</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to check if something went wrong during the poll wait queue</span>
<span class="cm">	 * install process. Namely an allocation for a wait queue failed due</span>
<span class="cm">	 * high memory pressure.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_unregister</span><span class="p">;</span>

	<span class="cm">/* Add the current item to the list of active epoll hook for this file */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_ep_links</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add the current item to the RB tree. All RB tree operations are</span>
<span class="cm">	 * protected by &quot;mtx&quot;, and ep_insert() is called with &quot;mtx&quot; held.</span>
<span class="cm">	 */</span>
	<span class="n">ep_rbtree_insert</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>

	<span class="cm">/* now check if we&#39;ve created too many backpaths */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reverse_path_check</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">error_remove_epi</span><span class="p">;</span>

	<span class="cm">/* We have to drop the new item inside our item list to keep track of it */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* If the file is already &quot;ready&quot; we drop it inside the ready list */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
		<span class="n">__pm_stay_awake</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>

		<span class="cm">/* Notify waiting tasks that events are available */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
			<span class="n">wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span>
			<span class="n">pwake</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">epoll_watches</span><span class="p">);</span>

	<span class="cm">/* We have to call this outside the lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pwake</span><span class="p">)</span>
		<span class="n">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_remove_epi:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>

	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rbn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rbr</span><span class="p">);</span>

<span class="nl">error_unregister:</span>
	<span class="n">ep_unregister_pollwait</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to do this because an event could have been arrived on some</span>
<span class="cm">	 * allocated wait queue. Note that we don&#39;t care about the ep-&gt;ovflist</span>
<span class="cm">	 * list, since that is used/cleaned only inside a section bound by &quot;mtx&quot;.</span>
<span class="cm">	 * And ep_insert() is called with &quot;mtx&quot; held.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">wakeup_source_unregister</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>

<span class="nl">error_create_wakeup_source:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">epi_cache</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Modify the interest event mask by dropping an event if the new mask</span>
<span class="cm"> * has a match in the current file status. Must be called with &quot;mtx&quot; held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_modify</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">;</span>
	<span class="n">poll_table</span> <span class="n">pt</span><span class="p">;</span>

	<span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the new event interest mask before calling f_op-&gt;poll();</span>
<span class="cm">	 * otherwise we might miss an event that happens between the</span>
<span class="cm">	 * f_op-&gt;poll() call and the new event set registering.</span>
<span class="cm">	 */</span>
	<span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">;</span>
	<span class="n">pt</span><span class="p">.</span><span class="n">_key</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">;</span>
	<span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span> <span class="cm">/* protected by mtx */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLWAKEUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">)</span>
			<span class="n">ep_create_wakeup_source</span><span class="p">(</span><span class="n">epi</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_destroy_wakeup_source</span><span class="p">(</span><span class="n">epi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get current event bits. We can safely use the file* here because</span>
<span class="cm">	 * its usage count has been increased by the caller of this function.</span>
<span class="cm">	 */</span>
	<span class="n">revents</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the item is &quot;hot&quot; and it is not registered inside the ready</span>
<span class="cm">	 * list, push it inside.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
			<span class="n">__pm_stay_awake</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>

			<span class="cm">/* Notify waiting tasks that events are available */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
				<span class="n">wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span>
				<span class="n">pwake</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We have to call this outside the lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pwake</span><span class="p">)</span>
		<span class="n">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_send_events_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ep_send_events_data</span> <span class="o">*</span><span class="n">esed</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">eventcnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uevent</span><span class="p">;</span>
	<span class="n">poll_table</span> <span class="n">pt</span><span class="p">;</span>

	<span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can loop without lock because we are passed a task private list.</span>
<span class="cm">	 * Items cannot vanish during the loop because ep_scan_ready_list() is</span>
<span class="cm">	 * holding &quot;mtx&quot; during this call.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">eventcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uevent</span> <span class="o">=</span> <span class="n">esed</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">;</span>
	     <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">eventcnt</span> <span class="o">&lt;</span> <span class="n">esed</span><span class="o">-&gt;</span><span class="n">maxevents</span><span class="p">;)</span> <span class="p">{</span>
		<span class="n">epi</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span><span class="p">,</span> <span class="n">rdllink</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Activate ep-&gt;ws before deactivating epi-&gt;ws to prevent</span>
<span class="cm">		 * triggering auto-suspend here (in case we reactive epi-&gt;ws</span>
<span class="cm">		 * below).</span>
<span class="cm">		 *</span>
<span class="cm">		 * This could be rearranged to delay the deactivation of epi-&gt;ws</span>
<span class="cm">		 * instead, but then epi-&gt;ws would temporarily be out of sync</span>
<span class="cm">		 * with ep_is_linked().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span> <span class="o">&amp;&amp;</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
			<span class="n">__pm_stay_awake</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>
		<span class="n">__pm_relax</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>

		<span class="n">pt</span><span class="p">.</span><span class="n">_key</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span><span class="p">;</span>
		<span class="n">revents</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the event mask intersect the caller-requested one,</span>
<span class="cm">		 * deliver the event to userspace. Again, ep_scan_ready_list()</span>
<span class="cm">		 * is holding &quot;mtx&quot;, so no operations coming from userspace</span>
<span class="cm">		 * can change the item.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">revents</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="n">revents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uevent</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">__put_user</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uevent</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
				<span class="n">__pm_stay_awake</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">eventcnt</span> <span class="o">?</span> <span class="n">eventcnt</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">eventcnt</span><span class="o">++</span><span class="p">;</span>
			<span class="n">uevent</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLONESHOT</span><span class="p">)</span>
				<span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;=</span> <span class="n">EP_PRIVATE_BITS</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLET</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * If this file has been added with Level</span>
<span class="cm">				 * Trigger mode, we need to insert back inside</span>
<span class="cm">				 * the ready list, so that the next call to</span>
<span class="cm">				 * epoll_wait() will check again the events</span>
<span class="cm">				 * availability. At this point, no one can insert</span>
<span class="cm">				 * into ep-&gt;rdllist besides us. The epoll_ctl()</span>
<span class="cm">				 * callers are locked out by</span>
<span class="cm">				 * ep_scan_ready_list() holding &quot;mtx&quot; and the</span>
<span class="cm">				 * poll callback will queue them in ep-&gt;ovflist.</span>
<span class="cm">				 */</span>
				<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
				<span class="n">__pm_stay_awake</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">eventcnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_send_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ep_send_events_data</span> <span class="n">esed</span><span class="p">;</span>

	<span class="n">esed</span><span class="p">.</span><span class="n">maxevents</span> <span class="o">=</span> <span class="n">maxevents</span><span class="p">;</span>
	<span class="n">esed</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ep_scan_ready_list</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep_send_events_proc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">esed</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="nf">ep_set_mstimeout</span><span class="p">(</span><span class="kt">long</span> <span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">,</span> <span class="n">ts</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">ms</span> <span class="o">/</span> <span class="n">MSEC_PER_SEC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">NSEC_PER_MSEC</span> <span class="o">*</span> <span class="p">(</span><span class="n">ms</span> <span class="o">%</span> <span class="n">MSEC_PER_SEC</span><span class="p">),</span>
	<span class="p">};</span>

	<span class="n">ktime_get_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">timespec_add_safe</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">ts</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep_poll - Retrieves ready events, and delivers them to the caller supplied</span>
<span class="cm"> *           event buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * @ep: Pointer to the eventpoll context.</span>
<span class="cm"> * @events: Pointer to the userspace buffer where the ready events should be</span>
<span class="cm"> *          stored.</span>
<span class="cm"> * @maxevents: Size (in terms of number of events) of the caller event buffer.</span>
<span class="cm"> * @timeout: Maximum timeout for the ready events fetch operation, in</span>
<span class="cm"> *           milliseconds. If the @timeout is zero, the function will not block,</span>
<span class="cm"> *           while if the @timeout is less than zero, the function will block</span>
<span class="cm"> *           until at least one event has been retrieved (or an error</span>
<span class="cm"> *           occurred).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: Returns the number of ready events which have been fetched, or an</span>
<span class="cm"> *          error code, in case of error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eavail</span><span class="p">,</span> <span class="n">timed_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">slack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">expires</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">ep_set_mstimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>

		<span class="n">slack</span> <span class="o">=</span> <span class="n">select_estimate_accuracy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end_time</span><span class="p">);</span>
		<span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">expires</span><span class="p">;</span>
		<span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">end_time</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Avoid the unnecessary trip to the wait queue loop, if the</span>
<span class="cm">		 * caller specified a non blocking operation.</span>
<span class="cm">		 */</span>
		<span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">check_events</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">fetch_events:</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_events_available</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t have any available event to return to the caller.</span>
<span class="cm">		 * We need to sleep here, and we will be wake up by</span>
<span class="cm">		 * ep_poll_callback() when events will become available.</span>
<span class="cm">		 */</span>
		<span class="n">init_waitqueue_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="n">__add_wait_queue_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We don&#39;t want to sleep if the ep_poll_callback() sends us</span>
<span class="cm">			 * a wakeup in between. That&#39;s why we set the task state</span>
<span class="cm">			 * to TASK_INTERRUPTIBLE before doing the checks.</span>
<span class="cm">			 */</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep_events_available</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">||</span> <span class="n">timed_out</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">schedule_hrtimeout_range</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">slack</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">))</span>
				<span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">__remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">check_events:</span>
	<span class="cm">/* Is it worth to try to dig for events ? */</span>
	<span class="n">eavail</span> <span class="o">=</span> <span class="n">ep_events_available</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to transfer events to user space. In case we get 0 events and</span>
<span class="cm">	 * there&#39;s still timeout left over, we go trying again in search of</span>
<span class="cm">	 * more luck.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="n">eavail</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">res</span> <span class="o">=</span> <span class="n">ep_send_events</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timed_out</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fetch_events</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep_loop_check_proc - Callback function to be passed to the @ep_call_nested()</span>
<span class="cm"> *                      API, to verify that adding an epoll file inside another</span>
<span class="cm"> *                      epoll structure, does not violate the constraints, in</span>
<span class="cm"> *                      terms of closed loops, or too deep chains (which can</span>
<span class="cm"> *                      result in excessive stack usage).</span>
<span class="cm"> *</span>
<span class="cm"> * @priv: Pointer to the epoll file to be currently checked.</span>
<span class="cm"> * @cookie: Original cookie for this call. This is the top-of-the-chain epoll</span>
<span class="cm"> *          data structure pointer.</span>
<span class="cm"> * @call_nests: Current dept of the @ep_call_nested() call stack.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: Returns zero if adding the epoll @file inside current epoll</span>
<span class="cm"> *          structure @ep does not violate the constraints, or -1 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_loop_check_proc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="kt">int</span> <span class="n">call_nests</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep_tovisit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rbp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>

	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">,</span> <span class="n">call_nests</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">visited</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">visited_list_link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">visited_list</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rbp</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rbr</span><span class="p">);</span> <span class="n">rbp</span><span class="p">;</span> <span class="n">rbp</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">rbp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">epi</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rbp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span><span class="p">,</span> <span class="n">rbn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_file_epoll</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ep_tovisit</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep_tovisit</span><span class="o">-&gt;</span><span class="n">visited</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">ep_call_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_loop_ncalls</span><span class="p">,</span> <span class="n">EP_MAX_NESTS</span><span class="p">,</span>
					<span class="n">ep_loop_check_proc</span><span class="p">,</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="p">,</span>
					<span class="n">ep_tovisit</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we&#39;ve reached a file that is not associated with</span>
<span class="cm">			 * an ep, then we need to check if the newly added</span>
<span class="cm">			 * links are going to add too many wakeup paths. We do</span>
<span class="cm">			 * this by adding it to the tfile_check_list, if it&#39;s</span>
<span class="cm">			 * not already there, and calling reverse_path_check()</span>
<span class="cm">			 * during ep_insert().</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_tfile_llink</span><span class="p">))</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_tfile_llink</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">tfile_check_list</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep_loop_check - Performs a check to verify that adding an epoll file (@file)</span>
<span class="cm"> *                 another epoll file (represented by @ep) does not create</span>
<span class="cm"> *                 closed loops or too deep chains.</span>
<span class="cm"> *</span>
<span class="cm"> * @ep: Pointer to the epoll private data structure.</span>
<span class="cm"> * @file: Pointer to the epoll file to be checked.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: Returns zero if adding the epoll @file inside current epoll</span>
<span class="cm"> *          structure @ep does not violate the constraints, or -1 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_loop_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep_cur</span><span class="p">,</span> <span class="o">*</span><span class="n">ep_next</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ep_call_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_loop_ncalls</span><span class="p">,</span> <span class="n">EP_MAX_NESTS</span><span class="p">,</span>
			      <span class="n">ep_loop_check_proc</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="cm">/* clear visited list */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ep_cur</span><span class="p">,</span> <span class="n">ep_next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">visited_list</span><span class="p">,</span>
							<span class="n">visited_list_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep_cur</span><span class="o">-&gt;</span><span class="n">visited</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep_cur</span><span class="o">-&gt;</span><span class="n">visited_list_link</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_tfile_check_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

	<span class="cm">/* first clear the tfile_check_list */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile_check_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">file</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile_check_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span><span class="p">,</span>
					<span class="n">f_tfile_llink</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_tfile_llink</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile_check_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Open an eventpoll file descriptor.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">epoll_create1</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">fd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

	<span class="cm">/* Check the EPOLL_* constant for consistency.  */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EPOLL_CLOEXEC</span> <span class="o">!=</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EPOLL_CLOEXEC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Create the internal data structure (&quot;struct eventpoll&quot;).</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">ep_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Creates all the items needed to setup an eventpoll file. That is,</span>
<span class="cm">	 * a file structure and a free file descriptor.</span>
<span class="cm">	 */</span>
	<span class="n">fd</span> <span class="o">=</span> <span class="n">get_unused_fd_flags</span><span class="p">(</span><span class="n">O_RDWR</span> <span class="o">|</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_CLOEXEC</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_ep</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">anon_inode_getfile</span><span class="p">(</span><span class="s">&quot;[eventpoll]&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventpoll_fops</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span>
				 <span class="n">O_RDWR</span> <span class="o">|</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_CLOEXEC</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_fd</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>

<span class="nl">out_free_fd:</span>
	<span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="nl">out_free_ep:</span>
	<span class="n">ep_free</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">epoll_create</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sys_epoll_create1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following function implements the controller interface for</span>
<span class="cm"> * the eventpoll file that enables the insertion/removal/change of</span>
<span class="cm"> * file descriptors inside the interest set.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">epoll_ctl</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">did_lock_epmutex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="o">*</span><span class="n">tfile</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">epds</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_op_has_event</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epds</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

	<span class="cm">/* Get the &quot;struct file *&quot; for the eventpoll file */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

	<span class="cm">/* Get the &quot;struct file *&quot; for the target file */</span>
	<span class="n">tfile</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tfile</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_fput</span><span class="p">;</span>

	<span class="cm">/* The target file descriptor must support poll */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_tgt_fput</span><span class="p">;</span>

	<span class="cm">/* Check if EPOLLWAKEUP is allowed */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">epds</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLWAKEUP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_EPOLLWAKEUP</span><span class="p">))</span>
		<span class="n">epds</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EPOLLWAKEUP</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to check that the file structure underneath the file descriptor</span>
<span class="cm">	 * the user passed to us _is_ an eventpoll file. And also we do not permit</span>
<span class="cm">	 * adding an epoll file descriptor inside itself.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="n">tfile</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_file_epoll</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_tgt_fput</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point it is safe to assume that the &quot;private_data&quot; contains</span>
<span class="cm">	 * our own data structure.</span>
<span class="cm">	 */</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When we insert an epoll file descriptor, inside another epoll file</span>
<span class="cm">	 * descriptor, there is the change of creating closed loops, which are</span>
<span class="cm">	 * better be handled here, than in more critical paths. While we are</span>
<span class="cm">	 * checking for loops we also determine the list of files reachable</span>
<span class="cm">	 * and hang them on the tfile_check_list, so we can check that we</span>
<span class="cm">	 * haven&#39;t created too many possible wakeup paths.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need to hold the epmutex across both ep_insert and ep_remove</span>
<span class="cm">	 * b/c we want to make sure we are looking at a coherent view of</span>
<span class="cm">	 * epoll network.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">EPOLL_CTL_ADD</span> <span class="o">||</span> <span class="n">op</span> <span class="o">==</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epmutex</span><span class="p">);</span>
		<span class="n">did_lock_epmutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_file_epoll</span><span class="p">(</span><span class="n">tfile</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ELOOP</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep_loop_check</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">tfile</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">clear_tfile_check_list</span><span class="p">();</span>
				<span class="k">goto</span> <span class="n">error_tgt_fput</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_tfile_llink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tfile_check_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to lookup the file inside our RB tree, Since we grabbed &quot;mtx&quot;</span>
<span class="cm">	 * above, we can be sure to be able to use the item looked up by</span>
<span class="cm">	 * ep_find() till we release the mutex.</span>
<span class="cm">	 */</span>
	<span class="n">epi</span> <span class="o">=</span> <span class="n">ep_find</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">tfile</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EPOLL_CTL_ADD</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epi</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">epds</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">ep_insert</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epds</span><span class="p">,</span> <span class="n">tfile</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="n">clear_tfile_check_list</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EPOLL_CTL_DEL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">ep_remove</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EPOLL_CTL_MOD</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">epds</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">ep_modify</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epds</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

<span class="nl">error_tgt_fput:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">did_lock_epmutex</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epmutex</span><span class="p">);</span>

	<span class="n">fput</span><span class="p">(</span><span class="n">tfile</span><span class="p">);</span>
<span class="nl">error_fput:</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="nl">error_return:</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Implement the event wait interface for the eventpoll file. It is the kernel</span>
<span class="cm"> * part of the user space epoll_wait(2).</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">epoll_wait</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span>
		<span class="kt">int</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="cm">/* The maximum number of event must be greater than zero */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxevents</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">maxevents</span> <span class="o">&gt;</span> <span class="n">EP_MAX_EVENTS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Verify that the area passed by the user is writeable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the &quot;struct file *&quot; for the eventpoll file */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to check that the file structure underneath the fd</span>
<span class="cm">	 * the user passed to us _is_ an eventpoll file.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_file_epoll</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_fput</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point it is safe to assume that the &quot;private_data&quot; contains</span>
<span class="cm">	 * our own data structure.</span>
<span class="cm">	 */</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="cm">/* Time to fish for events ... */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">ep_poll</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

<span class="nl">error_fput:</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="nl">error_return:</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Implement the event wait interface for the eventpoll file. It is the kernel</span>
<span class="cm"> * part of the user space epoll_pwait(2).</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE6</span><span class="p">(</span><span class="n">epoll_pwait</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span>
		<span class="kt">int</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="k">const</span> <span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">sigmask</span><span class="p">,</span>
		<span class="kt">size_t</span><span class="p">,</span> <span class="n">sigsetsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">ksigmask</span><span class="p">,</span> <span class="n">sigsaved</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the caller wants a certain signal mask to be set during the wait,</span>
<span class="cm">	 * we apply it here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigmask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sigsetsize</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sigset_t</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksigmask</span><span class="p">,</span> <span class="n">sigmask</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ksigmask</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">sigdelsetmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksigmask</span><span class="p">,</span> <span class="n">sigmask</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">)</span> <span class="o">|</span> <span class="n">sigmask</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">));</span>
		<span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ksigmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigsaved</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">sys_epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we changed the signal mask, we need to restore the original one.</span>
<span class="cm">	 * In case we&#39;ve got a signal while waiting, we do not restore the</span>
<span class="cm">	 * signal mask yet, and we allow do_signal() to deliver the signal on</span>
<span class="cm">	 * the way back to userspace, before the signal mask is restored.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigmask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">saved_sigmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigsaved</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="n">sigsaved</span><span class="p">));</span>
			<span class="n">set_restore_sigmask</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigsaved</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">eventpoll_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sysinfo</span> <span class="n">si</span><span class="p">;</span>

	<span class="n">si_meminfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allows top 4% of lomem to be allocated for epoll watches (per user).</span>
<span class="cm">	 */</span>
	<span class="n">max_user_watches</span> <span class="o">=</span> <span class="p">(((</span><span class="n">si</span><span class="p">.</span><span class="n">totalram</span> <span class="o">-</span> <span class="n">si</span><span class="p">.</span><span class="n">totalhigh</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">/</span>
		<span class="n">EP_ITEM_COST</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">max_user_watches</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the structure used to perform epoll file descriptor</span>
<span class="cm">	 * inclusion loops checks.</span>
<span class="cm">	 */</span>
	<span class="n">ep_nested_calls_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_loop_ncalls</span><span class="p">);</span>

	<span class="cm">/* Initialize the structure used to perform safe poll wait head wake ups */</span>
	<span class="n">ep_nested_calls_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_safewake_ncalls</span><span class="p">);</span>

	<span class="cm">/* Initialize the structure used to perform file&#39;s f_op-&gt;poll() calls */</span>
	<span class="n">ep_nested_calls_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_readywalk_ncalls</span><span class="p">);</span>

	<span class="cm">/* Allocates slab cache used to allocate &quot;struct epitem&quot; items */</span>
	<span class="n">epi_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;eventpoll_epi&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epitem</span><span class="p">),</span>
			<span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span> <span class="o">|</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Allocates slab cache used to allocate &quot;struct eppoll_entry&quot; */</span>
	<span class="n">pwq_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;eventpoll_pwq&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">eppoll_entry</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">fs_initcall</span><span class="p">(</span><span class="n">eventpoll_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
