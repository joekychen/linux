<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nfsd › nfs4callback.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nfs4callback.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Copyright (c) 2001 The Regents of the University of Michigan.</span>
<span class="cm"> *  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  Kendrick Smith &lt;kmsmith@umich.edu&gt;</span>
<span class="cm"> *  Andy Adamson &lt;andros@umich.edu&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> *  modification, are permitted provided that the following conditions</span>
<span class="cm"> *  are met:</span>
<span class="cm"> *</span>
<span class="cm"> *  1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *  2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *     documentation and/or other materials provided with the distribution.</span>
<span class="cm"> *  3. Neither the name of the University nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> *  THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED</span>
<span class="cm"> *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<span class="cm"> *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="cm"> *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</span>
<span class="cm"> *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="cm"> *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="cm"> *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR</span>
<span class="cm"> *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<span class="cm"> *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="cm"> *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="cm"> *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sunrpc/clnt.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/svc_xprt.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;nfsd.h&quot;</span>
<span class="cp">#include &quot;state.h&quot;</span>

<span class="cp">#define NFSDDBG_FACILITY                NFSDDBG_PROC</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">nfsd4_mark_cb_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">);</span>

<span class="cp">#define NFSPROC4_CB_NULL 0</span>
<span class="cp">#define NFSPROC4_CB_COMPOUND 1</span>

<span class="cm">/* Index of predefined Linux callback client operations */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NFSPROC4_CLNT_CB_NULL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">NFSPROC4_CLNT_CB_RECALL</span><span class="p">,</span>
	<span class="n">NFSPROC4_CLNT_CB_SEQUENCE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define NFS4_MAXTAGLEN		20</span>

<span class="cp">#define NFS4_enc_cb_null_sz		0</span>
<span class="cp">#define NFS4_dec_cb_null_sz		0</span>
<span class="cp">#define cb_compound_enc_hdr_sz		4</span>
<span class="cp">#define cb_compound_dec_hdr_sz		(3 + (NFS4_MAXTAGLEN &gt;&gt; 2))</span>
<span class="cp">#define sessionid_sz			(NFS4_MAX_SESSIONID_LEN &gt;&gt; 2)</span>
<span class="cp">#define cb_sequence_enc_sz		(sessionid_sz + 4 +             \</span>
<span class="cp">					1 </span><span class="cm">/* no referring calls list yet */</span><span class="cp">)</span>
<span class="cp">#define cb_sequence_dec_sz		(op_dec_sz + sessionid_sz + 4)</span>

<span class="cp">#define op_enc_sz			1</span>
<span class="cp">#define op_dec_sz			2</span>
<span class="cp">#define enc_nfs4_fh_sz			(1 + (NFS4_FHSIZE &gt;&gt; 2))</span>
<span class="cp">#define enc_stateid_sz			(NFS4_STATEID_SIZE &gt;&gt; 2)</span>
<span class="cp">#define NFS4_enc_cb_recall_sz		(cb_compound_enc_hdr_sz +       \</span>
<span class="cp">					cb_sequence_enc_sz +            \</span>
<span class="cp">					1 + enc_stateid_sz +            \</span>
<span class="cp">					enc_nfs4_fh_sz)</span>

<span class="cp">#define NFS4_dec_cb_recall_sz		(cb_compound_dec_hdr_sz  +      \</span>
<span class="cp">					cb_sequence_dec_sz +            \</span>
<span class="cp">					op_dec_sz)</span>

<span class="k">struct</span> <span class="n">nfs4_cb_compound_hdr</span> <span class="p">{</span>
	<span class="cm">/* args */</span>
	<span class="n">u32</span>		<span class="n">ident</span><span class="p">;</span>	<span class="cm">/* minorversion 0 only */</span>
	<span class="n">u32</span>		<span class="n">nops</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="o">*</span><span class="n">nops_p</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">minorversion</span><span class="p">;</span>
	<span class="cm">/* res */</span>
	<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Handle decode buffer overflows out-of-line.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_overflow_msg</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: %s prematurely hit the end of our receive buffer. &quot;</span>
		<span class="s">&quot;Remaining buffer length is %tu words.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">func</span><span class="p">,</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">xdr_encode_empty_array</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_zero</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Encode/decode NFSv4 CB basic data types</span>
<span class="cm"> *</span>
<span class="cm"> * Basic NFSv4 callback data types are defined in section 15 of RFC</span>
<span class="cm"> * 3530: &quot;Network File System (NFS) version 4 Protocol&quot; and section</span>
<span class="cm"> * 20 of RFC 5661: &quot;Network File System (NFS) Version 4 Minor Version</span>
<span class="cm"> * 1 Protocol&quot;</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	nfs_cb_opnum4</span>
<span class="cm"> *</span>
<span class="cm"> *	enum nfs_cb_opnum4 {</span>
<span class="cm"> *		OP_CB_GETATTR		= 3,</span>
<span class="cm"> *		  ...</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">nfs_cb_opnum4</span> <span class="p">{</span>
	<span class="n">OP_CB_GETATTR</span>			<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">OP_CB_RECALL</span>			<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">OP_CB_LAYOUTRECALL</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">OP_CB_NOTIFY</span>			<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">OP_CB_PUSH_DELEG</span>		<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">OP_CB_RECALL_ANY</span>		<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">OP_CB_RECALLABLE_OBJ_AVAIL</span>	<span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">OP_CB_RECALL_SLOT</span>		<span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">OP_CB_SEQUENCE</span>			<span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">OP_CB_WANTS_CANCELLED</span>		<span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	<span class="n">OP_CB_NOTIFY_LOCK</span>		<span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
	<span class="n">OP_CB_NOTIFY_DEVICEID</span>		<span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
	<span class="n">OP_CB_ILLEGAL</span>			<span class="o">=</span> <span class="mi">10044</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_nfs_cb_opnum4</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">nfs_cb_opnum4</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nfs_fh4</span>
<span class="cm"> *</span>
<span class="cm"> *	typedef opaque nfs_fh4&lt;NFS4_FHSIZE&gt;;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_nfs_fh4</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">knfsd_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">length</span> <span class="o">=</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_size</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">NFS4_FHSIZE</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">xdr_encode_opaque</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">fh_base</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * stateid4</span>
<span class="cm"> *</span>
<span class="cm"> *	struct stateid4 {</span>
<span class="cm"> *		uint32_t	seqid;</span>
<span class="cm"> *		opaque		other[12];</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_stateid4</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">const</span> <span class="n">stateid_t</span> <span class="o">*</span><span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS4_STATEID_SIZE</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">sid</span><span class="o">-&gt;</span><span class="n">si_generation</span><span class="p">);</span>
	<span class="n">xdr_encode_opaque_fixed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sid</span><span class="o">-&gt;</span><span class="n">si_opaque</span><span class="p">,</span> <span class="n">NFS4_STATEID_OTHER_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sessionid4</span>
<span class="cm"> *</span>
<span class="cm"> *	typedef opaque sessionid4[NFS4_SESSIONID_SIZE];</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_sessionid4</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">nfsd4_session</span> <span class="o">*</span><span class="n">session</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS4_MAX_SESSIONID_LEN</span><span class="p">);</span>
	<span class="n">xdr_encode_opaque_fixed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">se_sessionid</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>
					<span class="n">NFS4_MAX_SESSIONID_LEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nfsstat4</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">errno</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nfs_cb_errtbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">NFS4_OK</span><span class="p">,</span>		<span class="mi">0</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_PERM</span><span class="p">,</span>		<span class="o">-</span><span class="n">EPERM</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_NOENT</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENOENT</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_IO</span><span class="p">,</span>		<span class="o">-</span><span class="n">EIO</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_NXIO</span><span class="p">,</span>		<span class="o">-</span><span class="n">ENXIO</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_ACCESS</span><span class="p">,</span>	<span class="o">-</span><span class="n">EACCES</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_EXIST</span><span class="p">,</span>	<span class="o">-</span><span class="n">EEXIST</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_XDEV</span><span class="p">,</span>		<span class="o">-</span><span class="n">EXDEV</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_NOTDIR</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENOTDIR</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_ISDIR</span><span class="p">,</span>	<span class="o">-</span><span class="n">EISDIR</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_INVAL</span><span class="p">,</span>	<span class="o">-</span><span class="n">EINVAL</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_FBIG</span><span class="p">,</span>		<span class="o">-</span><span class="n">EFBIG</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_NOSPC</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENOSPC</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_ROFS</span><span class="p">,</span>		<span class="o">-</span><span class="n">EROFS</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_MLINK</span><span class="p">,</span>	<span class="o">-</span><span class="n">EMLINK</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_NAMETOOLONG</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENAMETOOLONG</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_NOTEMPTY</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENOTEMPTY</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_DQUOT</span><span class="p">,</span>	<span class="o">-</span><span class="n">EDQUOT</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_STALE</span><span class="p">,</span>	<span class="o">-</span><span class="n">ESTALE</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_BADHANDLE</span><span class="p">,</span>	<span class="o">-</span><span class="n">EBADHANDLE</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_BAD_COOKIE</span><span class="p">,</span>	<span class="o">-</span><span class="n">EBADCOOKIE</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_NOTSUPP</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENOTSUPP</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_TOOSMALL</span><span class="p">,</span>	<span class="o">-</span><span class="n">ETOOSMALL</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_SERVERFAULT</span><span class="p">,</span>	<span class="o">-</span><span class="n">ESERVERFAULT</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_BADTYPE</span><span class="p">,</span>	<span class="o">-</span><span class="n">EBADTYPE</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_LOCKED</span><span class="p">,</span>	<span class="o">-</span><span class="n">EAGAIN</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_RESOURCE</span><span class="p">,</span>	<span class="o">-</span><span class="n">EREMOTEIO</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_SYMLINK</span><span class="p">,</span>	<span class="o">-</span><span class="n">ELOOP</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_OP_ILLEGAL</span><span class="p">,</span>	<span class="o">-</span><span class="n">EOPNOTSUPP</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFS4ERR_DEADLOCK</span><span class="p">,</span>	<span class="o">-</span><span class="n">EDEADLK</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>			<span class="o">-</span><span class="n">EIO</span>		<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * If we cannot translate the error, the recovery routines should</span>
<span class="cm"> * handle it.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: remaining NFSv4 error codes have values &gt; 10000, so should</span>
<span class="cm"> * not conflict with native Linux error codes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_cb_stat_to_errno</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nfs_cb_errtbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stat</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfs_cb_errtbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stat</span> <span class="o">==</span> <span class="n">status</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">nfs_cb_errtbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">errno</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFSD: Unrecognized NFS CB status value: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_cb_op_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">nfs_opnum4</span> <span class="n">expected</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">nfsstat4</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">op</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">op</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="n">expected</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unexpected</span><span class="p">;</span>
	<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="nl">out_unexpected:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFSD: Callback server returned operation %d but &quot;</span>
		<span class="s">&quot;we issued a request for %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">expected</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * CB_COMPOUND4args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct CB_COMPOUND4args {</span>
<span class="cm"> *		utf8str_cs	tag;</span>
<span class="cm"> *		uint32_t	minorversion;</span>
<span class="cm"> *		uint32_t	callback_ident;</span>
<span class="cm"> *		nfs_cb_argop4	argarray&lt;&gt;;</span>
<span class="cm"> *	};</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_cb_compound4args</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">nfs4_cb_compound_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_empty_array</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>		<span class="cm">/* empty tag */</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">minorversion</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">ident</span><span class="p">);</span>

	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nops_p</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nops</span><span class="p">);</span>		<span class="cm">/* argarray element count */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update argarray element count</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_cb_nops</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_cb_compound_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nops</span> <span class="o">&gt;</span> <span class="n">NFS4_MAX_BACK_CHANNEL_OPS</span><span class="p">);</span>
	<span class="o">*</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nops_p</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * CB_COMPOUND4res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct CB_COMPOUND4res {</span>
<span class="cm"> *		nfsstat4	status;</span>
<span class="cm"> *		utf8str_cs	tag;</span>
<span class="cm"> *		nfs_cb_resop4	resarray&lt;&gt;;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_cb_compound4res</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">nfs4_cb_compound_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="cm">/* Ignore the tag */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nops</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * CB_RECALL4args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct CB_RECALL4args {</span>
<span class="cm"> *		stateid4	stateid;</span>
<span class="cm"> *		bool		truncate;</span>
<span class="cm"> *		nfs_fh4		fh;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_cb_recall4args</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs4_delegation</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">nfs4_cb_compound_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">encode_nfs_cb_opnum4</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">OP_CB_RECALL</span><span class="p">);</span>
	<span class="n">encode_stateid4</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dl_stid</span><span class="p">.</span><span class="n">sc_stateid</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_zero</span><span class="p">;</span>			<span class="cm">/* truncate */</span>

	<span class="n">encode_nfs_fh4</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dl_fh</span><span class="p">);</span>

	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nops</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * CB_SEQUENCE4args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct CB_SEQUENCE4args {</span>
<span class="cm"> *		sessionid4		csa_sessionid;</span>
<span class="cm"> *		sequenceid4		csa_sequenceid;</span>
<span class="cm"> *		slotid4			csa_slotid;</span>
<span class="cm"> *		slotid4			csa_highest_slotid;</span>
<span class="cm"> *		bool			csa_cachethis;</span>
<span class="cm"> *		referring_call_list4	csa_referring_call_lists&lt;&gt;;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_cb_sequence4args</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">nfs4_cb_compound_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfsd4_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_clp</span><span class="o">-&gt;</span><span class="n">cl_cb_session</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">minorversion</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">encode_nfs_cb_opnum4</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">OP_CB_SEQUENCE</span><span class="p">);</span>
	<span class="n">encode_sessionid4</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">se_cb_seq_nr</span><span class="p">);</span>	<span class="cm">/* csa_sequenceid */</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_zero</span><span class="p">;</span>			<span class="cm">/* csa_slotid */</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_zero</span><span class="p">;</span>			<span class="cm">/* csa_highest_slotid */</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_zero</span><span class="p">;</span>			<span class="cm">/* csa_cachethis */</span>
	<span class="n">xdr_encode_empty_array</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>		<span class="cm">/* csa_referring_call_lists */</span>

	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nops</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * CB_SEQUENCE4resok</span>
<span class="cm"> *</span>
<span class="cm"> *	struct CB_SEQUENCE4resok {</span>
<span class="cm"> *		sessionid4	csr_sessionid;</span>
<span class="cm"> *		sequenceid4	csr_sequenceid;</span>
<span class="cm"> *		slotid4		csr_slotid;</span>
<span class="cm"> *		slotid4		csr_highest_slotid;</span>
<span class="cm"> *		slotid4		csr_target_highest_slotid;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union CB_SEQUENCE4res switch (nfsstat4 csr_status) {</span>
<span class="cm"> *	case NFS4_OK:</span>
<span class="cm"> *		CB_SEQUENCE4resok	csr_resok4;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> * Our current back channel implmentation supports a single backchannel</span>
<span class="cm"> * with a single slot.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_cb_sequence4resok</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfsd4_session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_clp</span><span class="o">-&gt;</span><span class="n">cl_cb_session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_sessionid</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESERVERFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the server returns different values for sessionID, slotID or</span>
<span class="cm">	 * sequence number, the server is looney tunes.</span>
<span class="cm">	 */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS4_MAX_SESSIONID_LEN</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">NFS4_MAX_SESSIONID_LEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">se_sessionid</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>
					<span class="n">NFS4_MAX_SESSIONID_LEN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: %s Invalid session id</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">XDR_QUADLEN</span><span class="p">(</span><span class="n">NFS4_MAX_SESSIONID_LEN</span><span class="p">);</span>

	<span class="n">dummy</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dummy</span> <span class="o">!=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">se_cb_seq_nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: %s Invalid sequence number</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dummy</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dummy</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: %s Invalid slotid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME: process highest slotid and target highest slotid</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">nfsd4_mark_cb_fault</span><span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_clp</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_cb_sequence4res</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfsstat4</span> <span class="n">nfserr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_minorversion</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">decode_cb_op_status</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">OP_CB_SEQUENCE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfserr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nfserr</span> <span class="o">!=</span> <span class="n">NFS4_OK</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">decode_cb_sequence4resok</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="k">return</span> <span class="n">nfs_cb_stat_to_errno</span><span class="p">(</span><span class="n">nfserr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NFSv4.0 and NFSv4.1 XDR encode functions</span>
<span class="cm"> *</span>
<span class="cm"> * NFSv4.0 callback argument types are defined in section 15 of RFC</span>
<span class="cm"> * 3530: &quot;Network File System (NFS) version 4 Protocol&quot; and section 20</span>
<span class="cm"> * of RFC 5661:  &quot;Network File System (NFS) Version 4 Minor Version 1</span>
<span class="cm"> * Protocol&quot;.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * NB: Without this zero space reservation, callbacks over krb5p fail</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs4_xdr_enc_cb_null</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="o">*</span><span class="n">__unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 20.2. Operation 4: CB_RECALL - Recall a Delegation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs4_xdr_enc_cb_recall</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">nfs4_delegation</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_cb_compound_hdr</span> <span class="n">hdr</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ident</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_clp</span><span class="o">-&gt;</span><span class="n">cl_cb_ident</span><span class="p">,</span>
		<span class="p">.</span><span class="n">minorversion</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_minorversion</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">encode_cb_compound4args</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">);</span>
	<span class="n">encode_cb_sequence4args</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">);</span>
	<span class="n">encode_cb_recall4args</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">);</span>
	<span class="n">encode_cb_nops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NFSv4.0 and NFSv4.1 XDR decode functions</span>
<span class="cm"> *</span>
<span class="cm"> * NFSv4.0 callback result types are defined in section 15 of RFC</span>
<span class="cm"> * 3530: &quot;Network File System (NFS) version 4 Protocol&quot; and section 20</span>
<span class="cm"> * of RFC 5661:  &quot;Network File System (NFS) Version 4 Minor Version 1</span>
<span class="cm"> * Protocol&quot;.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs4_xdr_dec_cb_null</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">__unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 20.2. Operation 4: CB_RECALL - Recall a Delegation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs4_xdr_dec_cb_recall</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs4_cb_compound_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">nfsstat4</span> <span class="n">nfserr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">decode_cb_compound4res</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">decode_cb_sequence4res</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">decode_cb_op_status</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">OP_CB_RECALL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfserr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nfserr</span> <span class="o">!=</span> <span class="n">NFS4_OK</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">nfs_cb_stat_to_errno</span><span class="p">(</span><span class="n">nfserr</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * RPC procedure tables</span>
<span class="cm"> */</span>
<span class="cp">#define PROC(proc, call, argtype, restype)				\</span>
<span class="cp">[NFSPROC4_CLNT_##proc] = {						\</span>
<span class="cp">	.p_proc    = NFSPROC4_CB_##call,				\</span>
<span class="cp">	.p_encode  = (kxdreproc_t)nfs4_xdr_enc_##argtype,		\</span>
<span class="cp">	.p_decode  = (kxdrdproc_t)nfs4_xdr_dec_##restype,		\</span>
<span class="cp">	.p_arglen  = NFS4_enc_##argtype##_sz,				\</span>
<span class="cp">	.p_replen  = NFS4_dec_##restype##_sz,				\</span>
<span class="cp">	.p_statidx = NFSPROC4_CB_##call,				\</span>
<span class="cp">	.p_name    = #proc,						\</span>
<span class="cp">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_procinfo</span> <span class="n">nfs4_cb_procedures</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">CB_NULL</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">cb_null</span><span class="p">,</span>	<span class="n">cb_null</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">CB_RECALL</span><span class="p">,</span>	<span class="n">COMPOUND</span><span class="p">,</span>	<span class="n">cb_recall</span><span class="p">,</span>	<span class="n">cb_recall</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_version</span> <span class="n">nfs_cb_version4</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/*</span>
<span class="cm"> * Note on the callback rpc program version number: despite language in rfc</span>
<span class="cm"> * 5661 section 18.36.3 requiring servers to use 4 in this field, the</span>
<span class="cm"> * official xdr descriptions for both 4.0 and 4.1 specify version 1, and</span>
<span class="cm"> * in practice that appears to be what implementations use.  The section</span>
<span class="cm"> * 18.36.3 language is expected to be fixed in an erratum.</span>
<span class="cm"> */</span>
	<span class="p">.</span><span class="n">number</span>			<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nrprocs</span>		<span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">nfs4_cb_procedures</span><span class="p">),</span>
	<span class="p">.</span><span class="n">procs</span>			<span class="o">=</span> <span class="n">nfs4_cb_procedures</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_version</span> <span class="o">*</span><span class="n">nfs_cb_version</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">nfs_cb_version4</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_program</span> <span class="n">cb_program</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_stat</span> <span class="n">cb_stats</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">program</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">cb_program</span>
<span class="p">};</span>

<span class="cp">#define NFS4_CALLBACK 0x40000000</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_program</span> <span class="n">cb_program</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;nfs4_cb&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">number</span>			<span class="o">=</span> <span class="n">NFS4_CALLBACK</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nrvers</span>			<span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">nfs_cb_version</span><span class="p">),</span>
	<span class="p">.</span><span class="n">version</span>		<span class="o">=</span> <span class="n">nfs_cb_version</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">cb_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pipe_dir_name</span>		<span class="o">=</span> <span class="s">&quot;nfsd4_cb&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">max_cb_time</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">nfsd4_lease</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="p">(</span><span class="kt">time_t</span><span class="p">)</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_callback_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_cb_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfsd4_session</span> <span class="o">*</span><span class="n">ses</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_timeout</span>	<span class="n">timeparms</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">to_initval</span>	<span class="o">=</span> <span class="n">max_cb_time</span><span class="p">(),</span>
		<span class="p">.</span><span class="n">to_retries</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">rpc_create_args</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">net</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span>
		<span class="p">.</span><span class="n">address</span>	<span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">cb_addr</span><span class="p">,</span>
		<span class="p">.</span><span class="n">addrsize</span>	<span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">cb_addrlen</span><span class="p">,</span>
		<span class="p">.</span><span class="n">saddress</span>	<span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">cb_saddr</span><span class="p">,</span>
		<span class="p">.</span><span class="n">timeout</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">timeparms</span><span class="p">,</span>
		<span class="p">.</span><span class="n">program</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">cb_program</span><span class="p">,</span>
		<span class="p">.</span><span class="n">version</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="p">(</span><span class="n">RPC_CLNT_CREATE_NOPING</span> <span class="o">|</span> <span class="n">RPC_CLNT_CREATE_QUIET</span><span class="p">),</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">client</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_minorversion</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cred</span><span class="p">.</span><span class="n">cr_principal</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_flavor</span> <span class="o">&gt;=</span> <span class="n">RPC_AUTH_GSS_KRB5</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">client_name</span> <span class="o">=</span> <span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cred</span><span class="p">.</span><span class="n">cr_principal</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">prognumber</span>	<span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">cb_prog</span><span class="p">,</span>
		<span class="n">args</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">XPRT_TRANSPORT_TCP</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">authflavor</span> <span class="o">=</span> <span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_flavor</span><span class="p">;</span>
		<span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_ident</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">cb_ident</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">cb_xprt</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_conn</span><span class="p">.</span><span class="n">cb_xprt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">cb_xprt</span><span class="p">;</span>
		<span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_session</span> <span class="o">=</span> <span class="n">ses</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">bc_xprt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">cb_xprt</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">prognumber</span> <span class="o">=</span> <span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_session</span><span class="o">-&gt;</span><span class="n">se_cb_prog</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">XPRT_TRANSPORT_BC_TCP</span><span class="p">;</span>
		<span class="n">args</span><span class="p">.</span><span class="n">authflavor</span> <span class="o">=</span> <span class="n">RPC_AUTH_UNIX</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Create RPC client */</span>
	<span class="n">client</span> <span class="o">=</span> <span class="n">rpc_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">client</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFSD: couldn&#39;t create callback client: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">PTR_ERR</span><span class="p">(</span><span class="n">client</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_client</span> <span class="o">=</span> <span class="n">client</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">warn_no_callback_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFSD: warning: no callback path to client %.*s: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_name</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfsd4_mark_cb_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_state</span> <span class="o">=</span> <span class="n">NFSD4_CB_DOWN</span><span class="p">;</span>
	<span class="n">warn_no_callback_path</span><span class="p">(</span><span class="n">clp</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfsd4_mark_cb_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_state</span> <span class="o">=</span> <span class="n">NFSD4_CB_FAULT</span><span class="p">;</span>
	<span class="n">warn_no_callback_path</span><span class="p">(</span><span class="n">clp</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfsd4_cb_probe_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">calldata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">calldata</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_client</span><span class="p">,</span> <span class="n">cl_cb_null</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">)</span>
		<span class="n">nfsd4_mark_cb_down</span><span class="p">(</span><span class="n">clp</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_state</span> <span class="o">=</span> <span class="n">NFSD4_CB_UP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_call_ops</span> <span class="n">nfsd4_cb_probe_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* XXX: release method to ensure we set the cb channel down if</span>
<span class="cm">	 * necessary on early failure? */</span>
	<span class="p">.</span><span class="n">rpc_call_done</span> <span class="o">=</span> <span class="n">nfsd4_cb_probe_done</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_cred</span> <span class="o">*</span><span class="n">callback_cred</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">set_callback_cred</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">callback_cred</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">callback_cred</span> <span class="o">=</span> <span class="n">rpc_lookup_machine_cred</span><span class="p">(</span><span class="s">&quot;nfs&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">callback_cred</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">callback_wq</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">run_nfsd4_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">callback_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_probe_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_null</span><span class="p">;</span>

	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_op</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_clp</span> <span class="o">=</span> <span class="n">clp</span><span class="p">;</span>

	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_msg</span><span class="p">.</span><span class="n">rpc_proc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfs4_cb_procedures</span><span class="p">[</span><span class="n">NFSPROC4_CLNT_CB_NULL</span><span class="p">];</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_msg</span><span class="p">.</span><span class="n">rpc_argp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_msg</span><span class="p">.</span><span class="n">rpc_resp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_msg</span><span class="p">.</span><span class="n">rpc_cred</span> <span class="o">=</span> <span class="n">callback_cred</span><span class="p">;</span>

	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsd4_cb_probe_ops</span><span class="p">;</span>

	<span class="n">run_nfsd4_cb</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Poke the callback thread to process any updates to the callback</span>
<span class="cm"> * parameters, and send a null probe.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfsd4_probe_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* XXX: atomicity?  Also, should we be using cl_flags? */</span>
	<span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_state</span> <span class="o">=</span> <span class="n">NFSD4_CB_UNKNOWN</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">NFSD4_CLIENT_CB_UPDATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_flags</span><span class="p">);</span>
	<span class="n">do_probe_callback</span><span class="p">(</span><span class="n">clp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfsd4_probe_callback_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nfsd4_probe_callback</span><span class="p">(</span><span class="n">clp</span><span class="p">);</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">callback_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfsd4_change_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_cb_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_state</span> <span class="o">=</span> <span class="n">NFSD4_CB_UNKNOWN</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_conn</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_cb_conn</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There&#39;s currently a single callback channel slot.</span>
<span class="cm"> * If the slot is available, then mark it busy.  Otherwise, set the</span>
<span class="cm"> * thread for sleeping on the callback RPC wait queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">nfsd41_cb_get_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_slot_busy</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rpc_sleep_on</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_waitq</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s slot is busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * TODO: cb_sequence should support referring call lists, cachethis, multiple</span>
<span class="cm"> * slots, and mark callback channel down on communication errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfsd4_cb_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">calldata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span> <span class="o">=</span> <span class="n">calldata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_delegation</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_delegation</span><span class="p">,</span> <span class="n">dl_recall</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dl_stid</span><span class="p">.</span><span class="n">sc_client</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">minorversion</span> <span class="o">=</span> <span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_minorversion</span><span class="p">;</span>

	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_minorversion</span> <span class="o">=</span> <span class="n">minorversion</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">minorversion</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfsd41_cb_get_slot</span><span class="p">(</span><span class="n">clp</span><span class="p">,</span> <span class="n">task</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_per_client</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* This is the first call, not a restart */</span>
		<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_per_client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_callbacks</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="n">rpc_call_start</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfsd4_cb_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">calldata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span> <span class="o">=</span> <span class="n">calldata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_delegation</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_delegation</span><span class="p">,</span> <span class="n">dl_recall</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dl_stid</span><span class="p">.</span><span class="n">sc_client</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: minorversion=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_minorversion</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_minorversion</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No need for lock, access serialized in nfsd4_cb_prepare */</span>
		<span class="o">++</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_session</span><span class="o">-&gt;</span><span class="n">se_cb_seq_nr</span><span class="p">;</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_slot_busy</span><span class="p">);</span>
		<span class="n">rpc_wake_up_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_waitq</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: freed slot, new seqid=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_session</span><span class="o">-&gt;</span><span class="n">se_cb_seq_nr</span><span class="p">);</span>

		<span class="cm">/* We&#39;re done looking into the sequence information */</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_msg</span><span class="p">.</span><span class="n">rpc_resp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfsd4_cb_recall_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">calldata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span> <span class="o">=</span> <span class="n">calldata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_delegation</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_delegation</span><span class="p">,</span> <span class="n">dl_recall</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dl_stid</span><span class="p">.</span><span class="n">sc_client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">current_rpc_client</span> <span class="o">=</span> <span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_client</span><span class="p">;</span>

	<span class="n">nfsd4_cb_done</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">calldata</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current_rpc_client</span> <span class="o">!=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_client</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We&#39;re shutting down or changing cl_cb_client; leave</span>
<span class="cm">		 * it to nfsd4_process_cb_update to restart the call if</span>
<span class="cm">		 * necessary. */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_done</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EBADHANDLE</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">NFS4ERR_BAD_STATEID</span>:
		<span class="cm">/* Race: client probably got cb_recall</span>
<span class="cm">		 * before open reply granting delegation */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Network partition? */</span>
		<span class="n">nfsd4_mark_cb_down</span><span class="p">(</span><span class="n">clp</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dl_retries</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rpc_delay</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rpc_restart_call_prepare</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nfsd4_mark_cb_down</span><span class="p">(</span><span class="n">clp</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">tk_status</span><span class="p">);</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfsd4_cb_recall_release</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">calldata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span> <span class="o">=</span> <span class="n">calldata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_clp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_delegation</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_delegation</span><span class="p">,</span> <span class="n">dl_recall</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_per_client</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
		<span class="n">nfs4_put_delegation</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_call_ops</span> <span class="n">nfsd4_cb_recall_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">rpc_call_prepare</span> <span class="o">=</span> <span class="n">nfsd4_cb_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rpc_call_done</span> <span class="o">=</span> <span class="n">nfsd4_cb_recall_done</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rpc_release</span> <span class="o">=</span> <span class="n">nfsd4_cb_recall_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">nfsd4_create_callback_queue</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">callback_wq</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;nfsd4_callbacks&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">callback_wq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfsd4_destroy_callback_queue</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">callback_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* must be called under the state lock */</span>
<span class="kt">void</span> <span class="nf">nfsd4_shutdown_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">NFSD4_CLIENT_CB_KILL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note this won&#39;t actually result in a null callback;</span>
<span class="cm">	 * instead, nfsd4_do_callback_rpc() will detect the killed</span>
<span class="cm">	 * client, destroy the rpc client, and stop:</span>
<span class="cm">	 */</span>
	<span class="n">do_probe_callback</span><span class="p">(</span><span class="n">clp</span><span class="p">);</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">callback_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfsd4_release_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_ops</span><span class="o">-&gt;</span><span class="n">rpc_release</span><span class="p">)</span>
		<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_ops</span><span class="o">-&gt;</span><span class="n">rpc_release</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* requires cl_lock: */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nfsd4_conn</span> <span class="o">*</span> <span class="nf">__nfsd4_find_backchannel</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfsd4_session</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd4_conn</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_sessions</span><span class="p">,</span> <span class="n">se_perclnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">se_conns</span><span class="p">,</span> <span class="n">cn_persession</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cn_flags</span> <span class="o">&amp;</span> <span class="n">NFS4_CDFC4_BACK</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfsd4_process_cb_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs4_cb_conn</span> <span class="n">conn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_clp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd4_session</span> <span class="o">*</span><span class="n">ses</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd4_conn</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is either an update, or the client dying; in either case,</span>
<span class="cm">	 * kill the old client:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_client</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rpc_shutdown_client</span><span class="p">(</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_client</span><span class="p">);</span>
		<span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_client</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_conn</span><span class="p">.</span><span class="n">cb_xprt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">svc_xprt_put</span><span class="p">(</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_conn</span><span class="p">.</span><span class="n">cb_xprt</span><span class="p">);</span>
		<span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_conn</span><span class="p">.</span><span class="n">cb_xprt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFSD4_CLIENT_CB_KILL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only serialized callback code is allowed to clear these</span>
<span class="cm">	 * flags; main nfsd code can only set them:</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_flags</span> <span class="o">&amp;</span> <span class="n">NFSD4_CLIENT_CB_FLAG_MASK</span><span class="p">));</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">NFSD4_CLIENT_CB_UPDATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_flags</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_clp</span><span class="o">-&gt;</span><span class="n">cl_cb_conn</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_cb_conn</span><span class="p">));</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">__nfsd4_find_backchannel</span><span class="p">(</span><span class="n">clp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">svc_xprt_get</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cn_xprt</span><span class="p">);</span>
		<span class="n">conn</span><span class="p">.</span><span class="n">cb_xprt</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cn_xprt</span><span class="p">;</span>
		<span class="n">ses</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cn_session</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">setup_callback_client</span><span class="p">(</span><span class="n">clp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">,</span> <span class="n">ses</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfsd4_mark_cb_down</span><span class="p">(</span><span class="n">clp</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Yay, the callback channel&#39;s back! Restart any callbacks: */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_callbacks</span><span class="p">,</span> <span class="n">cb_per_client</span><span class="p">)</span>
		<span class="n">run_nfsd4_cb</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfsd4_do_callback_rpc</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfsd4_callback</span><span class="p">,</span> <span class="n">cb_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_clp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span><span class="n">clnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_flags</span> <span class="o">&amp;</span> <span class="n">NFSD4_CLIENT_CB_FLAG_MASK</span><span class="p">)</span>
		<span class="n">nfsd4_process_cb_update</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>

	<span class="n">clnt</span> <span class="o">=</span> <span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_cb_client</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Callback channel broken, or client killed; give up: */</span>
		<span class="n">nfsd4_release_cb</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rpc_call_async</span><span class="p">(</span><span class="n">clnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_msg</span><span class="p">,</span> <span class="n">RPC_TASK_SOFT</span> <span class="o">|</span> <span class="n">RPC_TASK_SOFTCONN</span><span class="p">,</span>
			<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_ops</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfsd4_cb_recall</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_delegation</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="o">*</span><span class="n">cb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dl_recall</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dl_stid</span><span class="p">.</span><span class="n">sc_client</span><span class="p">;</span>

	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">dl_retries</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_op</span> <span class="o">=</span> <span class="n">dp</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_clp</span> <span class="o">=</span> <span class="n">clp</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_msg</span><span class="p">.</span><span class="n">rpc_proc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfs4_cb_procedures</span><span class="p">[</span><span class="n">NFSPROC4_CLNT_CB_RECALL</span><span class="p">];</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_msg</span><span class="p">.</span><span class="n">rpc_argp</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_msg</span><span class="p">.</span><span class="n">rpc_resp</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_msg</span><span class="p">.</span><span class="n">rpc_cred</span> <span class="o">=</span> <span class="n">callback_cred</span><span class="p">;</span>

	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsd4_cb_recall_ops</span><span class="p">;</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">dl_retries</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_per_client</span><span class="p">);</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">cb_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">run_nfsd4_cb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dl_recall</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
