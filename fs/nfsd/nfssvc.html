<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nfsd › nfssvc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nfssvc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Central processing for nfsd.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Olaf Kirch (okir@monad.swb.de)</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995, 1996, 1997 Olaf Kirch &lt;okir@monad.swb.de&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/fs_struct.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>

<span class="cp">#include &lt;linux/sunrpc/stats.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/svcsock.h&gt;</span>
<span class="cp">#include &lt;linux/lockd/bind.h&gt;</span>
<span class="cp">#include &lt;linux/nfsacl.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &quot;nfsd.h&quot;</span>
<span class="cp">#include &quot;cache.h&quot;</span>
<span class="cp">#include &quot;vfs.h&quot;</span>

<span class="cp">#define NFSDDBG_FACILITY	NFSDDBG_SVC</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">svc_program</span>	<span class="n">nfsd_program</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">nfsd</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vrqstp</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">timeval</span>			<span class="n">nfssvc_boot</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * nfsd_mutex protects nfsd_serv -- both the pointer itself and the members</span>
<span class="cm"> * of the svc_serv struct. In particular, -&gt;sv_nrthreads but also to some</span>
<span class="cm"> * extent -&gt;sv_temp_socks and -&gt;sv_permsocks. It also protects nfsdstats.th_cnt</span>
<span class="cm"> *</span>
<span class="cm"> * If (out side the lock) nfsd_serv is non-NULL, then it must point to a</span>
<span class="cm"> * properly initialised &#39;struct svc_serv&#39; with -&gt;sv_nrthreads &gt; 0. That number</span>
<span class="cm"> * of nfsd threads must exist and each must listed in -&gt;sp_all_threads in each</span>
<span class="cm"> * entry of -&gt;sv_pools[].</span>
<span class="cm"> *</span>
<span class="cm"> * Transitions of the thread count between zero and non-zero are of particular</span>
<span class="cm"> * interest since the svc_serv needs to be created and initialized at that</span>
<span class="cm"> * point, or freed.</span>
<span class="cm"> *</span>
<span class="cm"> * Finally, the nfsd_mutex also protects some of the global variables that are</span>
<span class="cm"> * accessed when nfsd starts and that are settable via the write_* routines in</span>
<span class="cm"> * nfsctl.c. In particular:</span>
<span class="cm"> *</span>
<span class="cm"> *	user_recovery_dirname</span>
<span class="cm"> *	user_lease_time</span>
<span class="cm"> *	nfsd_versions</span>
<span class="cm"> */</span>
<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">nfsd_mutex</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">svc_serv</span> 		<span class="o">*</span><span class="n">nfsd_serv</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * nfsd_drc_lock protects nfsd_drc_max_pages and nfsd_drc_pages_used.</span>
<span class="cm"> * nfsd_drc_max_pages limits the total amount of memory available for</span>
<span class="cm"> * version 4.1 DRC caches.</span>
<span class="cm"> * nfsd_drc_pages_used tracks the current version 4.1 DRC memory usage.</span>
<span class="cm"> */</span>
<span class="n">spinlock_t</span>	<span class="n">nfsd_drc_lock</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">nfsd_drc_max_mem</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">nfsd_drc_mem_used</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_stat</span>	<span class="n">nfsd_acl_svcstats</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_version</span> <span class="o">*</span>	<span class="n">nfsd_acl_version</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsd_acl_version2</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsd_acl_version3</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define NFSD_ACL_MINVERS            2</span>
<span class="cp">#define NFSD_ACL_NRVERS		ARRAY_SIZE(nfsd_acl_version)</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_version</span> <span class="o">*</span><span class="n">nfsd_acl_versions</span><span class="p">[</span><span class="n">NFSD_ACL_NRVERS</span><span class="p">];</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_program</span>	<span class="n">nfsd_acl_program</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">pg_prog</span>		<span class="o">=</span> <span class="n">NFS_ACL_PROGRAM</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pg_nvers</span>		<span class="o">=</span> <span class="n">NFSD_ACL_NRVERS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pg_vers</span>		<span class="o">=</span> <span class="n">nfsd_acl_versions</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pg_name</span>		<span class="o">=</span> <span class="s">&quot;nfsacl&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pg_class</span>		<span class="o">=</span> <span class="s">&quot;nfsd&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pg_stats</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsd_acl_svcstats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pg_authenticate</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">svc_set_client</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_stat</span>	<span class="n">nfsd_acl_svcstats</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">program</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsd_acl_program</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL) */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_version</span> <span class="o">*</span>	<span class="n">nfsd_version</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsd_version2</span><span class="p">,</span>
<span class="cp">#if defined(CONFIG_NFSD_V3)</span>
	<span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsd_version3</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(CONFIG_NFSD_V4)</span>
	<span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsd_version4</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#define NFSD_MINVERS    	2</span>
<span class="cp">#define NFSD_NRVERS		ARRAY_SIZE(nfsd_version)</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">svc_version</span> <span class="o">*</span><span class="n">nfsd_versions</span><span class="p">[</span><span class="n">NFSD_NRVERS</span><span class="p">];</span>

<span class="k">struct</span> <span class="n">svc_program</span>		<span class="n">nfsd_program</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)</span>
	<span class="p">.</span><span class="n">pg_next</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsd_acl_program</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">pg_prog</span>		<span class="o">=</span> <span class="n">NFS_PROGRAM</span><span class="p">,</span>		<span class="cm">/* program number */</span>
	<span class="p">.</span><span class="n">pg_nvers</span>		<span class="o">=</span> <span class="n">NFSD_NRVERS</span><span class="p">,</span>		<span class="cm">/* nr of entries in nfsd_version */</span>
	<span class="p">.</span><span class="n">pg_vers</span>		<span class="o">=</span> <span class="n">nfsd_versions</span><span class="p">,</span>	<span class="cm">/* version table */</span>
	<span class="p">.</span><span class="n">pg_name</span>		<span class="o">=</span> <span class="s">&quot;nfsd&quot;</span><span class="p">,</span>		<span class="cm">/* program name */</span>
	<span class="p">.</span><span class="n">pg_class</span>		<span class="o">=</span> <span class="s">&quot;nfsd&quot;</span><span class="p">,</span>		<span class="cm">/* authentication class */</span>
	<span class="p">.</span><span class="n">pg_stats</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsd_svcstats</span><span class="p">,</span>	<span class="cm">/* version table */</span>
	<span class="p">.</span><span class="n">pg_authenticate</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">svc_set_client</span><span class="p">,</span>	<span class="cm">/* export authentication */</span>

<span class="p">};</span>

<span class="n">u32</span> <span class="n">nfsd_supported_minorversion</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">nfsd_vers</span><span class="p">(</span><span class="kt">int</span> <span class="n">vers</span><span class="p">,</span> <span class="k">enum</span> <span class="n">vers_op</span> <span class="n">change</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vers</span> <span class="o">&lt;</span> <span class="n">NFSD_MINVERS</span> <span class="o">||</span> <span class="n">vers</span> <span class="o">&gt;=</span> <span class="n">NFSD_NRVERS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">change</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NFSD_SET</span>:
		<span class="n">nfsd_versions</span><span class="p">[</span><span class="n">vers</span><span class="p">]</span> <span class="o">=</span> <span class="n">nfsd_version</span><span class="p">[</span><span class="n">vers</span><span class="p">];</span>
<span class="cp">#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vers</span> <span class="o">&lt;</span> <span class="n">NFSD_ACL_NRVERS</span><span class="p">)</span>
			<span class="n">nfsd_acl_versions</span><span class="p">[</span><span class="n">vers</span><span class="p">]</span> <span class="o">=</span> <span class="n">nfsd_acl_version</span><span class="p">[</span><span class="n">vers</span><span class="p">];</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NFSD_CLEAR</span>:
		<span class="n">nfsd_versions</span><span class="p">[</span><span class="n">vers</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vers</span> <span class="o">&lt;</span> <span class="n">NFSD_ACL_NRVERS</span><span class="p">)</span>
			<span class="n">nfsd_acl_versions</span><span class="p">[</span><span class="n">vers</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NFSD_TEST</span>:
		<span class="k">return</span> <span class="n">nfsd_versions</span><span class="p">[</span><span class="n">vers</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NFSD_AVAIL</span>:
		<span class="k">return</span> <span class="n">nfsd_version</span><span class="p">[</span><span class="n">vers</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nfsd_minorversion</span><span class="p">(</span><span class="n">u32</span> <span class="n">minorversion</span><span class="p">,</span> <span class="k">enum</span> <span class="n">vers_op</span> <span class="n">change</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">minorversion</span> <span class="o">&gt;</span> <span class="n">NFSD_SUPPORTED_MINOR_VERSION</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">change</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NFSD_SET</span>:
		<span class="n">nfsd_supported_minorversion</span> <span class="o">=</span> <span class="n">minorversion</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NFSD_CLEAR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">minorversion</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">nfsd_supported_minorversion</span> <span class="o">=</span> <span class="n">minorversion</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NFSD_TEST</span>:
		<span class="k">return</span> <span class="n">minorversion</span> <span class="o">&lt;=</span> <span class="n">nfsd_supported_minorversion</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NFSD_AVAIL</span>:
		<span class="k">return</span> <span class="n">minorversion</span> <span class="o">&lt;=</span> <span class="n">NFSD_SUPPORTED_MINOR_VERSION</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum number of nfsd processes</span>
<span class="cm"> */</span>
<span class="cp">#define	NFSD_MAXSERVS		8192</span>

<span class="kt">int</span> <span class="nf">nfsd_nrthreads</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span><span class="p">)</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfsd_init_socks</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_permsocks</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">svc_create_xprt</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="s">&quot;udp&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span>
					<span class="n">SVC_SOCK_DEFAULTS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">svc_create_xprt</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span>
					<span class="n">SVC_SOCK_DEFAULTS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">nfsd_up</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfsd_startup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrservs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_up</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Readahead param cache - will no-op if it already exists.</span>
<span class="cm">	 * (Note therefore results will be suboptimal if number of</span>
<span class="cm">	 * threads is modified after nfsd start.)</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nfsd_racache_init</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">nrservs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nfsd_init_socks</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_racache</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">lockd_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_racache</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nfs4_state_start</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_lockd</span><span class="p">;</span>
	<span class="n">nfsd_up</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_lockd:</span>
	<span class="n">lockd_down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">);</span>
<span class="nl">out_racache:</span>
	<span class="n">nfsd_racache_shutdown</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfsd_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * write_ports can create the server without actually starting</span>
<span class="cm">	 * any threads--if we get shut down before any threads are</span>
<span class="cm">	 * started, then nfsd_last_thread will be run before any of this</span>
<span class="cm">	 * other initialization has been done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfsd_up</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">nfs4_state_shutdown</span><span class="p">();</span>
	<span class="n">lockd_down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">);</span>
	<span class="n">nfsd_racache_shutdown</span><span class="p">();</span>
	<span class="n">nfsd_up</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfsd_last_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span><span class="n">serv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* When last nfsd thread exits we need to do some clean-up */</span>
	<span class="n">nfsd_serv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">nfsd_shutdown</span><span class="p">();</span>

	<span class="n">svc_rpcb_cleanup</span><span class="p">(</span><span class="n">serv</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;nfsd: last server has exited, flushing export &quot;</span>
			    <span class="s">&quot;cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">nfsd_export_flush</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfsd_reset_versions</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">found_one</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">NFSD_MINVERS</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NFSD_NRVERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_program</span><span class="p">.</span><span class="n">pg_vers</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">found_one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found_one</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">NFSD_MINVERS</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NFSD_NRVERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">nfsd_program</span><span class="p">.</span><span class="n">pg_vers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nfsd_version</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">NFSD_ACL_MINVERS</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NFSD_ACL_NRVERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">nfsd_acl_program</span><span class="p">.</span><span class="n">pg_vers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">nfsd_acl_version</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Each session guarantees a negotiated per slot memory cache for replies</span>
<span class="cm"> * which in turn consumes memory beyond the v2/v3/v4.0 server. A dedicated</span>
<span class="cm"> * NFSv4.1 server might want to use more memory for a DRC than a machine</span>
<span class="cm"> * with mutiple services.</span>
<span class="cm"> *</span>
<span class="cm"> * Impose a hard limit on the number of pages for the DRC which varies</span>
<span class="cm"> * according to the machines free pages. This is of course only a default.</span>
<span class="cm"> *</span>
<span class="cm"> * For now this is a #defined shift which could be under admin control</span>
<span class="cm"> * in the future.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_max_drc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cp">#define NFSD_DRC_SIZE_SHIFT	10</span>
	<span class="n">nfsd_drc_max_mem</span> <span class="o">=</span> <span class="p">(</span><span class="n">nr_free_buffer_pages</span><span class="p">()</span>
					<span class="o">&gt;&gt;</span> <span class="n">NFSD_DRC_SIZE_SHIFT</span><span class="p">)</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">nfsd_drc_mem_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_drc_lock</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s nfsd_drc_max_mem %u </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">nfsd_drc_max_mem</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfsd_get_default_max_blksize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sysinfo</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">target</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">si_meminfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">totalram</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">totalhigh</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Aim for 1/4096 of memory per thread This gives 1MB on 4Gig</span>
<span class="cm">	 * machines, but only uses 32K on 128M machines.  Bottom out at</span>
<span class="cm">	 * 8K on 32M and smaller.  Of course, this is only a default.</span>
<span class="cm">	 */</span>
	<span class="n">target</span> <span class="o">&gt;&gt;=</span> <span class="mi">12</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">NFSSVC_MAXBLKSIZE</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nfsd_create_serv</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">svc_get</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_max_blksize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nfsd_max_blksize</span> <span class="o">=</span> <span class="n">nfsd_get_default_max_blksize</span><span class="p">();</span>
	<span class="n">nfsd_reset_versions</span><span class="p">();</span>
	<span class="n">nfsd_serv</span> <span class="o">=</span> <span class="n">svc_create_pooled</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_program</span><span class="p">,</span> <span class="n">nfsd_max_blksize</span><span class="p">,</span>
				      <span class="n">nfsd_last_thread</span><span class="p">,</span> <span class="n">nfsd</span><span class="p">,</span> <span class="n">THIS_MODULE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">svc_bind</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">net_ns</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">svc_destroy</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_max_drc</span><span class="p">();</span>
	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfssvc_boot</span><span class="p">);</span>		<span class="cm">/* record boot time */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nfsd_nrpools</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_nrpools</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nfsd_get_nrthreads</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nthreads</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_nrpools</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">nthreads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_pools</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sp_nrthreads</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nfsd_set_nrthreads</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nthreads</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_nrpools</span><span class="p">)</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_nrpools</span><span class="p">;</span>

	<span class="cm">/* enforce a global maximum number of threads */</span>
	<span class="n">tot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nthreads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">NFSD_MAXSERVS</span><span class="p">)</span>
			<span class="n">nthreads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NFSD_MAXSERVS</span><span class="p">;</span>
		<span class="n">tot</span> <span class="o">+=</span> <span class="n">nthreads</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tot</span> <span class="o">&gt;</span> <span class="n">NFSD_MAXSERVS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* total too large: scale down requested numbers */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">tot</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		    	<span class="kt">int</span> <span class="n">new</span> <span class="o">=</span> <span class="n">nthreads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">NFSD_MAXSERVS</span> <span class="o">/</span> <span class="n">tot</span><span class="p">;</span>
			<span class="n">tot</span> <span class="o">-=</span> <span class="p">(</span><span class="n">nthreads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">new</span><span class="p">);</span>
			<span class="n">nthreads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">tot</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nthreads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
			<span class="n">tot</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * There must always be a thread in pool 0; the admin</span>
<span class="cm">	 * can&#39;t shut down NFS completely using pool_threads.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nthreads</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nthreads</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* apply the new numbers */</span>
	<span class="n">svc_get</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">svc_set_num_threads</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_pools</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				    	  <span class="n">nthreads</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">svc_shutdown_net</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
	<span class="n">svc_destroy</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Adjust the number of threads and return the new number of threads.</span>
<span class="cm"> * This is also the function that starts the server if necessary, if</span>
<span class="cm"> * this is the first time nrservs is nonzero.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">nfsd_svc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrservs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">error</span><span class="p">;</span>
	<span class="n">bool</span>	<span class="n">nfsd_up_before</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfsd: creating service</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nrservs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nrservs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nrservs</span> <span class="o">&gt;</span> <span class="n">NFSD_MAXSERVS</span><span class="p">)</span>
		<span class="n">nrservs</span> <span class="o">=</span> <span class="n">NFSD_MAXSERVS</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nrservs</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nfsd_serv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">nfsd_create_serv</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">nfsd_up_before</span> <span class="o">=</span> <span class="n">nfsd_up</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">nfsd_startup</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">nrservs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_destroy</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">svc_set_num_threads</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">nrservs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_shutdown</span><span class="p">;</span>
	<span class="cm">/* We are holding a reference to nfsd_serv which</span>
<span class="cm">	 * we don&#39;t want to count in the return value,</span>
<span class="cm">	 * so subtract 1</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out_shutdown:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nfsd_up_before</span><span class="p">)</span>
		<span class="n">nfsd_shutdown</span><span class="p">();</span>
<span class="nl">out_destroy:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">svc_shutdown_net</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
	<span class="n">svc_destroy</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">);</span>		<span class="cm">/* Release server */</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * This is the NFS server kernel thread</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nfsd</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vrqstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="p">)</span> <span class="n">vrqstp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">preverr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Lock module and set up kernel thread */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>

	<span class="cm">/* At this point, the thread shares current-&gt;fs</span>
<span class="cm">	 * with the init process. We need to create files with a</span>
<span class="cm">	 * umask of 0 instead of init&#39;s umask. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unshare_fs_struct</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unable to start nfsd thread: out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">umask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * thread is spawned with all signals set to SIG_IGN, re-enable</span>
<span class="cm">	 * the ones that will bring down the thread</span>
<span class="cm">	 */</span>
	<span class="n">allow_signal</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">);</span>
	<span class="n">allow_signal</span><span class="p">(</span><span class="n">SIGHUP</span><span class="p">);</span>
	<span class="n">allow_signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">);</span>
	<span class="n">allow_signal</span><span class="p">(</span><span class="n">SIGQUIT</span><span class="p">);</span>

	<span class="n">nfsdstats</span><span class="p">.</span><span class="n">th_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We want less throttling in balance_dirty_pages() so that nfs to</span>
<span class="cm">	 * localhost doesn&#39;t cause nfsd to lock up due to all the client&#39;s</span>
<span class="cm">	 * dirty pages.</span>
<span class="cm">	 */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_LESS_THROTTLE</span><span class="p">;</span>
	<span class="n">set_freezable</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * The main request loop</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Find a socket with data available and call its</span>
<span class="cm">		 * recvfrom routine.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">svc_recv</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="n">HZ</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">preverr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: unexpected error &quot;</span>
					<span class="s">&quot;from svc_recv (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="o">-</span><span class="n">err</span><span class="p">);</span>
				<span class="n">preverr</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="n">HZ</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">validate_process_creds</span><span class="p">();</span>
		<span class="n">svc_process</span><span class="p">(</span><span class="n">rqstp</span><span class="p">);</span>
		<span class="n">validate_process_creds</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Clear signals before calling svc_exit_thread() */</span>
	<span class="n">flush_signals</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="n">nfsdstats</span><span class="p">.</span><span class="n">th_cnt</span> <span class="o">--</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_server</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">svc_shutdown_net</span><span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">);</span>

	<span class="cm">/* Release the thread */</span>
	<span class="n">svc_exit_thread</span><span class="p">(</span><span class="n">rqstp</span><span class="p">);</span>

	<span class="cm">/* Release module */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="n">module_put_and_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__be32</span> <span class="nf">map_new_errors</span><span class="p">(</span><span class="n">u32</span> <span class="n">vers</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">nfserr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfserr</span> <span class="o">==</span> <span class="n">nfserr_jukebox</span> <span class="o">&amp;&amp;</span> <span class="n">vers</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nfserr_dropit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfserr</span> <span class="o">==</span> <span class="n">nfserr_wrongsec</span> <span class="o">&amp;&amp;</span> <span class="n">vers</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nfserr_acces</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nfserr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">nfsd_dispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">statp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_procedure</span>	<span class="o">*</span><span class="n">proc</span><span class="p">;</span>
	<span class="n">kxdrproc_t</span>		<span class="n">xdr</span><span class="p">;</span>
	<span class="n">__be32</span>			<span class="n">nfserr</span><span class="p">;</span>
	<span class="n">__be32</span>			<span class="o">*</span><span class="n">nfserrp</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfsd_dispatch: vers %d proc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_vers</span><span class="p">,</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_proc</span><span class="p">);</span>
	<span class="n">proc</span> <span class="o">=</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_procinfo</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Give the xdr decoder a chance to change this if it wants</span>
<span class="cm">	 * (necessary in the NFSv4.0 compound case)</span>
<span class="cm">	 */</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_cachetype</span> <span class="o">=</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pc_cachetype</span><span class="p">;</span>
	<span class="cm">/* Decode arguments */</span>
	<span class="n">xdr</span> <span class="o">=</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pc_decode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xdr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xdr</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="p">(</span><span class="n">__be32</span><span class="o">*</span><span class="p">)</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_arg</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span>
			<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_argp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfsd: failed to decode arguments!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="n">statp</span> <span class="o">=</span> <span class="n">rpc_garbage_args</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check whether we have this call in the cache. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">nfsd_cache_lookup</span><span class="p">(</span><span class="n">rqstp</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RC_INTR</span>:
	<span class="k">case</span> <span class="n">RC_DROPIT</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RC_REPLY</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RC_DOIT</span>:<span class="p">;</span>
		<span class="cm">/* do it */</span>
	<span class="p">}</span>

	<span class="cm">/* need to grab the location to store the status, as</span>
<span class="cm">	 * nfsv4 does some encoding while processing </span>
<span class="cm">	 */</span>
	<span class="n">nfserrp</span> <span class="o">=</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span>
		<span class="o">+</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>
	<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be32</span><span class="p">);</span>

	<span class="cm">/* Now call the procedure handler, and encode NFS status. */</span>
	<span class="n">nfserr</span> <span class="o">=</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pc_func</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_argp</span><span class="p">,</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resp</span><span class="p">);</span>
	<span class="n">nfserr</span> <span class="o">=</span> <span class="n">map_new_errors</span><span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_vers</span><span class="p">,</span> <span class="n">nfserr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfserr</span> <span class="o">==</span> <span class="n">nfserr_dropit</span> <span class="o">||</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_dropme</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfsd: Dropping request; may be revisited later</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nfsd_cache_update</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">RC_NOCACHE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_proc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">nfserrp</span><span class="o">++</span> <span class="o">=</span> <span class="n">nfserr</span><span class="p">;</span>

	<span class="cm">/* Encode result.</span>
<span class="cm">	 * For NFSv2, additional info is never returned in case of an error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nfserr</span> <span class="o">&amp;&amp;</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_vers</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xdr</span> <span class="o">=</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pc_encode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xdr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xdr</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">nfserrp</span><span class="p">,</span>
				<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resp</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Failed to encode result. Release cache entry */</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfsd: failed to encode result!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">nfsd_cache_update</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">RC_NOCACHE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="o">*</span><span class="n">statp</span> <span class="o">=</span> <span class="n">rpc_system_err</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Store reply in cache. */</span>
	<span class="n">nfsd_cache_update</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pc_cachetype</span><span class="p">,</span> <span class="n">statp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nfsd_pool_stats_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* bump up the psudo refcount while traversing */</span>
	<span class="n">svc_get</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">svc_pool_stats_open</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nfsd_pool_stats_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="cm">/* this function really, really should have been called svc_put() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">svc_shutdown_net</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
	<span class="n">svc_destroy</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
