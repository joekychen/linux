<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nfsd › nfsd.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nfsd.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Hodge-podge collection of knfsd-related stuff.</span>
<span class="cm"> * I will sort this out later.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995-1997 Olaf Kirch &lt;okir@monad.swb.de&gt;</span>
<span class="cm"> */</span>

<span class="cp">#ifndef LINUX_NFSD_NFSD_H</span>
<span class="cp">#define LINUX_NFSD_NFSD_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>

<span class="cp">#include &lt;linux/nfs.h&gt;</span>
<span class="cp">#include &lt;linux/nfs2.h&gt;</span>
<span class="cp">#include &lt;linux/nfs3.h&gt;</span>
<span class="cp">#include &lt;linux/nfs4.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/msg_prot.h&gt;</span>

<span class="cp">#include &lt;linux/nfsd/debug.h&gt;</span>
<span class="cp">#include &lt;linux/nfsd/export.h&gt;</span>
<span class="cp">#include &lt;linux/nfsd/stats.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * nfsd version</span>
<span class="cm"> */</span>
<span class="cp">#define NFSD_SUPPORTED_MINOR_VERSION	1</span>
<span class="cm">/*</span>
<span class="cm"> * Maximum blocksizes supported by daemon under various circumstances.</span>
<span class="cm"> */</span>
<span class="cp">#define NFSSVC_MAXBLKSIZE       RPCSVC_MAXPAYLOAD</span>
<span class="cm">/* NFSv2 is limited by the protocol specification, see RFC 1094 */</span>
<span class="cp">#define NFSSVC_MAXBLKSIZE_V2    (8*1024)</span>


<span class="cm">/*</span>
<span class="cm"> * Largest number of bytes we need to allocate for an NFS</span>
<span class="cm"> * call or reply.  Used to control buffer sizes.  We use</span>
<span class="cm"> * the length of v3 WRITE, READDIR and READDIR replies</span>
<span class="cm"> * which are an RPC header, up to 26 XDR units of reply</span>
<span class="cm"> * data, and some page data.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that accuracy here doesn&#39;t matter too much as the</span>
<span class="cm"> * size is rounded up to a page size when allocating space.</span>
<span class="cm"> */</span>
<span class="cp">#define NFSD_BUFSIZE            ((RPC_MAX_HEADER_WITH_AUTH+26)*XDR_UNIT + NFSSVC_MAXBLKSIZE)</span>

<span class="k">struct</span> <span class="n">readdir_cd</span> <span class="p">{</span>
	<span class="n">__be32</span>			<span class="n">err</span><span class="p">;</span>	<span class="cm">/* 0, nfserr, or nfserr_eof */</span>
<span class="p">};</span>


<span class="k">extern</span> <span class="k">struct</span> <span class="n">svc_program</span>	<span class="n">nfsd_program</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">svc_version</span>	<span class="n">nfsd_version2</span><span class="p">,</span> <span class="n">nfsd_version3</span><span class="p">,</span>
				<span class="n">nfsd_version4</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">u32</span>			<span class="n">nfsd_supported_minorversion</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span>		<span class="n">nfsd_mutex</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">svc_serv</span>		<span class="o">*</span><span class="n">nfsd_serv</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">spinlock_t</span>		<span class="n">nfsd_drc_lock</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nfsd_drc_max_mem</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nfsd_drc_mem_used</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">nfs_exports_op</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Function prototypes.</span>
<span class="cm"> */</span>
<span class="kt">int</span>		<span class="n">nfsd_svc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrservs</span><span class="p">);</span>
<span class="kt">int</span>		<span class="n">nfsd_dispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">statp</span><span class="p">);</span>

<span class="kt">int</span>		<span class="n">nfsd_nrthreads</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span>		<span class="n">nfsd_nrpools</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span>		<span class="n">nfsd_get_nrthreads</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span>		<span class="n">nfsd_set_nrthreads</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)</span>
<span class="cp">#ifdef CONFIG_NFSD_V2_ACL</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">svc_version</span> <span class="n">nfsd_acl_version2</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#define nfsd_acl_version2 NULL</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_NFSD_V3_ACL</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">svc_version</span> <span class="n">nfsd_acl_version3</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#define nfsd_acl_version3 NULL</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="k">enum</span> <span class="n">vers_op</span> <span class="p">{</span><span class="n">NFSD_SET</span><span class="p">,</span> <span class="n">NFSD_CLEAR</span><span class="p">,</span> <span class="n">NFSD_TEST</span><span class="p">,</span> <span class="n">NFSD_AVAIL</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">nfsd_vers</span><span class="p">(</span><span class="kt">int</span> <span class="n">vers</span><span class="p">,</span> <span class="k">enum</span> <span class="n">vers_op</span> <span class="n">change</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">nfsd_minorversion</span><span class="p">(</span><span class="n">u32</span> <span class="n">minorversion</span><span class="p">,</span> <span class="k">enum</span> <span class="n">vers_op</span> <span class="n">change</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">nfsd_reset_versions</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">nfsd_create_serv</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">nfsd_max_blksize</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nfsd_v4client</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_prog</span> <span class="o">==</span> <span class="n">NFS_PROGRAM</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rq_vers</span> <span class="o">==</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> * NFSv4 State</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_NFSD_V4</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_delegations</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">nfs4_state_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">nfsd4_init_slabs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">nfsd4_free_slabs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">nfs4_state_start</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">nfs4_state_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">nfs4_reset_lease</span><span class="p">(</span><span class="kt">time_t</span> <span class="n">leasetime</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">nfs4_reset_recoverydir</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">recdir</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nfs4_state_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nfsd4_init_slabs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nfsd4_free_slabs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nfs4_state_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nfs4_state_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nfs4_reset_lease</span><span class="p">(</span><span class="kt">time_t</span> <span class="n">leasetime</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nfs4_reset_recoverydir</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">recdir</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * lockd binding</span>
<span class="cm"> */</span>
<span class="kt">void</span>		<span class="n">nfsd_lockd_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span>		<span class="n">nfsd_lockd_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * These macros provide pre-xdr&#39;ed values for faster operation.</span>
<span class="cm"> */</span>
<span class="cp">#define	nfs_ok			cpu_to_be32(NFS_OK)</span>
<span class="cp">#define	nfserr_perm		cpu_to_be32(NFSERR_PERM)</span>
<span class="cp">#define	nfserr_noent		cpu_to_be32(NFSERR_NOENT)</span>
<span class="cp">#define	nfserr_io		cpu_to_be32(NFSERR_IO)</span>
<span class="cp">#define	nfserr_nxio		cpu_to_be32(NFSERR_NXIO)</span>
<span class="cp">#define	nfserr_eagain		cpu_to_be32(NFSERR_EAGAIN)</span>
<span class="cp">#define	nfserr_acces		cpu_to_be32(NFSERR_ACCES)</span>
<span class="cp">#define	nfserr_exist		cpu_to_be32(NFSERR_EXIST)</span>
<span class="cp">#define	nfserr_xdev		cpu_to_be32(NFSERR_XDEV)</span>
<span class="cp">#define	nfserr_nodev		cpu_to_be32(NFSERR_NODEV)</span>
<span class="cp">#define	nfserr_notdir		cpu_to_be32(NFSERR_NOTDIR)</span>
<span class="cp">#define	nfserr_isdir		cpu_to_be32(NFSERR_ISDIR)</span>
<span class="cp">#define	nfserr_inval		cpu_to_be32(NFSERR_INVAL)</span>
<span class="cp">#define	nfserr_fbig		cpu_to_be32(NFSERR_FBIG)</span>
<span class="cp">#define	nfserr_nospc		cpu_to_be32(NFSERR_NOSPC)</span>
<span class="cp">#define	nfserr_rofs		cpu_to_be32(NFSERR_ROFS)</span>
<span class="cp">#define	nfserr_mlink		cpu_to_be32(NFSERR_MLINK)</span>
<span class="cp">#define	nfserr_opnotsupp	cpu_to_be32(NFSERR_OPNOTSUPP)</span>
<span class="cp">#define	nfserr_nametoolong	cpu_to_be32(NFSERR_NAMETOOLONG)</span>
<span class="cp">#define	nfserr_notempty		cpu_to_be32(NFSERR_NOTEMPTY)</span>
<span class="cp">#define	nfserr_dquot		cpu_to_be32(NFSERR_DQUOT)</span>
<span class="cp">#define	nfserr_stale		cpu_to_be32(NFSERR_STALE)</span>
<span class="cp">#define	nfserr_remote		cpu_to_be32(NFSERR_REMOTE)</span>
<span class="cp">#define	nfserr_wflush		cpu_to_be32(NFSERR_WFLUSH)</span>
<span class="cp">#define	nfserr_badhandle	cpu_to_be32(NFSERR_BADHANDLE)</span>
<span class="cp">#define	nfserr_notsync		cpu_to_be32(NFSERR_NOT_SYNC)</span>
<span class="cp">#define	nfserr_badcookie	cpu_to_be32(NFSERR_BAD_COOKIE)</span>
<span class="cp">#define	nfserr_notsupp		cpu_to_be32(NFSERR_NOTSUPP)</span>
<span class="cp">#define	nfserr_toosmall		cpu_to_be32(NFSERR_TOOSMALL)</span>
<span class="cp">#define	nfserr_serverfault	cpu_to_be32(NFSERR_SERVERFAULT)</span>
<span class="cp">#define	nfserr_badtype		cpu_to_be32(NFSERR_BADTYPE)</span>
<span class="cp">#define	nfserr_jukebox		cpu_to_be32(NFSERR_JUKEBOX)</span>
<span class="cp">#define	nfserr_denied		cpu_to_be32(NFSERR_DENIED)</span>
<span class="cp">#define	nfserr_deadlock		cpu_to_be32(NFSERR_DEADLOCK)</span>
<span class="cp">#define nfserr_expired          cpu_to_be32(NFSERR_EXPIRED)</span>
<span class="cp">#define	nfserr_bad_cookie	cpu_to_be32(NFSERR_BAD_COOKIE)</span>
<span class="cp">#define	nfserr_same		cpu_to_be32(NFSERR_SAME)</span>
<span class="cp">#define	nfserr_clid_inuse	cpu_to_be32(NFSERR_CLID_INUSE)</span>
<span class="cp">#define	nfserr_stale_clientid	cpu_to_be32(NFSERR_STALE_CLIENTID)</span>
<span class="cp">#define	nfserr_resource		cpu_to_be32(NFSERR_RESOURCE)</span>
<span class="cp">#define	nfserr_moved		cpu_to_be32(NFSERR_MOVED)</span>
<span class="cp">#define	nfserr_nofilehandle	cpu_to_be32(NFSERR_NOFILEHANDLE)</span>
<span class="cp">#define	nfserr_minor_vers_mismatch	cpu_to_be32(NFSERR_MINOR_VERS_MISMATCH)</span>
<span class="cp">#define nfserr_share_denied	cpu_to_be32(NFSERR_SHARE_DENIED)</span>
<span class="cp">#define nfserr_stale_stateid	cpu_to_be32(NFSERR_STALE_STATEID)</span>
<span class="cp">#define nfserr_old_stateid	cpu_to_be32(NFSERR_OLD_STATEID)</span>
<span class="cp">#define nfserr_bad_stateid	cpu_to_be32(NFSERR_BAD_STATEID)</span>
<span class="cp">#define nfserr_bad_seqid	cpu_to_be32(NFSERR_BAD_SEQID)</span>
<span class="cp">#define	nfserr_symlink		cpu_to_be32(NFSERR_SYMLINK)</span>
<span class="cp">#define	nfserr_not_same		cpu_to_be32(NFSERR_NOT_SAME)</span>
<span class="cp">#define nfserr_lock_range	cpu_to_be32(NFSERR_LOCK_RANGE)</span>
<span class="cp">#define	nfserr_restorefh	cpu_to_be32(NFSERR_RESTOREFH)</span>
<span class="cp">#define	nfserr_attrnotsupp	cpu_to_be32(NFSERR_ATTRNOTSUPP)</span>
<span class="cp">#define	nfserr_bad_xdr		cpu_to_be32(NFSERR_BAD_XDR)</span>
<span class="cp">#define	nfserr_openmode		cpu_to_be32(NFSERR_OPENMODE)</span>
<span class="cp">#define	nfserr_badowner		cpu_to_be32(NFSERR_BADOWNER)</span>
<span class="cp">#define	nfserr_locks_held	cpu_to_be32(NFSERR_LOCKS_HELD)</span>
<span class="cp">#define	nfserr_op_illegal	cpu_to_be32(NFSERR_OP_ILLEGAL)</span>
<span class="cp">#define	nfserr_grace		cpu_to_be32(NFSERR_GRACE)</span>
<span class="cp">#define	nfserr_no_grace		cpu_to_be32(NFSERR_NO_GRACE)</span>
<span class="cp">#define	nfserr_reclaim_bad	cpu_to_be32(NFSERR_RECLAIM_BAD)</span>
<span class="cp">#define	nfserr_badname		cpu_to_be32(NFSERR_BADNAME)</span>
<span class="cp">#define	nfserr_cb_path_down	cpu_to_be32(NFSERR_CB_PATH_DOWN)</span>
<span class="cp">#define	nfserr_locked		cpu_to_be32(NFSERR_LOCKED)</span>
<span class="cp">#define	nfserr_wrongsec		cpu_to_be32(NFSERR_WRONGSEC)</span>
<span class="cp">#define nfserr_badiomode		cpu_to_be32(NFS4ERR_BADIOMODE)</span>
<span class="cp">#define nfserr_badlayout		cpu_to_be32(NFS4ERR_BADLAYOUT)</span>
<span class="cp">#define nfserr_bad_session_digest	cpu_to_be32(NFS4ERR_BAD_SESSION_DIGEST)</span>
<span class="cp">#define nfserr_badsession		cpu_to_be32(NFS4ERR_BADSESSION)</span>
<span class="cp">#define nfserr_badslot			cpu_to_be32(NFS4ERR_BADSLOT)</span>
<span class="cp">#define nfserr_complete_already		cpu_to_be32(NFS4ERR_COMPLETE_ALREADY)</span>
<span class="cp">#define nfserr_conn_not_bound_to_session cpu_to_be32(NFS4ERR_CONN_NOT_BOUND_TO_SESSION)</span>
<span class="cp">#define nfserr_deleg_already_wanted	cpu_to_be32(NFS4ERR_DELEG_ALREADY_WANTED)</span>
<span class="cp">#define nfserr_back_chan_busy		cpu_to_be32(NFS4ERR_BACK_CHAN_BUSY)</span>
<span class="cp">#define nfserr_layouttrylater		cpu_to_be32(NFS4ERR_LAYOUTTRYLATER)</span>
<span class="cp">#define nfserr_layoutunavailable	cpu_to_be32(NFS4ERR_LAYOUTUNAVAILABLE)</span>
<span class="cp">#define nfserr_nomatching_layout	cpu_to_be32(NFS4ERR_NOMATCHING_LAYOUT)</span>
<span class="cp">#define nfserr_recallconflict		cpu_to_be32(NFS4ERR_RECALLCONFLICT)</span>
<span class="cp">#define nfserr_unknown_layouttype	cpu_to_be32(NFS4ERR_UNKNOWN_LAYOUTTYPE)</span>
<span class="cp">#define nfserr_seq_misordered		cpu_to_be32(NFS4ERR_SEQ_MISORDERED)</span>
<span class="cp">#define nfserr_sequence_pos		cpu_to_be32(NFS4ERR_SEQUENCE_POS)</span>
<span class="cp">#define nfserr_req_too_big		cpu_to_be32(NFS4ERR_REQ_TOO_BIG)</span>
<span class="cp">#define nfserr_rep_too_big		cpu_to_be32(NFS4ERR_REP_TOO_BIG)</span>
<span class="cp">#define nfserr_rep_too_big_to_cache	cpu_to_be32(NFS4ERR_REP_TOO_BIG_TO_CACHE)</span>
<span class="cp">#define nfserr_retry_uncached_rep	cpu_to_be32(NFS4ERR_RETRY_UNCACHED_REP)</span>
<span class="cp">#define nfserr_unsafe_compound		cpu_to_be32(NFS4ERR_UNSAFE_COMPOUND)</span>
<span class="cp">#define nfserr_too_many_ops		cpu_to_be32(NFS4ERR_TOO_MANY_OPS)</span>
<span class="cp">#define nfserr_op_not_in_session	cpu_to_be32(NFS4ERR_OP_NOT_IN_SESSION)</span>
<span class="cp">#define nfserr_hash_alg_unsupp		cpu_to_be32(NFS4ERR_HASH_ALG_UNSUPP)</span>
<span class="cp">#define nfserr_clientid_busy		cpu_to_be32(NFS4ERR_CLIENTID_BUSY)</span>
<span class="cp">#define nfserr_pnfs_io_hole		cpu_to_be32(NFS4ERR_PNFS_IO_HOLE)</span>
<span class="cp">#define nfserr_seq_false_retry		cpu_to_be32(NFS4ERR_SEQ_FALSE_RETRY)</span>
<span class="cp">#define nfserr_bad_high_slot		cpu_to_be32(NFS4ERR_BAD_HIGH_SLOT)</span>
<span class="cp">#define nfserr_deadsession		cpu_to_be32(NFS4ERR_DEADSESSION)</span>
<span class="cp">#define nfserr_encr_alg_unsupp		cpu_to_be32(NFS4ERR_ENCR_ALG_UNSUPP)</span>
<span class="cp">#define nfserr_pnfs_no_layout		cpu_to_be32(NFS4ERR_PNFS_NO_LAYOUT)</span>
<span class="cp">#define nfserr_not_only_op		cpu_to_be32(NFS4ERR_NOT_ONLY_OP)</span>
<span class="cp">#define nfserr_wrong_cred		cpu_to_be32(NFS4ERR_WRONG_CRED)</span>
<span class="cp">#define nfserr_wrong_type		cpu_to_be32(NFS4ERR_WRONG_TYPE)</span>
<span class="cp">#define nfserr_dirdeleg_unavail		cpu_to_be32(NFS4ERR_DIRDELEG_UNAVAIL)</span>
<span class="cp">#define nfserr_reject_deleg		cpu_to_be32(NFS4ERR_REJECT_DELEG)</span>
<span class="cp">#define nfserr_returnconflict		cpu_to_be32(NFS4ERR_RETURNCONFLICT)</span>
<span class="cp">#define nfserr_deleg_revoked		cpu_to_be32(NFS4ERR_DELEG_REVOKED)</span>

<span class="cm">/* error codes for internal use */</span>
<span class="cm">/* if a request fails due to kmalloc failure, it gets dropped.</span>
<span class="cm"> *  Client should resend eventually</span>
<span class="cm"> */</span>
<span class="cp">#define	nfserr_dropit		cpu_to_be32(30000)</span>
<span class="cm">/* end-of-file indicator in readdir */</span>
<span class="cp">#define	nfserr_eof		cpu_to_be32(30001)</span>
<span class="cm">/* replay detected */</span>
<span class="cp">#define	nfserr_replay_me	cpu_to_be32(11001)</span>
<span class="cm">/* nfs41 replay detected */</span>
<span class="cp">#define	nfserr_replay_cache	cpu_to_be32(11002)</span>

<span class="cm">/* Check for dir entries &#39;.&#39; and &#39;..&#39; */</span>
<span class="cp">#define isdotent(n, l)	(l &lt; 3 &amp;&amp; n[0] == &#39;.&#39; &amp;&amp; (l == 1 || n[1] == &#39;.&#39;))</span>

<span class="cm">/*</span>
<span class="cm"> * Time of server startup</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">timeval</span>	<span class="n">nfssvc_boot</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NFSD_V4</span>

<span class="k">extern</span> <span class="kt">time_t</span> <span class="n">nfsd4_lease</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">time_t</span> <span class="n">nfsd4_grace</span><span class="p">;</span>

<span class="cm">/* before processing a COMPOUND operation, we have to check that there</span>
<span class="cm"> * is enough space in the buffer for XDR encode to succeed.  otherwise,</span>
<span class="cm"> * we might process an operation with side effects, and be unable to</span>
<span class="cm"> * tell the client that the operation succeeded.</span>
<span class="cm"> *</span>
<span class="cm"> * COMPOUND_SLACK_SPACE - this is the minimum bytes of buffer space</span>
<span class="cm"> * needed to encode an &quot;ordinary&quot; _successful_ operation.  (GETATTR,</span>
<span class="cm"> * READ, READDIR, and READLINK have their own buffer checks.)  if we</span>
<span class="cm"> * fall below this level, we fail the next operation with NFS4ERR_RESOURCE.</span>
<span class="cm"> *</span>
<span class="cm"> * COMPOUND_ERR_SLACK_SPACE - this is the minimum bytes of buffer space</span>
<span class="cm"> * needed to encode an operation which has failed with NFS4ERR_RESOURCE.</span>
<span class="cm"> * care is taken to ensure that we never fall below this level for any</span>
<span class="cm"> * reason.</span>
<span class="cm"> */</span>
<span class="cp">#define	COMPOUND_SLACK_SPACE		140    </span><span class="cm">/* OP_GETFH */</span><span class="cp"></span>
<span class="cp">#define COMPOUND_ERR_SLACK_SPACE	12     </span><span class="cm">/* OP_SETATTR */</span><span class="cp"></span>

<span class="cp">#define NFSD_LAUNDROMAT_MINTIMEOUT      1   </span><span class="cm">/* seconds */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The following attributes are currently not supported by the NFSv4 server:</span>
<span class="cm"> *    ARCHIVE       (deprecated anyway)</span>
<span class="cm"> *    HIDDEN        (unlikely to be supported any time soon)</span>
<span class="cm"> *    MIMETYPE      (unlikely to be supported any time soon)</span>
<span class="cm"> *    QUOTA_*       (will be supported in a forthcoming patch)</span>
<span class="cm"> *    SYSTEM        (unlikely to be supported any time soon)</span>
<span class="cm"> *    TIME_BACKUP   (unlikely to be supported any time soon)</span>
<span class="cm"> *    TIME_CREATE   (unlikely to be supported any time soon)</span>
<span class="cm"> */</span>
<span class="cp">#define NFSD4_SUPPORTED_ATTRS_WORD0                                                         \</span>
<span class="cp">(FATTR4_WORD0_SUPPORTED_ATTRS   | FATTR4_WORD0_TYPE         | FATTR4_WORD0_FH_EXPIRE_TYPE   \</span>
<span class="cp"> | FATTR4_WORD0_CHANGE          | FATTR4_WORD0_SIZE         | FATTR4_WORD0_LINK_SUPPORT     \</span>
<span class="cp"> | FATTR4_WORD0_SYMLINK_SUPPORT | FATTR4_WORD0_NAMED_ATTR   | FATTR4_WORD0_FSID             \</span>
<span class="cp"> | FATTR4_WORD0_UNIQUE_HANDLES  | FATTR4_WORD0_LEASE_TIME   | FATTR4_WORD0_RDATTR_ERROR     \</span>
<span class="cp"> | FATTR4_WORD0_ACLSUPPORT      | FATTR4_WORD0_CANSETTIME   | FATTR4_WORD0_CASE_INSENSITIVE \</span>
<span class="cp"> | FATTR4_WORD0_CASE_PRESERVING | FATTR4_WORD0_CHOWN_RESTRICTED                             \</span>
<span class="cp"> | FATTR4_WORD0_FILEHANDLE      | FATTR4_WORD0_FILEID       | FATTR4_WORD0_FILES_AVAIL      \</span>
<span class="cp"> | FATTR4_WORD0_FILES_FREE      | FATTR4_WORD0_FILES_TOTAL  | FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_HOMOGENEOUS      \</span>
<span class="cp"> | FATTR4_WORD0_MAXFILESIZE     | FATTR4_WORD0_MAXLINK      | FATTR4_WORD0_MAXNAME          \</span>
<span class="cp"> | FATTR4_WORD0_MAXREAD         | FATTR4_WORD0_MAXWRITE     | FATTR4_WORD0_ACL)</span>

<span class="cp">#define NFSD4_SUPPORTED_ATTRS_WORD1                                                         \</span>
<span class="cp">(FATTR4_WORD1_MODE              | FATTR4_WORD1_NO_TRUNC     | FATTR4_WORD1_NUMLINKS         \</span>
<span class="cp"> | FATTR4_WORD1_OWNER	        | FATTR4_WORD1_OWNER_GROUP  | FATTR4_WORD1_RAWDEV           \</span>
<span class="cp"> | FATTR4_WORD1_SPACE_AVAIL     | FATTR4_WORD1_SPACE_FREE   | FATTR4_WORD1_SPACE_TOTAL      \</span>
<span class="cp"> | FATTR4_WORD1_SPACE_USED      | FATTR4_WORD1_TIME_ACCESS  | FATTR4_WORD1_TIME_ACCESS_SET  \</span>
<span class="cp"> | FATTR4_WORD1_TIME_DELTA   | FATTR4_WORD1_TIME_METADATA    \</span>
<span class="cp"> | FATTR4_WORD1_TIME_MODIFY     | FATTR4_WORD1_TIME_MODIFY_SET | FATTR4_WORD1_MOUNTED_ON_FILEID)</span>

<span class="cp">#define NFSD4_SUPPORTED_ATTRS_WORD2 0</span>

<span class="cp">#define NFSD4_1_SUPPORTED_ATTRS_WORD0 \</span>
<span class="cp">	NFSD4_SUPPORTED_ATTRS_WORD0</span>

<span class="cp">#define NFSD4_1_SUPPORTED_ATTRS_WORD1 \</span>
<span class="cp">	NFSD4_SUPPORTED_ATTRS_WORD1</span>

<span class="cp">#define NFSD4_1_SUPPORTED_ATTRS_WORD2 \</span>
<span class="cp">	(NFSD4_SUPPORTED_ATTRS_WORD2 | FATTR4_WORD2_SUPPATTR_EXCLCREAT)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">nfsd_suppattrs0</span><span class="p">(</span><span class="n">u32</span> <span class="n">minorversion</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">minorversion</span> <span class="o">?</span> <span class="n">NFSD4_1_SUPPORTED_ATTRS_WORD0</span>
			    <span class="o">:</span> <span class="n">NFSD4_SUPPORTED_ATTRS_WORD0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">nfsd_suppattrs1</span><span class="p">(</span><span class="n">u32</span> <span class="n">minorversion</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">minorversion</span> <span class="o">?</span> <span class="n">NFSD4_1_SUPPORTED_ATTRS_WORD1</span>
			    <span class="o">:</span> <span class="n">NFSD4_SUPPORTED_ATTRS_WORD1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">nfsd_suppattrs2</span><span class="p">(</span><span class="n">u32</span> <span class="n">minorversion</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">minorversion</span> <span class="o">?</span> <span class="n">NFSD4_1_SUPPORTED_ATTRS_WORD2</span>
			    <span class="o">:</span> <span class="n">NFSD4_SUPPORTED_ATTRS_WORD2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* These will return ERR_INVAL if specified in GETATTR or READDIR. */</span>
<span class="cp">#define NFSD_WRITEONLY_ATTRS_WORD1 \</span>
<span class="cp">	(FATTR4_WORD1_TIME_ACCESS_SET   | FATTR4_WORD1_TIME_MODIFY_SET)</span>

<span class="cm">/* These are the only attrs allowed in CREATE/OPEN/SETATTR. */</span>
<span class="cp">#define NFSD_WRITEABLE_ATTRS_WORD0 \</span>
<span class="cp">	(FATTR4_WORD0_SIZE | FATTR4_WORD0_ACL)</span>
<span class="cp">#define NFSD_WRITEABLE_ATTRS_WORD1 \</span>
<span class="cp">	(FATTR4_WORD1_MODE | FATTR4_WORD1_OWNER | FATTR4_WORD1_OWNER_GROUP \</span>
<span class="cp">	| FATTR4_WORD1_TIME_ACCESS_SET | FATTR4_WORD1_TIME_MODIFY_SET)</span>
<span class="cp">#define NFSD_WRITEABLE_ATTRS_WORD2 0</span>

<span class="cp">#define NFSD_SUPPATTR_EXCLCREAT_WORD0 \</span>
<span class="cp">	NFSD_WRITEABLE_ATTRS_WORD0</span>
<span class="cm">/*</span>
<span class="cm"> * we currently store the exclusive create verifier in the v_{a,m}time</span>
<span class="cm"> * attributes so the client can&#39;t set these at create time using EXCLUSIVE4_1</span>
<span class="cm"> */</span>
<span class="cp">#define NFSD_SUPPATTR_EXCLCREAT_WORD1 \</span>
<span class="cp">	(NFSD_WRITEABLE_ATTRS_WORD1 &amp; \</span>
<span class="cp">	 ~(FATTR4_WORD1_TIME_ACCESS_SET | FATTR4_WORD1_TIME_MODIFY_SET))</span>
<span class="cp">#define NFSD_SUPPATTR_EXCLCREAT_WORD2 \</span>
<span class="cp">	NFSD_WRITEABLE_ATTRS_WORD2</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">nfsd4_is_junction</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_cld_notifier</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unregister_cld_notifier</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_NFSD_V4 */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nfsd4_is_junction</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define register_cld_notifier() 0</span>
<span class="cp">#define unregister_cld_notifier() do { } while(0)</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_NFSD_V4 */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* LINUX_NFSD_NFSD_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
