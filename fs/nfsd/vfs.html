<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nfsd › vfs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>vfs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * File operations used by nfsd. Some of these have been ripped from</span>
<span class="cm"> * other parts of the kernel because they weren&#39;t exported, others</span>
<span class="cm"> * are partial duplicates with added or changed functionality.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that several functions dget() the dentry upon which they want</span>
<span class="cm"> * to act, most notably those that create directory entries. Response</span>
<span class="cm"> * dentry&#39;s are dput()&#39;d if necessary in the release callback.</span>
<span class="cm"> * So if you notice code paths that apparently fail to dput() the</span>
<span class="cm"> * dentry, don&#39;t worry--they have been taken care of.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995-1999 Olaf Kirch &lt;okir@monad.swb.de&gt;</span>
<span class="cm"> * Zerocpy NFS support (C) 2002 Hirokazu Takahashi &lt;taka@valinux.co.jp&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/splice.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/fsnotify.h&gt;</span>
<span class="cp">#include &lt;linux/posix_acl_xattr.h&gt;</span>
<span class="cp">#include &lt;linux/xattr.h&gt;</span>
<span class="cp">#include &lt;linux/jhash.h&gt;</span>
<span class="cp">#include &lt;linux/ima.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/exportfs.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>

<span class="cp">#ifdef CONFIG_NFSD_V3</span>
<span class="cp">#include &quot;xdr3.h&quot;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NFSD_V3 */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_NFSD_V4</span>
<span class="cp">#include &quot;acl.h&quot;</span>
<span class="cp">#include &quot;idmap.h&quot;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NFSD_V4 */</span><span class="cp"></span>

<span class="cp">#include &quot;nfsd.h&quot;</span>
<span class="cp">#include &quot;vfs.h&quot;</span>

<span class="cp">#define NFSDDBG_FACILITY		NFSDDBG_FILEOP</span>


<span class="cm">/*</span>
<span class="cm"> * This is a cache of readahead params that help us choose the proper</span>
<span class="cm"> * readahead strategy. Initially, we set all readahead parameters to 0</span>
<span class="cm"> * and let the VFS handle things.</span>
<span class="cm"> * If you increase the number of cached files very much, you&#39;ll need to</span>
<span class="cm"> * add a hash table here.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">raparms</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">raparms</span>		<span class="o">*</span><span class="n">p_next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">p_count</span><span class="p">;</span>
	<span class="n">ino_t</span>			<span class="n">p_ino</span><span class="p">;</span>
	<span class="n">dev_t</span>			<span class="n">p_dev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">p_set</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_ra_state</span>	<span class="n">p_ra</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">p_hindex</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">raparm_hbucket</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">raparms</span>		<span class="o">*</span><span class="n">pb_head</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">pb_lock</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="cp">#define RAPARM_HASH_BITS	4</span>
<span class="cp">#define RAPARM_HASH_SIZE	(1&lt;&lt;RAPARM_HASH_BITS)</span>
<span class="cp">#define RAPARM_HASH_MASK	(RAPARM_HASH_SIZE-1)</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">raparm_hbucket</span>	<span class="n">raparm_hash</span><span class="p">[</span><span class="n">RAPARM_HASH_SIZE</span><span class="p">];</span>

<span class="cm">/* </span>
<span class="cm"> * Called from nfsd_lookup and encode_dirent. Check if we have crossed </span>
<span class="cm"> * a mount point.</span>
<span class="cm"> * Returns -EAGAIN or -ETIMEDOUT leaving *dpp and *expp unchanged,</span>
<span class="cm"> *  or nfs_ok having possibly changed *dpp and *expp</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">nfsd_cross_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">**</span><span class="n">dpp</span><span class="p">,</span> 
		        <span class="k">struct</span> <span class="n">svc_export</span> <span class="o">**</span><span class="n">expp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_export</span> <span class="o">*</span><span class="n">exp</span> <span class="o">=</span> <span class="o">*</span><span class="n">expp</span><span class="p">,</span> <span class="o">*</span><span class="n">exp2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="o">*</span><span class="n">dpp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span> <span class="o">=</span> <span class="p">{.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mntget</span><span class="p">(</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">ex_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">),</span>
			    <span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">dentry</span><span class="p">)};</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">follow_down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">exp2</span> <span class="o">=</span> <span class="n">rqst_exp_get_by_name</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">exp2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">exp2</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We normally allow NFS clients to continue</span>
<span class="cm">		 * &quot;underneath&quot; a mountpoint that is not exported.</span>
<span class="cm">		 * The exception is V4ROOT, where no traversal is ever</span>
<span class="cm">		 * allowed without an explicit export of the new</span>
<span class="cm">		 * directory.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">ex_flags</span> <span class="o">&amp;</span> <span class="n">NFSEXP_V4ROOT</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_v4client</span><span class="p">(</span><span class="n">rqstp</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">ex_flags</span> <span class="o">&amp;</span> <span class="n">NFSEXP_CROSSMOUNT</span><span class="p">)</span> <span class="o">||</span> <span class="n">EX_NOHIDE</span><span class="p">(</span><span class="n">exp2</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* successfully crossed mount point */</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is subtle: path.dentry is *not* on path.mnt</span>
<span class="cm">		 * at this point.  The only reason we are safe is that</span>
<span class="cm">		 * original mnt is pinned down by exp, so we should</span>
<span class="cm">		 * put path *before* putting exp</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">dpp</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
		<span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
		<span class="o">*</span><span class="n">expp</span> <span class="o">=</span> <span class="n">exp2</span><span class="p">;</span>
		<span class="n">exp2</span> <span class="o">=</span> <span class="n">exp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="n">exp_put</span><span class="p">(</span><span class="n">exp2</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">follow_to_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">==</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span> <span class="o">&amp;&amp;</span> <span class="n">follow_up</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
		<span class="p">;</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">dget_parent</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfsd_lookup_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dparent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_export</span> <span class="o">**</span><span class="n">exp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">**</span><span class="n">dentryp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_export</span> <span class="o">*</span><span class="n">exp2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span> <span class="o">=</span> <span class="p">{.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mntget</span><span class="p">((</span><span class="o">*</span><span class="n">exp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ex_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">),</span>
			    <span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">dparent</span><span class="p">)};</span>

	<span class="n">follow_to_parent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>

	<span class="n">exp2</span> <span class="o">=</span> <span class="n">rqst_exp_parent</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">exp2</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">dentryp</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">dparent</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">exp2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">exp2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">dentryp</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">exp_put</span><span class="p">(</span><span class="o">*</span><span class="n">exp</span><span class="p">);</span>
		<span class="o">*</span><span class="n">exp</span> <span class="o">=</span> <span class="n">exp2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For nfsd purposes, we treat V4ROOT exports as though there was an</span>
<span class="cm"> * export at *every* directory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfsd_mountpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_export</span> <span class="o">*</span><span class="n">exp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d_mountpoint</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd4_is_junction</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">ex_flags</span> <span class="o">&amp;</span> <span class="n">NFSEXP_V4ROOT</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__be32</span>
<span class="nf">nfsd_lookup_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">svc_export</span> <span class="o">**</span><span class="n">exp_ret</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">**</span><span class="n">dentry_ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_export</span>	<span class="o">*</span><span class="n">exp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">dparent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">host_err</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfsd: nfsd_lookup(fh %s, %.*s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SVCFH_fmt</span><span class="p">(</span><span class="n">fhp</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span><span class="n">name</span><span class="p">);</span>

	<span class="n">dparent</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">;</span>
	<span class="n">exp</span>  <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="p">;</span>
	<span class="n">exp_get</span><span class="p">(</span><span class="n">exp</span><span class="p">);</span>

	<span class="cm">/* Lookup the name, but don&#39;t follow links */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isdotent</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">dparent</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dparent</span> <span class="o">!=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">ex_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">)</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">dget_parent</span><span class="p">(</span><span class="n">dparent</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EX_NOHIDE</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nfsd_v4client</span><span class="p">(</span><span class="n">rqstp</span><span class="p">))</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">dparent</span><span class="p">);</span> <span class="cm">/* .. == . just like at / */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* checking mountpoint crossing is very different when stepping up */</span>
			<span class="n">host_err</span> <span class="o">=</span> <span class="n">nfsd_lookup_parent</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">dparent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fh_lock</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">lookup_one_len</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dparent</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * check if we have crossed a mount point ...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_mountpoint</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">exp</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">host_err</span> <span class="o">=</span> <span class="n">nfsd_cross_mnt</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exp</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">dentry_ret</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="o">*</span><span class="n">exp_ret</span> <span class="o">=</span> <span class="n">exp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_nfserr:</span>
	<span class="n">exp_put</span><span class="p">(</span><span class="n">exp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up one component of a pathname.</span>
<span class="cm"> * N.B. After this call _both_ fhp and resfh need an fh_put</span>
<span class="cm"> *</span>
<span class="cm"> * If the lookup would cross a mountpoint, and the mounted filesystem</span>
<span class="cm"> * is exported to the client with NFSEXP_NOHIDE, then the lookup is</span>
<span class="cm"> * accepted as it stands and the mounted directory is</span>
<span class="cm"> * returned. Otherwise the covered directory is returned.</span>
<span class="cm"> * NOTE: this mountpoint crossing is not supported properly by all</span>
<span class="cm"> *   clients and is explicitly disallowed for NFSv3</span>
<span class="cm"> *      NeilBrown &lt;neilb@cse.unsw.edu.au&gt;</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">resfh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_export</span>	<span class="o">*</span><span class="n">exp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">S_IFDIR</span><span class="p">,</span> <span class="n">NFSD_MAY_EXEC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_lookup_dentry</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">check_nfsd_access</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">rqstp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note: we compose the file handle now, but as the</span>
<span class="cm">	 * dentry may be negative, it may need to be updated.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_compose</span><span class="p">(</span><span class="n">resfh</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">fhp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_noent</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">exp_put</span><span class="p">(</span><span class="n">exp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfsd_break_lease</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">break_lease</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Commit metadata changes to stable storage.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">commit_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">export_operations</span> <span class="o">*</span><span class="n">export_ops</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_export_op</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EX_ISSYNC</span><span class="p">(</span><span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">export_ops</span><span class="o">-&gt;</span><span class="n">commit_metadata</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">export_ops</span><span class="o">-&gt;</span><span class="n">commit_metadata</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sync_inode_metadata</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set various file attributes.</span>
<span class="cm"> * N.B. After this call fhp needs an fh_put</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">iap</span><span class="p">,</span>
	     <span class="kt">int</span> <span class="n">check_guard</span><span class="p">,</span> <span class="kt">time_t</span> <span class="n">guardtime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">accmode</span> <span class="o">=</span> <span class="n">NFSD_MAY_SATTR</span><span class="p">;</span>
	<span class="n">umode_t</span>		<span class="n">ftype</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">host_err</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">size_change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATTR_ATIME</span> <span class="o">|</span> <span class="n">ATTR_MTIME</span> <span class="o">|</span> <span class="n">ATTR_SIZE</span><span class="p">))</span>
		<span class="n">accmode</span> <span class="o">|=</span> <span class="n">NFSD_MAY_WRITE</span><span class="o">|</span><span class="n">NFSD_MAY_OWNER_OVERRIDE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span>
		<span class="n">ftype</span> <span class="o">=</span> <span class="n">S_IFREG</span><span class="p">;</span>

	<span class="cm">/* Get inode */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">ftype</span><span class="p">,</span> <span class="n">accmode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">;</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="cm">/* Ignore any mode updates on symlinks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATTR_MODE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * NFSv2 does not differentiate between &quot;set-[ac]time-to-now&quot;</span>
<span class="cm">	 * which only requires access, and &quot;set-[ac]time-to-X&quot; which</span>
<span class="cm">	 * requires ownership.</span>
<span class="cm">	 * So if it looks like it might be &quot;set both to the same time which</span>
<span class="cm">	 * is close to now&quot;, and if inode_change_ok fails, then we</span>
<span class="cm">	 * convert to &quot;set to now&quot; instead of &quot;set to explicit time&quot;</span>
<span class="cm">	 *</span>
<span class="cm">	 * We only call inode_change_ok as the last test as technically</span>
<span class="cm">	 * it is not an interface that we should be using.  It is only</span>
<span class="cm">	 * valid if the filesystem does not define it&#39;s own i_op-&gt;setattr.</span>
<span class="cm">	 */</span>
<span class="cp">#define BOTH_TIME_SET (ATTR_ATIME_SET | ATTR_MTIME_SET)</span>
<span class="cp">#define	MAX_TOUCH_TIME_ERROR (30*60)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">BOTH_TIME_SET</span><span class="p">)</span> <span class="o">==</span> <span class="n">BOTH_TIME_SET</span> <span class="o">&amp;&amp;</span>
	    <span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Looks probable.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Now just make sure time is in the right ballpark.</span>
<span class="cm">		 * Solaris, at least, doesn&#39;t seem to care what the time</span>
<span class="cm">		 * request is.  We require it be within 30 minutes of now.</span>
<span class="cm">		 */</span>
		<span class="kt">time_t</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">get_seconds</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="n">MAX_TOUCH_TIME_ERROR</span> <span class="o">&amp;&amp;</span>
		    <span class="n">inode_change_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iap</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Turn off ATTR_[AM]TIME_SET but leave ATTR_[AM]TIME.</span>
<span class="cm">			 * This will cause notify_change to set these times</span>
<span class="cm">			 * to &quot;now&quot;</span>
<span class="cm">			 */</span>
			<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BOTH_TIME_SET</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	    
	<span class="cm">/*</span>
<span class="cm">	 * The size case is special.</span>
<span class="cm">	 * It changes the file as well as the attributes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_permission</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span>
					<span class="n">NFSD_MAY_TRUNC</span><span class="o">|</span><span class="n">NFSD_MAY_OWNER_OVERRIDE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">host_err</span> <span class="o">=</span> <span class="n">get_write_access</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>

		<span class="n">size_change</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">locks_verify_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_write_access</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* sanitize the mode change */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mode</span> <span class="o">&amp;=</span> <span class="n">S_IALLUGO</span><span class="p">;</span>
		<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mode</span> <span class="o">|=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">S_IALLUGO</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Revoke setuid/setgid on chown */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(((</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_uid</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">((</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_gid</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">|=</span> <span class="n">ATTR_KILL_PRIV</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* we&#39;re setting mode too, just clear the s*id bits */</span>
			<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_ISUID</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mode</span> <span class="o">&amp;</span> <span class="n">S_IXGRP</span><span class="p">)</span>
				<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_ISGID</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* set ATTR_KILL_* bits and let VFS handle it */</span>
			<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ATTR_KILL_SUID</span> <span class="o">|</span> <span class="n">ATTR_KILL_SGID</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Change the attributes. */</span>

	<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">|=</span> <span class="n">ATTR_CTIME</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_notsync</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_guard</span> <span class="o">||</span> <span class="n">guardtime</span> <span class="o">==</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">nfsd_break_lease</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>
		<span class="n">fh_lock</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>

		<span class="n">host_err</span> <span class="o">=</span> <span class="n">notify_change</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">iap</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
		<span class="n">fh_unlock</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size_change</span><span class="p">)</span>
		<span class="n">put_write_access</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">commit_metadata</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_nfserr:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_NFSD_V2_ACL) || \</span>
<span class="cp">    defined(CONFIG_NFSD_V3_ACL) || \</span>
<span class="cp">    defined(CONFIG_NFSD_V4)</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nfsd_getxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">buflen</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">buflen</span> <span class="o">=</span> <span class="n">vfs_getxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">buflen</span><span class="p">;</span>

	<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">buflen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">vfs_getxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_NFSD_V4)</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">set_nfsv4_acl_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">posix_acl</span> <span class="o">*</span><span class="n">pacl</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">buflen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">buflen</span> <span class="o">=</span> <span class="n">posix_acl_xattr_size</span><span class="p">(</span><span class="n">pacl</span><span class="o">-&gt;</span><span class="n">a_count</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">buflen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">posix_acl_to_xattr</span><span class="p">(</span><span class="n">pacl</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_setxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__be32</span>
<span class="nf">nfsd4_set_nfs4_acl</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">nfs4_acl</span> <span class="o">*</span><span class="n">acl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">host_error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">posix_acl</span> <span class="o">*</span><span class="n">pacl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">dpacl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Get inode */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NFSD_MAY_SATTR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">;</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">NFS4_ACL_DIR</span><span class="p">;</span>

	<span class="n">host_error</span> <span class="o">=</span> <span class="n">nfs4_acl_nfsv4_to_posix</span><span class="p">(</span><span class="n">acl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pacl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dpacl</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">nfserr_attrnotsupp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">host_error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>

	<span class="n">host_error</span> <span class="o">=</span> <span class="n">set_nfsv4_acl_one</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">pacl</span><span class="p">,</span> <span class="n">POSIX_ACL_XATTR_ACCESS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">host_error</span> <span class="o">=</span> <span class="n">set_nfsv4_acl_one</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">dpacl</span><span class="p">,</span> <span class="n">POSIX_ACL_XATTR_DEFAULT</span><span class="p">);</span>

<span class="nl">out_release:</span>
	<span class="n">posix_acl_release</span><span class="p">(</span><span class="n">pacl</span><span class="p">);</span>
	<span class="n">posix_acl_release</span><span class="p">(</span><span class="n">dpacl</span><span class="p">);</span>
<span class="nl">out_nfserr:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nfserr_attrnotsupp</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_error</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">posix_acl</span> <span class="o">*</span>
<span class="nf">_get_posix_acl</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">posix_acl</span> <span class="o">*</span><span class="n">pacl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">buflen</span><span class="p">;</span>

	<span class="n">buflen</span> <span class="o">=</span> <span class="n">nfsd_getxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buflen</span><span class="p">)</span>
		<span class="n">buflen</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">buflen</span><span class="p">);</span>

	<span class="n">pacl</span> <span class="o">=</span> <span class="n">posix_acl_from_xattr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pacl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">nfsd4_get_nfs4_acl</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_acl</span> <span class="o">**</span><span class="n">acl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">posix_acl</span> <span class="o">*</span><span class="n">pacl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">dpacl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pacl</span> <span class="o">=</span> <span class="n">_get_posix_acl</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">POSIX_ACL_XATTR_ACCESS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pacl</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pacl</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">)</span>
		<span class="n">pacl</span> <span class="o">=</span> <span class="n">posix_acl_from_mode</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pacl</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pacl</span><span class="p">);</span>
		<span class="n">pacl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dpacl</span> <span class="o">=</span> <span class="n">_get_posix_acl</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">POSIX_ACL_XATTR_DEFAULT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dpacl</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dpacl</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">)</span>
			<span class="n">dpacl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dpacl</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dpacl</span><span class="p">);</span>
			<span class="n">dpacl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">NFS4_ACL_DIR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">acl</span> <span class="o">=</span> <span class="n">nfs4_acl_posix_to_nfsv4</span><span class="p">(</span><span class="n">pacl</span><span class="p">,</span> <span class="n">dpacl</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="o">*</span><span class="n">acl</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="o">*</span><span class="n">acl</span><span class="p">);</span>
		<span class="o">*</span><span class="n">acl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">posix_acl_release</span><span class="p">(</span><span class="n">pacl</span><span class="p">);</span>
	<span class="n">posix_acl_release</span><span class="p">(</span><span class="n">dpacl</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NFS junction information is stored in an extended attribute.</span>
<span class="cm"> */</span>
<span class="cp">#define NFSD_JUNCTION_XATTR_NAME	XATTR_TRUSTED_PREFIX &quot;junction.nfs&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * nfsd4_is_junction - Test if an object could be an NFS junction</span>
<span class="cm"> *</span>
<span class="cm"> * @dentry: object to test</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if &quot;dentry&quot; appears to contain NFS junction information.</span>
<span class="cm"> * Otherwise 0 is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfsd4_is_junction</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IXUGO</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_ISVTX</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vfs_getxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">NFSD_JUNCTION_XATTR_NAME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* defined(CONFIG_NFSD_V4) */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_NFSD_V3</span>
<span class="cm">/*</span>
<span class="cm"> * Check server access rights to a file system object</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">accessmap</span> <span class="p">{</span>
	<span class="n">u32</span>		<span class="n">access</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">how</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">accessmap</span>	<span class="n">nfs3_regaccess</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span>	<span class="n">NFS3_ACCESS_READ</span><span class="p">,</span>	<span class="n">NFSD_MAY_READ</span>			<span class="p">},</span>
    <span class="p">{</span>	<span class="n">NFS3_ACCESS_EXECUTE</span><span class="p">,</span>	<span class="n">NFSD_MAY_EXEC</span>			<span class="p">},</span>
    <span class="p">{</span>	<span class="n">NFS3_ACCESS_MODIFY</span><span class="p">,</span>	<span class="n">NFSD_MAY_WRITE</span><span class="o">|</span><span class="n">NFSD_MAY_TRUNC</span>	<span class="p">},</span>
    <span class="p">{</span>	<span class="n">NFS3_ACCESS_EXTEND</span><span class="p">,</span>	<span class="n">NFSD_MAY_WRITE</span>			<span class="p">},</span>

    <span class="p">{</span>	<span class="mi">0</span><span class="p">,</span>			<span class="mi">0</span>				<span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">accessmap</span>	<span class="n">nfs3_diraccess</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span>	<span class="n">NFS3_ACCESS_READ</span><span class="p">,</span>	<span class="n">NFSD_MAY_READ</span>			<span class="p">},</span>
    <span class="p">{</span>	<span class="n">NFS3_ACCESS_LOOKUP</span><span class="p">,</span>	<span class="n">NFSD_MAY_EXEC</span>			<span class="p">},</span>
    <span class="p">{</span>	<span class="n">NFS3_ACCESS_MODIFY</span><span class="p">,</span>	<span class="n">NFSD_MAY_EXEC</span><span class="o">|</span><span class="n">NFSD_MAY_WRITE</span><span class="o">|</span><span class="n">NFSD_MAY_TRUNC</span><span class="p">},</span>
    <span class="p">{</span>	<span class="n">NFS3_ACCESS_EXTEND</span><span class="p">,</span>	<span class="n">NFSD_MAY_EXEC</span><span class="o">|</span><span class="n">NFSD_MAY_WRITE</span>	<span class="p">},</span>
    <span class="p">{</span>	<span class="n">NFS3_ACCESS_DELETE</span><span class="p">,</span>	<span class="n">NFSD_MAY_REMOVE</span>			<span class="p">},</span>

    <span class="p">{</span>	<span class="mi">0</span><span class="p">,</span>			<span class="mi">0</span>				<span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">accessmap</span>	<span class="n">nfs3_anyaccess</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* Some clients - Solaris 2.6 at least, make an access call</span>
<span class="cm">	 * to the server to check for access for things like /dev/null</span>
<span class="cm">	 * (which really, the server doesn&#39;t care about).  So</span>
<span class="cm">	 * We provide simple access checking for them, looking</span>
<span class="cm">	 * mainly at mode bits, and we make sure to ignore read-only</span>
<span class="cm">	 * filesystem checks</span>
<span class="cm">	 */</span>
    <span class="p">{</span>	<span class="n">NFS3_ACCESS_READ</span><span class="p">,</span>	<span class="n">NFSD_MAY_READ</span>			<span class="p">},</span>
    <span class="p">{</span>	<span class="n">NFS3_ACCESS_EXECUTE</span><span class="p">,</span>	<span class="n">NFSD_MAY_EXEC</span>			<span class="p">},</span>
    <span class="p">{</span>	<span class="n">NFS3_ACCESS_MODIFY</span><span class="p">,</span>	<span class="n">NFSD_MAY_WRITE</span><span class="o">|</span><span class="n">NFSD_MAY_LOCAL_ACCESS</span>	<span class="p">},</span>
    <span class="p">{</span>	<span class="n">NFS3_ACCESS_EXTEND</span><span class="p">,</span>	<span class="n">NFSD_MAY_WRITE</span><span class="o">|</span><span class="n">NFSD_MAY_LOCAL_ACCESS</span>	<span class="p">},</span>

    <span class="p">{</span>	<span class="mi">0</span><span class="p">,</span>			<span class="mi">0</span>				<span class="p">}</span>
<span class="p">};</span>

<span class="n">__be32</span>
<span class="nf">nfsd_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">access</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">supported</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">accessmap</span>	<span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_export</span>	<span class="o">*</span><span class="n">export</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">query</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sresult</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__be32</span>			<span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NFSD_MAY_NOP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">export</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="p">;</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">map</span> <span class="o">=</span> <span class="n">nfs3_regaccess</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">map</span> <span class="o">=</span> <span class="n">nfs3_diraccess</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">map</span> <span class="o">=</span> <span class="n">nfs3_anyaccess</span><span class="p">;</span>


	<span class="n">query</span> <span class="o">=</span> <span class="o">*</span><span class="n">access</span><span class="p">;</span>
	<span class="k">for</span>  <span class="p">(;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">;</span> <span class="n">map</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">access</span> <span class="o">&amp;</span> <span class="n">query</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__be32</span> <span class="n">err2</span><span class="p">;</span>

			<span class="n">sresult</span> <span class="o">|=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">;</span>

			<span class="n">err2</span> <span class="o">=</span> <span class="n">nfsd_permission</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">export</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">how</span><span class="p">);</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">err2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">nfs_ok</span>:
				<span class="n">result</span> <span class="o">|=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
				
			<span class="cm">/* the following error codes just mean the access was not allowed,</span>
<span class="cm">			 * rather than an error occurred */</span>
			<span class="k">case</span> <span class="n">nfserr_rofs</span>:
			<span class="k">case</span> <span class="n">nfserr_acces</span>:
			<span class="k">case</span> <span class="n">nfserr_perm</span>:
				<span class="cm">/* simply don&#39;t &quot;or&quot; in the access bit. */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">err2</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">access</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">supported</span><span class="p">)</span>
		<span class="o">*</span><span class="n">supported</span> <span class="o">=</span> <span class="n">sresult</span><span class="p">;</span>

 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NFSD_V3 */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfsd_open_break_lease</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">access</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">access</span> <span class="o">&amp;</span> <span class="n">NFSD_MAY_NOT_BREAK_LEASE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">access</span> <span class="o">&amp;</span> <span class="n">NFSD_MAY_WRITE</span><span class="p">)</span> <span class="o">?</span> <span class="n">O_WRONLY</span> <span class="o">:</span> <span class="n">O_RDONLY</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">break_lease</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Open an existing file or directory.</span>
<span class="cm"> * The may_flags argument indicates the type of open (read/write/lock)</span>
<span class="cm"> * and additional flags.</span>
<span class="cm"> * N.B. After this call fhp needs an fh_put</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">type</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">may_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">**</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">flags</span> <span class="o">=</span> <span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_LARGEFILE</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">host_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">validate_process_creds</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we get here, then the client has already done an &quot;open&quot;,</span>
<span class="cm">	 * and (hopefully) checked permission - so allow OWNER_OVERRIDE</span>
<span class="cm">	 * in case a chmod has now revoked permission.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">may_flags</span> <span class="o">|</span> <span class="n">NFSD_MAY_OWNER_OVERRIDE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">;</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="cm">/* Disallow write access to files with the append-only bit set</span>
<span class="cm">	 * or any access when mandatory locking enabled</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_perm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_APPEND</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">may_flags</span> <span class="o">&amp;</span> <span class="n">NFSD_MAY_WRITE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We must ignore files (but only files) which might have mandatory</span>
<span class="cm">	 * locks on them because there is no way to know if the accesser has</span>
<span class="cm">	 * the lock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">((</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mandatory_lock</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">host_err</span> <span class="o">=</span> <span class="n">nfsd_open_break_lease</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">may_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span> <span class="cm">/* NOMEM or WOULDBLOCK */</span>
		<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">may_flags</span> <span class="o">&amp;</span> <span class="n">NFSD_MAY_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">may_flags</span> <span class="o">&amp;</span> <span class="n">NFSD_MAY_READ</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">O_RDWR</span><span class="o">|</span><span class="n">O_LARGEFILE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">O_WRONLY</span><span class="o">|</span><span class="n">O_LARGEFILE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">filp</span> <span class="o">=</span> <span class="n">dentry_open</span><span class="p">(</span><span class="n">dget</span><span class="p">(</span><span class="n">dentry</span><span class="p">),</span> <span class="n">mntget</span><span class="p">(</span><span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="o">-&gt;</span><span class="n">ex_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">),</span>
			    <span class="n">flags</span><span class="p">,</span> <span class="n">current_cred</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="o">*</span><span class="n">filp</span><span class="p">))</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="o">*</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">ima_file_check</span><span class="p">(</span><span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">may_flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">may_flags</span> <span class="o">&amp;</span> <span class="n">NFSD_MAY_64BIT_COOKIE</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">filp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">|=</span> <span class="n">FMODE_64BITHASH</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="p">(</span><span class="o">*</span><span class="n">filp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">|=</span> <span class="n">FMODE_32BITHASH</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_nfserr:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">validate_process_creds</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Close a file.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">nfsd_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Obtain the readahead parameters for the file</span>
<span class="cm"> * specified by (dev, ino).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">raparms</span> <span class="o">*</span>
<span class="nf">nfsd_get_raparms</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">dev</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">raparms</span>	<span class="o">*</span><span class="n">ra</span><span class="p">,</span> <span class="o">**</span><span class="n">rap</span><span class="p">,</span> <span class="o">**</span><span class="n">frap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">raparm_hbucket</span> <span class="o">*</span><span class="n">rab</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">jhash_2words</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="mh">0xfeedbeef</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RAPARM_HASH_MASK</span><span class="p">;</span>
	<span class="n">rab</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">raparm_hash</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rab</span><span class="o">-&gt;</span><span class="n">pb_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rab</span><span class="o">-&gt;</span><span class="n">pb_head</span><span class="p">;</span> <span class="p">(</span><span class="n">ra</span> <span class="o">=</span> <span class="o">*</span><span class="n">rap</span><span class="p">);</span> <span class="n">rap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_ino</span> <span class="o">==</span> <span class="n">ino</span> <span class="o">&amp;&amp;</span> <span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="n">depth</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">frap</span> <span class="o">=</span> <span class="n">rap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">nfsdstats</span><span class="p">.</span><span class="n">ra_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frap</span><span class="p">)</span> <span class="p">{</span>	
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rab</span><span class="o">-&gt;</span><span class="n">pb_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rap</span> <span class="o">=</span> <span class="n">frap</span><span class="p">;</span>
	<span class="n">ra</span> <span class="o">=</span> <span class="o">*</span><span class="n">frap</span><span class="p">;</span>
	<span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_ino</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_set</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_hindex</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rap</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">rab</span><span class="o">-&gt;</span><span class="n">pb_head</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">rap</span> <span class="o">=</span> <span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
		<span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_next</span>   <span class="o">=</span> <span class="n">rab</span><span class="o">-&gt;</span><span class="n">pb_head</span><span class="p">;</span>
		<span class="n">rab</span><span class="o">-&gt;</span><span class="n">pb_head</span> <span class="o">=</span> <span class="n">ra</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">nfsdstats</span><span class="p">.</span><span class="n">ra_depth</span><span class="p">[</span><span class="n">depth</span><span class="o">*</span><span class="mi">10</span><span class="o">/</span><span class="n">nfsdstats</span><span class="p">.</span><span class="n">ra_size</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rab</span><span class="o">-&gt;</span><span class="n">pb_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ra</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Grab and keep cached pages associated with a file in the svc_rqst</span>
<span class="cm"> * so that they can be passed to the network sendmsg/sendpage routines</span>
<span class="cm"> * directly. They will be released after the sending has completed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nfsd_splice_actor</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">splice_desc</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pp</span> <span class="o">=</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_respages</span> <span class="o">+</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resused</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">page_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">);</span>
		<span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resused</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">page_base</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">page_len</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="n">pp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span>
			<span class="n">put_page</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">);</span>
		<span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resused</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">page_len</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_res</span><span class="p">.</span><span class="n">page_len</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfsd_direct_splice_actor</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">splice_desc</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__splice_from_pipe</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">nfsd_splice_actor</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__be32</span>
<span class="nf">nfsd_vfs_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
              <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vlen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm_segment_t</span>	<span class="n">oldfs</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">host_err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_perm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">splice_read</span> <span class="o">&amp;&amp;</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_splice_ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">splice_desc</span> <span class="n">sd</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">len</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">.</span><span class="n">total_len</span>	<span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span>
			<span class="p">.</span><span class="n">pos</span>		<span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
			<span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="n">rqstp</span><span class="p">,</span>
		<span class="p">};</span>

		<span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_resused</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">splice_direct_to_actor</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="p">,</span> <span class="n">nfsd_direct_splice_actor</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">oldfs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
		<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">vfs_readv</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iovec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">vec</span><span class="p">,</span> <span class="n">vlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">set_fs</span><span class="p">(</span><span class="n">oldfs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfsdstats</span><span class="p">.</span><span class="n">io_read</span> <span class="o">+=</span> <span class="n">host_err</span><span class="p">;</span>
		<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">host_err</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">fsnotify_access</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> 
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kill_suid</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iattr</span>	<span class="n">ia</span><span class="p">;</span>
	<span class="n">ia</span><span class="p">.</span><span class="n">ia_valid</span> <span class="o">=</span> <span class="n">ATTR_KILL_SUID</span> <span class="o">|</span> <span class="n">ATTR_KILL_SGID</span> <span class="o">|</span> <span class="n">ATTR_KILL_PRIV</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">notify_change</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ia</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Gathered writes: If another process is currently writing to the file,</span>
<span class="cm"> * there&#39;s a high chance this is another nfsd (triggered by a bulk write</span>
<span class="cm"> * from a client&#39;s biod). Rather than syncing the file with each write</span>
<span class="cm"> * request, we sleep for 10 msec.</span>
<span class="cm"> *</span>
<span class="cm"> * I don&#39;t know if this roughly approximates C. Juszak&#39;s idea of</span>
<span class="cm"> * gathered writes, but it&#39;s a nice and simple solution (IMHO), and it</span>
<span class="cm"> * seems to work:-)</span>
<span class="cm"> *</span>
<span class="cm"> * Note: we do this only in the NFSv2 case, since v3 and higher have a</span>
<span class="cm"> * better tool (separate unstable writes and commits) for solving this</span>
<span class="cm"> * problem.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_for_concurrent_writes</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">ino_t</span> <span class="n">last_ino</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">dev_t</span> <span class="n">last_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_writecount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">last_ino</span> <span class="o">==</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">&amp;&amp;</span> <span class="n">last_dev</span> <span class="o">==</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfsd: write defer %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfsd: write resume %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_DIRTY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfsd: write sync %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vfs_fsync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">last_ino</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
	<span class="n">last_dev</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_dev</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__be32</span>
<span class="nf">nfsd_vfs_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vlen</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">cnt</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">stablep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_export</span>	<span class="o">*</span><span class="n">exp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">mm_segment_t</span>		<span class="n">oldfs</span><span class="p">;</span>
	<span class="n">__be32</span>			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">host_err</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">stable</span> <span class="o">=</span> <span class="o">*</span><span class="n">stablep</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">use_wgather</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">exp</span>   <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Request sync writes if</span>
<span class="cm">	 *  -	the sync export option has been set, or</span>
<span class="cm">	 *  -	the client requested O_SYNC behavior (NFSv3 feature).</span>
<span class="cm">	 *  -   The file system doesn&#39;t support fsync().</span>
<span class="cm">	 * When NFSv2 gathered writes have been configured for this volume,</span>
<span class="cm">	 * flushing the data to disk is handled separately below.</span>
<span class="cm">	 */</span>
	<span class="n">use_wgather</span> <span class="o">=</span> <span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_vers</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">EX_WGATHER</span><span class="p">(</span><span class="n">exp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">fsync</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* COMMIT3 cannot work */</span>
	       <span class="n">stable</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	       <span class="o">*</span><span class="n">stablep</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* FILE_SYNC */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EX_ISSYNC</span><span class="p">(</span><span class="n">exp</span><span class="p">))</span>
		<span class="n">stable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stable</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">use_wgather</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">|=</span> <span class="n">O_SYNC</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Write the data. */</span>
	<span class="n">oldfs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span> <span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="n">host_err</span> <span class="o">=</span> <span class="n">vfs_writev</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iovec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">vec</span><span class="p">,</span> <span class="n">vlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">oldfs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>
	<span class="o">*</span><span class="n">cnt</span> <span class="o">=</span> <span class="n">host_err</span><span class="p">;</span>
	<span class="n">nfsdstats</span><span class="p">.</span><span class="n">io_write</span> <span class="o">+=</span> <span class="n">host_err</span><span class="p">;</span>
	<span class="n">fsnotify_modify</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="cm">/* clear setuid/setgid flag after write */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">S_ISUID</span> <span class="o">|</span> <span class="n">S_ISGID</span><span class="p">))</span>
		<span class="n">kill_suid</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stable</span> <span class="o">&amp;&amp;</span> <span class="n">use_wgather</span><span class="p">)</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">wait_for_concurrent_writes</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

<span class="nl">out_nfserr:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfsd: write complete host_err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host_err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read data from a file. count must contain the requested read count</span>
<span class="cm"> * on entry. On return, *count contains the number of bytes actually read.</span>
<span class="cm"> * N.B. After this call fhp needs an fh_put</span>
<span class="cm"> */</span>
<span class="n">__be32</span> <span class="nf">nfsd_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span>
	<span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vlen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">raparms</span>	<span class="o">*</span><span class="n">ra</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_open</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">S_IFREG</span><span class="p">,</span> <span class="n">NFSD_MAY_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="cm">/* Get readahead parameters */</span>
	<span class="n">ra</span> <span class="o">=</span> <span class="n">nfsd_get_raparms</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_dev</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ra</span> <span class="o">&amp;&amp;</span> <span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_set</span><span class="p">)</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_ra</span> <span class="o">=</span> <span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_ra</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_vfs_read</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">vlen</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="cm">/* Write back readahead params */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ra</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">raparm_hbucket</span> <span class="o">*</span><span class="n">rab</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">raparm_hash</span><span class="p">[</span><span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_hindex</span><span class="p">];</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rab</span><span class="o">-&gt;</span><span class="n">pb_lock</span><span class="p">);</span>
		<span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_ra</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_ra</span><span class="p">;</span>
		<span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_set</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ra</span><span class="o">-&gt;</span><span class="n">p_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rab</span><span class="o">-&gt;</span><span class="n">pb_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">nfsd_close</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* As above, but use the provided file descriptor. */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_read_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vlen</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span>		<span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_permission</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="p">,</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">,</span>
				<span class="n">NFSD_MAY_READ</span><span class="o">|</span><span class="n">NFSD_MAY_OWNER_OVERRIDE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_vfs_read</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">vlen</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="cm">/* Note file may still be NULL in NFSv4 special stateid case: */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_read</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">vlen</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write data to a file.</span>
<span class="cm"> * The stable flag requests synchronous writes.</span>
<span class="cm"> * N.B. After this call fhp needs an fh_put</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vlen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">cnt</span><span class="p">,</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">stablep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span>			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_permission</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="p">,</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">,</span>
				<span class="n">NFSD_MAY_WRITE</span><span class="o">|</span><span class="n">NFSD_MAY_OWNER_OVERRIDE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_vfs_write</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">vlen</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span>
				<span class="n">stablep</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_open</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">S_IFREG</span><span class="p">,</span> <span class="n">NFSD_MAY_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_vfs_write</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">vlen</span><span class="p">,</span>
					     <span class="n">cnt</span><span class="p">,</span> <span class="n">stablep</span><span class="p">);</span>
		<span class="n">nfsd_close</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NFSD_V3</span>
<span class="cm">/*</span>
<span class="cm"> * Commit all pending writes to stable storage.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: we only guarantee that data that lies within the range specified</span>
<span class="cm"> * by the &#39;offset&#39; and &#39;count&#39; parameters will be synced.</span>
<span class="cm"> *</span>
<span class="cm"> * Unfortunately we cannot lock the file to make sure we return full WCC</span>
<span class="cm"> * data to the client, as locking happens lower down in the filesystem.</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span>
               <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="n">loff_t</span>		<span class="n">end</span> <span class="o">=</span> <span class="n">LLONG_MAX</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_inval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_open</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">S_IFREG</span><span class="p">,</span>
			<span class="n">NFSD_MAY_WRITE</span><span class="o">|</span><span class="n">NFSD_MAY_NOT_BREAK_LEASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EX_ISSYNC</span><span class="p">(</span><span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err2</span> <span class="o">=</span> <span class="n">vfs_fsync_range</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err2</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">err2</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_notsupp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nfsd_close</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NFSD_V3 */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">__be32</span>
<span class="nf">nfsd_create_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">resfhp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">iap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Mode has already been set earlier in create:</span>
<span class="cm">	 */</span>
	<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATTR_MODE</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Setting uid/gid works only for root.  Irix appears to</span>
<span class="cm">	 * send along the gid on create when it tries to implement</span>
<span class="cm">	 * setgid directories via NFS:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_fsuid</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ATTR_UID</span><span class="o">|</span><span class="n">ATTR_GID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nfsd_setattr</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">resfhp</span><span class="p">,</span> <span class="n">iap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">time_t</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* HPUX client sometimes creates a file in mode 000, and sets size to 0.</span>
<span class="cm"> * setting size to 0 may fail for some specific file systems by the permission</span>
<span class="cm"> * checking which requires WRITE permission but the mode is 000.</span>
<span class="cm"> * we ignore the resizing(to 0) on the just new created file, since the size is</span>
<span class="cm"> * 0 after file created.</span>
<span class="cm"> *</span>
<span class="cm"> * call this only after vfs_create() is called.</span>
<span class="cm"> * */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">nfsd_check_ignore_resizing</span><span class="p">(</span><span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">iap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATTR_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create a file (regular, directory, device, fifo); UNIX sockets </span>
<span class="cm"> * not yet implemented.</span>
<span class="cm"> * If the response fh has been verified, the parent directory should</span>
<span class="cm"> * already be locked. Note that the parent directory is left locked.</span>
<span class="cm"> *</span>
<span class="cm"> * N.B. Every call to nfsd_create needs an fh_put for _both_ fhp and resfhp</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flen</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">iap</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">rdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">resfhp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="o">*</span><span class="n">dchild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dirp</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">err</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">err2</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">host_err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_perm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flen</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_exist</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isdotent</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">flen</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">S_IFDIR</span><span class="p">,</span> <span class="n">NFSD_MAY_CREATE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">;</span>
	<span class="n">dirp</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_notdir</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirp</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check whether the response file handle has been verified yet.</span>
<span class="cm">	 * If it has, the parent directory should already be locked.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resfhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* called from nfsd_proc_mkdir, or possibly nfsd3_proc_create */</span>
		<span class="n">fh_lock_nested</span><span class="p">(</span><span class="n">fhp</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
		<span class="n">dchild</span> <span class="o">=</span> <span class="n">lookup_one_len</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">flen</span><span class="p">);</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dchild</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dchild</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">fh_compose</span><span class="p">(</span><span class="n">resfhp</span><span class="p">,</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="p">,</span> <span class="n">dchild</span><span class="p">,</span> <span class="n">fhp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* called from nfsd_proc_create */</span>
		<span class="n">dchild</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">resfhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_locked</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* not actually possible */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;nfsd_create: parent %s/%s not locked!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_io</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure the child dentry is still negative ...</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_exist</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dchild</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfsd_create: dentry %s/%s not negative!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dchild</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span> 
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">))</span>
		<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mode</span> <span class="o">&amp;</span> <span class="n">S_IALLUGO</span><span class="p">)</span> <span class="o">|</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_inval</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">special_file</span><span class="p">(</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;nfsd: bad file type %o in nfsd_create</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">type</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">host_err</span> <span class="o">=</span> <span class="n">fh_want_write</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the dir op function pointer.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFREG</span>:
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">vfs_create</span><span class="p">(</span><span class="n">dirp</span><span class="p">,</span> <span class="n">dchild</span><span class="p">,</span> <span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host_err</span><span class="p">)</span>
			<span class="n">nfsd_check_ignore_resizing</span><span class="p">(</span><span class="n">iap</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">vfs_mkdir</span><span class="p">(</span><span class="n">dirp</span><span class="p">,</span> <span class="n">dchild</span><span class="p">,</span> <span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFCHR</span>:
	<span class="k">case</span> <span class="n">S_IFBLK</span>:
	<span class="k">case</span> <span class="n">S_IFIFO</span>:
	<span class="k">case</span> <span class="n">S_IFSOCK</span>:
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">vfs_mknod</span><span class="p">(</span><span class="n">dirp</span><span class="p">,</span> <span class="n">dchild</span><span class="p">,</span> <span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mode</span><span class="p">,</span> <span class="n">rdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fh_drop_write</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_create_setattr</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">resfhp</span><span class="p">,</span> <span class="n">iap</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * nfsd_setattr already committed the child.  Transactional filesystems</span>
<span class="cm">	 * had a chance to commit changes for both parent and child</span>
<span class="cm">	 * simultaneously making the following commit_metadata a noop.</span>
<span class="cm">	 */</span>
	<span class="n">err2</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">commit_metadata</span><span class="p">(</span><span class="n">fhp</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err2</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">err2</span><span class="p">;</span>
	<span class="n">fh_drop_write</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Update the file handle to get the new inode info.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">fh_update</span><span class="p">(</span><span class="n">resfhp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dchild</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dchild</span><span class="p">))</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dchild</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_nfserr:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NFSD_V3</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nfsd_create_is_exclusive</span><span class="p">(</span><span class="kt">int</span> <span class="n">createmode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">createmode</span> <span class="o">==</span> <span class="n">NFS3_CREATE_EXCLUSIVE</span>
	       <span class="o">||</span> <span class="n">createmode</span> <span class="o">==</span> <span class="n">NFS4_CREATE_EXCLUSIVE4_1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NFSv3 and NFSv4 version of nfsd_create</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">do_nfsd_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flen</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">iap</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">resfhp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">createmode</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">verifier</span><span class="p">,</span>
	        <span class="n">bool</span> <span class="o">*</span><span class="n">truncp</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">created</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="o">*</span><span class="n">dchild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dirp</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">host_err</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">v_mtime</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">v_atime</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_perm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flen</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_exist</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isdotent</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">flen</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">))</span>
		<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">S_IFDIR</span><span class="p">,</span> <span class="n">NFSD_MAY_EXEC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">;</span>
	<span class="n">dirp</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="cm">/* Get all the sanity checks out of the way before</span>
<span class="cm">	 * we lock the parent. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_notdir</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirp</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">fh_lock_nested</span><span class="p">(</span><span class="n">fhp</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compose the response file handle.</span>
<span class="cm">	 */</span>
	<span class="n">dchild</span> <span class="o">=</span> <span class="n">lookup_one_len</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">flen</span><span class="p">);</span>
	<span class="n">host_err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dchild</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dchild</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>

	<span class="cm">/* If file doesn&#39;t exist, check for permissions to create one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dchild</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">S_IFDIR</span><span class="p">,</span> <span class="n">NFSD_MAY_CREATE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_compose</span><span class="p">(</span><span class="n">resfhp</span><span class="p">,</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="p">,</span> <span class="n">dchild</span><span class="p">,</span> <span class="n">fhp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_create_is_exclusive</span><span class="p">(</span><span class="n">createmode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* solaris7 gets confused (bugid 4218508) if these have</span>
<span class="cm">		 * the high bit set, so just clear the high bits. If this is</span>
<span class="cm">		 * ever changed to use different attrs for storing the</span>
<span class="cm">		 * verifier, then do_open_lookup() will also need to be fixed</span>
<span class="cm">		 * accordingly.</span>
<span class="cm">		 */</span>
		<span class="n">v_mtime</span> <span class="o">=</span> <span class="n">verifier</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;</span><span class="mh">0x7fffffff</span><span class="p">;</span>
		<span class="n">v_atime</span> <span class="o">=</span> <span class="n">verifier</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&amp;</span><span class="mh">0x7fffffff</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">host_err</span> <span class="o">=</span> <span class="n">fh_want_write</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dchild</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">createmode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NFS3_CREATE_UNCHECKED</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">dchild</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">truncp</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* in nfsv4, we need to treat this case a little</span>
<span class="cm">				 * differently.  we don&#39;t want to truncate the</span>
<span class="cm">				 * file now; this would be wrong if the OPEN</span>
<span class="cm">				 * fails for some other reason.  furthermore,</span>
<span class="cm">				 * if the size is nonzero, we should ignore it</span>
<span class="cm">				 * according to spec!</span>
<span class="cm">				 */</span>
				<span class="o">*</span><span class="n">truncp</span> <span class="o">=</span> <span class="p">(</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;=</span> <span class="n">ATTR_SIZE</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">set_attr</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NFS3_CREATE_EXCLUSIVE</span>:
			<span class="k">if</span> <span class="p">(</span>   <span class="n">dchild</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="n">v_mtime</span>
			    <span class="o">&amp;&amp;</span> <span class="n">dchild</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="n">v_atime</span>
			    <span class="o">&amp;&amp;</span> <span class="n">dchild</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_size</span>  <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NFS4_CREATE_EXCLUSIVE4_1</span>:
			<span class="k">if</span> <span class="p">(</span>   <span class="n">dchild</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="n">v_mtime</span>
			    <span class="o">&amp;&amp;</span> <span class="n">dchild</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="n">v_atime</span>
			    <span class="o">&amp;&amp;</span> <span class="n">dchild</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_size</span>  <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
				<span class="k">goto</span> <span class="n">set_attr</span><span class="p">;</span>
			 <span class="cm">/* fallthru */</span>
		<span class="k">case</span> <span class="n">NFS3_CREATE_GUARDED</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_exist</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fh_drop_write</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">host_err</span> <span class="o">=</span> <span class="n">vfs_create</span><span class="p">(</span><span class="n">dirp</span><span class="p">,</span> <span class="n">dchild</span><span class="p">,</span> <span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fh_drop_write</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">created</span><span class="p">)</span>
		<span class="o">*</span><span class="n">created</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">nfsd_check_ignore_resizing</span><span class="p">(</span><span class="n">iap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_create_is_exclusive</span><span class="p">(</span><span class="n">createmode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Cram the verifier into atime/mtime */</span>
		<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">=</span> <span class="n">ATTR_MTIME</span><span class="o">|</span><span class="n">ATTR_ATIME</span>
			<span class="o">|</span> <span class="n">ATTR_MTIME_SET</span><span class="o">|</span><span class="n">ATTR_ATIME_SET</span><span class="p">;</span>
		<span class="cm">/* XXX someone who knows this better please fix it for nsec */</span> 
		<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">v_mtime</span><span class="p">;</span>
		<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">v_atime</span><span class="p">;</span>
		<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iap</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">set_attr:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_create_setattr</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">resfhp</span><span class="p">,</span> <span class="n">iap</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * nfsd_setattr already committed the child (and possibly also the parent).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">commit_metadata</span><span class="p">(</span><span class="n">fhp</span><span class="p">));</span>

	<span class="n">fh_drop_write</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Update the filehandle to get the new inode info.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">fh_update</span><span class="p">(</span><span class="n">resfhp</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">fh_unlock</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dchild</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dchild</span><span class="p">))</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dchild</span><span class="p">);</span>
 	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
 
 <span class="nl">out_nfserr:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NFSD_V3 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Read a symlink. On entry, *lenp must contain the maximum path length that</span>
<span class="cm"> * fits into the buffer. On return, it contains the true length.</span>
<span class="cm"> * N.B. After this call fhp needs an fh_put</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_readlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lenp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">mm_segment_t</span>	<span class="n">oldfs</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">host_err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">S_IFLNK</span><span class="p">,</span> <span class="n">NFSD_MAY_NOP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="o">-&gt;</span><span class="n">ex_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">;</span>
	<span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">;</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_inval</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">readlink</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">touch_atime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="cm">/* N.B. Why does this call need a get_fs()??</span>
<span class="cm">	 * Remove the set_fs and watch the fireworks:-) --okir</span>
<span class="cm">	 */</span>

	<span class="n">oldfs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span> <span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="n">host_err</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">readlink</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">lenp</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">oldfs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>
	<span class="o">*</span><span class="n">lenp</span> <span class="o">=</span> <span class="n">host_err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_nfserr:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create a symlink and look up its inode</span>
<span class="cm"> * N.B. After this call _both_ fhp and resfhp need an fh_put</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flen</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>  <span class="kt">int</span> <span class="n">plen</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">resfhp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">iap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="o">*</span><span class="n">dnew</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">err</span><span class="p">,</span> <span class="n">cerr</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">host_err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_noent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flen</span> <span class="o">||</span> <span class="o">!</span><span class="n">plen</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_exist</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isdotent</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">flen</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">S_IFDIR</span><span class="p">,</span> <span class="n">NFSD_MAY_CREATE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">fh_lock</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">;</span>
	<span class="n">dnew</span> <span class="o">=</span> <span class="n">lookup_one_len</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">flen</span><span class="p">);</span>
	<span class="n">host_err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dnew</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dnew</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>

	<span class="n">host_err</span> <span class="o">=</span> <span class="n">fh_want_write</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">plen</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">path_alloced</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">plen</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path_alloced</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">host_err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">strncpy</span><span class="p">(</span><span class="n">path_alloced</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>
			<span class="n">path_alloced</span><span class="p">[</span><span class="n">plen</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">host_err</span> <span class="o">=</span> <span class="n">vfs_symlink</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">dnew</span><span class="p">,</span> <span class="n">path_alloced</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">path_alloced</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">vfs_symlink</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">dnew</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">commit_metadata</span><span class="p">(</span><span class="n">fhp</span><span class="p">));</span>
	<span class="n">fh_unlock</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>

	<span class="n">fh_drop_write</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>

	<span class="n">cerr</span> <span class="o">=</span> <span class="n">fh_compose</span><span class="p">(</span><span class="n">resfhp</span><span class="p">,</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="p">,</span> <span class="n">dnew</span><span class="p">,</span> <span class="n">fhp</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dnew</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">err</span> <span class="o">=</span> <span class="n">cerr</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_nfserr:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create a hardlink</span>
<span class="cm"> * N.B. After this call _both_ ffhp and tfhp need an fh_put</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">ffhp</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">tfhp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">ddir</span><span class="p">,</span> <span class="o">*</span><span class="n">dnew</span><span class="p">,</span> <span class="o">*</span><span class="n">dold</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dirp</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">host_err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">ffhp</span><span class="p">,</span> <span class="n">S_IFDIR</span><span class="p">,</span> <span class="n">NFSD_MAY_CREATE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">tfhp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NFSD_MAY_NOP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_isdir</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">tfhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_perm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_exist</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isdotent</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">fh_lock_nested</span><span class="p">(</span><span class="n">ffhp</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
	<span class="n">ddir</span> <span class="o">=</span> <span class="n">ffhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">;</span>
	<span class="n">dirp</span> <span class="o">=</span> <span class="n">ddir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">dnew</span> <span class="o">=</span> <span class="n">lookup_one_len</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ddir</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">host_err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dnew</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dnew</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>

	<span class="n">dold</span> <span class="o">=</span> <span class="n">tfhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">;</span>

	<span class="n">host_err</span> <span class="o">=</span> <span class="n">fh_want_write</span><span class="p">(</span><span class="n">tfhp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_noent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dold</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_drop_write</span><span class="p">;</span>
	<span class="n">host_err</span> <span class="o">=</span> <span class="n">nfsd_break_lease</span><span class="p">(</span><span class="n">dold</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_drop_write</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">host_err</span> <span class="o">=</span> <span class="n">vfs_link</span><span class="p">(</span><span class="n">dold</span><span class="p">,</span> <span class="n">dirp</span><span class="p">,</span> <span class="n">dnew</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host_err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">commit_metadata</span><span class="p">(</span><span class="n">ffhp</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">commit_metadata</span><span class="p">(</span><span class="n">tfhp</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EXDEV</span> <span class="o">&amp;&amp;</span> <span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_vers</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_acces</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_drop_write:</span>
	<span class="n">fh_drop_write</span><span class="p">(</span><span class="n">tfhp</span><span class="p">);</span>
<span class="nl">out_dput:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dnew</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">fh_unlock</span><span class="p">(</span><span class="n">ffhp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_nfserr:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Rename a file</span>
<span class="cm"> * N.B. After this call _both_ ffhp and tfhp need an fh_put</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">ffhp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flen</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">tfhp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">fdentry</span><span class="p">,</span> <span class="o">*</span><span class="n">tdentry</span><span class="p">,</span> <span class="o">*</span><span class="n">odentry</span><span class="p">,</span> <span class="o">*</span><span class="n">ndentry</span><span class="p">,</span> <span class="o">*</span><span class="n">trap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">fdir</span><span class="p">,</span> <span class="o">*</span><span class="n">tdir</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">host_err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">ffhp</span><span class="p">,</span> <span class="n">S_IFDIR</span><span class="p">,</span> <span class="n">NFSD_MAY_REMOVE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">tfhp</span><span class="p">,</span> <span class="n">S_IFDIR</span><span class="p">,</span> <span class="n">NFSD_MAY_CREATE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">fdentry</span> <span class="o">=</span> <span class="n">ffhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">;</span>
	<span class="n">fdir</span> <span class="o">=</span> <span class="n">fdentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">tdentry</span> <span class="o">=</span> <span class="n">tfhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">;</span>
	<span class="n">tdir</span> <span class="o">=</span> <span class="n">tdentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_vers</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="n">nfserr_acces</span> <span class="o">:</span> <span class="n">nfserr_xdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ffhp</span><span class="o">-&gt;</span><span class="n">fh_export</span> <span class="o">!=</span> <span class="n">tfhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_perm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flen</span> <span class="o">||</span> <span class="n">isdotent</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">flen</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">tlen</span> <span class="o">||</span> <span class="n">isdotent</span><span class="p">(</span><span class="n">tname</span><span class="p">,</span> <span class="n">tlen</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* cannot use fh_lock as we need deadlock protective ordering</span>
<span class="cm">	 * so do it by hand */</span>
	<span class="n">trap</span> <span class="o">=</span> <span class="n">lock_rename</span><span class="p">(</span><span class="n">tdentry</span><span class="p">,</span> <span class="n">fdentry</span><span class="p">);</span>
	<span class="n">ffhp</span><span class="o">-&gt;</span><span class="n">fh_locked</span> <span class="o">=</span> <span class="n">tfhp</span><span class="o">-&gt;</span><span class="n">fh_locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">fill_pre_wcc</span><span class="p">(</span><span class="n">ffhp</span><span class="p">);</span>
	<span class="n">fill_pre_wcc</span><span class="p">(</span><span class="n">tfhp</span><span class="p">);</span>

	<span class="n">odentry</span> <span class="o">=</span> <span class="n">lookup_one_len</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fdentry</span><span class="p">,</span> <span class="n">flen</span><span class="p">);</span>
	<span class="n">host_err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">odentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">odentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>

	<span class="n">host_err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">odentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dput_old</span><span class="p">;</span>
	<span class="n">host_err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">odentry</span> <span class="o">==</span> <span class="n">trap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dput_old</span><span class="p">;</span>

	<span class="n">ndentry</span> <span class="o">=</span> <span class="n">lookup_one_len</span><span class="p">(</span><span class="n">tname</span><span class="p">,</span> <span class="n">tdentry</span><span class="p">,</span> <span class="n">tlen</span><span class="p">);</span>
	<span class="n">host_err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ndentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ndentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_dput_old</span><span class="p">;</span>
	<span class="n">host_err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTEMPTY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndentry</span> <span class="o">==</span> <span class="n">trap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dput_new</span><span class="p">;</span>

	<span class="n">host_err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EXDEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ffhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="o">-&gt;</span><span class="n">ex_path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">!=</span> <span class="n">tfhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="o">-&gt;</span><span class="n">ex_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dput_new</span><span class="p">;</span>
	<span class="n">host_err</span> <span class="o">=</span> <span class="n">fh_want_write</span><span class="p">(</span><span class="n">ffhp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dput_new</span><span class="p">;</span>

	<span class="n">host_err</span> <span class="o">=</span> <span class="n">nfsd_break_lease</span><span class="p">(</span><span class="n">odentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_drop_write</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">nfsd_break_lease</span><span class="p">(</span><span class="n">ndentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_drop_write</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">host_err</span> <span class="o">=</span> <span class="n">vfs_rename</span><span class="p">(</span><span class="n">fdir</span><span class="p">,</span> <span class="n">odentry</span><span class="p">,</span> <span class="n">tdir</span><span class="p">,</span> <span class="n">ndentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host_err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">commit_metadata</span><span class="p">(</span><span class="n">tfhp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host_err</span><span class="p">)</span>
			<span class="n">host_err</span> <span class="o">=</span> <span class="n">commit_metadata</span><span class="p">(</span><span class="n">ffhp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_drop_write:</span>
	<span class="n">fh_drop_write</span><span class="p">(</span><span class="n">ffhp</span><span class="p">);</span>
 <span class="nl">out_dput_new:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">ndentry</span><span class="p">);</span>
 <span class="nl">out_dput_old:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">odentry</span><span class="p">);</span>
 <span class="nl">out_nfserr:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>

	<span class="cm">/* we cannot reply on fh_unlock on the two filehandles,</span>
<span class="cm">	 * as that would do the wrong thing if the two directories</span>
<span class="cm">	 * were the same, so again we do it by hand</span>
<span class="cm">	 */</span>
	<span class="n">fill_post_wcc</span><span class="p">(</span><span class="n">ffhp</span><span class="p">);</span>
	<span class="n">fill_post_wcc</span><span class="p">(</span><span class="n">tfhp</span><span class="p">);</span>
	<span class="n">unlock_rename</span><span class="p">(</span><span class="n">tdentry</span><span class="p">,</span> <span class="n">fdentry</span><span class="p">);</span>
	<span class="n">ffhp</span><span class="o">-&gt;</span><span class="n">fh_locked</span> <span class="o">=</span> <span class="n">tfhp</span><span class="o">-&gt;</span><span class="n">fh_locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unlink a file or directory</span>
<span class="cm"> * N.B. After this call fhp needs an fh_put</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="o">*</span><span class="n">rdentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">dirp</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">host_err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_acces</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flen</span> <span class="o">||</span> <span class="n">isdotent</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">flen</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">S_IFDIR</span><span class="p">,</span> <span class="n">NFSD_MAY_REMOVE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">fh_lock_nested</span><span class="p">(</span><span class="n">fhp</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">;</span>
	<span class="n">dirp</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">rdentry</span> <span class="o">=</span> <span class="n">lookup_one_len</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">flen</span><span class="p">);</span>
	<span class="n">host_err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rdentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rdentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_nfserr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rdentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">rdentry</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_noent</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">)</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">rdentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">;</span>

	<span class="n">host_err</span> <span class="o">=</span> <span class="n">fh_want_write</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">host_err</span> <span class="o">=</span> <span class="n">nfsd_break_lease</span><span class="p">(</span><span class="n">rdentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_drop_write</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">S_IFDIR</span><span class="p">)</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">vfs_unlink</span><span class="p">(</span><span class="n">dirp</span><span class="p">,</span> <span class="n">rdentry</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">vfs_rmdir</span><span class="p">(</span><span class="n">dirp</span><span class="p">,</span> <span class="n">rdentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host_err</span><span class="p">)</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">commit_metadata</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
<span class="nl">out_drop_write:</span>
	<span class="n">fh_drop_write</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
<span class="nl">out_put:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">rdentry</span><span class="p">);</span>

<span class="nl">out_nfserr:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We do this buffering because we must not call back into the file</span>
<span class="cm"> * system&#39;s -&gt;lookup() method from the filldir callback. That may well</span>
<span class="cm"> * deadlock a number of file systems.</span>
<span class="cm"> *</span>
<span class="cm"> * This is based heavily on the implementation of same in XFS.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">buffered_dirent</span> <span class="p">{</span>
	<span class="n">u64</span>		<span class="n">ino</span><span class="p">;</span>
	<span class="n">loff_t</span>		<span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">namlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">d_type</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="n">name</span><span class="p">[];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">readdir_data</span> <span class="p">{</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">dirent</span><span class="p">;</span>
	<span class="kt">size_t</span>		<span class="n">used</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">full</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfsd_buffered_filldir</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">namlen</span><span class="p">,</span>
				 <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ino</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">readdir_data</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">__buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffered_dirent</span> <span class="o">*</span><span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">dirent</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reclen</span><span class="p">;</span>

	<span class="n">reclen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffered_dirent</span><span class="p">)</span> <span class="o">+</span> <span class="n">namlen</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">+</span> <span class="n">reclen</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">de</span><span class="o">-&gt;</span><span class="n">namlen</span> <span class="o">=</span> <span class="n">namlen</span><span class="p">;</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">d_type</span> <span class="o">=</span> <span class="n">d_type</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">de</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namlen</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">+=</span> <span class="n">reclen</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__be32</span> <span class="nf">nfsd_buffered_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">func</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">readdir_cd</span> <span class="o">*</span><span class="n">cdp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offsetp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">readdir_data</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffered_dirent</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">host_err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">buf</span><span class="p">.</span><span class="n">dirent</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">.</span><span class="n">dirent</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nfserrno</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">offsetp</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir_inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reclen</span><span class="p">;</span>

		<span class="n">cdp</span><span class="o">-&gt;</span><span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_eof</span><span class="p">;</span> <span class="cm">/* will be cleared on successful read */</span>
		<span class="n">buf</span><span class="p">.</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">.</span><span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">host_err</span> <span class="o">=</span> <span class="n">vfs_readdir</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">nfsd_buffered_filldir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">full</span><span class="p">)</span>
			<span class="n">host_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">used</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Various filldir functions may end up calling back into</span>
<span class="cm">		 * lookup_one_len() and the file system&#39;s -&gt;lookup() method.</span>
<span class="cm">		 * These expect i_mutex to be held, as it would within readdir.</span>
<span class="cm">		 */</span>
		<span class="n">host_err</span> <span class="o">=</span> <span class="n">mutex_lock_killable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">buffered_dirent</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">.</span><span class="n">dirent</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">cdp</span><span class="p">,</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">,</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
				 <span class="n">de</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">d_type</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cdp</span><span class="o">-&gt;</span><span class="n">err</span> <span class="o">!=</span> <span class="n">nfs_ok</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">reclen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">de</span><span class="p">)</span> <span class="o">+</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">namlen</span><span class="p">,</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
			<span class="n">size</span> <span class="o">-=</span> <span class="n">reclen</span><span class="p">;</span>
			<span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">buffered_dirent</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">de</span> <span class="o">+</span> <span class="n">reclen</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* We bailed out early */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">vfs_llseek</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_CUR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">buf</span><span class="p">.</span><span class="n">dirent</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host_err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">host_err</span><span class="p">);</span>

	<span class="o">*</span><span class="n">offsetp</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cdp</span><span class="o">-&gt;</span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read entries from a directory.</span>
<span class="cm"> * The  NFSv3/4 verifier we ignore for now.</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offsetp</span><span class="p">,</span> 
	     <span class="k">struct</span> <span class="n">readdir_cd</span> <span class="o">*</span><span class="n">cdp</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span>		<span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="n">loff_t</span>		<span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">offsetp</span><span class="p">;</span>
	<span class="kt">int</span>             <span class="n">may_flags</span> <span class="o">=</span> <span class="n">NFSD_MAY_READ</span><span class="p">;</span>

	<span class="cm">/* NFSv2 only supports 32 bit cookies */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rqstp</span><span class="o">-&gt;</span><span class="n">rq_vers</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">may_flags</span> <span class="o">|=</span> <span class="n">NFSD_MAY_64BIT_COOKIE</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_open</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="n">S_IFDIR</span><span class="p">,</span> <span class="n">may_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">vfs_llseek</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfserrno</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_close</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_buffered_readdir</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">cdp</span><span class="p">,</span> <span class="n">offsetp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">nfserr_eof</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="n">nfserr_toosmall</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_ok</span><span class="p">;</span> <span class="cm">/* can still be found in -&gt;err */</span>
<span class="nl">out_close:</span>
	<span class="n">nfsd_close</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get file system stats</span>
<span class="cm"> * N.B. After this call fhp needs an fh_put</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="n">stat</span><span class="p">,</span> <span class="kt">int</span> <span class="n">access</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fh_verify</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">fhp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NFSD_MAY_NOP</span> <span class="o">|</span> <span class="n">access</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">mnt</span>	<span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_export</span><span class="o">-&gt;</span><span class="n">ex_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">,</span>
			<span class="p">.</span><span class="n">dentry</span>	<span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">,</span>
		<span class="p">};</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vfs_statfs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">stat</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nfserr_io</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">exp_rdonly</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_export</span> <span class="o">*</span><span class="n">exp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nfsexp_flags</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NFSEXP_READONLY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check for a user&#39;s access permissions to this inode.</span>
<span class="cm"> */</span>
<span class="n">__be32</span>
<span class="nf">nfsd_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">svc_export</span> <span class="o">*</span><span class="n">exp</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">acc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">acc</span> <span class="o">&amp;</span> <span class="n">NFSD_MAY_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">NFSD_MAY_NOP</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	dprintk(&quot;nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s\n&quot;,</span>
<span class="c">		acc,</span>
<span class="c">		(acc &amp; NFSD_MAY_READ)?	&quot; read&quot;  : &quot;&quot;,</span>
<span class="c">		(acc &amp; NFSD_MAY_WRITE)?	&quot; write&quot; : &quot;&quot;,</span>
<span class="c">		(acc &amp; NFSD_MAY_EXEC)?	&quot; exec&quot;  : &quot;&quot;,</span>
<span class="c">		(acc &amp; NFSD_MAY_SATTR)?	&quot; sattr&quot; : &quot;&quot;,</span>
<span class="c">		(acc &amp; NFSD_MAY_TRUNC)?	&quot; trunc&quot; : &quot;&quot;,</span>
<span class="c">		(acc &amp; NFSD_MAY_LOCK)?	&quot; lock&quot;  : &quot;&quot;,</span>
<span class="c">		(acc &amp; NFSD_MAY_OWNER_OVERRIDE)? &quot; owneroverride&quot; : &quot;&quot;,</span>
<span class="c">		inode-&gt;i_mode,</span>
<span class="c">		IS_IMMUTABLE(inode)?	&quot; immut&quot; : &quot;&quot;,</span>
<span class="c">		IS_APPEND(inode)?	&quot; append&quot; : &quot;&quot;,</span>
<span class="c">		__mnt_is_readonly(exp-&gt;ex_path.mnt)?	&quot; ro&quot; : &quot;&quot;);</span>
<span class="c">	dprintk(&quot;      owner %d/%d user %d/%d\n&quot;,</span>
<span class="c">		inode-&gt;i_uid, inode-&gt;i_gid, current_fsuid(), current_fsgid());</span>
<span class="cp">#endif</span>

	<span class="cm">/* Normally we reject any write/sattr etc access on a read-only file</span>
<span class="cm">	 * system.  But if it is IRIX doing check on write-access for a </span>
<span class="cm">	 * device special file, we ignore rofs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">acc</span> <span class="o">&amp;</span> <span class="n">NFSD_MAY_LOCAL_ACCESS</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">acc</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NFSD_MAY_WRITE</span> <span class="o">|</span> <span class="n">NFSD_MAY_SATTR</span> <span class="o">|</span> <span class="n">NFSD_MAY_TRUNC</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">exp_rdonly</span><span class="p">(</span><span class="n">rqstp</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">__mnt_is_readonly</span><span class="p">(</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">ex_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">nfserr_rofs</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="cm">/* (acc &amp; NFSD_MAY_WRITE) &amp;&amp; */</span> <span class="n">IS_IMMUTABLE</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">nfserr_perm</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">acc</span> <span class="o">&amp;</span> <span class="n">NFSD_MAY_TRUNC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">IS_APPEND</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">nfserr_perm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acc</span> <span class="o">&amp;</span> <span class="n">NFSD_MAY_LOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If we cannot rely on authentication in NLM requests,</span>
<span class="cm">		 * just allow locks, otherwise require read permission, or</span>
<span class="cm">		 * ownership</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">ex_flags</span> <span class="o">&amp;</span> <span class="n">NFSEXP_NOAUTHNLM</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">acc</span> <span class="o">=</span> <span class="n">NFSD_MAY_READ</span> <span class="o">|</span> <span class="n">NFSD_MAY_OWNER_OVERRIDE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * The file owner always gets access permission for accesses that</span>
<span class="cm">	 * would normally be checked at open time. This is to make</span>
<span class="cm">	 * file access work even when the client has done a fchmod(fd, 0).</span>
<span class="cm">	 *</span>
<span class="cm">	 * However, `cp foo bar&#39; should fail nevertheless when bar is</span>
<span class="cm">	 * readonly. A sensible way to do this might be to reject all</span>
<span class="cm">	 * attempts to truncate a read-only file, because a creat() call</span>
<span class="cm">	 * always implies file truncation.</span>
<span class="cm">	 * ... but this isn&#39;t really fair.  A process may reasonably call</span>
<span class="cm">	 * ftruncate on an open file descriptor on a file with perm 000.</span>
<span class="cm">	 * We must trust the client to do permission checking - using &quot;ACCESS&quot;</span>
<span class="cm">	 * with NFSv3.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">acc</span> <span class="o">&amp;</span> <span class="n">NFSD_MAY_OWNER_OVERRIDE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">==</span> <span class="n">current_fsuid</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* This assumes  NFSD_MAY_{READ,WRITE,EXEC} == MAY_{READ,WRITE,EXEC} */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">acc</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MAY_READ</span><span class="o">|</span><span class="n">MAY_WRITE</span><span class="o">|</span><span class="n">MAY_EXEC</span><span class="p">));</span>

	<span class="cm">/* Allow read access to binaries even when mode 111 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EACCES</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">acc</span> <span class="o">==</span> <span class="p">(</span><span class="n">NFSD_MAY_READ</span> <span class="o">|</span> <span class="n">NFSD_MAY_OWNER_OVERRIDE</span><span class="p">)</span> <span class="o">||</span>
	      <span class="n">acc</span> <span class="o">==</span> <span class="p">(</span><span class="n">NFSD_MAY_READ</span> <span class="o">|</span> <span class="n">NFSD_MAY_READ_IF_EXEC</span><span class="p">)))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">MAY_EXEC</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="o">?</span> <span class="n">nfserrno</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">nfsd_racache_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">raparms</span> <span class="o">*</span><span class="n">raparm</span><span class="p">,</span> <span class="o">*</span><span class="n">last_raparm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfsd: freeing readahead buffers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RAPARM_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raparm</span> <span class="o">=</span> <span class="n">raparm_hash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pb_head</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">raparm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">last_raparm</span> <span class="o">=</span> <span class="n">raparm</span><span class="p">;</span>
			<span class="n">raparm</span> <span class="o">=</span> <span class="n">raparm</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">last_raparm</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">raparm_hash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pb_head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Initialize readahead param cache</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">nfsd_racache_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">cache_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">nperbucket</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">raparms</span> <span class="o">**</span><span class="n">raparm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">raparm_hash</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pb_head</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nperbucket</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">cache_size</span><span class="p">,</span> <span class="n">RAPARM_HASH_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nperbucket</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">nperbucket</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">cache_size</span> <span class="o">=</span> <span class="n">nperbucket</span> <span class="o">*</span> <span class="n">RAPARM_HASH_SIZE</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfsd: allocating %d readahead buffers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cache_size</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RAPARM_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raparm_hash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pb_lock</span><span class="p">);</span>

		<span class="n">raparm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">raparm_hash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pb_head</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nperbucket</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">raparm</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">raparms</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">raparm</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_nomem</span><span class="p">;</span>
			<span class="n">raparm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">raparm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">raparm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nfsdstats</span><span class="p">.</span><span class="n">ra_size</span> <span class="o">=</span> <span class="n">cache_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_nomem:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfsd: kmalloc failed, freeing readahead buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">nfsd_racache_shutdown</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)</span>
<span class="k">struct</span> <span class="n">posix_acl</span> <span class="o">*</span>
<span class="nf">nfsd_get_posix_acl</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">posix_acl</span> <span class="o">*</span><span class="n">acl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_POSIXACL</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ACL_TYPE_ACCESS</span>:
		<span class="n">name</span> <span class="o">=</span> <span class="n">POSIX_ACL_XATTR_ACCESS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ACL_TYPE_DEFAULT</span>:
		<span class="n">name</span> <span class="o">=</span> <span class="n">POSIX_ACL_XATTR_DEFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">nfsd_getxattr</span><span class="p">(</span><span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="n">acl</span> <span class="o">=</span> <span class="n">posix_acl_from_xattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">acl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">nfsd_set_posix_acl</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_fh</span> <span class="o">*</span><span class="n">fhp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">posix_acl</span> <span class="o">*</span><span class="n">acl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_POSIXACL</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">setxattr</span> <span class="o">||</span> <span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">removexattr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ACL_TYPE_ACCESS</span>:
			<span class="n">name</span> <span class="o">=</span> <span class="n">POSIX_ACL_XATTR_ACCESS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ACL_TYPE_DEFAULT</span>:
			<span class="n">name</span> <span class="o">=</span> <span class="n">POSIX_ACL_XATTR_DEFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acl</span> <span class="o">&amp;&amp;</span> <span class="n">acl</span><span class="o">-&gt;</span><span class="n">a_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">posix_acl_xattr_size</span><span class="p">(</span><span class="n">acl</span><span class="o">-&gt;</span><span class="n">a_count</span><span class="p">);</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">value</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">posix_acl_to_xattr</span><span class="p">(</span><span class="n">acl</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">getout</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">fh_want_write</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">getout</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_setxattr</span><span class="p">(</span><span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">ACL_TYPE_DEFAULT</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_removexattr</span><span class="p">(</span><span class="n">fhp</span><span class="o">-&gt;</span><span class="n">fh_dentry</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">)</span>
				<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">fh_drop_write</span><span class="p">(</span><span class="n">fhp</span><span class="p">);</span>

<span class="nl">getout:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif  </span><span class="cm">/* defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
