<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nfsd › nfsctl.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nfsctl.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Syscall interface to knfsd.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1995, 1996 Olaf Kirch &lt;okir@monad.swb.de&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>

<span class="cp">#include &lt;linux/sunrpc/svcsock.h&gt;</span>
<span class="cp">#include &lt;linux/lockd/lockd.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/clnt.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/gss_api.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/gss_krb5_enctypes.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/rpc_pipe_fs.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &quot;idmap.h&quot;</span>
<span class="cp">#include &quot;nfsd.h&quot;</span>
<span class="cp">#include &quot;cache.h&quot;</span>
<span class="cp">#include &quot;fault_inject.h&quot;</span>
<span class="cp">#include &quot;netns.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> *	We have a single directory with several nodes in it.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NFSD_Root</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">NFSD_List</span><span class="p">,</span>
	<span class="n">NFSD_Export_features</span><span class="p">,</span>
	<span class="n">NFSD_Fh</span><span class="p">,</span>
	<span class="n">NFSD_FO_UnlockIP</span><span class="p">,</span>
	<span class="n">NFSD_FO_UnlockFS</span><span class="p">,</span>
	<span class="n">NFSD_Threads</span><span class="p">,</span>
	<span class="n">NFSD_Pool_Threads</span><span class="p">,</span>
	<span class="n">NFSD_Pool_Stats</span><span class="p">,</span>
	<span class="n">NFSD_Versions</span><span class="p">,</span>
	<span class="n">NFSD_Ports</span><span class="p">,</span>
	<span class="n">NFSD_MaxBlkSize</span><span class="p">,</span>
	<span class="n">NFSD_SupportedEnctypes</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * The below MUST come last.  Otherwise we leave a hole in nfsd_files[]</span>
<span class="cm">	 * with !CONFIG_NFSD_V4 and simple_fill_super() goes oops</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CONFIG_NFSD_V4</span>
	<span class="n">NFSD_Leasetime</span><span class="p">,</span>
	<span class="n">NFSD_Gracetime</span><span class="p">,</span>
	<span class="n">NFSD_RecoveryDir</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * write() for these nodes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">write_filehandle</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">write_unlock_ip</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">write_unlock_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">write_threads</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">write_pool_threads</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">write_versions</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">write_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">write_maxblksize</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NFSD_V4</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">write_leasetime</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">write_gracetime</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">write_recoverydir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">write_op</span><span class="p">[])(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">NFSD_Fh</span><span class="p">]</span> <span class="o">=</span> <span class="n">write_filehandle</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NFSD_FO_UnlockIP</span><span class="p">]</span> <span class="o">=</span> <span class="n">write_unlock_ip</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NFSD_FO_UnlockFS</span><span class="p">]</span> <span class="o">=</span> <span class="n">write_unlock_fs</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NFSD_Threads</span><span class="p">]</span> <span class="o">=</span> <span class="n">write_threads</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NFSD_Pool_Threads</span><span class="p">]</span> <span class="o">=</span> <span class="n">write_pool_threads</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NFSD_Versions</span><span class="p">]</span> <span class="o">=</span> <span class="n">write_versions</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NFSD_Ports</span><span class="p">]</span> <span class="o">=</span> <span class="n">write_ports</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NFSD_MaxBlkSize</span><span class="p">]</span> <span class="o">=</span> <span class="n">write_maxblksize</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NFSD_V4</span>
	<span class="p">[</span><span class="n">NFSD_Leasetime</span><span class="p">]</span> <span class="o">=</span> <span class="n">write_leasetime</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NFSD_Gracetime</span><span class="p">]</span> <span class="o">=</span> <span class="n">write_gracetime</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NFSD_RecoveryDir</span><span class="p">]</span> <span class="o">=</span> <span class="n">write_recoverydir</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nfsctl_transaction_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ino_t</span> <span class="n">ino</span> <span class="o">=</span>  <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">rv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">write_op</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">write_op</span><span class="p">[</span><span class="n">ino</span><span class="p">])</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">simple_transaction_get</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="n">rv</span> <span class="o">=</span>  <span class="n">write_op</span><span class="p">[</span><span class="n">ino</span><span class="p">](</span><span class="n">file</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">simple_transaction_set</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nfsctl_transaction_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* An attempt to read a transaction file without writing</span>
<span class="cm">		 * causes a 0-byte write so that the file can return</span>
<span class="cm">		 * state information</span>
<span class="cm">		 */</span>
		<span class="kt">ssize_t</span> <span class="n">rv</span> <span class="o">=</span> <span class="n">nfsctl_transaction_write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">simple_transaction_read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">transaction_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">nfsctl_transaction_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">nfsctl_transaction_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">simple_transaction_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">exports_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd_net</span> <span class="o">*</span><span class="n">nn</span> <span class="o">=</span> <span class="n">net_generic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">nfsd_net_id</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfs_exports_op</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">nn</span><span class="o">-&gt;</span><span class="n">svc_export_cache</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">exports_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">exports_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">export_features_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;0x%x 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">NFSEXP_ALLFLAGS</span><span class="p">,</span> <span class="n">NFSEXP_SECINFO_FLAGS</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">export_features_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">export_features_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">export_features_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">export_features_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#if defined(CONFIG_SUNRPC_GSS) || defined(CONFIG_SUNRPC_GSS_MODULE)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">supported_enctypes_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">KRB5_SUPPORTED_ENCTYPES</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">supported_enctypes_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">supported_enctypes_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">supported_enctypes_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">supported_enctypes_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SUNRPC_GSS or CONFIG_SUNRPC_GSS_MODULE */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">nfsd_pool_stats_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nfsd_pool_stats_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">pool_stats_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">nfsd_pool_stats_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">nfsd_pool_stats_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*----------------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * payload - write methods</span>
<span class="cm"> */</span>


<span class="cm">/**</span>
<span class="cm"> * write_unlock_ip - Release all locks used by a client</span>
<span class="cm"> *</span>
<span class="cm"> * Experimental.</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:	&#39;\n&#39;-terminated C string containing a</span>
<span class="cm"> *				presentation format IP address</span>
<span class="cm"> *			size:	length of C string in @buf</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	returns zero if all specified locks were released;</span>
<span class="cm"> *			returns one if one or more locks were not released</span>
<span class="cm"> *	On error:	return code is negative errno value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_unlock_ip</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">salen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">fo_path</span><span class="p">;</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">fo_path</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qword_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">fo_path</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rpc_pton</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">fo_path</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">sap</span><span class="p">,</span> <span class="n">salen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nlmsvc_unlock_all_by_ip</span><span class="p">(</span><span class="n">sap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_unlock_fs - Release all locks on a local file system</span>
<span class="cm"> *</span>
<span class="cm"> * Experimental.</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:	&#39;\n&#39;-terminated C string containing the</span>
<span class="cm"> *				absolute pathname of a local file system</span>
<span class="cm"> *			size:	length of C string in @buf</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	returns zero if all specified locks were released;</span>
<span class="cm"> *			returns one if one or more locks were not released</span>
<span class="cm"> *	On error:	return code is negative errno value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_unlock_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">fo_path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">fo_path</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qword_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">fo_path</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">kern_path</span><span class="p">(</span><span class="n">fo_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX: Needs better sanity checking.  Otherwise we could end up</span>
<span class="cm">	 * releasing locks on the wrong file system.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For example:</span>
<span class="cm">	 * 1.  Does the path refer to a directory?</span>
<span class="cm">	 * 2.  Is that directory a mount point, or</span>
<span class="cm">	 * 3.  Is that directory the root of an exported file system?</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">nlmsvc_unlock_all_by_sb</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>

	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_filehandle - Get a variable-length NFS file handle by path</span>
<span class="cm"> *</span>
<span class="cm"> * On input, the buffer contains a &#39;\n&#39;-terminated C string comprised of</span>
<span class="cm"> * three alphanumeric words separated by whitespace.  The string may</span>
<span class="cm"> * contain escape sequences.</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:</span>
<span class="cm"> *				domain:		client domain name</span>
<span class="cm"> *				path:		export pathname</span>
<span class="cm"> *				maxsize:	numeric maximum size of</span>
<span class="cm"> *						@buf</span>
<span class="cm"> *			size:	length of C string in @buf</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	passed-in buffer filled with &#39;\n&#39;-terminated C</span>
<span class="cm"> *			string containing a ASCII hex text version</span>
<span class="cm"> *			of the NFS file handle;</span>
<span class="cm"> *			return code is the size in bytes of the string</span>
<span class="cm"> *	On error:	return code is negative errno value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_filehandle</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">dname</span><span class="p">,</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">maxsize</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mesg</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">auth_domain</span> <span class="o">*</span><span class="n">dom</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">knfsd_fh</span> <span class="n">fh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dname</span> <span class="o">=</span> <span class="n">mesg</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">qword_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mesg</span><span class="p">,</span> <span class="n">dname</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	
	<span class="n">path</span> <span class="o">=</span> <span class="n">dname</span><span class="o">+</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">qword_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mesg</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mesg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maxsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">maxsize</span> <span class="o">&lt;</span> <span class="n">NFS_FHSIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxsize</span> <span class="o">&gt;</span> <span class="n">NFS3_FHSIZE</span><span class="p">)</span>
		<span class="n">maxsize</span> <span class="o">=</span> <span class="n">NFS3_FHSIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qword_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mesg</span><span class="p">,</span> <span class="n">mesg</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* we have all the words, they are in buf.. */</span>
	<span class="n">dom</span> <span class="o">=</span> <span class="n">unix_domain_find</span><span class="p">(</span><span class="n">dname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dom</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">exp_rootfh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">dom</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fh</span><span class="p">,</span>  <span class="n">maxsize</span><span class="p">);</span>
	<span class="n">auth_domain_put</span><span class="p">(</span><span class="n">dom</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	
	<span class="n">mesg</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">SIMPLE_TRANSACTION_LIMIT</span><span class="p">;</span>
	<span class="n">qword_addhex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mesg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fh</span><span class="p">.</span><span class="n">fh_base</span><span class="p">,</span> <span class="n">fh</span><span class="p">.</span><span class="n">fh_size</span><span class="p">);</span>
	<span class="n">mesg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mesg</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>	
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_threads - Start NFSD, or report the current number of running threads</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:		ignored</span>
<span class="cm"> *			size:		zero</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	passed-in buffer filled with &#39;\n&#39;-terminated C</span>
<span class="cm"> *			string numeric value representing the number of</span>
<span class="cm"> *			running NFSD threads;</span>
<span class="cm"> *			return code is the size in bytes of the string</span>
<span class="cm"> *	On error:	return code is zero</span>
<span class="cm"> *</span>
<span class="cm"> * OR</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:		C string containing an unsigned</span>
<span class="cm"> *					integer value representing the</span>
<span class="cm"> *					number of NFSD threads to start</span>
<span class="cm"> *			size:		non-zero length of C string in @buf</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	NFS service is started;</span>
<span class="cm"> *			passed-in buffer filled with &#39;\n&#39;-terminated C</span>
<span class="cm"> *			string numeric value representing the number of</span>
<span class="cm"> *			running NFSD threads;</span>
<span class="cm"> *			return code is the size in bytes of the string</span>
<span class="cm"> *	On error:	return code is zero or a negative errno value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_threads</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mesg</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">newthreads</span><span class="p">;</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mesg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newthreads</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newthreads</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">nfsd_svc</span><span class="p">(</span><span class="n">NFS_PORT</span><span class="p">,</span> <span class="n">newthreads</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">nfsd_nrthreads</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">SIMPLE_TRANSACTION_LIMIT</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_pool_threads - Set or report the current number of threads per pool</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:		ignored</span>
<span class="cm"> *			size:		zero</span>
<span class="cm"> *</span>
<span class="cm"> * OR</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> * 			buf:		C string containing whitespace-</span>
<span class="cm"> * 					separated unsigned integer values</span>
<span class="cm"> *					representing the number of NFSD</span>
<span class="cm"> *					threads to start in each pool</span>
<span class="cm"> *			size:		non-zero length of C string in @buf</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	passed-in buffer filled with &#39;\n&#39;-terminated C</span>
<span class="cm"> *			string containing integer values representing the</span>
<span class="cm"> *			number of NFSD threads in each pool;</span>
<span class="cm"> *			return code is the size in bytes of the string</span>
<span class="cm"> *	On error:	return code is zero or a negative errno value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_pool_threads</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* if size &gt; 0, look for an array of number of threads per node</span>
<span class="cm">	 * and apply them  then write out number of threads per node as reply</span>
<span class="cm">	 */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mesg</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">npools</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">nthreads</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="n">npools</span> <span class="o">=</span> <span class="n">nfsd_nrpools</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">npools</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * NFS is shut down.  The admin can start it by</span>
<span class="cm">		 * writing to the threads file but NOT the pool_threads</span>
<span class="cm">		 * file, sorry.  Report zero threads.</span>
<span class="cm">		 */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">nthreads</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">npools</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nthreads</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npools</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mesg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nthreads</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>		<span class="cm">/* fewer numbers than pools */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>	<span class="cm">/* syntax error */</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nthreads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">nfsd_set_nrthreads</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nthreads</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">nfsd_get_nrthreads</span><span class="p">(</span><span class="n">npools</span><span class="p">,</span> <span class="n">nthreads</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">mesg</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">SIMPLE_TRANSACTION_LIMIT</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npools</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">mesg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;%d%c&quot;</span><span class="p">,</span> <span class="n">nthreads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">npools</span><span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="sc">&#39;\n&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">));</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">mesg</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">mesg</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">mesg</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">nthreads</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__write_versions</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mesg</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">vers</span><span class="p">,</span> <span class="o">*</span><span class="n">minorp</span><span class="p">,</span> <span class="n">sign</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">remaining</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">minor</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">tlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span><span class="p">)</span>
			<span class="cm">/* Cannot change versions without updating</span>
<span class="cm">			 * nfsd_serv-&gt;sv_xdrsize, and reallocing</span>
<span class="cm">			 * rq_argp and rq_resp</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">vers</span> <span class="o">=</span> <span class="n">mesg</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">qword_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mesg</span><span class="p">,</span> <span class="n">vers</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">sign</span> <span class="o">=</span> <span class="o">*</span><span class="n">vers</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sign</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span> <span class="o">||</span> <span class="n">sign</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span>
				<span class="n">num</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">((</span><span class="n">vers</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">minorp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">num</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="n">vers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">minorp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">minorp</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="n">minor</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">minorp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">minor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_minorversion</span><span class="p">(</span><span class="n">minor</span><span class="p">,</span> <span class="n">sign</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span> <span class="o">?</span>
						     <span class="n">NFSD_CLEAR</span> <span class="o">:</span> <span class="n">NFSD_SET</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">switch</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">2</span>:
			<span class="k">case</span> <span class="mi">3</span>:
			<span class="k">case</span> <span class="mi">4</span>:
				<span class="n">nfsd_vers</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span> <span class="o">?</span> <span class="n">NFSD_CLEAR</span> <span class="o">:</span> <span class="n">NFSD_SET</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="nl">next:</span>
			<span class="n">vers</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">qword_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mesg</span><span class="p">,</span> <span class="n">vers</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* If all get turned off, turn them back on, as</span>
<span class="cm">		 * having no versions is BAD</span>
<span class="cm">		 */</span>
		<span class="n">nfsd_reset_versions</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Now write current state into reply buffer */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sep</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="n">remaining</span> <span class="o">=</span> <span class="n">SIMPLE_TRANSACTION_LIMIT</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">num</span><span class="o">=</span><span class="mi">2</span> <span class="p">;</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">4</span> <span class="p">;</span> <span class="n">num</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_vers</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">NFSD_AVAIL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="s">&quot;%s%c%d&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span>
				       <span class="n">nfsd_vers</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">NFSD_TEST</span><span class="p">)</span><span class="o">?</span><span class="sc">&#39;+&#39;</span><span class="o">:</span><span class="sc">&#39;-&#39;</span><span class="p">,</span>
				       <span class="n">num</span><span class="p">);</span>
			<span class="n">sep</span> <span class="o">=</span> <span class="s">&quot; &quot;</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">remaining</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">remaining</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">tlen</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_vers</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">NFSD_AVAIL</span><span class="p">))</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">minor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">minor</span> <span class="o">&lt;=</span> <span class="n">NFSD_SUPPORTED_MINOR_VERSION</span><span class="p">;</span>
		     <span class="n">minor</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="s">&quot; %c4.%u&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="n">nfsd_vers</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">NFSD_TEST</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					 <span class="n">nfsd_minorversion</span><span class="p">(</span><span class="n">minor</span><span class="p">,</span> <span class="n">NFSD_TEST</span><span class="p">))</span> <span class="o">?</span>
						<span class="sc">&#39;+&#39;</span> <span class="o">:</span> <span class="sc">&#39;-&#39;</span><span class="p">,</span>
					<span class="n">minor</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">remaining</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">remaining</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">tlen</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">remaining</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tlen</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_versions - Set or report the available NFS protocol versions</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:		ignored</span>
<span class="cm"> *			size:		zero</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	passed-in buffer filled with &#39;\n&#39;-terminated C</span>
<span class="cm"> *			string containing positive or negative integer</span>
<span class="cm"> *			values representing the current status of each</span>
<span class="cm"> *			protocol version;</span>
<span class="cm"> *			return code is the size in bytes of the string</span>
<span class="cm"> *	On error:	return code is zero or a negative errno value</span>
<span class="cm"> *</span>
<span class="cm"> * OR</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> * 			buf:		C string containing whitespace-</span>
<span class="cm"> * 					separated positive or negative</span>
<span class="cm"> * 					integer values representing NFS</span>
<span class="cm"> * 					protocol versions to enable (&quot;+n&quot;)</span>
<span class="cm"> * 					or disable (&quot;-n&quot;)</span>
<span class="cm"> *			size:		non-zero length of C string in @buf</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	status of zero or more protocol versions has</span>
<span class="cm"> *			been updated; passed-in buffer filled with</span>
<span class="cm"> *			&#39;\n&#39;-terminated C string containing positive</span>
<span class="cm"> *			or negative integer values representing the</span>
<span class="cm"> *			current status of each protocol version;</span>
<span class="cm"> *			return code is the size in bytes of the string</span>
<span class="cm"> *	On error:	return code is zero or a negative errno value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_versions</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">rv</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">__write_versions</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Zero-length write.  Return a list of NFSD&#39;s current listener</span>
<span class="cm"> * transports.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__write_ports_names</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">svc_xprt_names</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">SIMPLE_TRANSACTION_LIMIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A single &#39;fd&#39; number was written, in which case it must be for</span>
<span class="cm"> * a socket of a supported family/protocol, and we use it as an</span>
<span class="cm"> * nfsd listener.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__write_ports_addfd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mesg</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mesg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_create_serv</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">svc_addsock</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">SIMPLE_TRANSACTION_LIMIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">svc_shutdown_net</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
		<span class="n">svc_destroy</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Decrease the count, but don&#39;t shut down the service */</span>
	<span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span><span class="o">--</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A &#39;-&#39; followed by the &#39;name&#39; of a socket means we close the socket.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__write_ports_delfd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">toclose</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">toclose</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">toclose</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">svc_sock_names</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
					<span class="n">SIMPLE_TRANSACTION_LIMIT</span><span class="p">,</span> <span class="n">toclose</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">toclose</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A transport listener is added by writing it&#39;s transport name and</span>
<span class="cm"> * a port number.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__write_ports_addxprt</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">transport</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%15s %4u&quot;</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">port</span> <span class="o">&gt;</span> <span class="n">USHRT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfsd_create_serv</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">svc_create_xprt</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span>
				<span class="n">PF_INET</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">SVC_SOCK_ANONYMOUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">svc_create_xprt</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span>
				<span class="n">PF_INET6</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">SVC_SOCK_ANONYMOUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_close</span><span class="p">;</span>

	<span class="cm">/* Decrease the count, but don&#39;t shut down the service */</span>
	<span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span><span class="o">--</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_close:</span>
	<span class="n">xprt</span> <span class="o">=</span> <span class="n">svc_find_xprt</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">svc_close_xprt</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
		<span class="n">svc_xprt_put</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_err:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span><span class="o">-&gt;</span><span class="n">sv_nrthreads</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">svc_shutdown_net</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
	<span class="n">svc_destroy</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A transport listener is removed by writing a &quot;-&quot;, it&#39;s transport</span>
<span class="cm"> * name, and it&#39;s port number.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__write_ports_delxprt</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">xprt</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">transport</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;%15s %4u&quot;</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">port</span> <span class="o">&gt;</span> <span class="n">USHRT_MAX</span> <span class="o">||</span> <span class="n">nfsd_serv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">xprt</span> <span class="o">=</span> <span class="n">svc_find_xprt</span><span class="p">(</span><span class="n">nfsd_serv</span><span class="p">,</span> <span class="n">transport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">AF_UNSPEC</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xprt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="n">svc_close_xprt</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="n">svc_xprt_put</span><span class="p">(</span><span class="n">xprt</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__write_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__write_ports_names</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">return</span> <span class="n">__write_ports_addfd</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">isdigit</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="k">return</span> <span class="n">__write_ports_delfd</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isalpha</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">return</span> <span class="n">__write_ports_addxprt</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">isalpha</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="k">return</span> <span class="n">__write_ports_delxprt</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_ports - Pass a socket file descriptor or transport name to listen on</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:		ignored</span>
<span class="cm"> *			size:		zero</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	passed-in buffer filled with a &#39;\n&#39;-terminated C</span>
<span class="cm"> *			string containing a whitespace-separated list of</span>
<span class="cm"> *			named NFSD listeners;</span>
<span class="cm"> *			return code is the size in bytes of the string</span>
<span class="cm"> *	On error:	return code is zero or a negative errno value</span>
<span class="cm"> *</span>
<span class="cm"> * OR</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:		C string containing an unsigned</span>
<span class="cm"> *					integer value representing a bound</span>
<span class="cm"> *					but unconnected socket that is to be</span>
<span class="cm"> *					used as an NFSD listener; listen(3)</span>
<span class="cm"> *					must be called for a SOCK_STREAM</span>
<span class="cm"> *					socket, otherwise it is ignored</span>
<span class="cm"> *			size:		non-zero length of C string in @buf</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	NFS service is started;</span>
<span class="cm"> *			passed-in buffer filled with a &#39;\n&#39;-terminated C</span>
<span class="cm"> *			string containing a unique alphanumeric name of</span>
<span class="cm"> *			the listener;</span>
<span class="cm"> *			return code is the size in bytes of the string</span>
<span class="cm"> *	On error:	return code is a negative errno value</span>
<span class="cm"> *</span>
<span class="cm"> * OR</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:		C string containing a &quot;-&quot; followed</span>
<span class="cm"> *					by an integer value representing a</span>
<span class="cm"> *					previously passed in socket file</span>
<span class="cm"> *					descriptor</span>
<span class="cm"> *			size:		non-zero length of C string in @buf</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	NFS service no longer listens on that socket;</span>
<span class="cm"> *			passed-in buffer filled with a &#39;\n&#39;-terminated C</span>
<span class="cm"> *			string containing a unique name of the listener;</span>
<span class="cm"> *			return code is the size in bytes of the string</span>
<span class="cm"> *	On error:	return code is a negative errno value</span>
<span class="cm"> *</span>
<span class="cm"> * OR</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:		C string containing a transport</span>
<span class="cm"> *					name and an unsigned integer value</span>
<span class="cm"> *					representing the port to listen on,</span>
<span class="cm"> *					separated by whitespace</span>
<span class="cm"> *			size:		non-zero length of C string in @buf</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	returns zero; NFS service is started</span>
<span class="cm"> *	On error:	return code is a negative errno value</span>
<span class="cm"> *</span>
<span class="cm"> * OR</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:		C string containing a &quot;-&quot; followed</span>
<span class="cm"> *					by a transport name and an unsigned</span>
<span class="cm"> *					integer value representing the port</span>
<span class="cm"> *					to listen on, separated by whitespace</span>
<span class="cm"> *			size:		non-zero length of C string in @buf</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	returns zero; NFS service no longer listens</span>
<span class="cm"> *			on that transport</span>
<span class="cm"> *	On error:	return code is a negative errno value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">rv</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">__write_ports</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">nfsd_max_blksize</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * write_maxblksize - Set or report the current NFS blksize</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:		ignored</span>
<span class="cm"> *			size:		zero</span>
<span class="cm"> *</span>
<span class="cm"> * OR</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> * 			buf:		C string containing an unsigned</span>
<span class="cm"> * 					integer value representing the new</span>
<span class="cm"> * 					NFS blksize</span>
<span class="cm"> *			size:		non-zero length of C string in @buf</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	passed-in buffer filled with &#39;\n&#39;-terminated C string</span>
<span class="cm"> *			containing numeric value of the current NFS blksize</span>
<span class="cm"> *			setting;</span>
<span class="cm"> *			return code is the size in bytes of the string</span>
<span class="cm"> *	On error:	return code is zero or a negative errno value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_maxblksize</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mesg</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">bsize</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mesg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bsize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
		<span class="cm">/* force bsize into allowed range and</span>
<span class="cm">		 * required alignment.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bsize</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">)</span>
			<span class="n">bsize</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bsize</span> <span class="o">&gt;</span> <span class="n">NFSSVC_MAXBLKSIZE</span><span class="p">)</span>
			<span class="n">bsize</span> <span class="o">=</span> <span class="n">NFSSVC_MAXBLKSIZE</span><span class="p">;</span>
		<span class="n">bsize</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1024</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nfsd_max_blksize</span> <span class="o">=</span> <span class="n">bsize</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">SIMPLE_TRANSACTION_LIMIT</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">nfsd_max_blksize</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NFSD_V4</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__nfsd4_write_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">time_t</span> <span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mesg</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mesg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some sanity checking.  We don&#39;t have a reason for</span>
<span class="cm">		 * these particular numbers, but problems with the</span>
<span class="cm">		 * extremes are:</span>
<span class="cm">		 *	- Too short: the briefest network outage may</span>
<span class="cm">		 *	  cause clients to lose all their locks.  Also,</span>
<span class="cm">		 *	  the frequent polling may be wasteful.</span>
<span class="cm">		 *	- Too long: do you really want reboot recovery</span>
<span class="cm">		 *	  to take more than an hour?  Or to make other</span>
<span class="cm">		 *	  clients wait an hour before being able to</span>
<span class="cm">		 *	  revoke a dead client&#39;s locks?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">3600</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">time</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">SIMPLE_TRANSACTION_LIMIT</span><span class="p">,</span> <span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">time</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nfsd4_write_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">time_t</span> <span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">rv</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">__nfsd4_write_time</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_leasetime - Set or report the current NFSv4 lease time</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:		ignored</span>
<span class="cm"> *			size:		zero</span>
<span class="cm"> *</span>
<span class="cm"> * OR</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:		C string containing an unsigned</span>
<span class="cm"> *					integer value representing the new</span>
<span class="cm"> *					NFSv4 lease expiry time</span>
<span class="cm"> *			size:		non-zero length of C string in @buf</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	passed-in buffer filled with &#39;\n&#39;-terminated C</span>
<span class="cm"> *			string containing unsigned integer value of the</span>
<span class="cm"> *			current lease expiry time;</span>
<span class="cm"> *			return code is the size in bytes of the string</span>
<span class="cm"> *	On error:	return code is zero or a negative errno value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_leasetime</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nfsd4_write_time</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsd4_lease</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_gracetime - Set or report current NFSv4 grace period time</span>
<span class="cm"> *</span>
<span class="cm"> * As above, but sets the time of the NFSv4 grace period.</span>
<span class="cm"> *</span>
<span class="cm"> * Note this should never be set to less than the *previous*</span>
<span class="cm"> * lease-period time, but we don&#39;t try to enforce this.  (In the common</span>
<span class="cm"> * case (a new boot), we don&#39;t know what the previous lease time was</span>
<span class="cm"> * anyway.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_gracetime</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nfsd4_write_time</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsd4_grace</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">nfs4_recoverydir</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__write_recoverydir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mesg</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">recdir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfsd_serv</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PATH_MAX</span> <span class="o">||</span> <span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">recdir</span> <span class="o">=</span> <span class="n">mesg</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">qword_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mesg</span><span class="p">,</span> <span class="n">recdir</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">nfs4_reset_recoverydir</span><span class="p">(</span><span class="n">recdir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">SIMPLE_TRANSACTION_LIMIT</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">nfs4_recoverydir</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_recoverydir - Set or report the pathname of the recovery directory</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:		ignored</span>
<span class="cm"> *			size:		zero</span>
<span class="cm"> *</span>
<span class="cm"> * OR</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *			buf:		C string containing the pathname</span>
<span class="cm"> *					of the directory on a local file</span>
<span class="cm"> *					system containing permanent NFSv4</span>
<span class="cm"> *					recovery data</span>
<span class="cm"> *			size:		non-zero length of C string in @buf</span>
<span class="cm"> * Output:</span>
<span class="cm"> *	On success:	passed-in buffer filled with &#39;\n&#39;-terminated C string</span>
<span class="cm"> *			containing the current recovery pathname setting;</span>
<span class="cm"> *			return code is the size in bytes of the string</span>
<span class="cm"> *	On error:	return code is zero or a negative errno value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_recoverydir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">rv</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">__write_recoverydir</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*----------------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> *	populating the filesystem.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfsd_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">tree_descr</span> <span class="n">nfsd_files</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">NFSD_List</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;exports&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exports_operations</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">},</span>
		<span class="p">[</span><span class="n">NFSD_Export_features</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;export_features&quot;</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">export_features_operations</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">},</span>
		<span class="p">[</span><span class="n">NFSD_FO_UnlockIP</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;unlock_ip&quot;</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">transaction_ops</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">NFSD_FO_UnlockFS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;unlock_filesystem&quot;</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">transaction_ops</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">NFSD_Fh</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;filehandle&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transaction_ops</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">NFSD_Threads</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;threads&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transaction_ops</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">NFSD_Pool_Threads</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;pool_threads&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transaction_ops</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">NFSD_Pool_Stats</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;pool_stats&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool_stats_operations</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">},</span>
		<span class="p">[</span><span class="n">NFSD_Versions</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;versions&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transaction_ops</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">NFSD_Ports</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;portlist&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transaction_ops</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUGO</span><span class="p">},</span>
		<span class="p">[</span><span class="n">NFSD_MaxBlkSize</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;max_block_size&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transaction_ops</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUGO</span><span class="p">},</span>
<span class="cp">#if defined(CONFIG_SUNRPC_GSS) || defined(CONFIG_SUNRPC_GSS_MODULE)</span>
		<span class="p">[</span><span class="n">NFSD_SupportedEnctypes</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;supported_krb5_enctypes&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">supported_enctypes_ops</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">},</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SUNRPC_GSS or CONFIG_SUNRPC_GSS_MODULE */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_NFSD_V4</span>
		<span class="p">[</span><span class="n">NFSD_Leasetime</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;nfsv4leasetime&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transaction_ops</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">NFSD_Gracetime</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;nfsv4gracetime&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transaction_ops</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="p">},</span>
		<span class="p">[</span><span class="n">NFSD_RecoveryDir</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;nfsv4recoverydir&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transaction_ops</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUSR</span><span class="p">},</span>
<span class="cp">#endif</span>
		<span class="cm">/* last one */</span> <span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">}</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="n">simple_fill_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mh">0x6e667364</span><span class="p">,</span> <span class="n">nfsd_files</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">nfsd_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mount_single</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">nfsd_fill_super</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">nfsd_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;nfsd&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span>		<span class="o">=</span> <span class="n">nfsd_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span>	<span class="o">=</span> <span class="n">kill_litter_super</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_proc_exports_entry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="s">&quot;fs/nfs&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;exports&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exports_operations</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_proc_exports_entry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">nfsd_net_id</span><span class="p">;</span>

<span class="k">static</span> <span class="n">__net_init</span> <span class="kt">int</span> <span class="nf">nfsd_init_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">nfsd_export_init</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_export_error</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">nfsd_idmap_init</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_idmap_error</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_idmap_error:</span>
	<span class="n">nfsd_export_shutdown</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="nl">out_export_error:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__net_exit</span> <span class="kt">void</span> <span class="nf">nfsd_exit_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nfsd_idmap_shutdown</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">nfsd_export_shutdown</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="n">nfsd_net_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">nfsd_init_net</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exit</span> <span class="o">=</span> <span class="n">nfsd_exit_net</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsd_net_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfsd_net</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_nfsd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Installing knfsd (copyright (C) 1996 okir@monad.swb.de).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">register_cld_notifier</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">register_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_net_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unregister_notifier</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">nfsd4_init_slabs</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unregister_pernet</span><span class="p">;</span>
	<span class="n">nfs4_state_init</span><span class="p">();</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">nfsd_fault_inject_init</span><span class="p">();</span> <span class="cm">/* nfsd fault injection controls */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_slabs</span><span class="p">;</span>
	<span class="n">nfsd_stat_init</span><span class="p">();</span>	<span class="cm">/* Statistics */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">nfsd_reply_cache_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_stat</span><span class="p">;</span>
	<span class="n">nfsd_lockd_init</span><span class="p">();</span>	<span class="cm">/* lockd-&gt;nfsd callbacks */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">create_proc_exports_entry</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_lockd</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_all</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_free_all:</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;fs/nfs/exports&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;fs/nfs&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">out_free_lockd:</span>
	<span class="n">nfsd_lockd_shutdown</span><span class="p">();</span>
	<span class="n">nfsd_reply_cache_shutdown</span><span class="p">();</span>
<span class="nl">out_free_stat:</span>
	<span class="n">nfsd_stat_shutdown</span><span class="p">();</span>
	<span class="n">nfsd_fault_inject_cleanup</span><span class="p">();</span>
<span class="nl">out_free_slabs:</span>
	<span class="n">nfsd4_free_slabs</span><span class="p">();</span>
<span class="nl">out_unregister_pernet:</span>
	<span class="n">unregister_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_net_ops</span><span class="p">);</span>
<span class="nl">out_unregister_notifier:</span>
	<span class="n">unregister_cld_notifier</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">exit_nfsd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nfsd_reply_cache_shutdown</span><span class="p">();</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;fs/nfs/exports&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;fs/nfs&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">nfsd_stat_shutdown</span><span class="p">();</span>
	<span class="n">nfsd_lockd_shutdown</span><span class="p">();</span>
	<span class="n">nfsd4_free_slabs</span><span class="p">();</span>
	<span class="n">nfsd_fault_inject_cleanup</span><span class="p">();</span>
	<span class="n">unregister_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_fs_type</span><span class="p">);</span>
	<span class="n">unregister_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsd_net_ops</span><span class="p">);</span>
	<span class="n">unregister_cld_notifier</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Olaf Kirch &lt;okir@monad.swb.de&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">init_nfsd</span><span class="p">)</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">exit_nfsd</span><span class="p">)</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
