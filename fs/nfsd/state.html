<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nfsd › state.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>state.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Copyright (c) 2001 The Regents of the University of Michigan.</span>
<span class="cm"> *  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  Kendrick Smith &lt;kmsmith@umich.edu&gt;</span>
<span class="cm"> *  Andy Adamson &lt;andros@umich.edu&gt;</span>
<span class="cm"> *  </span>
<span class="cm"> *  Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> *  modification, are permitted provided that the following conditions</span>
<span class="cm"> *  are met:</span>
<span class="cm"> *  </span>
<span class="cm"> *  1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *  2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *     documentation and/or other materials provided with the distribution.</span>
<span class="cm"> *  3. Neither the name of the University nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> *  THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED</span>
<span class="cm"> *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<span class="cm"> *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="cm"> *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</span>
<span class="cm"> *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="cm"> *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="cm"> *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR</span>
<span class="cm"> *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<span class="cm"> *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="cm"> *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="cm"> *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _NFSD4_STATE_H</span>
<span class="cp">#define _NFSD4_STATE_H</span>

<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/svc_xprt.h&gt;</span>
<span class="cp">#include &lt;linux/nfsd/nfsfh.h&gt;</span>
<span class="cp">#include &quot;nfsfh.h&quot;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u32</span>             <span class="n">cl_boot</span><span class="p">;</span>
	<span class="n">u32</span>             <span class="n">cl_id</span><span class="p">;</span>
<span class="p">}</span> <span class="n">clientid_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">clientid_t</span>	<span class="n">so_clid</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">so_id</span><span class="p">;</span>
<span class="p">}</span> <span class="n">stateid_opaque_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">u32</span>                     <span class="n">si_generation</span><span class="p">;</span>
	<span class="n">stateid_opaque_t</span>        <span class="n">si_opaque</span><span class="p">;</span>
<span class="p">}</span> <span class="n">stateid_t</span><span class="p">;</span>

<span class="cp">#define STATEID_FMT	&quot;(%08x/%08x/%08x/%08x)&quot;</span>
<span class="cp">#define STATEID_VAL(s) \</span>
<span class="cp">	(s)-&gt;si_opaque.so_clid.cl_boot, \</span>
<span class="cp">	(s)-&gt;si_opaque.so_clid.cl_id, \</span>
<span class="cp">	(s)-&gt;si_opaque.so_id, \</span>
<span class="cp">	(s)-&gt;si_generation</span>

<span class="k">struct</span> <span class="n">nfsd4_callback</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cb_op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">cb_clp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cb_per_client</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cb_minorversion</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_message</span> <span class="n">cb_msg</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_call_ops</span> <span class="o">*</span><span class="n">cb_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">cb_work</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cb_done</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nfs4_stid</span> <span class="p">{</span>
<span class="cp">#define NFS4_OPEN_STID 1</span>
<span class="cp">#define NFS4_LOCK_STID 2</span>
<span class="cp">#define NFS4_DELEG_STID 4</span>
<span class="cm">/* For an open stateid kept around *only* to process close replays: */</span>
<span class="cp">#define NFS4_CLOSED_STID 8</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sc_type</span><span class="p">;</span>
	<span class="n">stateid_t</span> <span class="n">sc_stateid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">sc_client</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nfs4_delegation</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs4_stid</span>	<span class="n">dl_stid</span><span class="p">;</span> <span class="cm">/* must be first field */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">dl_perfile</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">dl_perclnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">dl_recall_lru</span><span class="p">;</span>  <span class="cm">/* delegation recalled */</span>
	<span class="n">atomic_t</span>		<span class="n">dl_count</span><span class="p">;</span>       <span class="cm">/* ref count */</span>
	<span class="k">struct</span> <span class="n">nfs4_file</span>	<span class="o">*</span><span class="n">dl_file</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">dl_type</span><span class="p">;</span>
	<span class="kt">time_t</span>			<span class="n">dl_time</span><span class="p">;</span>
<span class="cm">/* For recall: */</span>
	<span class="k">struct</span> <span class="n">knfsd_fh</span>		<span class="n">dl_fh</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">dl_retries</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd4_callback</span>	<span class="n">dl_recall</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* client delegation callback info */</span>
<span class="k">struct</span> <span class="n">nfs4_cb_conn</span> <span class="p">{</span>
	<span class="cm">/* SETCLIENTID info */</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">cb_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">cb_saddr</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">cb_addrlen</span><span class="p">;</span>
	<span class="n">u32</span>                     <span class="n">cb_prog</span><span class="p">;</span> <span class="cm">/* used only in 4.0 case;</span>
<span class="cm">					    per-session otherwise */</span>
	<span class="n">u32</span>                     <span class="n">cb_ident</span><span class="p">;</span>	<span class="cm">/* minorversion 0 only */</span>
	<span class="k">struct</span> <span class="n">svc_xprt</span>		<span class="o">*</span><span class="n">cb_xprt</span><span class="p">;</span>	<span class="cm">/* minorversion 1 only */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nfs4_delegation</span> <span class="o">*</span><span class="nf">delegstateid</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_stid</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_delegation</span><span class="p">,</span> <span class="n">dl_stid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Maximum number of slots per session. 160 is useful for long haul TCP */</span>
<span class="cp">#define NFSD_MAX_SLOTS_PER_SESSION     160</span>
<span class="cm">/* Maximum number of operations per session compound */</span>
<span class="cp">#define NFSD_MAX_OPS_PER_COMPOUND	16</span>
<span class="cm">/* Maximum  session per slot cache size */</span>
<span class="cp">#define NFSD_SLOT_CACHE_SIZE		1024</span>
<span class="cm">/* Maximum number of NFSD_SLOT_CACHE_SIZE slots per session */</span>
<span class="cp">#define NFSD_CACHE_SIZE_SLOTS_PER_SESSION	32</span>
<span class="cp">#define NFSD_MAX_MEM_PER_SESSION  \</span>
<span class="cp">		(NFSD_CACHE_SIZE_SLOTS_PER_SESSION * NFSD_SLOT_CACHE_SIZE)</span>

<span class="k">struct</span> <span class="n">nfsd4_slot</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">sl_seqid</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">sl_status</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">sl_datalen</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">sl_opcnt</span><span class="p">;</span>
<span class="cp">#define NFSD4_SLOT_INUSE	(1 &lt;&lt; 0)</span>
<span class="cp">#define NFSD4_SLOT_CACHETHIS	(1 &lt;&lt; 1)</span>
<span class="cp">#define NFSD4_SLOT_INITIALIZED	(1 &lt;&lt; 2)</span>
	<span class="n">u8</span>	<span class="n">sl_flags</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">sl_data</span><span class="p">[];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nfsd4_channel_attrs</span> <span class="p">{</span>
	<span class="n">u32</span>		<span class="n">headerpadsz</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">maxreq_sz</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">maxresp_sz</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">maxresp_cached</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">maxops</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">maxreqs</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">nr_rdma_attrs</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">rdma_attrs</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nfsd4_create_session</span> <span class="p">{</span>
	<span class="n">clientid_t</span>			<span class="n">clientid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_sessionid</span>		<span class="n">sessionid</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">seqid</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd4_channel_attrs</span>	<span class="n">fore_channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd4_channel_attrs</span>	<span class="n">back_channel</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">callback_prog</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">uid</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">gid</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nfsd4_bind_conn_to_session</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs4_sessionid</span>		<span class="n">sessionid</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">dir</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The single slot clientid cache structure */</span>
<span class="k">struct</span> <span class="n">nfsd4_clid_slot</span> <span class="p">{</span>
	<span class="n">u32</span>				<span class="n">sl_seqid</span><span class="p">;</span>
	<span class="n">__be32</span>				<span class="n">sl_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd4_create_session</span>	<span class="n">sl_cr_ses</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nfsd4_conn</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cn_persession</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_xprt</span> <span class="o">*</span><span class="n">cn_xprt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">svc_xpt_user</span> <span class="n">cn_xpt_user</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd4_session</span> <span class="o">*</span><span class="n">cn_session</span><span class="p">;</span>
<span class="cm">/* CDFC4_FORE, CDFC4_BACK: */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cn_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nfsd4_session</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">se_ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">se_hash</span><span class="p">;</span>	<span class="cm">/* hash by sessionid */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">se_perclnt</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">se_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_client</span>	<span class="o">*</span><span class="n">se_client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_sessionid</span>	<span class="n">se_sessionid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd4_channel_attrs</span> <span class="n">se_fchannel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd4_channel_attrs</span> <span class="n">se_bchannel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">se_conns</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">se_cb_prog</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">se_cb_seq_nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd4_slot</span>	<span class="o">*</span><span class="n">se_slots</span><span class="p">[];</span>	<span class="cm">/* forward channel slots */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfsd4_put_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfsd4_session</span> <span class="o">*</span><span class="n">ses</span><span class="p">);</span>

<span class="cm">/* formatted contents of nfs4_sessionid */</span>
<span class="k">struct</span> <span class="n">nfsd4_sessionid</span> <span class="p">{</span>
	<span class="n">clientid_t</span>	<span class="n">clientid</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">sequence</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">reserved</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define HEXDIR_LEN     33 </span><span class="cm">/* hex version of 16 byte md5 of cl_name plus &#39;\0&#39; */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * struct nfs4_client - one per client.  Clientids live here.</span>
<span class="cm"> * 	o Each nfs4_client is hashed by clientid.</span>
<span class="cm"> *</span>
<span class="cm"> * 	o Each nfs4_clients is also hashed by name </span>
<span class="cm"> * 	  (the opaque quantity initially sent by the client to identify itself).</span>
<span class="cm"> * 	  </span>
<span class="cm"> *	o cl_perclient list is used to ensure no dangling stateowner references</span>
<span class="cm"> *	  when we expire the nfs4_client</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nfs4_client</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cl_idhash</span><span class="p">;</span> 	<span class="cm">/* hash by cl_clientid.id */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cl_strhash</span><span class="p">;</span> 	<span class="cm">/* hash by cl_name */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cl_openowners</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr</span>		<span class="n">cl_stateids</span><span class="p">;</span>	<span class="cm">/* stateid lookup */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cl_delegations</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>        <span class="n">cl_lru</span><span class="p">;</span>         <span class="cm">/* tail queue */</span>
	<span class="k">struct</span> <span class="n">xdr_netobj</span>	<span class="n">cl_name</span><span class="p">;</span> 	<span class="cm">/* id generated by client */</span>
	<span class="kt">char</span>                    <span class="n">cl_recdir</span><span class="p">[</span><span class="n">HEXDIR_LEN</span><span class="p">];</span> <span class="cm">/* recovery dir */</span>
	<span class="n">nfs4_verifier</span>		<span class="n">cl_verifier</span><span class="p">;</span> 	<span class="cm">/* generated by client */</span>
	<span class="kt">time_t</span>                  <span class="n">cl_time</span><span class="p">;</span>        <span class="cm">/* time of last lease renewal */</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">cl_addr</span><span class="p">;</span> 	<span class="cm">/* client ipaddress */</span>
	<span class="n">u32</span>			<span class="n">cl_flavor</span><span class="p">;</span>	<span class="cm">/* setclientid pseudoflavor */</span>
	<span class="k">struct</span> <span class="n">svc_cred</span>		<span class="n">cl_cred</span><span class="p">;</span> 	<span class="cm">/* setclientid principal */</span>
	<span class="n">clientid_t</span>		<span class="n">cl_clientid</span><span class="p">;</span>	<span class="cm">/* generated by server */</span>
	<span class="n">nfs4_verifier</span>		<span class="n">cl_confirm</span><span class="p">;</span>	<span class="cm">/* generated by server */</span>
	<span class="n">u32</span>			<span class="n">cl_minorversion</span><span class="p">;</span>

	<span class="cm">/* for v4.0 and v4.1 callbacks: */</span>
	<span class="k">struct</span> <span class="n">nfs4_cb_conn</span>	<span class="n">cl_cb_conn</span><span class="p">;</span>
<span class="cp">#define NFSD4_CLIENT_CB_UPDATE		(0)</span>
<span class="cp">#define NFSD4_CLIENT_CB_KILL		(1)</span>
<span class="cp">#define NFSD4_CLIENT_STABLE		(2)	</span><span class="cm">/* client on stable storage */</span><span class="cp"></span>
<span class="cp">#define NFSD4_CLIENT_RECLAIM_COMPLETE	(3)	</span><span class="cm">/* reclaim_complete done */</span><span class="cp"></span>
<span class="cp">#define NFSD4_CLIENT_CB_FLAG_MASK	(1 &lt;&lt; NFSD4_CLIENT_CB_UPDATE | \</span>
<span class="cp">					 1 &lt;&lt; NFSD4_CLIENT_CB_KILL)</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">cl_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span>		<span class="o">*</span><span class="n">cl_cb_client</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">cl_cb_ident</span><span class="p">;</span>
<span class="cp">#define NFSD4_CB_UP		0</span>
<span class="cp">#define NFSD4_CB_UNKNOWN	1</span>
<span class="cp">#define NFSD4_CB_DOWN		2</span>
<span class="cp">#define NFSD4_CB_FAULT		3</span>
	<span class="kt">int</span>			<span class="n">cl_cb_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd4_callback</span>	<span class="n">cl_cb_null</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd4_session</span>	<span class="o">*</span><span class="n">cl_cb_session</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cl_callbacks</span><span class="p">;</span> <span class="cm">/* list of in-progress callbacks */</span>

	<span class="cm">/* for all client information that callback code might need: */</span>
	<span class="n">spinlock_t</span>		<span class="n">cl_lock</span><span class="p">;</span>

	<span class="cm">/* for nfs41 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cl_sessions</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfsd4_clid_slot</span>	<span class="n">cl_cs_slot</span><span class="p">;</span>	<span class="cm">/* create_session slot */</span>
	<span class="n">u32</span>			<span class="n">cl_exchange_flags</span><span class="p">;</span>
	<span class="cm">/* number of rpc&#39;s in progress over an associated session: */</span>
	<span class="n">atomic_t</span>		<span class="n">cl_refcount</span><span class="p">;</span>

	<span class="cm">/* for nfs41 callbacks */</span>
	<span class="cm">/* We currently support a single back channel with a single slot */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">cl_cb_slot_busy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_wait_queue</span>	<span class="n">cl_cb_waitq</span><span class="p">;</span>	<span class="cm">/* backchannel callers may */</span>
						<span class="cm">/* wait here for slots */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">mark_client_expired</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">is_client_expired</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* struct nfs4_client_reset</span>
<span class="cm"> * one per old client. Populates reset_str_hashtbl. Filled from conf_id_hashtbl</span>
<span class="cm"> * upon lease reset, or from upcall to state_daemon (to read in state</span>
<span class="cm"> * from non-volitile storage) upon reboot.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nfs4_client_reclaim</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cr_strhash</span><span class="p">;</span>	<span class="cm">/* hash by cr_name */</span>
	<span class="kt">char</span>			<span class="n">cr_recdir</span><span class="p">[</span><span class="n">HEXDIR_LEN</span><span class="p">];</span> <span class="cm">/* recover dir */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">update_stateid</span><span class="p">(</span><span class="n">stateid_t</span> <span class="o">*</span><span class="n">stateid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">stateid</span><span class="o">-&gt;</span><span class="n">si_generation</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* Wraparound recommendation from 3530bis-13 9.1.3.2: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stateid</span><span class="o">-&gt;</span><span class="n">si_generation</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">stateid</span><span class="o">-&gt;</span><span class="n">si_generation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* A reasonable value for REPLAY_ISIZE was estimated as follows:  </span>
<span class="cm"> * The OPEN response, typically the largest, requires </span>
<span class="cm"> *   4(status) + 8(stateid) + 20(changeinfo) + 4(rflags) +  8(verifier) + </span>
<span class="cm"> *   4(deleg. type) + 8(deleg. stateid) + 4(deleg. recall flag) + </span>
<span class="cm"> *   20(deleg. space limit) + ~32(deleg. ace) = 112 bytes </span>
<span class="cm"> */</span>

<span class="cp">#define NFSD4_REPLAY_ISIZE       112 </span>

<span class="cm">/*</span>
<span class="cm"> * Replay buffer, where the result of the last seqid-mutating operation </span>
<span class="cm"> * is cached. </span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nfs4_replay</span> <span class="p">{</span>
	<span class="n">__be32</span>			<span class="n">rp_status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">rp_buflen</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">rp_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">knfsd_fh</span>		<span class="n">rp_openfh</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">rp_ibuf</span><span class="p">[</span><span class="n">NFSD4_REPLAY_ISIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nfs4_stateowner</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>        <span class="n">so_strhash</span><span class="p">;</span>   <span class="cm">/* hash by op_name */</span>
	<span class="k">struct</span> <span class="n">list_head</span>        <span class="n">so_stateids</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span>    <span class="n">so_client</span><span class="p">;</span>
	<span class="cm">/* after increment in ENCODE_SEQID_OP_TAIL, represents the next</span>
<span class="cm">	 * sequence id expected from the client: */</span>
	<span class="n">u32</span>                     <span class="n">so_seqid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xdr_netobj</span>       <span class="n">so_owner</span><span class="p">;</span>     <span class="cm">/* open owner name */</span>
	<span class="k">struct</span> <span class="n">nfs4_replay</span>	<span class="n">so_replay</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">so_is_open_owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nfs4_openowner</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs4_stateowner</span>	<span class="n">oo_owner</span><span class="p">;</span> <span class="cm">/* must be first field */</span>
	<span class="k">struct</span> <span class="n">list_head</span>        <span class="n">oo_perclient</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We keep around openowners a little while after last close,</span>
<span class="cm">	 * which saves clients from having to confirm, and allows us to</span>
<span class="cm">	 * handle close replays if they come soon enough.  The close_lru</span>
<span class="cm">	 * is a list of such openowners, to be reaped by the laundromat</span>
<span class="cm">	 * thread eventually if they remain unused:</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">oo_close_lru</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_ol_stateid</span> <span class="o">*</span><span class="n">oo_last_closed_stid</span><span class="p">;</span>
	<span class="kt">time_t</span>			<span class="n">oo_time</span><span class="p">;</span> <span class="cm">/* time of placement on so_close_lru */</span>
<span class="cp">#define NFS4_OO_CONFIRMED   1</span>
<span class="cp">#define NFS4_OO_PURGE_CLOSE 2</span>
<span class="cp">#define NFS4_OO_NEW         4</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">oo_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nfs4_lockowner</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs4_stateowner</span>	<span class="n">lo_owner</span><span class="p">;</span> <span class="cm">/* must be first element */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">lo_owner_ino_hash</span><span class="p">;</span> <span class="cm">/* hash by owner,file */</span>
	<span class="k">struct</span> <span class="n">list_head</span>        <span class="n">lo_perstateid</span><span class="p">;</span> <span class="cm">/* for lockowners only */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">lo_list</span><span class="p">;</span> <span class="cm">/* for temporary uses */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nfs4_openowner</span> <span class="o">*</span> <span class="nf">openowner</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_stateowner</span> <span class="o">*</span><span class="n">so</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">so</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_openowner</span><span class="p">,</span> <span class="n">oo_owner</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nfs4_lockowner</span> <span class="o">*</span> <span class="nf">lockowner</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_stateowner</span> <span class="o">*</span><span class="n">so</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">so</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_lockowner</span><span class="p">,</span> <span class="n">lo_owner</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">*  nfs4_file: a file opened by some number of (open) nfs4_stateowners.</span>
<span class="cm">*    o fi_perfile list is used to search for conflicting </span>
<span class="cm">*      share_acces, share_deny on the file.</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">nfs4_file</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">fi_ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>        <span class="n">fi_hash</span><span class="p">;</span>    <span class="cm">/* hash by &quot;struct inode *&quot; */</span>
	<span class="k">struct</span> <span class="n">list_head</span>        <span class="n">fi_stateids</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">fi_delegations</span><span class="p">;</span>
	<span class="cm">/* One each for O_RDONLY, O_WRONLY, O_RDWR: */</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span>		<span class="n">fi_fds</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * Each open or lock stateid contributes 0-4 to the counts</span>
<span class="cm">	 * below depending on which bits are set in st_access_bitmap:</span>
<span class="cm">	 *     1 to fi_access[O_RDONLY] if NFS4_SHARE_ACCES_READ is set</span>
<span class="cm">	 *   + 1 to fi_access[O_WRONLY] if NFS4_SHARE_ACCESS_WRITE is set</span>
<span class="cm">	 *   + 1 to both of the above if NFS4_SHARE_ACCESS_BOTH is set.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span>		<span class="n">fi_access</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">fi_deleg_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span>	<span class="o">*</span><span class="n">fi_lease</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">fi_delegees</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">fi_inode</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">fi_had_conflict</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* XXX: for first cut may fall back on returning file that doesn&#39;t work</span>
<span class="cm"> * at all? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">find_writeable_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_file</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fi_fds</span><span class="p">[</span><span class="n">O_WRONLY</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">fi_fds</span><span class="p">[</span><span class="n">O_WRONLY</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">fi_fds</span><span class="p">[</span><span class="n">O_RDWR</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">find_readable_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_file</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fi_fds</span><span class="p">[</span><span class="n">O_RDONLY</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">fi_fds</span><span class="p">[</span><span class="n">O_RDONLY</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">fi_fds</span><span class="p">[</span><span class="n">O_RDWR</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">find_any_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_file</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fi_fds</span><span class="p">[</span><span class="n">O_RDWR</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">fi_fds</span><span class="p">[</span><span class="n">O_RDWR</span><span class="p">];</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fi_fds</span><span class="p">[</span><span class="n">O_WRONLY</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">fi_fds</span><span class="p">[</span><span class="n">O_WRONLY</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">fi_fds</span><span class="p">[</span><span class="n">O_RDONLY</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* &quot;ol&quot; stands for &quot;Open or Lock&quot;.  Better suggestions welcome. */</span>
<span class="k">struct</span> <span class="n">nfs4_ol_stateid</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs4_stid</span>    <span class="n">st_stid</span><span class="p">;</span> <span class="cm">/* must be first field */</span>
	<span class="k">struct</span> <span class="n">list_head</span>              <span class="n">st_perfile</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>              <span class="n">st_perstateowner</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>              <span class="n">st_lockowners</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_stateowner</span>      <span class="o">*</span> <span class="n">st_stateowner</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_file</span>            <span class="o">*</span> <span class="n">st_file</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>                 <span class="n">st_access_bmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>                 <span class="n">st_deny_bmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_ol_stateid</span>         <span class="o">*</span> <span class="n">st_openstp</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nfs4_ol_stateid</span> <span class="o">*</span><span class="nf">openlockstateid</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_stid</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_ol_stateid</span><span class="p">,</span> <span class="n">st_stid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* flags for preprocess_seqid_op() */</span>
<span class="cp">#define RD_STATE	        0x00000010</span>
<span class="cp">#define WR_STATE	        0x00000020</span>

<span class="k">struct</span> <span class="n">nfsd4_compound_state</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">__be32</span> <span class="n">nfs4_preprocess_stateid_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfsd4_compound_state</span> <span class="o">*</span><span class="n">cstate</span><span class="p">,</span>
		<span class="n">stateid_t</span> <span class="o">*</span><span class="n">stateid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">**</span><span class="n">filp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfs4_lock_state</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfs4_unlock_state</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nfs4_in_grace</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfs4_release_reclaim</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">nfs4_client_reclaim</span> <span class="o">*</span><span class="n">nfsd4_find_reclaim_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">crp</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__be32</span> <span class="n">nfs4_check_open_reclaim</span><span class="p">(</span><span class="n">clientid_t</span> <span class="o">*</span><span class="n">clid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfs4_free_openowner</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_openowner</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfs4_free_lockowner</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_lockowner</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">set_callback_cred</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfsd4_probe_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfsd4_probe_callback_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfsd4_change_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_cb_conn</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfsd4_do_callback_rpc</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfsd4_cb_recall</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_delegation</span> <span class="o">*</span><span class="n">dp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nfsd4_create_callback_queue</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfsd4_destroy_callback_queue</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfsd4_shutdown_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfs4_put_delegation</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_delegation</span> <span class="o">*</span><span class="n">dp</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__be32</span> <span class="n">nfs4_make_rec_clidname</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">clidname</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_netobj</span> <span class="o">*</span><span class="n">clname</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nfs4_client_to_reclaim</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nfs4_has_reclaimed_state</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">bool</span> <span class="n">use_exchange_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">release_session_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfsd4_session</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__be32</span> <span class="n">nfs4_validate_stateid</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="p">,</span> <span class="n">stateid_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfsd4_purge_closed_stateid</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_stateowner</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* nfs4recover operations */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nfsd4_client_tracking_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfsd4_client_tracking_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfsd4_client_record_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfsd4_client_record_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nfsd4_client_record_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nfsd4_record_grace_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">time_t</span> <span class="n">boot_time</span><span class="p">);</span>
<span class="cp">#endif   </span><span class="cm">/* NFSD4_STATE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
