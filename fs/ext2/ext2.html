<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ext2 › ext2.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ext2.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 1992, 1993, 1994, 1995</span>
<span class="cm"> * Remy Card (card@masi.ibp.fr)</span>
<span class="cm"> * Laboratoire MASI - Institut Blaise Pascal</span>
<span class="cm"> * Universite Pierre et Marie Curie (Paris VI)</span>
<span class="cm"> *</span>
<span class="cm"> *  from</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/include/linux/minix_fs.h</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/ext2_fs.h&gt;</span>
<span class="cp">#include &lt;linux/blockgroup_lock.h&gt;</span>
<span class="cp">#include &lt;linux/percpu_counter.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>

<span class="cm">/* XXX Here for now... not interested in restructing headers JUST now */</span>

<span class="cm">/* data type for block offset of block group */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">ext2_grpblk_t</span><span class="p">;</span>

<span class="cm">/* data type for filesystem-wide blocks number */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ext2_fsblk_t</span><span class="p">;</span>

<span class="cp">#define E2FSBLK &quot;%lu&quot;</span>

<span class="k">struct</span> <span class="n">ext2_reserve_window</span> <span class="p">{</span>
	<span class="n">ext2_fsblk_t</span>		<span class="n">_rsv_start</span><span class="p">;</span>	<span class="cm">/* First byte reserved */</span>
	<span class="n">ext2_fsblk_t</span>		<span class="n">_rsv_end</span><span class="p">;</span>	<span class="cm">/* Last byte reserved or 0 */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span>	 	<span class="n">rsv_node</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">rsv_goal_size</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">rsv_alloc_hit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_reserve_window</span>	<span class="n">rsv_window</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ext2_block_alloc_info</span> <span class="p">{</span>
	<span class="cm">/* information about reservation window */</span>
	<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span>	<span class="n">rsv_window_node</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * was i_next_alloc_block in ext2_inode_info</span>
<span class="cm">	 * is the logical (file-relative) number of the</span>
<span class="cm">	 * most-recently-allocated block in this file.</span>
<span class="cm">	 * We use this for detecting linearly ascending allocation requests.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span>			<span class="n">last_alloc_logical_block</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Was i_next_alloc_goal in ext2_inode_info</span>
<span class="cm">	 * is the *physical* companion to i_next_alloc_block.</span>
<span class="cm">	 * it the the physical block number of the block which was most-recentl</span>
<span class="cm">	 * allocated to this file.  This give us the goal (target) for the next</span>
<span class="cm">	 * allocation when we detect linearly ascending requests.</span>
<span class="cm">	 */</span>
	<span class="n">ext2_fsblk_t</span>		<span class="n">last_alloc_physical_block</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define rsv_start rsv_window._rsv_start</span>
<span class="cp">#define rsv_end rsv_window._rsv_end</span>

<span class="cm">/*</span>
<span class="cm"> * second extended-fs super-block data in memory</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext2_sb_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_frag_size</span><span class="p">;</span>	<span class="cm">/* Size of a fragment in bytes */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_frags_per_block</span><span class="p">;</span><span class="cm">/* Number of fragments per block */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_inodes_per_block</span><span class="p">;</span><span class="cm">/* Number of inodes per block */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_frags_per_group</span><span class="p">;</span><span class="cm">/* Number of fragments in a group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_blocks_per_group</span><span class="p">;</span><span class="cm">/* Number of blocks in a group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_inodes_per_group</span><span class="p">;</span><span class="cm">/* Number of inodes in a group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_itb_per_group</span><span class="p">;</span>	<span class="cm">/* Number of inode table blocks per group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_gdb_count</span><span class="p">;</span>	<span class="cm">/* Number of group descriptor blocks */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_desc_per_block</span><span class="p">;</span>	<span class="cm">/* Number of group descriptors per block */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_groups_count</span><span class="p">;</span>	<span class="cm">/* Number of groups in the fs */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_overhead_last</span><span class="p">;</span>  <span class="cm">/* Last calculated overhead */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_blocks_last</span><span class="p">;</span>    <span class="cm">/* Last seen block count */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">s_sbh</span><span class="p">;</span>	<span class="cm">/* Buffer containing the super block */</span>
	<span class="k">struct</span> <span class="n">ext2_super_block</span> <span class="o">*</span> <span class="n">s_es</span><span class="p">;</span>	<span class="cm">/* Pointer to the super block in the buffer */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span> <span class="n">s_group_desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">s_mount_opt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_sb_block</span><span class="p">;</span>
	<span class="n">kuid_t</span> <span class="n">s_resuid</span><span class="p">;</span>
	<span class="n">kgid_t</span> <span class="n">s_resgid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">s_mount_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">s_pad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_addr_per_block_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_desc_per_block_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_inode_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_first_ino</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">s_next_gen_lock</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">s_next_generation</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_dir_count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">s_debts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">s_freeblocks_counter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">s_freeinodes_counter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">s_dirs_counter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blockgroup_lock</span> <span class="o">*</span><span class="n">s_blockgroup_lock</span><span class="p">;</span>
	<span class="cm">/* root of the per fs reservation window tree */</span>
	<span class="n">spinlock_t</span> <span class="n">s_rsv_window_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">s_rsv_window_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="n">s_rsv_window_head</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * s_lock protects against concurrent modifications of s_mount_state,</span>
<span class="cm">	 * s_blocks_last, s_overhead_last and the content of superblock&#39;s</span>
<span class="cm">	 * buffer pointed to by sbi-&gt;s_es.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: It is used in ext2_show_options() to provide a consistent view</span>
<span class="cm">	 * of the mount options.</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span> <span class="n">s_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">spinlock_t</span> <span class="o">*</span>
<span class="nf">sb_bgl_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext2_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bgl_lock_ptr</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_blockgroup_lock</span><span class="p">,</span> <span class="n">block_group</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Define EXT2FS_DEBUG to produce debug messages</span>
<span class="cm"> */</span>
<span class="cp">#undef EXT2FS_DEBUG</span>

<span class="cm">/*</span>
<span class="cm"> * Define EXT2_RESERVATION to reserve data blocks for expanding files</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_DEFAULT_RESERVE_BLOCKS     8</span>
<span class="cm">/*max window size: 1024(direct blocks) + 3([t,d]indirect blocks) */</span>
<span class="cp">#define EXT2_MAX_RESERVE_BLOCKS         1027</span>
<span class="cp">#define EXT2_RESERVE_WINDOW_NOT_ALLOCATED 0</span>
<span class="cm">/*</span>
<span class="cm"> * The second extended file system version</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2FS_DATE		&quot;95/08/09&quot;</span>
<span class="cp">#define EXT2FS_VERSION		&quot;0.5b&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Debug code</span>
<span class="cm"> */</span>
<span class="cp">#ifdef EXT2FS_DEBUG</span>
<span class="cp">#	define ext2_debug(f, a...)	{ \</span>
<span class="cp">					printk (&quot;EXT2-fs DEBUG (%s, %d): %s:&quot;, \</span>
<span class="cp">						__FILE__, __LINE__, __func__); \</span>
<span class="cp">				  	printk (f, ## a); \</span>
<span class="cp">					}</span>
<span class="cp">#else</span>
<span class="cp">#	define ext2_debug(f, a...)	</span><span class="cm">/**/</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Special inode numbers</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT2_BAD_INO		 1	</span><span class="cm">/* Bad blocks inode */</span><span class="cp"></span>
<span class="cp">#define EXT2_ROOT_INO		 2	</span><span class="cm">/* Root inode */</span><span class="cp"></span>
<span class="cp">#define EXT2_BOOT_LOADER_INO	 5	</span><span class="cm">/* Boot loader inode */</span><span class="cp"></span>
<span class="cp">#define EXT2_UNDEL_DIR_INO	 6	</span><span class="cm">/* Undelete directory inode */</span><span class="cp"></span>

<span class="cm">/* First non-reserved inode for old ext2 filesystems */</span>
<span class="cp">#define EXT2_GOOD_OLD_FIRST_INO	11</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ext2_sb_info</span> <span class="o">*</span><span class="nf">EXT2_SB</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Macro-instructions used to manage several block sizes</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_MIN_BLOCK_SIZE		1024</span>
<span class="cp">#define	EXT2_MAX_BLOCK_SIZE		4096</span>
<span class="cp">#define EXT2_MIN_BLOCK_LOG_SIZE		  10</span>
<span class="cp">#define EXT2_BLOCK_SIZE(s)		((s)-&gt;s_blocksize)</span>
<span class="cp">#define	EXT2_ADDR_PER_BLOCK(s)		(EXT2_BLOCK_SIZE(s) / sizeof (__u32))</span>
<span class="cp">#define EXT2_BLOCK_SIZE_BITS(s)		((s)-&gt;s_blocksize_bits)</span>
<span class="cp">#define	EXT2_ADDR_PER_BLOCK_BITS(s)	(EXT2_SB(s)-&gt;s_addr_per_block_bits)</span>
<span class="cp">#define EXT2_INODE_SIZE(s)		(EXT2_SB(s)-&gt;s_inode_size)</span>
<span class="cp">#define EXT2_FIRST_INO(s)		(EXT2_SB(s)-&gt;s_first_ino)</span>

<span class="cm">/*</span>
<span class="cm"> * Macro-instructions used to manage fragments</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_MIN_FRAG_SIZE		1024</span>
<span class="cp">#define	EXT2_MAX_FRAG_SIZE		4096</span>
<span class="cp">#define EXT2_MIN_FRAG_LOG_SIZE		  10</span>
<span class="cp">#define EXT2_FRAG_SIZE(s)		(EXT2_SB(s)-&gt;s_frag_size)</span>
<span class="cp">#define EXT2_FRAGS_PER_BLOCK(s)		(EXT2_SB(s)-&gt;s_frags_per_block)</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of a blocks group descriptor</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext2_group_desc</span>
<span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">bg_block_bitmap</span><span class="p">;</span>		<span class="cm">/* Blocks bitmap block */</span>
	<span class="n">__le32</span>	<span class="n">bg_inode_bitmap</span><span class="p">;</span>		<span class="cm">/* Inodes bitmap block */</span>
	<span class="n">__le32</span>	<span class="n">bg_inode_table</span><span class="p">;</span>		<span class="cm">/* Inodes table block */</span>
	<span class="n">__le16</span>	<span class="n">bg_free_blocks_count</span><span class="p">;</span>	<span class="cm">/* Free blocks count */</span>
	<span class="n">__le16</span>	<span class="n">bg_free_inodes_count</span><span class="p">;</span>	<span class="cm">/* Free inodes count */</span>
	<span class="n">__le16</span>	<span class="n">bg_used_dirs_count</span><span class="p">;</span>	<span class="cm">/* Directories count */</span>
	<span class="n">__le16</span>	<span class="n">bg_pad</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">bg_reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Macro-instructions used to manage group descriptors</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_BLOCKS_PER_GROUP(s)	(EXT2_SB(s)-&gt;s_blocks_per_group)</span>
<span class="cp">#define EXT2_DESC_PER_BLOCK(s)		(EXT2_SB(s)-&gt;s_desc_per_block)</span>
<span class="cp">#define EXT2_INODES_PER_GROUP(s)	(EXT2_SB(s)-&gt;s_inodes_per_group)</span>
<span class="cp">#define EXT2_DESC_PER_BLOCK_BITS(s)	(EXT2_SB(s)-&gt;s_desc_per_block_bits)</span>

<span class="cm">/*</span>
<span class="cm"> * Constants relative to the data blocks</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT2_NDIR_BLOCKS		12</span>
<span class="cp">#define	EXT2_IND_BLOCK			EXT2_NDIR_BLOCKS</span>
<span class="cp">#define	EXT2_DIND_BLOCK			(EXT2_IND_BLOCK + 1)</span>
<span class="cp">#define	EXT2_TIND_BLOCK			(EXT2_DIND_BLOCK + 1)</span>
<span class="cp">#define	EXT2_N_BLOCKS			(EXT2_TIND_BLOCK + 1)</span>

<span class="cm">/*</span>
<span class="cm"> * Inode flags (GETFLAGS/SETFLAGS)</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT2_SECRM_FL			FS_SECRM_FL	</span><span class="cm">/* Secure deletion */</span><span class="cp"></span>
<span class="cp">#define	EXT2_UNRM_FL			FS_UNRM_FL	</span><span class="cm">/* Undelete */</span><span class="cp"></span>
<span class="cp">#define	EXT2_COMPR_FL			FS_COMPR_FL	</span><span class="cm">/* Compress file */</span><span class="cp"></span>
<span class="cp">#define EXT2_SYNC_FL			FS_SYNC_FL	</span><span class="cm">/* Synchronous updates */</span><span class="cp"></span>
<span class="cp">#define EXT2_IMMUTABLE_FL		FS_IMMUTABLE_FL	</span><span class="cm">/* Immutable file */</span><span class="cp"></span>
<span class="cp">#define EXT2_APPEND_FL			FS_APPEND_FL	</span><span class="cm">/* writes to file may only append */</span><span class="cp"></span>
<span class="cp">#define EXT2_NODUMP_FL			FS_NODUMP_FL	</span><span class="cm">/* do not dump file */</span><span class="cp"></span>
<span class="cp">#define EXT2_NOATIME_FL			FS_NOATIME_FL	</span><span class="cm">/* do not update atime */</span><span class="cp"></span>
<span class="cm">/* Reserved for compression usage... */</span>
<span class="cp">#define EXT2_DIRTY_FL			FS_DIRTY_FL</span>
<span class="cp">#define EXT2_COMPRBLK_FL		FS_COMPRBLK_FL	</span><span class="cm">/* One or more compressed clusters */</span><span class="cp"></span>
<span class="cp">#define EXT2_NOCOMP_FL			FS_NOCOMP_FL	</span><span class="cm">/* Don&#39;t compress */</span><span class="cp"></span>
<span class="cp">#define EXT2_ECOMPR_FL			FS_ECOMPR_FL	</span><span class="cm">/* Compression error */</span><span class="cp"></span>
<span class="cm">/* End compression flags --- maybe not all used */</span>	
<span class="cp">#define EXT2_BTREE_FL			FS_BTREE_FL	</span><span class="cm">/* btree format dir */</span><span class="cp"></span>
<span class="cp">#define EXT2_INDEX_FL			FS_INDEX_FL	</span><span class="cm">/* hash-indexed directory */</span><span class="cp"></span>
<span class="cp">#define EXT2_IMAGIC_FL			FS_IMAGIC_FL	</span><span class="cm">/* AFS directory */</span><span class="cp"></span>
<span class="cp">#define EXT2_JOURNAL_DATA_FL		FS_JOURNAL_DATA_FL </span><span class="cm">/* Reserved for ext3 */</span><span class="cp"></span>
<span class="cp">#define EXT2_NOTAIL_FL			FS_NOTAIL_FL	</span><span class="cm">/* file tail should not be merged */</span><span class="cp"></span>
<span class="cp">#define EXT2_DIRSYNC_FL			FS_DIRSYNC_FL	</span><span class="cm">/* dirsync behaviour (directories only) */</span><span class="cp"></span>
<span class="cp">#define EXT2_TOPDIR_FL			FS_TOPDIR_FL	</span><span class="cm">/* Top of directory hierarchies*/</span><span class="cp"></span>
<span class="cp">#define EXT2_RESERVED_FL		FS_RESERVED_FL	</span><span class="cm">/* reserved for ext2 lib */</span><span class="cp"></span>

<span class="cp">#define EXT2_FL_USER_VISIBLE		FS_FL_USER_VISIBLE	</span><span class="cm">/* User visible flags */</span><span class="cp"></span>
<span class="cp">#define EXT2_FL_USER_MODIFIABLE		FS_FL_USER_MODIFIABLE	</span><span class="cm">/* User modifiable flags */</span><span class="cp"></span>

<span class="cm">/* Flags that should be inherited by new inodes from their parent. */</span>
<span class="cp">#define EXT2_FL_INHERITED (EXT2_SECRM_FL | EXT2_UNRM_FL | EXT2_COMPR_FL |\</span>
<span class="cp">			   EXT2_SYNC_FL | EXT2_NODUMP_FL |\</span>
<span class="cp">			   EXT2_NOATIME_FL | EXT2_COMPRBLK_FL |\</span>
<span class="cp">			   EXT2_NOCOMP_FL | EXT2_JOURNAL_DATA_FL |\</span>
<span class="cp">			   EXT2_NOTAIL_FL | EXT2_DIRSYNC_FL)</span>

<span class="cm">/* Flags that are appropriate for regular files (all but dir-specific ones). */</span>
<span class="cp">#define EXT2_REG_FLMASK (~(EXT2_DIRSYNC_FL | EXT2_TOPDIR_FL))</span>

<span class="cm">/* Flags that are appropriate for non-directories/regular files. */</span>
<span class="cp">#define EXT2_OTHER_FLMASK (EXT2_NODUMP_FL | EXT2_NOATIME_FL)</span>

<span class="cm">/* Mask out flags that are inappropriate for the given type of inode. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">ext2_mask_flags</span><span class="p">(</span><span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT2_REG_FLMASK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT2_OTHER_FLMASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ioctl commands</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT2_IOC_GETFLAGS		FS_IOC_GETFLAGS</span>
<span class="cp">#define	EXT2_IOC_SETFLAGS		FS_IOC_SETFLAGS</span>
<span class="cp">#define	EXT2_IOC_GETVERSION		FS_IOC_GETVERSION</span>
<span class="cp">#define	EXT2_IOC_SETVERSION		FS_IOC_SETVERSION</span>
<span class="cp">#define	EXT2_IOC_GETRSVSZ		_IOR(&#39;f&#39;, 5, long)</span>
<span class="cp">#define	EXT2_IOC_SETRSVSZ		_IOW(&#39;f&#39;, 6, long)</span>

<span class="cm">/*</span>
<span class="cm"> * ioctl commands in 32 bit emulation</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_IOC32_GETFLAGS		FS_IOC32_GETFLAGS</span>
<span class="cp">#define EXT2_IOC32_SETFLAGS		FS_IOC32_SETFLAGS</span>
<span class="cp">#define EXT2_IOC32_GETVERSION		FS_IOC32_GETVERSION</span>
<span class="cp">#define EXT2_IOC32_SETVERSION		FS_IOC32_SETVERSION</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of an inode on the disk</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext2_inode</span> <span class="p">{</span>
	<span class="n">__le16</span>	<span class="n">i_mode</span><span class="p">;</span>		<span class="cm">/* File mode */</span>
	<span class="n">__le16</span>	<span class="n">i_uid</span><span class="p">;</span>		<span class="cm">/* Low 16 bits of Owner Uid */</span>
	<span class="n">__le32</span>	<span class="n">i_size</span><span class="p">;</span>		<span class="cm">/* Size in bytes */</span>
	<span class="n">__le32</span>	<span class="n">i_atime</span><span class="p">;</span>	<span class="cm">/* Access time */</span>
	<span class="n">__le32</span>	<span class="n">i_ctime</span><span class="p">;</span>	<span class="cm">/* Creation time */</span>
	<span class="n">__le32</span>	<span class="n">i_mtime</span><span class="p">;</span>	<span class="cm">/* Modification time */</span>
	<span class="n">__le32</span>	<span class="n">i_dtime</span><span class="p">;</span>	<span class="cm">/* Deletion Time */</span>
	<span class="n">__le16</span>	<span class="n">i_gid</span><span class="p">;</span>		<span class="cm">/* Low 16 bits of Group Id */</span>
	<span class="n">__le16</span>	<span class="n">i_links_count</span><span class="p">;</span>	<span class="cm">/* Links count */</span>
	<span class="n">__le32</span>	<span class="n">i_blocks</span><span class="p">;</span>	<span class="cm">/* Blocks count */</span>
	<span class="n">__le32</span>	<span class="n">i_flags</span><span class="p">;</span>	<span class="cm">/* File flags */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span>  <span class="n">l_i_reserved1</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">linux1</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span>  <span class="n">h_i_translator</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">hurd1</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span>  <span class="n">m_i_reserved1</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">masix1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">osd1</span><span class="p">;</span>				<span class="cm">/* OS dependent 1 */</span>
	<span class="n">__le32</span>	<span class="n">i_block</span><span class="p">[</span><span class="n">EXT2_N_BLOCKS</span><span class="p">];</span><span class="cm">/* Pointers to blocks */</span>
	<span class="n">__le32</span>	<span class="n">i_generation</span><span class="p">;</span>	<span class="cm">/* File version (for NFS) */</span>
	<span class="n">__le32</span>	<span class="n">i_file_acl</span><span class="p">;</span>	<span class="cm">/* File ACL */</span>
	<span class="n">__le32</span>	<span class="n">i_dir_acl</span><span class="p">;</span>	<span class="cm">/* Directory ACL */</span>
	<span class="n">__le32</span>	<span class="n">i_faddr</span><span class="p">;</span>	<span class="cm">/* Fragment address */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u8</span>	<span class="n">l_i_frag</span><span class="p">;</span>	<span class="cm">/* Fragment number */</span>
			<span class="n">__u8</span>	<span class="n">l_i_fsize</span><span class="p">;</span>	<span class="cm">/* Fragment size */</span>
			<span class="n">__u16</span>	<span class="n">i_pad1</span><span class="p">;</span>
			<span class="n">__le16</span>	<span class="n">l_i_uid_high</span><span class="p">;</span>	<span class="cm">/* these 2 fields    */</span>
			<span class="n">__le16</span>	<span class="n">l_i_gid_high</span><span class="p">;</span>	<span class="cm">/* were reserved2[0] */</span>
			<span class="n">__u32</span>	<span class="n">l_i_reserved2</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">linux2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u8</span>	<span class="n">h_i_frag</span><span class="p">;</span>	<span class="cm">/* Fragment number */</span>
			<span class="n">__u8</span>	<span class="n">h_i_fsize</span><span class="p">;</span>	<span class="cm">/* Fragment size */</span>
			<span class="n">__le16</span>	<span class="n">h_i_mode_high</span><span class="p">;</span>
			<span class="n">__le16</span>	<span class="n">h_i_uid_high</span><span class="p">;</span>
			<span class="n">__le16</span>	<span class="n">h_i_gid_high</span><span class="p">;</span>
			<span class="n">__le32</span>	<span class="n">h_i_author</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">hurd2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u8</span>	<span class="n">m_i_frag</span><span class="p">;</span>	<span class="cm">/* Fragment number */</span>
			<span class="n">__u8</span>	<span class="n">m_i_fsize</span><span class="p">;</span>	<span class="cm">/* Fragment size */</span>
			<span class="n">__u16</span>	<span class="n">m_pad1</span><span class="p">;</span>
			<span class="n">__u32</span>	<span class="n">m_i_reserved2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">masix2</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">osd2</span><span class="p">;</span>				<span class="cm">/* OS dependent 2 */</span>
<span class="p">};</span>

<span class="cp">#define i_size_high	i_dir_acl</span>

<span class="cp">#define i_reserved1	osd1.linux1.l_i_reserved1</span>
<span class="cp">#define i_frag		osd2.linux2.l_i_frag</span>
<span class="cp">#define i_fsize		osd2.linux2.l_i_fsize</span>
<span class="cp">#define i_uid_low	i_uid</span>
<span class="cp">#define i_gid_low	i_gid</span>
<span class="cp">#define i_uid_high	osd2.linux2.l_i_uid_high</span>
<span class="cp">#define i_gid_high	osd2.linux2.l_i_gid_high</span>
<span class="cp">#define i_reserved2	osd2.linux2.l_i_reserved2</span>

<span class="cm">/*</span>
<span class="cm"> * File system states</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT2_VALID_FS			0x0001	</span><span class="cm">/* Unmounted cleanly */</span><span class="cp"></span>
<span class="cp">#define	EXT2_ERROR_FS			0x0002	</span><span class="cm">/* Errors detected */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Mount flags</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_MOUNT_CHECK		0x000001  </span><span class="cm">/* Do mount-time checks */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_OLDALLOC		0x000002  </span><span class="cm">/* Don&#39;t use the new Orlov allocator */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_GRPID		0x000004  </span><span class="cm">/* Create files with directory&#39;s group */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_DEBUG		0x000008  </span><span class="cm">/* Some debugging messages */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_ERRORS_CONT		0x000010  </span><span class="cm">/* Continue on errors */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_ERRORS_RO		0x000020  </span><span class="cm">/* Remount fs ro on errors */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_ERRORS_PANIC		0x000040  </span><span class="cm">/* Panic on errors */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_MINIX_DF		0x000080  </span><span class="cm">/* Mimics the Minix statfs */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_NOBH			0x000100  </span><span class="cm">/* No buffer_heads */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_NO_UID32		0x000200  </span><span class="cm">/* Disable 32-bit UIDs */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_XATTR_USER		0x004000  </span><span class="cm">/* Extended user attributes */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_POSIX_ACL		0x008000  </span><span class="cm">/* POSIX Access Control Lists */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_XIP			0x010000  </span><span class="cm">/* Execute in place */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_USRQUOTA		0x020000  </span><span class="cm">/* user quota */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_GRPQUOTA		0x040000  </span><span class="cm">/* group quota */</span><span class="cp"></span>
<span class="cp">#define EXT2_MOUNT_RESERVATION		0x080000  </span><span class="cm">/* Preallocation */</span><span class="cp"></span>


<span class="cp">#define clear_opt(o, opt)		o &amp;= ~EXT2_MOUNT_##opt</span>
<span class="cp">#define set_opt(o, opt)			o |= EXT2_MOUNT_##opt</span>
<span class="cp">#define test_opt(sb, opt)		(EXT2_SB(sb)-&gt;s_mount_opt &amp; \</span>
<span class="cp">					 EXT2_MOUNT_##opt)</span>
<span class="cm">/*</span>
<span class="cm"> * Maximal mount counts between two filesystem checks</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_DFL_MAX_MNT_COUNT		20	</span><span class="cm">/* Allow 20 mounts */</span><span class="cp"></span>
<span class="cp">#define EXT2_DFL_CHECKINTERVAL		0	</span><span class="cm">/* Don&#39;t use interval check */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Behaviour when detecting errors</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_ERRORS_CONTINUE		1	</span><span class="cm">/* Continue execution */</span><span class="cp"></span>
<span class="cp">#define EXT2_ERRORS_RO			2	</span><span class="cm">/* Remount fs read-only */</span><span class="cp"></span>
<span class="cp">#define EXT2_ERRORS_PANIC		3	</span><span class="cm">/* Panic */</span><span class="cp"></span>
<span class="cp">#define EXT2_ERRORS_DEFAULT		EXT2_ERRORS_CONTINUE</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of the super block</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext2_super_block</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">s_inodes_count</span><span class="p">;</span>		<span class="cm">/* Inodes count */</span>
	<span class="n">__le32</span>	<span class="n">s_blocks_count</span><span class="p">;</span>		<span class="cm">/* Blocks count */</span>
	<span class="n">__le32</span>	<span class="n">s_r_blocks_count</span><span class="p">;</span>	<span class="cm">/* Reserved blocks count */</span>
	<span class="n">__le32</span>	<span class="n">s_free_blocks_count</span><span class="p">;</span>	<span class="cm">/* Free blocks count */</span>
	<span class="n">__le32</span>	<span class="n">s_free_inodes_count</span><span class="p">;</span>	<span class="cm">/* Free inodes count */</span>
	<span class="n">__le32</span>	<span class="n">s_first_data_block</span><span class="p">;</span>	<span class="cm">/* First Data Block */</span>
	<span class="n">__le32</span>	<span class="n">s_log_block_size</span><span class="p">;</span>	<span class="cm">/* Block size */</span>
	<span class="n">__le32</span>	<span class="n">s_log_frag_size</span><span class="p">;</span>	<span class="cm">/* Fragment size */</span>
	<span class="n">__le32</span>	<span class="n">s_blocks_per_group</span><span class="p">;</span>	<span class="cm">/* # Blocks per group */</span>
	<span class="n">__le32</span>	<span class="n">s_frags_per_group</span><span class="p">;</span>	<span class="cm">/* # Fragments per group */</span>
	<span class="n">__le32</span>	<span class="n">s_inodes_per_group</span><span class="p">;</span>	<span class="cm">/* # Inodes per group */</span>
	<span class="n">__le32</span>	<span class="n">s_mtime</span><span class="p">;</span>		<span class="cm">/* Mount time */</span>
	<span class="n">__le32</span>	<span class="n">s_wtime</span><span class="p">;</span>		<span class="cm">/* Write time */</span>
	<span class="n">__le16</span>	<span class="n">s_mnt_count</span><span class="p">;</span>		<span class="cm">/* Mount count */</span>
	<span class="n">__le16</span>	<span class="n">s_max_mnt_count</span><span class="p">;</span>	<span class="cm">/* Maximal mount count */</span>
	<span class="n">__le16</span>	<span class="n">s_magic</span><span class="p">;</span>		<span class="cm">/* Magic signature */</span>
	<span class="n">__le16</span>	<span class="n">s_state</span><span class="p">;</span>		<span class="cm">/* File system state */</span>
	<span class="n">__le16</span>	<span class="n">s_errors</span><span class="p">;</span>		<span class="cm">/* Behaviour when detecting errors */</span>
	<span class="n">__le16</span>	<span class="n">s_minor_rev_level</span><span class="p">;</span> 	<span class="cm">/* minor revision level */</span>
	<span class="n">__le32</span>	<span class="n">s_lastcheck</span><span class="p">;</span>		<span class="cm">/* time of last check */</span>
	<span class="n">__le32</span>	<span class="n">s_checkinterval</span><span class="p">;</span>	<span class="cm">/* max. time between checks */</span>
	<span class="n">__le32</span>	<span class="n">s_creator_os</span><span class="p">;</span>		<span class="cm">/* OS */</span>
	<span class="n">__le32</span>	<span class="n">s_rev_level</span><span class="p">;</span>		<span class="cm">/* Revision level */</span>
	<span class="n">__le16</span>	<span class="n">s_def_resuid</span><span class="p">;</span>		<span class="cm">/* Default uid for reserved blocks */</span>
	<span class="n">__le16</span>	<span class="n">s_def_resgid</span><span class="p">;</span>		<span class="cm">/* Default gid for reserved blocks */</span>
	<span class="cm">/*</span>
<span class="cm">	 * These fields are for EXT2_DYNAMIC_REV superblocks only.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: the difference between the compatible feature set and</span>
<span class="cm">	 * the incompatible feature set is that if there is a bit set</span>
<span class="cm">	 * in the incompatible feature set that the kernel doesn&#39;t</span>
<span class="cm">	 * know about, it should refuse to mount the filesystem.</span>
<span class="cm">	 * </span>
<span class="cm">	 * e2fsck&#39;s requirements are more strict; if it doesn&#39;t know</span>
<span class="cm">	 * about a feature in either the compatible or incompatible</span>
<span class="cm">	 * feature set, it must abort and not try to meddle with</span>
<span class="cm">	 * things it doesn&#39;t understand...</span>
<span class="cm">	 */</span>
	<span class="n">__le32</span>	<span class="n">s_first_ino</span><span class="p">;</span> 		<span class="cm">/* First non-reserved inode */</span>
	<span class="n">__le16</span>   <span class="n">s_inode_size</span><span class="p">;</span> 		<span class="cm">/* size of inode structure */</span>
	<span class="n">__le16</span>	<span class="n">s_block_group_nr</span><span class="p">;</span> 	<span class="cm">/* block group # of this superblock */</span>
	<span class="n">__le32</span>	<span class="n">s_feature_compat</span><span class="p">;</span> 	<span class="cm">/* compatible feature set */</span>
	<span class="n">__le32</span>	<span class="n">s_feature_incompat</span><span class="p">;</span> 	<span class="cm">/* incompatible feature set */</span>
	<span class="n">__le32</span>	<span class="n">s_feature_ro_compat</span><span class="p">;</span> 	<span class="cm">/* readonly-compatible feature set */</span>
	<span class="n">__u8</span>	<span class="n">s_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>		<span class="cm">/* 128-bit uuid for volume */</span>
	<span class="kt">char</span>	<span class="n">s_volume_name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span> 	<span class="cm">/* volume name */</span>
	<span class="kt">char</span>	<span class="n">s_last_mounted</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span> 	<span class="cm">/* directory where last mounted */</span>
	<span class="n">__le32</span>	<span class="n">s_algorithm_usage_bitmap</span><span class="p">;</span> <span class="cm">/* For compression */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Performance hints.  Directory preallocation should only</span>
<span class="cm">	 * happen if the EXT2_COMPAT_PREALLOC flag is on.</span>
<span class="cm">	 */</span>
	<span class="n">__u8</span>	<span class="n">s_prealloc_blocks</span><span class="p">;</span>	<span class="cm">/* Nr of blocks to try to preallocate*/</span>
	<span class="n">__u8</span>	<span class="n">s_prealloc_dir_blocks</span><span class="p">;</span>	<span class="cm">/* Nr to preallocate for dirs */</span>
	<span class="n">__u16</span>	<span class="n">s_padding1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Journaling support valid if EXT3_FEATURE_COMPAT_HAS_JOURNAL set.</span>
<span class="cm">	 */</span>
	<span class="n">__u8</span>	<span class="n">s_journal_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* uuid of journal superblock */</span>
	<span class="n">__u32</span>	<span class="n">s_journal_inum</span><span class="p">;</span>		<span class="cm">/* inode number of journal file */</span>
	<span class="n">__u32</span>	<span class="n">s_journal_dev</span><span class="p">;</span>		<span class="cm">/* device number of journal file */</span>
	<span class="n">__u32</span>	<span class="n">s_last_orphan</span><span class="p">;</span>		<span class="cm">/* start of list of inodes to delete */</span>
	<span class="n">__u32</span>	<span class="n">s_hash_seed</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* HTREE hash seed */</span>
	<span class="n">__u8</span>	<span class="n">s_def_hash_version</span><span class="p">;</span>	<span class="cm">/* Default hash version to use */</span>
	<span class="n">__u8</span>	<span class="n">s_reserved_char_pad</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">s_reserved_word_pad</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">s_default_mount_opts</span><span class="p">;</span>
 	<span class="n">__le32</span>	<span class="n">s_first_meta_bg</span><span class="p">;</span> 	<span class="cm">/* First metablock block group */</span>
	<span class="n">__u32</span>	<span class="n">s_reserved</span><span class="p">[</span><span class="mi">190</span><span class="p">];</span>	<span class="cm">/* Padding to the end of the block */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Codes for operating systems</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_OS_LINUX		0</span>
<span class="cp">#define EXT2_OS_HURD		1</span>
<span class="cp">#define EXT2_OS_MASIX		2</span>
<span class="cp">#define EXT2_OS_FREEBSD		3</span>
<span class="cp">#define EXT2_OS_LITES		4</span>

<span class="cm">/*</span>
<span class="cm"> * Revision levels</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_GOOD_OLD_REV	0	</span><span class="cm">/* The good old (original) format */</span><span class="cp"></span>
<span class="cp">#define EXT2_DYNAMIC_REV	1 	</span><span class="cm">/* V2 format w/ dynamic inode sizes */</span><span class="cp"></span>

<span class="cp">#define EXT2_CURRENT_REV	EXT2_GOOD_OLD_REV</span>
<span class="cp">#define EXT2_MAX_SUPP_REV	EXT2_DYNAMIC_REV</span>

<span class="cp">#define EXT2_GOOD_OLD_INODE_SIZE 128</span>

<span class="cm">/*</span>
<span class="cm"> * Feature set definitions</span>
<span class="cm"> */</span>

<span class="cp">#define EXT2_HAS_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	( EXT2_SB(sb)-&gt;s_es-&gt;s_feature_compat &amp; cpu_to_le32(mask) )</span>
<span class="cp">#define EXT2_HAS_RO_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	( EXT2_SB(sb)-&gt;s_es-&gt;s_feature_ro_compat &amp; cpu_to_le32(mask) )</span>
<span class="cp">#define EXT2_HAS_INCOMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	( EXT2_SB(sb)-&gt;s_es-&gt;s_feature_incompat &amp; cpu_to_le32(mask) )</span>
<span class="cp">#define EXT2_SET_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT2_SB(sb)-&gt;s_es-&gt;s_feature_compat |= cpu_to_le32(mask)</span>
<span class="cp">#define EXT2_SET_RO_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT2_SB(sb)-&gt;s_es-&gt;s_feature_ro_compat |= cpu_to_le32(mask)</span>
<span class="cp">#define EXT2_SET_INCOMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT2_SB(sb)-&gt;s_es-&gt;s_feature_incompat |= cpu_to_le32(mask)</span>
<span class="cp">#define EXT2_CLEAR_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT2_SB(sb)-&gt;s_es-&gt;s_feature_compat &amp;= ~cpu_to_le32(mask)</span>
<span class="cp">#define EXT2_CLEAR_RO_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT2_SB(sb)-&gt;s_es-&gt;s_feature_ro_compat &amp;= ~cpu_to_le32(mask)</span>
<span class="cp">#define EXT2_CLEAR_INCOMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT2_SB(sb)-&gt;s_es-&gt;s_feature_incompat &amp;= ~cpu_to_le32(mask)</span>

<span class="cp">#define EXT2_FEATURE_COMPAT_DIR_PREALLOC	0x0001</span>
<span class="cp">#define EXT2_FEATURE_COMPAT_IMAGIC_INODES	0x0002</span>
<span class="cp">#define EXT3_FEATURE_COMPAT_HAS_JOURNAL		0x0004</span>
<span class="cp">#define EXT2_FEATURE_COMPAT_EXT_ATTR		0x0008</span>
<span class="cp">#define EXT2_FEATURE_COMPAT_RESIZE_INO		0x0010</span>
<span class="cp">#define EXT2_FEATURE_COMPAT_DIR_INDEX		0x0020</span>
<span class="cp">#define EXT2_FEATURE_COMPAT_ANY			0xffffffff</span>

<span class="cp">#define EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER	0x0001</span>
<span class="cp">#define EXT2_FEATURE_RO_COMPAT_LARGE_FILE	0x0002</span>
<span class="cp">#define EXT2_FEATURE_RO_COMPAT_BTREE_DIR	0x0004</span>
<span class="cp">#define EXT2_FEATURE_RO_COMPAT_ANY		0xffffffff</span>

<span class="cp">#define EXT2_FEATURE_INCOMPAT_COMPRESSION	0x0001</span>
<span class="cp">#define EXT2_FEATURE_INCOMPAT_FILETYPE		0x0002</span>
<span class="cp">#define EXT3_FEATURE_INCOMPAT_RECOVER		0x0004</span>
<span class="cp">#define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV	0x0008</span>
<span class="cp">#define EXT2_FEATURE_INCOMPAT_META_BG		0x0010</span>
<span class="cp">#define EXT2_FEATURE_INCOMPAT_ANY		0xffffffff</span>

<span class="cp">#define EXT2_FEATURE_COMPAT_SUPP	EXT2_FEATURE_COMPAT_EXT_ATTR</span>
<span class="cp">#define EXT2_FEATURE_INCOMPAT_SUPP	(EXT2_FEATURE_INCOMPAT_FILETYPE| \</span>
<span class="cp">					 EXT2_FEATURE_INCOMPAT_META_BG)</span>
<span class="cp">#define EXT2_FEATURE_RO_COMPAT_SUPP	(EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER| \</span>
<span class="cp">					 EXT2_FEATURE_RO_COMPAT_LARGE_FILE| \</span>
<span class="cp">					 EXT2_FEATURE_RO_COMPAT_BTREE_DIR)</span>
<span class="cp">#define EXT2_FEATURE_RO_COMPAT_UNSUPPORTED	~EXT2_FEATURE_RO_COMPAT_SUPP</span>
<span class="cp">#define EXT2_FEATURE_INCOMPAT_UNSUPPORTED	~EXT2_FEATURE_INCOMPAT_SUPP</span>

<span class="cm">/*</span>
<span class="cm"> * Default values for user and/or group using reserved blocks</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT2_DEF_RESUID		0</span>
<span class="cp">#define	EXT2_DEF_RESGID		0</span>

<span class="cm">/*</span>
<span class="cm"> * Default mount options</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_DEFM_DEBUG		0x0001</span>
<span class="cp">#define EXT2_DEFM_BSDGROUPS	0x0002</span>
<span class="cp">#define EXT2_DEFM_XATTR_USER	0x0004</span>
<span class="cp">#define EXT2_DEFM_ACL		0x0008</span>
<span class="cp">#define EXT2_DEFM_UID16		0x0010</span>
    <span class="cm">/* Not used by ext2, but reserved for use by ext3 */</span>
<span class="cp">#define EXT3_DEFM_JMODE		0x0060 </span>
<span class="cp">#define EXT3_DEFM_JMODE_DATA	0x0020</span>
<span class="cp">#define EXT3_DEFM_JMODE_ORDERED	0x0040</span>
<span class="cp">#define EXT3_DEFM_JMODE_WBACK	0x0060</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of a directory entry</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ext2_dir_entry</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">inode</span><span class="p">;</span>			<span class="cm">/* Inode number */</span>
	<span class="n">__le16</span>	<span class="n">rec_len</span><span class="p">;</span>		<span class="cm">/* Directory entry length */</span>
	<span class="n">__le16</span>	<span class="n">name_len</span><span class="p">;</span>		<span class="cm">/* Name length */</span>
	<span class="kt">char</span>	<span class="n">name</span><span class="p">[];</span>			<span class="cm">/* File name, up to EXT2_NAME_LEN */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The new version of the directory entry.  Since EXT2 structures are</span>
<span class="cm"> * stored in intel byte order, and the name_len field could never be</span>
<span class="cm"> * bigger than 255 chars, it&#39;s safe to reclaim the extra byte for the</span>
<span class="cm"> * file_type field.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext2_dir_entry_2</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">inode</span><span class="p">;</span>			<span class="cm">/* Inode number */</span>
	<span class="n">__le16</span>	<span class="n">rec_len</span><span class="p">;</span>		<span class="cm">/* Directory entry length */</span>
	<span class="n">__u8</span>	<span class="n">name_len</span><span class="p">;</span>		<span class="cm">/* Name length */</span>
	<span class="n">__u8</span>	<span class="n">file_type</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">name</span><span class="p">[];</span>			<span class="cm">/* File name, up to EXT2_NAME_LEN */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Ext2 directory file types.  Only the low 3 bits are used.  The</span>
<span class="cm"> * other bits are reserved for now.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">EXT2_FT_UNKNOWN</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">EXT2_FT_REG_FILE</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">EXT2_FT_DIR</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">EXT2_FT_CHRDEV</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">EXT2_FT_BLKDEV</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">EXT2_FT_FIFO</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">EXT2_FT_SOCK</span>		<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">EXT2_FT_SYMLINK</span>		<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">EXT2_FT_MAX</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * EXT2_DIR_PAD defines the directory entries boundaries</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: It must be a multiple of 4</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_DIR_PAD		 	4</span>
<span class="cp">#define EXT2_DIR_ROUND 			(EXT2_DIR_PAD - 1)</span>
<span class="cp">#define EXT2_DIR_REC_LEN(name_len)	(((name_len) + 8 + EXT2_DIR_ROUND) &amp; \</span>
<span class="cp">					 ~EXT2_DIR_ROUND)</span>
<span class="cp">#define EXT2_MAX_REC_LEN		((1&lt;&lt;16)-1)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">verify_offsets</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define A(x,y) BUILD_BUG_ON(x != offsetof(struct ext2_super_block, y));</span>
	<span class="n">A</span><span class="p">(</span><span class="n">EXT2_SB_MAGIC_OFFSET</span><span class="p">,</span> <span class="n">s_magic</span><span class="p">);</span>
	<span class="n">A</span><span class="p">(</span><span class="n">EXT2_SB_BLOCKS_OFFSET</span><span class="p">,</span> <span class="n">s_blocks_count</span><span class="p">);</span>
	<span class="n">A</span><span class="p">(</span><span class="n">EXT2_SB_BSIZE_OFFSET</span><span class="p">,</span> <span class="n">s_log_block_size</span><span class="p">);</span>
<span class="cp">#undef A</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext2 mount options</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext2_mount_options</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_mount_opt</span><span class="p">;</span>
	<span class="n">kuid_t</span> <span class="n">s_resuid</span><span class="p">;</span>
	<span class="n">kgid_t</span> <span class="n">s_resgid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * second extended file system inode data in memory</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext2_inode_info</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">i_data</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
	<span class="n">__u32</span>	<span class="n">i_flags</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">i_faddr</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">i_frag_no</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">i_frag_size</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">i_state</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">i_file_acl</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">i_dir_acl</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">i_dtime</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * i_block_group is the number of the block group which contains</span>
<span class="cm">	 * this file&#39;s inode.  Constant across the lifetime of the inode,</span>
<span class="cm">	 * it is used for making block allocation decisions - we try to</span>
<span class="cm">	 * place a file&#39;s data blocks near its inode block, and new inodes</span>
<span class="cm">	 * near to their parent directory&#39;s inode.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span>	<span class="n">i_block_group</span><span class="p">;</span>

	<span class="cm">/* block reservation info */</span>
	<span class="k">struct</span> <span class="n">ext2_block_alloc_info</span> <span class="o">*</span><span class="n">i_block_alloc_info</span><span class="p">;</span>

	<span class="n">__u32</span>	<span class="n">i_dir_start_lookup</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_EXT2_FS_XATTR</span>
	<span class="cm">/*</span>
<span class="cm">	 * Extended attributes can be read independently of the main file</span>
<span class="cm">	 * data. Taking i_mutex even when reading would cause contention</span>
<span class="cm">	 * between readers of EAs and writers of regular file data, so</span>
<span class="cm">	 * instead we synchronize on xattr_sem when reading or changing</span>
<span class="cm">	 * EAs.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">xattr_sem</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">rwlock_t</span> <span class="n">i_meta_lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * truncate_mutex is for serialising ext2_truncate() against</span>
<span class="cm">	 * ext2_getblock().  It also protects the internals of the inode&#39;s</span>
<span class="cm">	 * reservation data structures: ext2_reserve_window and</span>
<span class="cm">	 * ext2_reserve_window_node.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">truncate_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="n">vfs_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">i_orphan</span><span class="p">;</span>	<span class="cm">/* unlinked but open inodes */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Inode dynamic state flags</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_STATE_NEW			0x00000001 </span><span class="cm">/* inode is newly created */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * Function prototypes</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Ok, these declarations are also in &lt;linux/kernel.h&gt; but none of the</span>
<span class="cm"> * ext2 source programs needs to include it so they are duplicated here.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ext2_inode_info</span> <span class="o">*</span><span class="nf">EXT2_I</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext2_inode_info</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* balloc.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext2_bg_has_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ext2_bg_num_gdb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ext2_fsblk_t</span> <span class="n">ext2_new_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ext2_fsblk_t</span> <span class="n">ext2_new_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext2_free_blocks</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ext2_count_free_blocks</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ext2_count_dirs</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext2_check_blocks_bitmap</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ext2_group_desc</span> <span class="o">*</span> <span class="n">ext2_get_group_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_group</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span> <span class="n">bh</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext2_discard_reservation</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext2_should_retry_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">retries</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext2_init_block_alloc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext2_rsv_window_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span><span class="p">);</span>

<span class="cm">/* dir.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext2_add_link</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ino_t</span> <span class="n">ext2_inode_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext2_make_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ext2_dir_entry_2</span> <span class="o">*</span> <span class="n">ext2_find_entry</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext2_delete_entry</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext2_dir_entry_2</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext2_empty_dir</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ext2_dir_entry_2</span> <span class="o">*</span> <span class="n">ext2_dotdot</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext2_set_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext2_dir_entry_2</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/* ialloc.c */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">ext2_new_inode</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext2_free_inode</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ext2_count_free_inodes</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext2_check_inodes_bitmap</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ext2_count_free</span> <span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>

<span class="cm">/* inode.c */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ext2_iget</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext2_write_inode</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext2_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext2_get_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext2_setattr</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext2_set_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext2_get_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext2_inode_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext2_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span>
		       <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* ioctl.c */</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">ext2_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">ext2_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="cm">/* namei.c */</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ext2_get_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span><span class="p">);</span>

<span class="cm">/* super.c */</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">ext2_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">ext2_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext2_update_dynamic_rev</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext2_write_super</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Inodes and files operations</span>
<span class="cm"> */</span>

<span class="cm">/* dir.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ext2_dir_operations</span><span class="p">;</span>

<span class="cm">/* file.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext2_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">datasync</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext2_file_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ext2_file_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ext2_xip_file_operations</span><span class="p">;</span>

<span class="cm">/* inode.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ext2_aops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ext2_aops_xip</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ext2_nobh_aops</span><span class="p">;</span>

<span class="cm">/* namei.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext2_dir_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext2_special_inode_operations</span><span class="p">;</span>

<span class="cm">/* symlink.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext2_fast_symlink_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext2_symlink_inode_operations</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ext2_fsblk_t</span>
<span class="nf">ext2_group_first_block_no</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">group_no</span> <span class="o">*</span> <span class="p">(</span><span class="n">ext2_fsblk_t</span><span class="p">)</span><span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define ext2_set_bit	__test_and_set_bit_le</span>
<span class="cp">#define ext2_clear_bit	__test_and_clear_bit_le</span>
<span class="cp">#define ext2_test_bit	test_bit_le</span>
<span class="cp">#define ext2_find_first_zero_bit	find_first_zero_bit_le</span>
<span class="cp">#define ext2_find_next_zero_bit		find_next_zero_bit_le</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
