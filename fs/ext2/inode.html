<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ext2 › inode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/ext2/inode.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1993, 1994, 1995</span>
<span class="cm"> * Remy Card (card@masi.ibp.fr)</span>
<span class="cm"> * Laboratoire MASI - Institut Blaise Pascal</span>
<span class="cm"> * Universite Pierre et Marie Curie (Paris VI)</span>
<span class="cm"> *</span>
<span class="cm"> *  from</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/fs/minix/inode.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  Goal-directed block allocation by Stephen Tweedie</span>
<span class="cm"> * 	(sct@dcs.ed.ac.uk), 1993, 1998</span>
<span class="cm"> *  Big-endian to little-endian byte-swapping/bitmaps by</span>
<span class="cm"> *        David S. Miller (davem@caip.rutgers.edu), 1995</span>
<span class="cm"> *  64-bit file support on 64-bit platforms by Jakub Jelinek</span>
<span class="cm"> * 	(jj@sunsite.ms.mff.cuni.cz)</span>
<span class="cm"> *</span>
<span class="cm"> *  Assorted race fixes, rewrite of ext2_get_block() by Al Viro, 2000</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/highuid.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/quotaops.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/mpage.h&gt;</span>
<span class="cp">#include &lt;linux/fiemap.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &quot;ext2.h&quot;</span>
<span class="cp">#include &quot;acl.h&quot;</span>
<span class="cp">#include &quot;xip.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__ext2_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">do_sync</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Test whether an inode is a fast symlink.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext2_inode_is_fast_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ea_blocks</span> <span class="o">=</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_file_acl</span> <span class="o">?</span>
		<span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">-</span> <span class="n">ea_blocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ext2_truncate_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext2_write_failed</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">to</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">truncate_pagecache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
		<span class="n">ext2_truncate_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called at the last iput() if i_nlink is zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext2_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext2_block_alloc_info</span> <span class="o">*</span><span class="n">rsv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">want_delete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">want_delete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dquot_drop</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">want_delete</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* set dtime */</span>
		<span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_dtime</span>	<span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">__ext2_write_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode_needs_sync</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
		<span class="cm">/* truncate to 0 */</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">)</span>
			<span class="n">ext2_truncate_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">invalidate_inode_buffers</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ext2_discard_reservation</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">rsv</span> <span class="o">=</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span><span class="p">;</span>
	<span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rsv</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rsv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">want_delete</span><span class="p">)</span>
		<span class="n">ext2_free_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Indirect</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_chain</span><span class="p">(</span><span class="n">Indirect</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">verify_chain</span><span class="p">(</span><span class="n">Indirect</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="n">Indirect</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">from</span> <span class="o">&lt;=</span> <span class="n">to</span> <span class="o">&amp;&amp;</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="o">*</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">)</span>
		<span class="n">from</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">from</span> <span class="o">&gt;</span> <span class="n">to</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext2_block_to_path - parse the block number into array of offsets</span>
<span class="cm"> *	@inode: inode in question (we are only interested in its superblock)</span>
<span class="cm"> *	@i_block: block number to be parsed</span>
<span class="cm"> *	@offsets: array to store the offsets in</span>
<span class="cm"> *      @boundary: set this non-zero if the referred-to block is likely to be</span>
<span class="cm"> *             followed (on disk) by an indirect block.</span>
<span class="cm"> *	To store the locations of file&#39;s data ext2 uses a data structure common</span>
<span class="cm"> *	for UNIX filesystems - tree of pointers anchored in the inode, with</span>
<span class="cm"> *	data blocks at leaves and indirect blocks in intermediate nodes.</span>
<span class="cm"> *	This function translates the block number into path in that tree -</span>
<span class="cm"> *	return value is the path length and @offsets[n] is the offset of</span>
<span class="cm"> *	pointer to (n+1)th node in the nth one. If @block is out of range</span>
<span class="cm"> *	(negative or too large) warning is printed and zero returned.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: function doesn&#39;t find node addresses, so no IO is needed. All</span>
<span class="cm"> *	we need to know is the capacity of indirect blocks (taken from the</span>
<span class="cm"> *	inode-&gt;i_sb).</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Portability note: the last comparison (check that we fit into triple</span>
<span class="cm"> * indirect block) is spelled differently, because otherwise on an</span>
<span class="cm"> * architecture with 32-bit longs and 8Kb pages we might get into trouble</span>
<span class="cm"> * if our filesystem had 8Kb blocks. We might use long long, but that would</span>
<span class="cm"> * kill us on x86. Oh, well, at least the sign propagation does not matter -</span>
<span class="cm"> * i_block would have to be negative in the very beginning, so we would not</span>
<span class="cm"> * get there at all.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext2_block_to_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="kt">long</span> <span class="n">i_block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">boundary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ptrs</span> <span class="o">=</span> <span class="n">EXT2_ADDR_PER_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ptrs_bits</span> <span class="o">=</span> <span class="n">EXT2_ADDR_PER_BLOCK_BITS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">long</span> <span class="n">direct_blocks</span> <span class="o">=</span> <span class="n">EXT2_NDIR_BLOCKS</span><span class="p">,</span>
		<span class="n">indirect_blocks</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">,</span>
		<span class="n">double_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ptrs_bits</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">final</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext2_msg</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
			<span class="s">&quot;warning: %s: block &lt; 0&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">&lt;</span> <span class="n">direct_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span><span class="p">;</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">direct_blocks</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">-=</span> <span class="n">direct_blocks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">indirect_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXT2_IND_BLOCK</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span><span class="p">;</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_block</span> <span class="o">-=</span> <span class="n">indirect_blocks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">double_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXT2_DIND_BLOCK</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&gt;&gt;</span> <span class="n">ptrs_bits</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">i_block</span> <span class="o">-=</span> <span class="n">double_blocks</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ptrs_bits</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">ptrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">EXT2_TIND_BLOCK</span><span class="p">;</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ptrs_bits</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">&gt;&gt;</span> <span class="n">ptrs_bits</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_block</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">final</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ext2_msg</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
			<span class="s">&quot;warning: %s: block is too big&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
		<span class="o">*</span><span class="n">boundary</span> <span class="o">=</span> <span class="n">final</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">i_block</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ptrs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext2_get_branch - read the chain of indirect blocks leading to data</span>
<span class="cm"> *	@inode: inode in question</span>
<span class="cm"> *	@depth: depth of the chain (1 - direct pointer, etc.)</span>
<span class="cm"> *	@offsets: offsets of pointers in inode/indirect blocks</span>
<span class="cm"> *	@chain: place to store the result</span>
<span class="cm"> *	@err: here we store the error value</span>
<span class="cm"> *</span>
<span class="cm"> *	Function fills the array of triples &lt;key, p, bh&gt; and returns %NULL</span>
<span class="cm"> *	if everything went OK or the pointer to the last filled triple</span>
<span class="cm"> *	(incomplete one) otherwise. Upon the return chain[i].key contains</span>
<span class="cm"> *	the number of (i+1)-th block in the chain (as it is stored in memory,</span>
<span class="cm"> *	i.e. little-endian 32-bit), chain[i].p contains the address of that</span>
<span class="cm"> *	number (it points into struct inode for i==0 and into the bh-&gt;b_data</span>
<span class="cm"> *	for i&gt;0) and chain[i].bh points to the buffer_head of i-th indirect</span>
<span class="cm"> *	block for i&gt;0 and NULL for i==0. In other words, it holds the block</span>
<span class="cm"> *	numbers of the chain, addresses they were taken from (and where we can</span>
<span class="cm"> *	verify that chain did not change) and buffer_heads hosting these</span>
<span class="cm"> *	numbers.</span>
<span class="cm"> *</span>
<span class="cm"> *	Function stops when it stumbles upon zero pointer (absent block)</span>
<span class="cm"> *		(pointer to last triple returned, *@err == 0)</span>
<span class="cm"> *	or when it gets an IO error reading an indirect block</span>
<span class="cm"> *		(ditto, *@err == -EIO)</span>
<span class="cm"> *	or when it notices that chain had been changed while it was reading</span>
<span class="cm"> *		(ditto, *@err == -EAGAIN)</span>
<span class="cm"> *	or when it reads all @depth-1 indirect blocks successfully and finds</span>
<span class="cm"> *	the whole chain, all way to the data (returns %NULL, *err == 0).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">Indirect</span> <span class="o">*</span><span class="nf">ext2_get_branch</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="o">*</span><span class="n">offsets</span><span class="p">,</span>
				 <span class="n">Indirect</span> <span class="n">chain</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
				 <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">Indirect</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chain</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* i_data is not going away, no lock needed */</span>
	<span class="n">add_chain</span> <span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data</span> <span class="o">+</span> <span class="o">*</span><span class="n">offsets</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_block</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_meta_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">verify_chain</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">changed</span><span class="p">;</span>
		<span class="n">add_chain</span><span class="p">(</span><span class="o">++</span><span class="n">p</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="p">(</span><span class="n">__le32</span><span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="o">*++</span><span class="n">offsets</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_meta_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">no_block</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">changed:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_meta_lock</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">no_block</span><span class="p">;</span>
<span class="nl">failure:</span>
	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="nl">no_block:</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext2_find_near - find a place for allocation with sufficient locality</span>
<span class="cm"> *	@inode: owner</span>
<span class="cm"> *	@ind: descriptor of indirect block.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function returns the preferred place for block allocation.</span>
<span class="cm"> *	It is used when heuristic for sequential allocation fails.</span>
<span class="cm"> *	Rules are:</span>
<span class="cm"> *	  + if there is a block to the left of our position - allocate near it.</span>
<span class="cm"> *	  + if pointer will live in indirect block - allocate near that block.</span>
<span class="cm"> *	  + if pointer will live in inode - allocate in the same cylinder group.</span>
<span class="cm"> *</span>
<span class="cm"> * In the latter case we colour the starting block by the callers PID to</span>
<span class="cm"> * prevent it from clashing with concurrent allocations for a different inode</span>
<span class="cm"> * in the same block group.   The PID is used here so that functionally related</span>
<span class="cm"> * files will be close-by on-disk.</span>
<span class="cm"> *</span>
<span class="cm"> *	Caller must make sure that @ind is valid and will stay that way.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">ext2_fsblk_t</span> <span class="nf">ext2_find_near</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">Indirect</span> <span class="o">*</span><span class="n">ind</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext2_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">ind</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">?</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">ind</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">:</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">bg_start</span><span class="p">;</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">colour</span><span class="p">;</span>

	<span class="cm">/* Try to find previous block */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">ind</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">;</span> <span class="n">p</span><span class="o">--</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/* No such thing, so let&#39;s try location of indirect block */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ind</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ind</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is going to be referred from inode itself? OK, just put it into</span>
<span class="cm">	 * the same cylinder group then.</span>
<span class="cm">	 */</span>
	<span class="n">bg_start</span> <span class="o">=</span> <span class="n">ext2_group_first_block_no</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_group</span><span class="p">);</span>
	<span class="n">colour</span> <span class="o">=</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">%</span> <span class="mi">16</span><span class="p">)</span> <span class="o">*</span>
			<span class="p">(</span><span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bg_start</span> <span class="o">+</span> <span class="n">colour</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext2_find_goal - find a preferred place for allocation.</span>
<span class="cm"> *	@inode: owner</span>
<span class="cm"> *	@block:  block we want</span>
<span class="cm"> *	@partial: pointer to the last triple within a chain</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns preferred place for a block (the goal).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ext2_fsblk_t</span> <span class="nf">ext2_find_goal</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">long</span> <span class="n">block</span><span class="p">,</span>
					  <span class="n">Indirect</span> <span class="o">*</span><span class="n">partial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext2_block_alloc_info</span> <span class="o">*</span><span class="n">block_i</span><span class="p">;</span>

	<span class="n">block_i</span> <span class="o">=</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * try the heuristic for sequential allocation,</span>
<span class="cm">	 * failing that at least try to get decent locality.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_i</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="n">block_i</span><span class="o">-&gt;</span><span class="n">last_alloc_logical_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">block_i</span><span class="o">-&gt;</span><span class="n">last_alloc_physical_block</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">block_i</span><span class="o">-&gt;</span><span class="n">last_alloc_physical_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ext2_find_near</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">partial</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext2_blks_to_allocate: Look up the block map and count the number</span>
<span class="cm"> *	of direct blocks need to be allocated for the given branch.</span>
<span class="cm"> *</span>
<span class="cm"> * 	@branch: chain of indirect blocks</span>
<span class="cm"> *	@k: number of blocks need for indirect blocks</span>
<span class="cm"> *	@blks: number of data blocks to be mapped.</span>
<span class="cm"> *	@blocks_to_boundary:  the offset in the indirect block</span>
<span class="cm"> *</span>
<span class="cm"> *	return the total number of blocks to be allocate, including the</span>
<span class="cm"> *	direct and indirect blocks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ext2_blks_to_allocate</span><span class="p">(</span><span class="n">Indirect</span> <span class="o">*</span> <span class="n">branch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blks</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">blocks_to_boundary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Simple case, [t,d]Indirect block(s) has not allocated yet</span>
<span class="cm">	 * then it&#39;s clear blocks on that path have not allocated</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* right now don&#39;t hanel cross boundary allocation */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blks</span> <span class="o">&lt;</span> <span class="n">blocks_to_boundary</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">blks</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">blocks_to_boundary</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">blks</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">blocks_to_boundary</span>
		<span class="o">&amp;&amp;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">branch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">p</span> <span class="o">+</span> <span class="n">count</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext2_alloc_blocks: multiple allocate blocks needed for a branch</span>
<span class="cm"> *	@indirect_blks: the number of blocks need to allocate for indirect</span>
<span class="cm"> *			blocks</span>
<span class="cm"> *</span>
<span class="cm"> *	@new_blocks: on return it will store the new block numbers for</span>
<span class="cm"> *	the indirect blocks(if needed) and the first direct block,</span>
<span class="cm"> *	@blks:	on return it will store the total number of allocated</span>
<span class="cm"> *		direct blocks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext2_alloc_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="n">ext2_fsblk_t</span> <span class="n">goal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">indirect_blks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blks</span><span class="p">,</span>
			<span class="n">ext2_fsblk_t</span> <span class="n">new_blocks</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">current_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Here we try to allocate the requested multiple blocks at once,</span>
<span class="cm">	 * on a best-effort basis.</span>
<span class="cm">	 * To build a branch, we should allocate blocks for</span>
<span class="cm">	 * the indirect blocks(if not allocated yet), and at least</span>
<span class="cm">	 * the first direct block of this branch.  That&#39;s the</span>
<span class="cm">	 * minimum number of blocks need to allocate(required)</span>
<span class="cm">	 */</span>
	<span class="n">target</span> <span class="o">=</span> <span class="n">blks</span> <span class="o">+</span> <span class="n">indirect_blks</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
		<span class="cm">/* allocating blocks for indirect blocks and direct blocks */</span>
		<span class="n">current_block</span> <span class="o">=</span> <span class="n">ext2_new_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">goal</span><span class="p">,</span><span class="o">&amp;</span><span class="n">count</span><span class="p">,</span><span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failed_out</span><span class="p">;</span>

		<span class="n">target</span> <span class="o">-=</span> <span class="n">count</span><span class="p">;</span>
		<span class="cm">/* allocate blocks for indirect blocks */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">indirect_blks</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_blocks</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_block</span><span class="o">++</span><span class="p">;</span>
			<span class="n">count</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* save the new block number for the first direct block */</span>
	<span class="n">new_blocks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_block</span><span class="p">;</span>

	<span class="cm">/* total number of blocks allocated for direct blocks */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">failed_out:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ext2_free_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span><span class="p">)</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext2_alloc_branch - allocate and set up a chain of blocks.</span>
<span class="cm"> *	@inode: owner</span>
<span class="cm"> *	@num: depth of the chain (number of blocks to allocate)</span>
<span class="cm"> *	@offsets: offsets (in the blocks) to store the pointers to next.</span>
<span class="cm"> *	@branch: place to store the chain in.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function allocates @num blocks, zeroes out all but the last one,</span>
<span class="cm"> *	links them into chain and (if we are synchronous) writes them to disk.</span>
<span class="cm"> *	In other words, it prepares a branch that can be spliced onto the</span>
<span class="cm"> *	inode. It stores the information about that chain in the branch[], in</span>
<span class="cm"> *	the same format as ext2_get_branch() would do. We are calling it after</span>
<span class="cm"> *	we had read the existing part of chain and partial points to the last</span>
<span class="cm"> *	triple of that (one with zero -&gt;key). Upon the exit we have the same</span>
<span class="cm"> *	picture as after the successful ext2_get_block(), except that in one</span>
<span class="cm"> *	place chain is disconnected - *branch-&gt;p is still zero (we did not</span>
<span class="cm"> *	set the last link), but branch-&gt;key contains the number that should</span>
<span class="cm"> *	be placed into *branch-&gt;p to fill that gap.</span>
<span class="cm"> *</span>
<span class="cm"> *	If allocation fails we free all blocks we&#39;ve allocated (and forget</span>
<span class="cm"> *	their buffer_heads) and return the error value the from failed</span>
<span class="cm"> *	ext2_alloc_block() (normally -ENOSPC). Otherwise we set the chain</span>
<span class="cm"> *	as described above and return 0.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext2_alloc_branch</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">indirect_blks</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">blks</span><span class="p">,</span> <span class="n">ext2_fsblk_t</span> <span class="n">goal</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">offsets</span><span class="p">,</span> <span class="n">Indirect</span> <span class="o">*</span><span class="n">branch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">new_blocks</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">current_block</span><span class="p">;</span>

	<span class="n">num</span> <span class="o">=</span> <span class="n">ext2_alloc_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">indirect_blks</span><span class="p">,</span>
				<span class="o">*</span><span class="n">blks</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">branch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="cm">/*</span>
<span class="cm">	 * metadata blocks and data blocks are allocated.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">indirect_blks</span><span class="p">;</span>  <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get buffer_head for parent block, zero it out</span>
<span class="cm">		 * and set the pointer to new one, then send</span>
<span class="cm">		 * parent to disk.</span>
<span class="cm">		 */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">new_blocks</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
		<span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_blocks</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
		<span class="o">*</span><span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">p</span> <span class="o">=</span> <span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">n</span> <span class="o">==</span> <span class="n">indirect_blks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">current_block</span> <span class="o">=</span> <span class="n">new_blocks</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
			<span class="cm">/*</span>
<span class="cm">			 * End of chain, update the last new metablock of</span>
<span class="cm">			 * the chain to point to the new allocated</span>
<span class="cm">			 * data blocks numbers</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="o">*</span><span class="p">(</span><span class="n">branch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">++</span><span class="n">current_block</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">mark_buffer_dirty_inode</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="cm">/* We used to sync bh here if IS_SYNC(inode).</span>
<span class="cm">		 * But we now rely upon generic_write_sync()</span>
<span class="cm">		 * and b_inode_buffers.  But not for directories.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">blks</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext2_splice_branch - splice the allocated branch onto inode.</span>
<span class="cm"> * @inode: owner</span>
<span class="cm"> * @block: (logical) number of block we are adding</span>
<span class="cm"> * @where: location of missing link</span>
<span class="cm"> * @num:   number of indirect blocks we are adding</span>
<span class="cm"> * @blks:  number of direct blocks we are adding</span>
<span class="cm"> *</span>
<span class="cm"> * This function fills the missing link and does all housekeeping needed in</span>
<span class="cm"> * inode (-&gt;i_blocks, etc.). In case of success we end up with the full</span>
<span class="cm"> * chain to new block and return 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext2_splice_branch</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="kt">long</span> <span class="n">block</span><span class="p">,</span> <span class="n">Indirect</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_block_alloc_info</span> <span class="o">*</span><span class="n">block_i</span><span class="p">;</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">current_block</span><span class="p">;</span>

	<span class="n">block_i</span> <span class="o">=</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span><span class="p">;</span>

	<span class="cm">/* XXX LOCKING probably should have i_meta_lock ?*/</span>
	<span class="cm">/* That&#39;s it */</span>

	<span class="o">*</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">where</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the host buffer_head or inode to point to more just allocated</span>
<span class="cm">	 * direct blocks blocks</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">blks</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">blks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span> <span class="p">)</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">current_block</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * update the most recently allocated logical &amp; physical block</span>
<span class="cm">	 * in i_block_alloc_info, to assist find the proper goal block for next</span>
<span class="cm">	 * allocation</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_i</span><span class="o">-&gt;</span><span class="n">last_alloc_logical_block</span> <span class="o">=</span> <span class="n">block</span> <span class="o">+</span> <span class="n">blks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">block_i</span><span class="o">-&gt;</span><span class="n">last_alloc_physical_block</span> <span class="o">=</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">where</span><span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="n">blks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We are done with atomic stuff, now do the rest of housekeeping */</span>

	<span class="cm">/* had we spliced it onto indirect block? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">)</span>
		<span class="n">mark_buffer_dirty_inode</span><span class="p">(</span><span class="n">where</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocation strategy is simple: if we have to allocate something, we will</span>
<span class="cm"> * have to go the whole way to leaf. So let&#39;s do it before attaching anything</span>
<span class="cm"> * to tree, set linkage between the newborn blocks, write them if sync is</span>
<span class="cm"> * required, recheck the path, free and repeat if check fails, otherwise</span>
<span class="cm"> * set the last missing link (that will protect us from any truncate-generated</span>
<span class="cm"> * removals - all blocks on the path are immune now) and possibly force the</span>
<span class="cm"> * write on the parent block.</span>
<span class="cm"> * That has a nice additional property: no special recovery from the failed</span>
<span class="cm"> * allocations is needed - we simply release blocks and do not touch anything</span>
<span class="cm"> * reachable from inode.</span>
<span class="cm"> *</span>
<span class="cm"> * `handle&#39; can be NULL if create == 0.</span>
<span class="cm"> *</span>
<span class="cm"> * return &gt; 0, # of blocks mapped or allocated.</span>
<span class="cm"> * return = 0, if plain lookup failed.</span>
<span class="cm"> * return &lt; 0, error case.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext2_get_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			   <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxblocks</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Indirect</span> <span class="n">chain</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Indirect</span> <span class="o">*</span><span class="n">partial</span><span class="p">;</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">goal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">indirect_blks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blocks_to_boundary</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">first_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext2_block_to_path</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">iblock</span><span class="p">,</span><span class="n">offsets</span><span class="p">,</span><span class="o">&amp;</span><span class="n">blocks_to_boundary</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">err</span><span class="p">);</span>

	<span class="n">partial</span> <span class="o">=</span> <span class="n">ext2_get_branch</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="cm">/* Simplest case - block found, no allocation needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">first_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
		<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span> <span class="cm">/* What&#39;s this do? */</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/*map more blocks*/</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">maxblocks</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">blocks_to_boundary</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext2_fsblk_t</span> <span class="n">blk</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">verify_chain</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">chain</span> <span class="o">+</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Indirect block might be removed by</span>
<span class="cm">				 * truncate while we were reading it.</span>
<span class="cm">				 * Handling of that case: forget what we&#39;ve</span>
<span class="cm">				 * got now, go to reread.</span>
<span class="cm">				 */</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
				<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">blk</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">p</span> <span class="o">+</span> <span class="n">count</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">blk</span> <span class="o">==</span> <span class="n">first_block</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">got_it</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Next simple case - plain lookup or failed read of indirect block */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">create</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">truncate_mutex</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the indirect block is missing while we are reading</span>
<span class="cm">	 * the chain(ext2_get_branch() returns -EAGAIN err), or</span>
<span class="cm">	 * if the chain has been changed after we grab the semaphore,</span>
<span class="cm">	 * (either because another process truncated this branch, or</span>
<span class="cm">	 * another get_block allocated this branch) re-grab the chain to see if</span>
<span class="cm">	 * the request block has been allocated or not.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Since we already block the truncate/other get_block</span>
<span class="cm">	 * at this point, we will have the current copy of the chain when we</span>
<span class="cm">	 * splice the branch into the tree.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="o">!</span><span class="n">verify_chain</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">partial</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">partial</span> <span class="o">&gt;</span> <span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">partial</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">partial</span> <span class="o">=</span> <span class="n">ext2_get_branch</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">truncate_mutex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
			<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">got_it</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Okay, we need to do block allocation.  Lazily initialize the block</span>
<span class="cm">	 * allocation info here if necessary</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span><span class="p">))</span>
		<span class="n">ext2_init_block_alloc_info</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">goal</span> <span class="o">=</span> <span class="n">ext2_find_goal</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">partial</span><span class="p">);</span>

	<span class="cm">/* the number of blocks need to allocate for [d,t]indirect blocks */</span>
	<span class="n">indirect_blks</span> <span class="o">=</span> <span class="p">(</span><span class="n">chain</span> <span class="o">+</span> <span class="n">depth</span><span class="p">)</span> <span class="o">-</span> <span class="n">partial</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Next look up the indirect map to count the totoal number of</span>
<span class="cm">	 * direct blocks to allocate for this branch.</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">ext2_blks_to_allocate</span><span class="p">(</span><span class="n">partial</span><span class="p">,</span> <span class="n">indirect_blks</span><span class="p">,</span>
					<span class="n">maxblocks</span><span class="p">,</span> <span class="n">blocks_to_boundary</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * XXX ???? Block out ext2_truncate while we alter the tree</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext2_alloc_branch</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">indirect_blks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span>
				<span class="n">offsets</span> <span class="o">+</span> <span class="p">(</span><span class="n">partial</span> <span class="o">-</span> <span class="n">chain</span><span class="p">),</span> <span class="n">partial</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">truncate_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext2_use_xip</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * we need to clear the block</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext2_clear_xip_target</span> <span class="p">(</span><span class="n">inode</span><span class="p">,</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">truncate_mutex</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ext2_splice_branch</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">partial</span><span class="p">,</span> <span class="n">indirect_blks</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">truncate_mutex</span><span class="p">);</span>
	<span class="n">set_buffer_new</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
<span class="nl">got_it:</span>
	<span class="n">map_bh</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">blocks_to_boundary</span><span class="p">)</span>
		<span class="n">set_buffer_boundary</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="cm">/* Clean up and exit */</span>
	<span class="n">partial</span> <span class="o">=</span> <span class="n">chain</span> <span class="o">+</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* the whole chain */</span>
<span class="nl">cleanup:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">partial</span> <span class="o">&gt;</span> <span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">partial</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ext2_get_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">max_blocks</span> <span class="o">=</span> <span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ext2_get_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">max_blocks</span><span class="p">,</span>
			      <span class="n">bh_result</span><span class="p">,</span> <span class="n">create</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ext2_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">generic_block_fiemap</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fieinfo</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				    <span class="n">ext2_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext2_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">block_write_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">ext2_get_block</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext2_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mpage_readpage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">ext2_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ext2_readpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mpage_readpages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">ext2_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ext2_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">block_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pagep</span><span class="p">,</span>
				<span class="n">ext2_get_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ext2_write_failed</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext2_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">generic_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
		<span class="n">ext2_write_failed</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ext2_nobh_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nobh_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pagep</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">,</span>
			       <span class="n">ext2_get_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ext2_write_failed</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext2_nobh_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nobh_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">ext2_get_block</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">sector_t</span> <span class="nf">ext2_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">generic_block_bmap</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span><span class="n">block</span><span class="p">,</span><span class="n">ext2_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ext2_direct_IO</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">blockdev_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span>
				 <span class="n">ext2_get_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">))</span>
		<span class="n">ext2_write_failed</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ext2_writepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mpage_writepages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">wbc</span><span class="p">,</span> <span class="n">ext2_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ext2_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span>		<span class="o">=</span> <span class="n">ext2_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span>		<span class="o">=</span> <span class="n">ext2_readpages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span>		<span class="o">=</span> <span class="n">ext2_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span>		<span class="o">=</span> <span class="n">ext2_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span>		<span class="o">=</span> <span class="n">ext2_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmap</span>			<span class="o">=</span> <span class="n">ext2_bmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">direct_IO</span>		<span class="o">=</span> <span class="n">ext2_direct_IO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepages</span>		<span class="o">=</span> <span class="n">ext2_writepages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">migratepage</span>		<span class="o">=</span> <span class="n">buffer_migrate_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_partially_uptodate</span>	<span class="o">=</span> <span class="n">block_is_partially_uptodate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_remove_page</span>	<span class="o">=</span> <span class="n">generic_error_remove_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ext2_aops_xip</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">bmap</span>			<span class="o">=</span> <span class="n">ext2_bmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_xip_mem</span>		<span class="o">=</span> <span class="n">ext2_get_xip_mem</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ext2_nobh_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span>		<span class="o">=</span> <span class="n">ext2_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span>		<span class="o">=</span> <span class="n">ext2_readpages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span>		<span class="o">=</span> <span class="n">ext2_nobh_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span>		<span class="o">=</span> <span class="n">ext2_nobh_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span>		<span class="o">=</span> <span class="n">nobh_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmap</span>			<span class="o">=</span> <span class="n">ext2_bmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">direct_IO</span>		<span class="o">=</span> <span class="n">ext2_direct_IO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepages</span>		<span class="o">=</span> <span class="n">ext2_writepages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">migratepage</span>		<span class="o">=</span> <span class="n">buffer_migrate_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_remove_page</span>	<span class="o">=</span> <span class="n">generic_error_remove_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Probably it should be a library function... search for first non-zero word</span>
<span class="cm"> * or memcmp with zero_page, whatever is better for particular architecture.</span>
<span class="cm"> * Linus?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">all_zeroes</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext2_find_shared - find the indirect blocks for partial truncation.</span>
<span class="cm"> *	@inode:	  inode in question</span>
<span class="cm"> *	@depth:	  depth of the affected branch</span>
<span class="cm"> *	@offsets: offsets of pointers in that branch (see ext2_block_to_path)</span>
<span class="cm"> *	@chain:	  place to store the pointers to partial indirect blocks</span>
<span class="cm"> *	@top:	  place to the (detached) top of branch</span>
<span class="cm"> *</span>
<span class="cm"> *	This is a helper function used by ext2_truncate().</span>
<span class="cm"> *</span>
<span class="cm"> *	When we do truncate() we may have to clean the ends of several indirect</span>
<span class="cm"> *	blocks but leave the blocks themselves alive. Block is partially</span>
<span class="cm"> *	truncated if some data below the new i_size is referred from it (and</span>
<span class="cm"> *	it is on the path to the first completely truncated data block, indeed).</span>
<span class="cm"> *	We have to free the top of that path along with everything to the right</span>
<span class="cm"> *	of the path. Since no allocation past the truncation point is possible</span>
<span class="cm"> *	until ext2_truncate() finishes, we may safely do the latter, but top</span>
<span class="cm"> *	of branch may require special attention - pageout below the truncation</span>
<span class="cm"> *	point might try to populate it.</span>
<span class="cm"> *</span>
<span class="cm"> *	We atomically detach the top of branch from the tree, store the block</span>
<span class="cm"> *	number of its root in *@top, pointers to buffer_heads of partially</span>
<span class="cm"> *	truncated blocks - in @chain[].bh and pointers to their last elements</span>
<span class="cm"> *	that should not be removed - in @chain[].p. Return value is the pointer</span>
<span class="cm"> *	to last filled element of @chain.</span>
<span class="cm"> *</span>
<span class="cm"> *	The work left to caller to do the actual freeing of subtrees:</span>
<span class="cm"> *		a) free the subtree starting from *@top</span>
<span class="cm"> *		b) free the subtrees whose roots are stored in</span>
<span class="cm"> *			(@chain[i].p+1 .. end of @chain[i].bh-&gt;b_data)</span>
<span class="cm"> *		c) free the subtrees growing from the inode past the @chain[0].p</span>
<span class="cm"> *			(no partially truncated stuff there).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">Indirect</span> <span class="o">*</span><span class="nf">ext2_find_shared</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">depth</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
				<span class="n">Indirect</span> <span class="n">chain</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
				<span class="n">__le32</span> <span class="o">*</span><span class="n">top</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Indirect</span> <span class="o">*</span><span class="n">partial</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="o">*</span><span class="n">top</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">offsets</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="n">k</span><span class="o">--</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="n">partial</span> <span class="o">=</span> <span class="n">ext2_get_branch</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="p">)</span>
		<span class="n">partial</span> <span class="o">=</span> <span class="n">chain</span> <span class="o">+</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the branch acquired continuation since we&#39;ve looked at it -</span>
<span class="cm">	 * fine, it should all survive and (new) top doesn&#39;t belong to us.</span>
<span class="cm">	 */</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_meta_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_meta_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_top</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">partial</span><span class="p">;</span> <span class="n">p</span><span class="o">&gt;</span><span class="n">chain</span> <span class="o">&amp;&amp;</span> <span class="n">all_zeroes</span><span class="p">((</span><span class="n">__le32</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span> <span class="n">p</span><span class="o">--</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * OK, we&#39;ve found the last block that must survive. The rest of our</span>
<span class="cm">	 * branch should be detached before unlocking. However, if that rest</span>
<span class="cm">	 * of branch is all ours and does not grow immediately from the inode</span>
<span class="cm">	 * it&#39;s easier to cheat and just decrement partial-&gt;p.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">chain</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">top</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_meta_lock</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span><span class="n">partial</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">partial</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">no_top:</span>
	<span class="k">return</span> <span class="n">partial</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext2_free_data - free a list of data blocks</span>
<span class="cm"> *	@inode:	inode we are dealing with</span>
<span class="cm"> *	@p:	array of block numbers</span>
<span class="cm"> *	@q:	points immediately past the end of array</span>
<span class="cm"> *</span>
<span class="cm"> *	We are freeing all blocks referred from that array (numbers are</span>
<span class="cm"> *	stored as little-endian 32-bit) and updating @inode-&gt;i_blocks</span>
<span class="cm"> *	appropriately.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext2_free_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block_to_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* accumulate blocks to free if they&#39;re contiguous */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">free_this</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block_to_free</span> <span class="o">==</span> <span class="n">nr</span> <span class="o">-</span> <span class="n">count</span><span class="p">)</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">ext2_free_blocks</span> <span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block_to_free</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
				<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="nl">free_this:</span>
				<span class="n">block_to_free</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>
				<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext2_free_blocks</span> <span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block_to_free</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext2_free_branches - free an array of branches</span>
<span class="cm"> *	@inode:	inode we are dealing with</span>
<span class="cm"> *	@p:	array of block numbers</span>
<span class="cm"> *	@q:	pointer immediately past the end of array</span>
<span class="cm"> *	@depth:	depth of the branches to free</span>
<span class="cm"> *</span>
<span class="cm"> *	We are freeing all blocks referred from these branches (numbers are</span>
<span class="cm"> *	stored as little-endian 32-bit) and updating @inode-&gt;i_blocks</span>
<span class="cm"> *	appropriately.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext2_free_branches</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">addr_per_block</span> <span class="o">=</span> <span class="n">EXT2_ADDR_PER_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * A read failure? Report error and clear slot</span>
<span class="cm">			 * (should be rare).</span>
<span class="cm">			 */</span> 
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ext2_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="s">&quot;ext2_free_branches&quot;</span><span class="p">,</span>
					<span class="s">&quot;Read failure, inode=%ld, block=%ld&quot;</span><span class="p">,</span>
					<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ext2_free_branches</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">__le32</span><span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">__le32</span><span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">addr_per_block</span><span class="p">,</span>
					   <span class="n">depth</span><span class="p">);</span>
			<span class="n">bforget</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">ext2_free_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ext2_free_data</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__ext2_truncate_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">i_data</span> <span class="o">=</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">addr_per_block</span> <span class="o">=</span> <span class="n">EXT2_ADDR_PER_BLOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Indirect</span> <span class="n">chain</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Indirect</span> <span class="o">*</span><span class="n">partial</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">iblock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="n">blocksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">iblock</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">EXT2_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">ext2_block_to_path</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * From here we block out all ext2_get_block() callers who want to</span>
<span class="cm">	 * modify the block allocation tree.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">truncate_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext2_free_data</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">i_data</span><span class="o">+</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">i_data</span> <span class="o">+</span> <span class="n">EXT2_NDIR_BLOCKS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">do_indirects</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">partial</span> <span class="o">=</span> <span class="n">ext2_find_shared</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">);</span>
	<span class="cm">/* Kill the top of shared branch (already detached) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">partial</span> <span class="o">==</span> <span class="n">chain</span><span class="p">)</span>
			<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">mark_buffer_dirty_inode</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">ext2_free_branches</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">chain</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">partial</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Clear the ends of indirect blocks on the shared branch */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">partial</span> <span class="o">&gt;</span> <span class="n">chain</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext2_free_branches</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				   <span class="n">partial</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">__le32</span><span class="o">*</span><span class="p">)</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="o">+</span><span class="n">addr_per_block</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">chain</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">partial</span><span class="p">);</span>
		<span class="n">mark_buffer_dirty_inode</span><span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">brelse</span> <span class="p">(</span><span class="n">partial</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">partial</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">do_indirects:</span>
	<span class="cm">/* Kill the remaining (whole) subtrees */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="nl">default:</span>
			<span class="n">nr</span> <span class="o">=</span> <span class="n">i_data</span><span class="p">[</span><span class="n">EXT2_IND_BLOCK</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i_data</span><span class="p">[</span><span class="n">EXT2_IND_BLOCK</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
				<span class="n">ext2_free_branches</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="n">EXT2_IND_BLOCK</span>:
			<span class="n">nr</span> <span class="o">=</span> <span class="n">i_data</span><span class="p">[</span><span class="n">EXT2_DIND_BLOCK</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i_data</span><span class="p">[</span><span class="n">EXT2_DIND_BLOCK</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
				<span class="n">ext2_free_branches</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="n">EXT2_DIND_BLOCK</span>:
			<span class="n">nr</span> <span class="o">=</span> <span class="n">i_data</span><span class="p">[</span><span class="n">EXT2_TIND_BLOCK</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i_data</span><span class="p">[</span><span class="n">EXT2_TIND_BLOCK</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
				<span class="n">ext2_free_branches</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="n">EXT2_TIND_BLOCK</span>:
			<span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ext2_discard_reservation</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">truncate_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext2_truncate_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * XXX: it seems like a bug here that we don&#39;t allow</span>
<span class="cm">	 * IS_APPEND inode to have blocks-past-i_size trimmed off.</span>
<span class="cm">	 * review and fix this.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also would be nice to be able to handle IO errors and such,</span>
<span class="cm">	 * but that&#39;s probably too much to ask.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext2_inode_is_fast_symlink</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_APPEND</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_IMMUTABLE</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">__ext2_truncate_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext2_setsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">newsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext2_inode_is_fast_symlink</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_APPEND</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_IMMUTABLE</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">inode_dio_wait</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping_is_xip</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">xip_truncate_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">NOBH</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">nobh_truncate_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span>
				<span class="n">newsize</span><span class="p">,</span> <span class="n">ext2_get_block</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">block_truncate_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span>
				<span class="n">newsize</span><span class="p">,</span> <span class="n">ext2_get_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">truncate_setsize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>
	<span class="n">__ext2_truncate_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode_needs_sync</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sync_mapping_buffers</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
		<span class="n">sync_inode_metadata</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ext2_inode</span> <span class="o">*</span><span class="nf">ext2_get_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">ino</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block_group</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_group_desc</span> <span class="o">*</span> <span class="n">gdp</span><span class="p">;</span>

	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ino</span> <span class="o">!=</span> <span class="n">EXT2_ROOT_INO</span> <span class="o">&amp;&amp;</span> <span class="n">ino</span> <span class="o">&lt;</span> <span class="n">EXT2_FIRST_INO</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">ino</span> <span class="o">&gt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_inodes_count</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">Einval</span><span class="p">;</span>

	<span class="n">block_group</span> <span class="o">=</span> <span class="p">(</span><span class="n">ino</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">EXT2_INODES_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">gdp</span> <span class="o">=</span> <span class="n">ext2_get_group_desc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block_group</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gdp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Egdp</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Figure out the offset within the block group inode table</span>
<span class="cm">	 */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">ino</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">EXT2_INODES_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="o">*</span> <span class="n">EXT2_INODE_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_inode_table</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">EXT2_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">Eio</span><span class="p">;</span>

	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">EXT2_BLOCK_SIZE</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext2_inode</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

<span class="nl">Einval:</span>
	<span class="n">ext2_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ext2_get_inode&quot;</span><span class="p">,</span> <span class="s">&quot;bad inode number: %lu&quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ino</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
<span class="nl">Eio:</span>
	<span class="n">ext2_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ext2_get_inode&quot;</span><span class="p">,</span>
		   <span class="s">&quot;unable to read inode block - inode=%lu, block=%lu&quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ino</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
<span class="nl">Egdp:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ext2_set_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">S_SYNC</span><span class="o">|</span><span class="n">S_APPEND</span><span class="o">|</span><span class="n">S_IMMUTABLE</span><span class="o">|</span><span class="n">S_NOATIME</span><span class="o">|</span><span class="n">S_DIRSYNC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT2_SYNC_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_SYNC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT2_APPEND_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_APPEND</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT2_IMMUTABLE_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_IMMUTABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT2_NOATIME_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_NOATIME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT2_DIRSYNC_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_DIRSYNC</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Propagate flags from i_flags to EXT2_I(inode)-&gt;i_flags */</span>
<span class="kt">void</span> <span class="nf">ext2_get_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext2_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_flags</span><span class="p">;</span>

	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">EXT2_SYNC_FL</span><span class="o">|</span><span class="n">EXT2_APPEND_FL</span><span class="o">|</span>
			<span class="n">EXT2_IMMUTABLE_FL</span><span class="o">|</span><span class="n">EXT2_NOATIME_FL</span><span class="o">|</span><span class="n">EXT2_DIRSYNC_FL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_SYNC</span><span class="p">)</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">EXT2_SYNC_FL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_APPEND</span><span class="p">)</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">EXT2_APPEND_FL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_IMMUTABLE</span><span class="p">)</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">EXT2_IMMUTABLE_FL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_NOATIME</span><span class="p">)</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">EXT2_NOATIME_FL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_DIRSYNC</span><span class="p">)</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">EXT2_DIRSYNC_FL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ext2_iget</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext2_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_inode</span> <span class="o">*</span><span class="n">raw_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">i_uid</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">i_gid</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">iget_locked</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">raw_inode</span> <span class="o">=</span> <span class="n">ext2_get_inode</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">raw_inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">raw_inode</span><span class="p">);</span>
 		<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">i_uid</span> <span class="o">=</span> <span class="p">(</span><span class="n">uid_t</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_low</span><span class="p">);</span>
	<span class="n">i_gid</span> <span class="o">=</span> <span class="p">(</span><span class="n">gid_t</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_low</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">test_opt</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">NO_UID32</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">i_uid</span> <span class="o">|=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_high</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">i_gid</span> <span class="o">|=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_high</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">i_uid_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">i_uid</span><span class="p">);</span>
	<span class="n">i_gid_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">i_gid</span><span class="p">);</span>
	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_links_count</span><span class="p">));</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="p">(</span><span class="kt">signed</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="p">(</span><span class="kt">signed</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="p">(</span><span class="kt">signed</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dtime</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_dtime</span><span class="p">);</span>
	<span class="cm">/* We now have enough fields to check if the inode was active or not.</span>
<span class="cm">	 * This is needed because nfsd might try to access dead inodes</span>
<span class="cm">	 * the test is that same one that e2fsck uses</span>
<span class="cm">	 * NeilBrown 1999oct15</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dtime</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* this inode is deleted */</span>
		<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_faddr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_faddr</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_frag_no</span> <span class="o">=</span> <span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_frag</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_frag_size</span> <span class="o">=</span> <span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_fsize</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_file_acl</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_file_acl</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dir_acl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">|=</span> <span class="p">((</span><span class="n">__u64</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size_high</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dir_acl</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_dir_acl</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dtime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_group</span> <span class="o">=</span> <span class="p">(</span><span class="n">ino</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">EXT2_INODES_PER_GROUP</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dir_start_lookup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE! The in-memory inode i_data array is in little-endian order</span>
<span class="cm">	 * even on big-endian machines: we do NOT byteswap the block numbers!</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">EXT2_N_BLOCKS</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_file_inode_operations</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext2_use_xip</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_aops_xip</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_xip_file_operations</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">NOBH</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_nobh_aops</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_file_operations</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_aops</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_file_operations</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_dir_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_dir_operations</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">NOBH</span><span class="p">))</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_nobh_aops</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_aops</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext2_inode_is_fast_symlink</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_fast_symlink_inode_operations</span><span class="p">;</span>
			<span class="n">nd_terminate_link</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_symlink_inode_operations</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">NOBH</span><span class="p">))</span>
				<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_nobh_aops</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_aops</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext2_special_inode_operations</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span>
			   <span class="n">old_decode_dev</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">0</span><span class="p">])));</span>
		<span class="k">else</span> 
			<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span>
			   <span class="n">new_decode_dev</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">1</span><span class="p">])));</span>
	<span class="p">}</span>
	<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">ext2_set_inode_flags</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
	
<span class="nl">bad_inode:</span>
	<span class="n">iget_failed</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ext2_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">do_sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext2_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">uid</span> <span class="o">=</span> <span class="n">i_uid_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">gid_t</span> <span class="n">gid</span> <span class="o">=</span> <span class="n">i_gid_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_inode</span> <span class="o">*</span> <span class="n">raw_inode</span> <span class="o">=</span> <span class="n">ext2_get_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">raw_inode</span><span class="p">))</span>
 		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* For fields not not tracking in the in-memory inode,</span>
<span class="cm">	 * initialise them to zero for new inodes. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">EXT2_STATE_NEW</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">raw_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_inode_size</span><span class="p">);</span>

	<span class="n">ext2_get_inode_flags</span><span class="p">(</span><span class="n">ei</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">test_opt</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">NO_UID32</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_low</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">low_16_bits</span><span class="p">(</span><span class="n">uid</span><span class="p">));</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_low</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">low_16_bits</span><span class="p">(</span><span class="n">gid</span><span class="p">));</span>
<span class="cm">/*</span>
<span class="cm"> * Fix up interoperability with old kernels. Otherwise, old inodes get</span>
<span class="cm"> * re-used with the upper 16 bits of the uid/gid intact</span>
<span class="cm"> */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dtime</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_high</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">high_16_bits</span><span class="p">(</span><span class="n">uid</span><span class="p">));</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_high</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">high_16_bits</span><span class="p">(</span><span class="n">gid</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_low</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">fs_high2lowuid</span><span class="p">(</span><span class="n">uid</span><span class="p">));</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_low</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">fs_high2lowgid</span><span class="p">(</span><span class="n">gid</span><span class="p">));</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid_high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_links_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>

	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_dtime</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dtime</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_faddr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_faddr</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_frag</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_frag_no</span><span class="p">;</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_fsize</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_frag_size</span><span class="p">;</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_file_acl</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_file_acl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_dir_acl</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_dir_acl</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size_high</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="mh">0x7fffffffULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EXT2_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					<span class="n">EXT2_FEATURE_RO_COMPAT_LARGE_FILE</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_rev_level</span> <span class="o">==</span>
					<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EXT2_GOOD_OLD_REV</span><span class="p">))</span> <span class="p">{</span>
			       <span class="cm">/* If this is the first large file</span>
<span class="cm">				* created, add a flag to the superblock.</span>
<span class="cm">				*/</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_lock</span><span class="p">);</span>
				<span class="n">ext2_update_dynamic_rev</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
				<span class="n">EXT2_SET_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					<span class="n">EXT2_FEATURE_RO_COMPAT_LARGE_FILE</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_lock</span><span class="p">);</span>
				<span class="n">ext2_write_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_valid_dev</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">old_encode_dev</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">));</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_encode_dev</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">));</span>
			<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">EXT2_N_BLOCKS</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_block</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_sync</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_req</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;IO error syncing ext2 inode [%s:%08lx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ino</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EXT2_STATE_NEW</span><span class="p">;</span>
	<span class="n">brelse</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ext2_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ext2_write_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ext2_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">iattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">inode_change_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_quota_modification</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iattr</span><span class="p">))</span>
		<span class="n">dquot_initialize</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_uid</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">gid_eq</span><span class="p">(</span><span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_gid</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">dquot_transfer</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iattr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ext2_setsize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">setattr_copy</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ext2_acl_chmod</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
