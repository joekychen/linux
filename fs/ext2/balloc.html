<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ext2 › balloc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>balloc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/ext2/balloc.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1993, 1994, 1995</span>
<span class="cm"> * Remy Card (card@masi.ibp.fr)</span>
<span class="cm"> * Laboratoire MASI - Institut Blaise Pascal</span>
<span class="cm"> * Universite Pierre et Marie Curie (Paris VI)</span>
<span class="cm"> *</span>
<span class="cm"> *  Enhanced block allocation by Stephen Tweedie (sct@redhat.com), 1993</span>
<span class="cm"> *  Big-endian to little-endian byte-swapping/bitmaps by</span>
<span class="cm"> *        David S. Miller (davem@caip.rutgers.edu), 1995</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;ext2.h&quot;</span>
<span class="cp">#include &lt;linux/quotaops.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * balloc.c contains the blocks allocation and deallocation routines</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The free blocks are managed by bitmaps.  A file system contains several</span>
<span class="cm"> * blocks groups.  Each group contains 1 bitmap block for blocks, 1 bitmap</span>
<span class="cm"> * block for inodes, N blocks for the inode table and data blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * The file system contains group descriptors which are located after the</span>
<span class="cm"> * super block.  Each descriptor contains the number of the bitmap block and</span>
<span class="cm"> * the free blocks count in the block.  The descriptors are loaded in memory</span>
<span class="cm"> * when a file system is mounted (see ext2_fill_super).</span>
<span class="cm"> */</span>


<span class="cp">#define in_range(b, first, len)	((b) &gt;= (first) &amp;&amp; (b) &lt;= (first) + (len) - 1)</span>

<span class="k">struct</span> <span class="n">ext2_group_desc</span> <span class="o">*</span> <span class="nf">ext2_get_group_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_group</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span> <span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group_desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_group_desc</span> <span class="o">*</span> <span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span> <span class="o">&gt;=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_groups_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext2_error</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ext2_get_group_desc&quot;</span><span class="p">,</span>
			    <span class="s">&quot;block_group &gt;= groups_count - &quot;</span>
			    <span class="s">&quot;block_group = %d, groups_count = %lu&quot;</span><span class="p">,</span>
			    <span class="n">block_group</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_groups_count</span><span class="p">);</span>

		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">group_desc</span> <span class="o">=</span> <span class="n">block_group</span> <span class="o">&gt;&gt;</span> <span class="n">EXT2_DESC_PER_BLOCK_BITS</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">block_group</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EXT2_DESC_PER_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_group_desc</span><span class="p">[</span><span class="n">group_desc</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">ext2_error</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ext2_get_group_desc&quot;</span><span class="p">,</span>
			    <span class="s">&quot;Group descriptor not loaded - &quot;</span>
			    <span class="s">&quot;block_group = %d, group_desc = %lu, desc = %lu&quot;</span><span class="p">,</span>
			     <span class="n">block_group</span><span class="p">,</span> <span class="n">group_desc</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext2_group_desc</span> <span class="o">*</span><span class="p">)</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_group_desc</span><span class="p">[</span><span class="n">group_desc</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span>
		<span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_group_desc</span><span class="p">[</span><span class="n">group_desc</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">desc</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext2_valid_block_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ext2_group_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_group</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext2_grpblk_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">ext2_grpblk_t</span> <span class="n">next_zero_bit</span><span class="p">;</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">bitmap_blk</span><span class="p">;</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">group_first_block</span><span class="p">;</span>

	<span class="n">group_first_block</span> <span class="o">=</span> <span class="n">ext2_group_first_block_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block_group</span><span class="p">);</span>

	<span class="cm">/* check whether block bitmap block number is set */</span>
	<span class="n">bitmap_blk</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_block_bitmap</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">bitmap_blk</span> <span class="o">-</span> <span class="n">group_first_block</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext2_test_bit</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span>
		<span class="cm">/* bad block bitmap */</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="cm">/* check whether the inode bitmap block number is set */</span>
	<span class="n">bitmap_blk</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_inode_bitmap</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">bitmap_blk</span> <span class="o">-</span> <span class="n">group_first_block</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext2_test_bit</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span>
		<span class="cm">/* bad block bitmap */</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="cm">/* check whether the inode table block number is set */</span>
	<span class="n">bitmap_blk</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_inode_table</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">bitmap_blk</span> <span class="o">-</span> <span class="n">group_first_block</span><span class="p">;</span>
	<span class="n">next_zero_bit</span> <span class="o">=</span> <span class="n">ext2_find_next_zero_bit</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span>
				<span class="n">offset</span> <span class="o">+</span> <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_itb_per_group</span><span class="p">,</span>
				<span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_zero_bit</span> <span class="o">&gt;=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_itb_per_group</span><span class="p">)</span>
		<span class="cm">/* good bitmap for inode tables */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="n">ext2_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="s">&quot;Invalid block bitmap - &quot;</span>
			<span class="s">&quot;block_group = %d, block = %lu&quot;</span><span class="p">,</span>
			<span class="n">block_group</span><span class="p">,</span> <span class="n">bitmap_blk</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read the bitmap for a given block_group,and validate the</span>
<span class="cm"> * bits for block/inode/inode tables are set in the bitmaps</span>
<span class="cm"> *</span>
<span class="cm"> * Return buffer_head on success or NULL in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>
<span class="nf">read_block_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext2_group_desc</span> <span class="o">*</span> <span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">bitmap_blk</span><span class="p">;</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">ext2_get_group_desc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block_group</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bitmap_blk</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_block_bitmap</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">bitmap_blk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext2_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			    <span class="s">&quot;Cannot read block bitmap - &quot;</span>
			    <span class="s">&quot;block_group = %d, block_bitmap = %u&quot;</span><span class="p">,</span>
			    <span class="n">block_group</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_block_bitmap</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">bh_uptodate_or_lock</span><span class="p">(</span><span class="n">bh</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bh_submit_read</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">ext2_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			    <span class="s">&quot;Cannot read block bitmap - &quot;</span>
			    <span class="s">&quot;block_group = %d, block_bitmap = %u&quot;</span><span class="p">,</span>
			    <span class="n">block_group</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_block_bitmap</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ext2_valid_block_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">block_group</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * file system mounted not to panic on error, continue with corrupt</span>
<span class="cm">	 * bitmap</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext2_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

		<span class="n">percpu_counter_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_freeblocks_counter</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">group_adjust_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group_no</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ext2_group_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext2_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="n">free_blocks</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">group_no</span><span class="p">));</span>
		<span class="n">free_blocks</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">);</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">free_blocks</span> <span class="o">+</span> <span class="n">count</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">group_no</span><span class="p">));</span>
		<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The reservation window structure operations</span>
<span class="cm"> * --------------------------------------------</span>
<span class="cm"> * Operations include:</span>
<span class="cm"> * dump, find, add, remove, is_empty, find_next_reservable_window, etc.</span>
<span class="cm"> *</span>
<span class="cm"> * We use a red-black tree to represent per-filesystem reservation</span>
<span class="cm"> * windows.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * __rsv_window_dump() -- Dump the filesystem block allocation reservation map</span>
<span class="cm"> * @rb_root:		root of per-filesystem reservation rb tree</span>
<span class="cm"> * @verbose:		verbose mode</span>
<span class="cm"> * @fn:			function which wishes to dump the reservation map</span>
<span class="cm"> *</span>
<span class="cm"> * If verbose is turned on, it will print the whole block reservation</span>
<span class="cm"> * windows(start, end). Otherwise, it will only print out the &quot;bad&quot; windows,</span>
<span class="cm"> * those windows that overlap with their immediate neighbors.</span>
<span class="cm"> */</span>
<span class="cp">#if 1</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__rsv_window_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">verbose</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bad</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="n">bad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Block Allocation Reservation Windows Map (%s):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rsv</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext2_reserve_window_node</span><span class="p">,</span> <span class="n">rsv_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;reservation window 0x%p &quot;</span>
				<span class="s">&quot;start: %lu, end: %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rsv</span><span class="p">,</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span><span class="p">,</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">&amp;&amp;</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">&gt;=</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Bad reservation %p (start &gt;= end)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">rsv</span><span class="p">);</span>
			<span class="n">bad</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">&gt;=</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Bad reservation %p (prev-&gt;end &gt;= start)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">rsv</span><span class="p">);</span>
			<span class="n">bad</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bad</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">verbose</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Restarting reservation walk in verbose mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">verbose</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">rsv</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Window map complete.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bad</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define rsv_window_dump(root, verbose) \</span>
<span class="cp">	__rsv_window_dump((root), (verbose), __func__)</span>
<span class="cp">#else</span>
<span class="cp">#define rsv_window_dump(root, verbose) do {} while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * goal_in_my_reservation()</span>
<span class="cm"> * @rsv:		inode&#39;s reservation window</span>
<span class="cm"> * @grp_goal:		given goal block relative to the allocation block group</span>
<span class="cm"> * @group:		the current allocation block group</span>
<span class="cm"> * @sb:			filesystem super block</span>
<span class="cm"> *</span>
<span class="cm"> * Test if the given goal block (group relative) is within the file&#39;s</span>
<span class="cm"> * own block reservation window range.</span>
<span class="cm"> *</span>
<span class="cm"> * If the reservation window is outside the goal allocation group, return 0;</span>
<span class="cm"> * grp_goal (given goal block) could be -1, which means no specific</span>
<span class="cm"> * goal block. In this case, always return 1.</span>
<span class="cm"> * If the goal block is within the reservation window, return 1;</span>
<span class="cm"> * otherwise, return 0;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">goal_in_my_reservation</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext2_reserve_window</span> <span class="o">*</span><span class="n">rsv</span><span class="p">,</span> <span class="n">ext2_grpblk_t</span> <span class="n">grp_goal</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">group_first_block</span><span class="p">,</span> <span class="n">group_last_block</span><span class="p">;</span>

	<span class="n">group_first_block</span> <span class="o">=</span> <span class="n">ext2_group_first_block_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
	<span class="n">group_last_block</span> <span class="o">=</span> <span class="n">group_first_block</span> <span class="o">+</span> <span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">_rsv_start</span> <span class="o">&gt;</span> <span class="n">group_last_block</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">_rsv_end</span> <span class="o">&lt;</span> <span class="n">group_first_block</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">grp_goal</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">grp_goal</span> <span class="o">+</span> <span class="n">group_first_block</span> <span class="o">&lt;</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">_rsv_start</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">grp_goal</span> <span class="o">+</span> <span class="n">group_first_block</span> <span class="o">&gt;</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">_rsv_end</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * search_reserve_window()</span>
<span class="cm"> * @rb_root:		root of reservation tree</span>
<span class="cm"> * @goal:		target allocation block</span>
<span class="cm"> *</span>
<span class="cm"> * Find the reserved window which includes the goal, or the previous one</span>
<span class="cm"> * if the goal is not in any window.</span>
<span class="cm"> * Returns NULL if there are no windows or if all windows start after the goal.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span>
<span class="nf">search_reserve_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">ext2_fsblk_t</span> <span class="n">goal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rsv</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext2_reserve_window_node</span><span class="p">,</span> <span class="n">rsv_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">goal</span> <span class="o">&lt;</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">goal</span> <span class="o">&gt;</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">rsv</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ve fallen off the end of the tree: the goal wasn&#39;t inside</span>
<span class="cm">	 * any particular node.  OK, the previous node must be to one</span>
<span class="cm">	 * side of the interval containing the goal.  If it&#39;s the RHS,</span>
<span class="cm">	 * we need to back up one.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">&gt;</span> <span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_node</span><span class="p">);</span>
		<span class="n">rsv</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext2_reserve_window_node</span><span class="p">,</span> <span class="n">rsv_node</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rsv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext2_rsv_window_add() -- Insert a window to the block reservation rb tree.</span>
<span class="cm"> * @sb:			super block</span>
<span class="cm"> * @rsv:		reservation window to add</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with rsv_lock held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext2_rsv_window_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rsv_window_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_node</span><span class="p">;</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">this</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext2_reserve_window_node</span><span class="p">,</span> <span class="n">rsv_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rsv_start</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rsv_end</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">rsv_window_dump</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rsv_window_remove() -- unlink a window from the reservation rb tree</span>
<span class="cm"> * @sb:			super block</span>
<span class="cm"> * @rsv:		reservation window to remove</span>
<span class="cm"> *</span>
<span class="cm"> * Mark the block reservation window as not allocated, and unlink it</span>
<span class="cm"> * from the filesystem reservation window rb tree. Must be called with</span>
<span class="cm"> * rsv_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rsv_window_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">=</span> <span class="n">EXT2_RESERVE_WINDOW_NOT_ALLOCATED</span><span class="p">;</span>
	<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">=</span> <span class="n">EXT2_RESERVE_WINDOW_NOT_ALLOCATED</span><span class="p">;</span>
	<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_alloc_hit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rsv_window_root</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * rsv_is_empty() -- Check if the reservation window is allocated.</span>
<span class="cm"> * @rsv:		given reservation window to check</span>
<span class="cm"> *</span>
<span class="cm"> * returns 1 if the end block is EXT2_RESERVE_WINDOW_NOT_ALLOCATED.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rsv_is_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext2_reserve_window</span> <span class="o">*</span><span class="n">rsv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* a valid reservation end block could not be 0 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">_rsv_end</span> <span class="o">==</span> <span class="n">EXT2_RESERVE_WINDOW_NOT_ALLOCATED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext2_init_block_alloc_info()</span>
<span class="cm"> * @inode:		file inode structure</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate and initialize the  reservation window structure, and</span>
<span class="cm"> * link the window to the ext2 inode structure at last</span>
<span class="cm"> *</span>
<span class="cm"> * The reservation window structure is only dynamically allocated</span>
<span class="cm"> * and linked to ext2 inode the first time the open file</span>
<span class="cm"> * needs a new block. So, before every ext2_new_block(s) call, for</span>
<span class="cm"> * regular files, we should check whether the reservation window</span>
<span class="cm"> * structure exists or not. In the latter case, this function is called.</span>
<span class="cm"> * Fail to do so will result in block reservation being turned off for that</span>
<span class="cm"> * open file.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from ext2_get_blocks_handle(), also called</span>
<span class="cm"> * when setting the reservation window size through ioctl before the file</span>
<span class="cm"> * is open for write (needs block allocation).</span>
<span class="cm"> *</span>
<span class="cm"> * Needs truncate_mutex protection prior to calling this function.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext2_init_block_alloc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext2_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext2_block_alloc_info</span> <span class="o">*</span><span class="n">block_i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>

	<span class="n">block_i</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">block_i</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">block_i</span><span class="o">-&gt;</span><span class="n">rsv_window_node</span><span class="p">;</span>

		<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">=</span> <span class="n">EXT2_RESERVE_WINDOW_NOT_ALLOCATED</span><span class="p">;</span>
		<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">=</span> <span class="n">EXT2_RESERVE_WINDOW_NOT_ALLOCATED</span><span class="p">;</span>

	 	<span class="cm">/*</span>
<span class="cm">		 * if filesystem is mounted with NORESERVATION, the goal</span>
<span class="cm">		 * reservation window size is set to zero to indicate</span>
<span class="cm">		 * block reservation is off</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_opt</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">RESERVATION</span><span class="p">))</span>
			<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_goal_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_goal_size</span> <span class="o">=</span> <span class="n">EXT2_DEFAULT_RESERVE_BLOCKS</span><span class="p">;</span>
		<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_alloc_hit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">block_i</span><span class="o">-&gt;</span><span class="n">last_alloc_logical_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">block_i</span><span class="o">-&gt;</span><span class="n">last_alloc_physical_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span> <span class="o">=</span> <span class="n">block_i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext2_discard_reservation()</span>
<span class="cm"> * @inode:		inode</span>
<span class="cm"> *</span>
<span class="cm"> * Discard(free) block reservation window on last file close, or truncate</span>
<span class="cm"> * or at last iput().</span>
<span class="cm"> *</span>
<span class="cm"> * It is being called in three cases:</span>
<span class="cm"> * 	ext2_release_file(): last writer closes the file</span>
<span class="cm"> * 	ext2_clear_inode(): last iput(), when nobody links to this file.</span>
<span class="cm"> * 	ext2_truncate(): when the block indirect map is about to change.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext2_discard_reservation</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext2_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext2_block_alloc_info</span> <span class="o">*</span><span class="n">block_i</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">rsv_lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EXT2_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rsv_window_lock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_i</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">block_i</span><span class="o">-&gt;</span><span class="n">rsv_window_node</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">))</span>
			<span class="n">rsv_window_remove</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">rsv</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext2_free_blocks() -- Free given blocks and update quota and i_blocks</span>
<span class="cm"> * @inode:		inode</span>
<span class="cm"> * @block:		start physcial block to free</span>
<span class="cm"> * @count:		number of blocks to free</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ext2_free_blocks</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bitmap_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block_group</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">overflow</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_sb_info</span> <span class="o">*</span> <span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext2_group_desc</span> <span class="o">*</span> <span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_super_block</span> <span class="o">*</span> <span class="n">es</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">group_freed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">block</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">block</span> <span class="o">||</span>
	    <span class="n">block</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_blocks_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext2_error</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ext2_free_blocks&quot;</span><span class="p">,</span>
			    <span class="s">&quot;Freeing blocks not in datazone - &quot;</span>
			    <span class="s">&quot;block = %lu, count = %lu&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ext2_debug</span> <span class="p">(</span><span class="s">&quot;freeing block(s) %lu-%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

<span class="nl">do_more:</span>
	<span class="n">overflow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">block_group</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">))</span> <span class="o">/</span>
		      <span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">))</span> <span class="o">%</span>
		      <span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check to see if we are freeing blocks across a group</span>
<span class="cm">	 * boundary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">overflow</span> <span class="o">=</span> <span class="n">bit</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">overflow</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="n">bitmap_bh</span> <span class="o">=</span> <span class="n">read_block_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap_bh</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">ext2_get_group_desc</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block_group</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_range</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_block_bitmap</span><span class="p">),</span> <span class="n">block</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">in_range</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_inode_bitmap</span><span class="p">),</span> <span class="n">block</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">in_range</span> <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_inode_table</span><span class="p">),</span>
		      <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_itb_per_group</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">in_range</span> <span class="p">(</span><span class="n">block</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_inode_table</span><span class="p">),</span>
		      <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_itb_per_group</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext2_error</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ext2_free_blocks&quot;</span><span class="p">,</span>
			    <span class="s">&quot;Freeing blocks in system zones - &quot;</span>
			    <span class="s">&quot;Block = %lu, count = %lu&quot;</span><span class="p">,</span>
			    <span class="n">block</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">group_freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext2_clear_bit_atomic</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">block_group</span><span class="p">),</span>
						<span class="n">bit</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ext2_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="s">&quot;bit already cleared for block %lu&quot;</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">group_freed</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_SYNCHRONOUS</span><span class="p">)</span>
		<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>

	<span class="n">group_adjust_blocks</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block_group</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">bh2</span><span class="p">,</span> <span class="n">group_freed</span><span class="p">);</span>
	<span class="n">freed</span> <span class="o">+=</span> <span class="n">group_freed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">overflow</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">overflow</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">do_more</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">error_return:</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="n">release_blocks</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">freed</span><span class="p">);</span>
	<span class="n">dquot_free_block_nodirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">freed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bitmap_search_next_usable_block()</span>
<span class="cm"> * @start:		the starting block (group relative) of the search</span>
<span class="cm"> * @bh:			bufferhead contains the block group bitmap</span>
<span class="cm"> * @maxblocks:		the ending block (group relative) of the reservation</span>
<span class="cm"> *</span>
<span class="cm"> * The bitmap search --- search forward through the actual bitmap on disk until</span>
<span class="cm"> * we find a bit free.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ext2_grpblk_t</span>
<span class="nf">bitmap_search_next_usable_block</span><span class="p">(</span><span class="n">ext2_grpblk_t</span> <span class="n">start</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
					<span class="n">ext2_grpblk_t</span> <span class="n">maxblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext2_grpblk_t</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">ext2_find_next_zero_bit</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">maxblocks</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&gt;=</span> <span class="n">maxblocks</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_next_usable_block()</span>
<span class="cm"> * @start:		the starting block (group relative) to find next</span>
<span class="cm"> * 			allocatable block in bitmap.</span>
<span class="cm"> * @bh:			bufferhead contains the block group bitmap</span>
<span class="cm"> * @maxblocks:		the ending block (group relative) for the search</span>
<span class="cm"> *</span>
<span class="cm"> * Find an allocatable block in a bitmap.  We perform the &quot;most</span>
<span class="cm"> * appropriate allocation&quot; algorithm of looking for a free block near</span>
<span class="cm"> * the initial goal; then for a free byte somewhere in the bitmap;</span>
<span class="cm"> * then for any free bit in the bitmap.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ext2_grpblk_t</span>
<span class="nf">find_next_usable_block</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext2_grpblk_t</span> <span class="n">here</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The goal was occupied; search forward for a free </span>
<span class="cm">		 * block within the next XX blocks.</span>
<span class="cm">		 *</span>
<span class="cm">		 * end_goal is more or less random, but it has to be</span>
<span class="cm">		 * less than EXT2_BLOCKS_PER_GROUP. Aligning up to the</span>
<span class="cm">		 * next 64-bit boundary is simple..</span>
<span class="cm">		 */</span>
		<span class="n">ext2_grpblk_t</span> <span class="n">end_goal</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">63</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">63</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end_goal</span> <span class="o">&gt;</span> <span class="n">maxblocks</span><span class="p">)</span>
			<span class="n">end_goal</span> <span class="o">=</span> <span class="n">maxblocks</span><span class="p">;</span>
		<span class="n">here</span> <span class="o">=</span> <span class="n">ext2_find_next_zero_bit</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">end_goal</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">here</span> <span class="o">&lt;</span> <span class="n">end_goal</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">here</span><span class="p">;</span>
		<span class="n">ext2_debug</span><span class="p">(</span><span class="s">&quot;Bit not found near goal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">here</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">here</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">here</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">here</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">memscan</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">((</span><span class="n">maxblocks</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">here</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">));</span>
	<span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&lt;</span> <span class="n">maxblocks</span> <span class="o">&amp;&amp;</span> <span class="n">next</span> <span class="o">&gt;=</span> <span class="n">here</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">here</span> <span class="o">=</span> <span class="n">bitmap_search_next_usable_block</span><span class="p">(</span><span class="n">here</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">maxblocks</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">here</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext2_try_to_allocate()</span>
<span class="cm"> * @sb:			superblock</span>
<span class="cm"> * @group:		given allocation block group</span>
<span class="cm"> * @bitmap_bh:		bufferhead holds the block bitmap</span>
<span class="cm"> * @grp_goal:		given target block within the group</span>
<span class="cm"> * @count:		target number of blocks to allocate</span>
<span class="cm"> * @my_rsv:		reservation window</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to allocate blocks within a give range. Set the range of allocation</span>
<span class="cm"> * first, then find the first free bit(s) from the bitmap (within the range),</span>
<span class="cm"> * and at last, allocate the blocks by claiming the found free bit as allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * To set the range of this allocation:</span>
<span class="cm"> * 	if there is a reservation window, only try to allocate block(s)</span>
<span class="cm"> * 	from the file&#39;s own reservation window;</span>
<span class="cm"> * 	Otherwise, the allocation range starts from the give goal block,</span>
<span class="cm"> * 	ends at the block group&#39;s last block.</span>
<span class="cm"> *</span>
<span class="cm"> * If we failed to allocate the desired block then we may end up crossing to a</span>
<span class="cm"> * new bitmap.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ext2_try_to_allocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="n">ext2_grpblk_t</span> <span class="n">grp_goal</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext2_reserve_window</span> <span class="o">*</span><span class="n">my_rsv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">group_first_block</span><span class="p">;</span>
       	<span class="n">ext2_grpblk_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* we do allocation within the reservation window if we have a window */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">my_rsv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">group_first_block</span> <span class="o">=</span> <span class="n">ext2_group_first_block_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">_rsv_start</span> <span class="o">&gt;=</span> <span class="n">group_first_block</span><span class="p">)</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">_rsv_start</span> <span class="o">-</span> <span class="n">group_first_block</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* reservation window cross group boundary */</span>
			<span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">_rsv_end</span> <span class="o">-</span> <span class="n">group_first_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
			<span class="cm">/* reservation window crosses group boundary */</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">grp_goal</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">grp_goal</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">))</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">grp_goal</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">grp_goal</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">grp_goal</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">grp_goal</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>

<span class="nl">repeat:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">grp_goal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">grp_goal</span> <span class="o">=</span> <span class="n">find_next_usable_block</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">grp_goal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_access</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_rsv</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span> <span class="o">&amp;&amp;</span> <span class="n">grp_goal</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">&amp;&amp;</span>
					<span class="o">!</span><span class="n">ext2_test_bit</span><span class="p">(</span><span class="n">grp_goal</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					     		<span class="n">bitmap_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">);</span>
			     		<span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">grp_goal</span><span class="o">--</span><span class="p">)</span>
				<span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">grp_goal</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext2_set_bit_atomic</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span> <span class="n">group</span><span class="p">),</span> <span class="n">grp_goal</span><span class="p">,</span>
			       				<span class="n">bitmap_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The block was allocated by another thread, or it was</span>
<span class="cm">		 * allocated and then freed by another thread</span>
<span class="cm">		 */</span>
		<span class="n">start</span><span class="o">++</span><span class="p">;</span>
		<span class="n">grp_goal</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_access</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">num</span><span class="o">++</span><span class="p">;</span>
	<span class="n">grp_goal</span><span class="o">++</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">grp_goal</span> <span class="o">&lt;</span> <span class="n">end</span>
		<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ext2_set_bit_atomic</span><span class="p">(</span><span class="n">sb_bgl_lock</span><span class="p">(</span><span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span> <span class="n">group</span><span class="p">),</span>
					<span class="n">grp_goal</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">num</span><span class="o">++</span><span class="p">;</span>
		<span class="n">grp_goal</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">grp_goal</span> <span class="o">-</span> <span class="n">num</span><span class="p">;</span>
<span class="nl">fail_access:</span>
	<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * 	find_next_reservable_window():</span>
<span class="cm"> *		find a reservable space within the given range.</span>
<span class="cm"> *		It does not allocate the reservation window for now:</span>
<span class="cm"> *		alloc_new_reservation() will do the work later.</span>
<span class="cm"> *</span>
<span class="cm"> * 	@search_head: the head of the searching list;</span>
<span class="cm"> *		This is not necessarily the list head of the whole filesystem</span>
<span class="cm"> *</span>
<span class="cm"> *		We have both head and start_block to assist the search</span>
<span class="cm"> *		for the reservable space. The list starts from head,</span>
<span class="cm"> *		but we will shift to the place where start_block is,</span>
<span class="cm"> *		then start from there, when looking for a reservable space.</span>
<span class="cm"> *</span>
<span class="cm"> * 	@size: the target new reservation window size</span>
<span class="cm"> *</span>
<span class="cm"> * 	@group_first_block: the first block we consider to start</span>
<span class="cm"> *			the real search from</span>
<span class="cm"> *</span>
<span class="cm"> * 	@last_block:</span>
<span class="cm"> *		the maximum block number that our goal reservable space</span>
<span class="cm"> *		could start from. This is normally the last block in this</span>
<span class="cm"> *		group. The search will end when we found the start of next</span>
<span class="cm"> *		possible reservable space is out of this boundary.</span>
<span class="cm"> *		This could handle the cross boundary reservation window</span>
<span class="cm"> *		request.</span>
<span class="cm"> *</span>
<span class="cm"> * 	basically we search from the given range, rather than the whole</span>
<span class="cm"> * 	reservation double linked list, (start_block, last_block)</span>
<span class="cm"> * 	to find a free region that is of my size and has not</span>
<span class="cm"> * 	been reserved.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_next_reservable_window</span><span class="p">(</span>
				<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">search_head</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">my_rsv</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">,</span>
				<span class="n">ext2_fsblk_t</span> <span class="n">start_block</span><span class="p">,</span>
				<span class="n">ext2_fsblk_t</span> <span class="n">last_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">rsv</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">cur</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_goal_size</span><span class="p">;</span>

	<span class="cm">/* TODO: make the start of the reservation window byte-aligned */</span>
	<span class="cm">/* cur = *start_block &amp; ~7;*/</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="n">start_block</span><span class="p">;</span>
	<span class="n">rsv</span> <span class="o">=</span> <span class="n">search_head</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&lt;=</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span><span class="p">)</span>
			<span class="n">cur</span> <span class="o">=</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* TODO?</span>
<span class="cm">		 * in the case we could not find a reservable space</span>
<span class="cm">		 * that is what is expected, during the re-search, we could</span>
<span class="cm">		 * remember what&#39;s the largest reservable space we could have</span>
<span class="cm">		 * and return that one.</span>
<span class="cm">		 *</span>
<span class="cm">		 * For now it will fail if we could not find the reservable</span>
<span class="cm">		 * space with expected-size (or more)...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&gt;</span> <span class="n">last_block</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* fail */</span>

		<span class="n">prev</span> <span class="o">=</span> <span class="n">rsv</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_node</span><span class="p">);</span>
		<span class="n">rsv</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span><span class="k">struct</span> <span class="n">ext2_reserve_window_node</span><span class="p">,</span><span class="n">rsv_node</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Reached the last reservation, we can just append to the</span>
<span class="cm">		 * previous one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Found a reserveable space big enough.  We could</span>
<span class="cm">			 * have a reservation across the group boundary here</span>
<span class="cm">		 	 */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * we come here either :</span>
<span class="cm">	 * when we reach the end of the whole list,</span>
<span class="cm">	 * and there is empty reservable space after last entry in the list.</span>
<span class="cm">	 * append it to the end of the list.</span>
<span class="cm">	 *</span>
<span class="cm">	 * or we found one reservable space in the middle of the list,</span>
<span class="cm">	 * return the reservation window that we could append to.</span>
<span class="cm">	 * succeed.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">my_rsv</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">)))</span>
		<span class="n">rsv_window_remove</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">my_rsv</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let&#39;s book the whole available window for now.  We will check the</span>
<span class="cm">	 * disk bitmap later and then, if there are free blocks then we adjust</span>
<span class="cm">	 * the window size if it&#39;s larger than requested.</span>
<span class="cm">	 * Otherwise, we will remove this node from the tree next time</span>
<span class="cm">	 * call find_next_reservable_window.</span>
<span class="cm">	 */</span>
	<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
	<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_alloc_hit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">my_rsv</span><span class="p">)</span>
		<span class="n">ext2_rsv_window_add</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">my_rsv</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * 	alloc_new_reservation()--allocate a new reservation window</span>
<span class="cm"> *</span>
<span class="cm"> *		To make a new reservation, we search part of the filesystem</span>
<span class="cm"> *		reservation list (the list that inside the group). We try to</span>
<span class="cm"> *		allocate a new reservation window near the allocation goal,</span>
<span class="cm"> *		or the beginning of the group, if there is no goal.</span>
<span class="cm"> *</span>
<span class="cm"> *		We first find a reservable space after the goal, then from</span>
<span class="cm"> *		there, we check the bitmap for the first free block after</span>
<span class="cm"> *		it. If there is no free block until the end of group, then the</span>
<span class="cm"> *		whole group is full, we failed. Otherwise, check if the free</span>
<span class="cm"> *		block is inside the expected reservable space, if so, we</span>
<span class="cm"> *		succeed.</span>
<span class="cm"> *		If the first free block is outside the reservable space, then</span>
<span class="cm"> *		start from the first free block, we search for next available</span>
<span class="cm"> *		space, and go on.</span>
<span class="cm"> *</span>
<span class="cm"> *	on succeed, a new reservation will be found and inserted into the list</span>
<span class="cm"> *	It contains at least one free block, and it does not overlap with other</span>
<span class="cm"> *	reservation windows.</span>
<span class="cm"> *</span>
<span class="cm"> *	failed: we failed to find a reservation window in this group</span>
<span class="cm"> *</span>
<span class="cm"> *	@rsv: the reservation</span>
<span class="cm"> *</span>
<span class="cm"> *	@grp_goal: The goal (group-relative).  It is where the search for a</span>
<span class="cm"> *		free reservable space should start from.</span>
<span class="cm"> *		if we have a goal(goal &gt;0 ), then start from there,</span>
<span class="cm"> *		no goal(goal = -1), we start from the first block</span>
<span class="cm"> *		of the group.</span>
<span class="cm"> *</span>
<span class="cm"> *	@sb: the super block</span>
<span class="cm"> *	@group: the group we are trying to allocate in</span>
<span class="cm"> *	@bitmap_bh: the block group block bitmap</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_new_reservation</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">my_rsv</span><span class="p">,</span>
		<span class="n">ext2_grpblk_t</span> <span class="n">grp_goal</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bitmap_bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">search_head</span><span class="p">;</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">group_first_block</span><span class="p">,</span> <span class="n">group_end_block</span><span class="p">,</span> <span class="n">start_block</span><span class="p">;</span>
	<span class="n">ext2_grpblk_t</span> <span class="n">first_free_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">fs_rsv_root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rsv_window_root</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">rsv_lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rsv_window_lock</span><span class="p">;</span>

	<span class="n">group_first_block</span> <span class="o">=</span> <span class="n">ext2_group_first_block_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
	<span class="n">group_end_block</span> <span class="o">=</span> <span class="n">group_first_block</span> <span class="o">+</span> <span class="p">(</span><span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">grp_goal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">start_block</span> <span class="o">=</span> <span class="n">group_first_block</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">start_block</span> <span class="o">=</span> <span class="n">grp_goal</span> <span class="o">+</span> <span class="n">group_first_block</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_goal_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if the old reservation is cross group boundary</span>
<span class="cm">		 * and if the goal is inside the old reservation window,</span>
<span class="cm">		 * we will come here when we just failed to allocate from</span>
<span class="cm">		 * the first part of the window. We still have another part</span>
<span class="cm">		 * that belongs to the next group. In this case, there is no</span>
<span class="cm">		 * point to discard our window and try to allocate a new one</span>
<span class="cm">		 * in this group(which will fail). we should</span>
<span class="cm">		 * keep the reservation window, just simply move on.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Maybe we could shift the start block of the reservation</span>
<span class="cm">		 * window to the first block of next group.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">&lt;=</span> <span class="n">group_end_block</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">&gt;</span> <span class="n">group_end_block</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">start_block</span> <span class="o">&gt;=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_alloc_hit</span> <span class="o">&gt;</span>
		     <span class="p">(</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">-</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * if the previously allocation hit ratio is</span>
<span class="cm">			 * greater than 1/2, then we double the size of</span>
<span class="cm">			 * the reservation window the next time,</span>
<span class="cm">			 * otherwise we keep the same size window</span>
<span class="cm">			 */</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">EXT2_MAX_RESERVE_BLOCKS</span><span class="p">)</span>
				<span class="n">size</span> <span class="o">=</span> <span class="n">EXT2_MAX_RESERVE_BLOCKS</span><span class="p">;</span>
			<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_goal_size</span><span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * shift the search start to the window near the goal block</span>
<span class="cm">	 */</span>
	<span class="n">search_head</span> <span class="o">=</span> <span class="n">search_reserve_window</span><span class="p">(</span><span class="n">fs_rsv_root</span><span class="p">,</span> <span class="n">start_block</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * find_next_reservable_window() simply finds a reservable window</span>
<span class="cm">	 * inside the given range(start_block, group_end_block).</span>
<span class="cm">	 *</span>
<span class="cm">	 * To make sure the reservation window has a free bit inside it, we</span>
<span class="cm">	 * need to check the bitmap after we found a reservable window.</span>
<span class="cm">	 */</span>
<span class="nl">retry:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">find_next_reservable_window</span><span class="p">(</span><span class="n">search_head</span><span class="p">,</span> <span class="n">my_rsv</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span>
						<span class="n">start_block</span><span class="p">,</span> <span class="n">group_end_block</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">))</span>
			<span class="n">rsv_window_remove</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">my_rsv</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * On success, find_next_reservable_window() returns the</span>
<span class="cm">	 * reservation window where there is a reservable space after it.</span>
<span class="cm">	 * Before we reserve this reservable space, we need</span>
<span class="cm">	 * to make sure there is at least a free block inside this region.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Search the first free bit on the block bitmap.  Search starts from</span>
<span class="cm">	 * the start block of the reservable space we just found.</span>
<span class="cm">	 */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
	<span class="n">first_free_block</span> <span class="o">=</span> <span class="n">bitmap_search_next_usable_block</span><span class="p">(</span>
			<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">-</span> <span class="n">group_first_block</span><span class="p">,</span>
			<span class="n">bitmap_bh</span><span class="p">,</span> <span class="n">group_end_block</span> <span class="o">-</span> <span class="n">group_first_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">first_free_block</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * no free block left on the bitmap, no point</span>
<span class="cm">		 * to reserve the space. return failed.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">))</span>
			<span class="n">rsv_window_remove</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">my_rsv</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* failed */</span>
	<span class="p">}</span>

	<span class="n">start_block</span> <span class="o">=</span> <span class="n">first_free_block</span> <span class="o">+</span> <span class="n">group_first_block</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * check if the first free block is within the</span>
<span class="cm">	 * free space we just reserved</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_block</span> <span class="o">&gt;=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">&amp;&amp;</span> <span class="n">start_block</span> <span class="o">&lt;=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* success */</span>
	<span class="cm">/*</span>
<span class="cm">	 * if the first free bit we found is out of the reservable space</span>
<span class="cm">	 * continue search for next reservable space,</span>
<span class="cm">	 * start from where the free block is,</span>
<span class="cm">	 * we also shift the list head to where we stopped last time</span>
<span class="cm">	 */</span>
	<span class="n">search_head</span> <span class="o">=</span> <span class="n">my_rsv</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * try_to_extend_reservation()</span>
<span class="cm"> * @my_rsv:		given reservation window</span>
<span class="cm"> * @sb:			super block</span>
<span class="cm"> * @size:		the delta to extend</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to expand the reservation window large enough to have</span>
<span class="cm"> * required number of free blocks</span>
<span class="cm"> *</span>
<span class="cm"> * Since ext2_try_to_allocate() will always allocate blocks within</span>
<span class="cm"> * the reservation window range, if the window size is too small,</span>
<span class="cm"> * multiple blocks allocation has to stop at the end of the reservation</span>
<span class="cm"> * window. To make this more efficient, given the total number of</span>
<span class="cm"> * blocks needed and the current size of the window, we try to</span>
<span class="cm"> * expand the reservation window size if necessary on a best-effort</span>
<span class="cm"> * basis before ext2_new_blocks() tries to allocate blocks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">try_to_extend_reservation</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">my_rsv</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">next_rsv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">rsv_lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rsv_window_lock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
		<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">next_rsv</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext2_reserve_window_node</span><span class="p">,</span> <span class="n">rsv_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">next_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">-</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
			<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">=</span> <span class="n">next_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">rsv_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext2_try_to_allocate_with_rsv()</span>
<span class="cm"> * @sb:			superblock</span>
<span class="cm"> * @group:		given allocation block group</span>
<span class="cm"> * @bitmap_bh:		bufferhead holds the block bitmap</span>
<span class="cm"> * @grp_goal:		given target block within the group</span>
<span class="cm"> * @count:		target number of blocks to allocate</span>
<span class="cm"> * @my_rsv:		reservation window</span>
<span class="cm"> *</span>
<span class="cm"> * This is the main function used to allocate a new block and its reservation</span>
<span class="cm"> * window.</span>
<span class="cm"> *</span>
<span class="cm"> * Each time when a new block allocation is need, first try to allocate from</span>
<span class="cm"> * its own reservation.  If it does not have a reservation window, instead of</span>
<span class="cm"> * looking for a free bit on bitmap first, then look up the reservation list to</span>
<span class="cm"> * see if it is inside somebody else&#39;s reservation window, we try to allocate a</span>
<span class="cm"> * reservation window for it starting from the goal first. Then do the block</span>
<span class="cm"> * allocation within the reservation window.</span>
<span class="cm"> *</span>
<span class="cm"> * This will avoid keeping on searching the reservation list again and</span>
<span class="cm"> * again when somebody is looking for a free block (without</span>
<span class="cm"> * reservation), and there are lots of free blocks, but they are all</span>
<span class="cm"> * being reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * We use a red-black tree for the per-filesystem reservation list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ext2_grpblk_t</span>
<span class="nf">ext2_try_to_allocate_with_rsv</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="n">ext2_grpblk_t</span> <span class="n">grp_goal</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span> <span class="n">my_rsv</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">group_first_block</span><span class="p">,</span> <span class="n">group_last_block</span><span class="p">;</span>
	<span class="n">ext2_grpblk_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we don&#39;t deal with reservation when</span>
<span class="cm">	 * filesystem is mounted without reservation</span>
<span class="cm">	 * or the file is not a regular file</span>
<span class="cm">	 * or last attempt to allocate a block with reservation turned on failed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">my_rsv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ext2_try_to_allocate</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">,</span>
						<span class="n">grp_goal</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * grp_goal is a group relative block number (if there is a goal)</span>
<span class="cm">	 * 0 &lt;= grp_goal &lt; EXT2_BLOCKS_PER_GROUP(sb)</span>
<span class="cm">	 * first block is a filesystem wide block number</span>
<span class="cm">	 * first block is the block number of the first block in this group</span>
<span class="cm">	 */</span>
	<span class="n">group_first_block</span> <span class="o">=</span> <span class="n">ext2_group_first_block_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
	<span class="n">group_last_block</span> <span class="o">=</span> <span class="n">group_first_block</span> <span class="o">+</span> <span class="p">(</span><span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Basically we will allocate a new block from inode&#39;s reservation</span>
<span class="cm">	 * window.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need to allocate a new reservation window, if:</span>
<span class="cm">	 * a) inode does not have a reservation window; or</span>
<span class="cm">	 * b) last attempt to allocate a block from existing reservation</span>
<span class="cm">	 *    failed; or</span>
<span class="cm">	 * c) we come here with a goal and with a reservation window</span>
<span class="cm">	 *</span>
<span class="cm">	 * We do not need to allocate a new reservation window if we come here</span>
<span class="cm">	 * at the beginning with a goal and the goal is inside the window, or</span>
<span class="cm">	 * we don&#39;t have a goal but already have a reservation window.</span>
<span class="cm">	 * then we could go to allocate from the reservation window directly.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">goal_in_my_reservation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">,</span>
						<span class="n">grp_goal</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_goal_size</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
				<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_goal_size</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">alloc_new_reservation</span><span class="p">(</span><span class="n">my_rsv</span><span class="p">,</span> <span class="n">grp_goal</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span>
							<span class="n">group</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>			<span class="cm">/* failed */</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">goal_in_my_reservation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">,</span>
							<span class="n">grp_goal</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">sb</span><span class="p">))</span>
				<span class="n">grp_goal</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">grp_goal</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">-</span>
					<span class="p">(</span><span class="n">grp_goal</span> <span class="o">+</span> <span class="n">group_first_block</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">curr</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
				<span class="n">try_to_extend_reservation</span><span class="p">(</span><span class="n">my_rsv</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span>
							<span class="o">*</span><span class="n">count</span> <span class="o">-</span> <span class="n">curr</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_start</span> <span class="o">&gt;</span> <span class="n">group_last_block</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_end</span> <span class="o">&lt;</span> <span class="n">group_first_block</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rsv_window_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_rsv_window_root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ext2_try_to_allocate</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">bitmap_bh</span><span class="p">,</span> <span class="n">grp_goal</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_alloc_hit</span> <span class="o">+=</span> <span class="n">num</span><span class="p">;</span>
			<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>				<span class="cm">/* succeed */</span>
		<span class="p">}</span>
		<span class="n">num</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext2_has_free_blocks()</span>
<span class="cm"> * @sbi:		in-core super block structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Check if filesystem has at least 1 free block available for allocation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext2_has_free_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext2_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">free_blocks</span><span class="p">,</span> <span class="n">root_blocks</span><span class="p">;</span>

	<span class="n">free_blocks</span> <span class="o">=</span> <span class="n">percpu_counter_read_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_freeblocks_counter</span><span class="p">);</span>
	<span class="n">root_blocks</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_r_blocks_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_blocks</span> <span class="o">&lt;</span> <span class="n">root_blocks</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RESOURCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_resuid</span><span class="p">,</span> <span class="n">current_fsuid</span><span class="p">())</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">gid_eq</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_resgid</span><span class="p">,</span> <span class="n">GLOBAL_ROOT_GID</span><span class="p">)</span> <span class="o">||</span>
		 <span class="o">!</span><span class="n">in_group_p</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_resgid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext2_new_blocks() -- core block(s) allocation function</span>
<span class="cm"> * @inode:		file inode</span>
<span class="cm"> * @goal:		given target block(filesystem wide)</span>
<span class="cm"> * @count:		target number of blocks to allocate</span>
<span class="cm"> * @errp:		error code</span>
<span class="cm"> *</span>
<span class="cm"> * ext2_new_blocks uses a goal block to assist allocation.  If the goal is</span>
<span class="cm"> * free, or there is a free block within 32 blocks of the goal, that block</span>
<span class="cm"> * is allocated.  Otherwise a forward search is made for a free block; within </span>
<span class="cm"> * each block group the search first looks for an entire free byte in the block</span>
<span class="cm"> * bitmap, and then for any free bit if that fails.</span>
<span class="cm"> * This function also updates quota and i_blocks field.</span>
<span class="cm"> */</span>
<span class="n">ext2_fsblk_t</span> <span class="nf">ext2_new_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext2_fsblk_t</span> <span class="n">goal</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bitmap_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">gdp_bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">group_no</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">goal_group</span><span class="p">;</span>
	<span class="n">ext2_grpblk_t</span> <span class="n">grp_target_blk</span><span class="p">;</span>	<span class="cm">/* blockgroup relative goal block */</span>
	<span class="n">ext2_grpblk_t</span> <span class="n">grp_alloc_blk</span><span class="p">;</span>	<span class="cm">/* blockgroup-relative allocated block*/</span>
	<span class="n">ext2_fsblk_t</span> <span class="n">ret_block</span><span class="p">;</span>		<span class="cm">/* filesyetem-wide allocated block */</span>
	<span class="kt">int</span> <span class="n">bgi</span><span class="p">;</span>			<span class="cm">/* blockgroup iteration index */</span>
	<span class="kt">int</span> <span class="n">performed_allocation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext2_grpblk_t</span> <span class="n">free_blocks</span><span class="p">;</span>	<span class="cm">/* number of free blocks in a group */</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_group_desc</span> <span class="o">*</span><span class="n">gdp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_super_block</span> <span class="o">*</span><span class="n">es</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_reserve_window_node</span> <span class="o">*</span><span class="n">my_rsv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_block_alloc_info</span> <span class="o">*</span><span class="n">block_i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">windowsz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ngroups</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num</span> <span class="o">=</span> <span class="o">*</span><span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ext2_new_blocks: nonexistent device&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check quota for allocation of this block.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dquot_alloc_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">es</span> <span class="o">=</span> <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="p">;</span>
	<span class="n">ext2_debug</span><span class="p">(</span><span class="s">&quot;goal=%lu.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allocate a block from reservation only when</span>
<span class="cm">	 * filesystem is mounted with reservation(default,-o reservation), and</span>
<span class="cm">	 * it&#39;s a regular file, and</span>
<span class="cm">	 * the desired window size is greater than 0 (One could use ioctl</span>
<span class="cm">	 * command EXT2_IOC_SETRSVSZ to set the window size to 0 to turn off</span>
<span class="cm">	 * reservation on that particular file)</span>
<span class="cm">	 */</span>
	<span class="n">block_i</span> <span class="o">=</span> <span class="n">EXT2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_block_alloc_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">windowsz</span> <span class="o">=</span> <span class="n">block_i</span><span class="o">-&gt;</span><span class="n">rsv_window_node</span><span class="p">.</span><span class="n">rsv_goal_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">windowsz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">my_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">block_i</span><span class="o">-&gt;</span><span class="n">rsv_window_node</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext2_has_free_blocks</span><span class="p">(</span><span class="n">sbi</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * First, test whether the goal block is free.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">goal</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">goal</span> <span class="o">&gt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_blocks_count</span><span class="p">))</span>
		<span class="n">goal</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">);</span>
	<span class="n">group_no</span> <span class="o">=</span> <span class="p">(</span><span class="n">goal</span> <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">))</span> <span class="o">/</span>
			<span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">goal_group</span> <span class="o">=</span> <span class="n">group_no</span><span class="p">;</span>
<span class="nl">retry_alloc:</span>
	<span class="n">gdp</span> <span class="o">=</span> <span class="n">ext2_get_group_desc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group_no</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gdp_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gdp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">io_error</span><span class="p">;</span>

	<span class="n">free_blocks</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * if there is not enough free blocks to make a new resevation</span>
<span class="cm">	 * turn off reservation for this allocation</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">my_rsv</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">free_blocks</span> <span class="o">&lt;</span> <span class="n">windowsz</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">free_blocks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rsv_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_rsv</span><span class="o">-&gt;</span><span class="n">rsv_window</span><span class="p">)))</span>
		<span class="n">my_rsv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">free_blocks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">grp_target_blk</span> <span class="o">=</span> <span class="p">((</span><span class="n">goal</span> <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">))</span> <span class="o">%</span>
				<span class="n">EXT2_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
		<span class="n">bitmap_bh</span> <span class="o">=</span> <span class="n">read_block_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group_no</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap_bh</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">io_error</span><span class="p">;</span>
		<span class="n">grp_alloc_blk</span> <span class="o">=</span> <span class="n">ext2_try_to_allocate_with_rsv</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group_no</span><span class="p">,</span>
					<span class="n">bitmap_bh</span><span class="p">,</span> <span class="n">grp_target_blk</span><span class="p">,</span>
					<span class="n">my_rsv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">grp_alloc_blk</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">allocated</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ngroups</span> <span class="o">=</span> <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_groups_count</span><span class="p">;</span>
	<span class="n">smp_rmb</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now search the rest of the groups.  We assume that</span>
<span class="cm">	 * group_no and gdp correctly point to the last group visited.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bgi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bgi</span> <span class="o">&lt;</span> <span class="n">ngroups</span><span class="p">;</span> <span class="n">bgi</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">group_no</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">group_no</span> <span class="o">&gt;=</span> <span class="n">ngroups</span><span class="p">)</span>
			<span class="n">group_no</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">gdp</span> <span class="o">=</span> <span class="n">ext2_get_group_desc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group_no</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gdp_bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gdp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">io_error</span><span class="p">;</span>

		<span class="n">free_blocks</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * skip this group (and avoid loading bitmap) if there</span>
<span class="cm">		 * are no free blocks</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">free_blocks</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * skip this group if the number of</span>
<span class="cm">		 * free blocks is less than half of the reservation</span>
<span class="cm">		 * window size.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">my_rsv</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">free_blocks</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">windowsz</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
		<span class="n">bitmap_bh</span> <span class="o">=</span> <span class="n">read_block_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group_no</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap_bh</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">io_error</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * try to allocate block(s) from this group, without a goal(-1).</span>
<span class="cm">		 */</span>
		<span class="n">grp_alloc_blk</span> <span class="o">=</span> <span class="n">ext2_try_to_allocate_with_rsv</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group_no</span><span class="p">,</span>
					<span class="n">bitmap_bh</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">my_rsv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">grp_alloc_blk</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">allocated</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We may end up a bogus earlier ENOSPC error due to</span>
<span class="cm">	 * filesystem is &quot;full&quot; of reservations, but</span>
<span class="cm">	 * there maybe indeed free blocks available on disk</span>
<span class="cm">	 * In this case, we just forget about the reservations</span>
<span class="cm">	 * just do block allocation as without reservations.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">my_rsv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">my_rsv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">windowsz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">group_no</span> <span class="o">=</span> <span class="n">goal_group</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry_alloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* No space left on the device */</span>
	<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">allocated:</span>

	<span class="n">ext2_debug</span><span class="p">(</span><span class="s">&quot;using block group %d(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">group_no</span><span class="p">,</span> <span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">);</span>

	<span class="n">ret_block</span> <span class="o">=</span> <span class="n">grp_alloc_blk</span> <span class="o">+</span> <span class="n">ext2_group_first_block_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group_no</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_range</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_block_bitmap</span><span class="p">),</span> <span class="n">ret_block</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">in_range</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_inode_bitmap</span><span class="p">),</span> <span class="n">ret_block</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">in_range</span><span class="p">(</span><span class="n">ret_block</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_inode_table</span><span class="p">),</span>
		      <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_itb_per_group</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">in_range</span><span class="p">(</span><span class="n">ret_block</span> <span class="o">+</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gdp</span><span class="o">-&gt;</span><span class="n">bg_inode_table</span><span class="p">),</span>
		      <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_itb_per_group</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext2_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ext2_new_blocks&quot;</span><span class="p">,</span>
			    <span class="s">&quot;Allocating block in system zone - &quot;</span>
			    <span class="s">&quot;blocks from &quot;</span><span class="n">E2FSBLK</span><span class="s">&quot;, length %lu&quot;</span><span class="p">,</span>
			    <span class="n">ret_block</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * ext2_try_to_allocate marked the blocks we allocated as in</span>
<span class="cm">		 * use.  So we may want to selectively mark some of the blocks</span>
<span class="cm">		 * as free</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">retry_alloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">performed_allocation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_block</span> <span class="o">+</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_blocks_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext2_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;ext2_new_blocks&quot;</span><span class="p">,</span>
			    <span class="s">&quot;block(&quot;</span><span class="n">E2FSBLK</span><span class="s">&quot;) &gt;= blocks count(%d) - &quot;</span>
			    <span class="s">&quot;block_group = %d, es == %p &quot;</span><span class="p">,</span> <span class="n">ret_block</span><span class="p">,</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_blocks_count</span><span class="p">),</span> <span class="n">group_no</span><span class="p">,</span> <span class="n">es</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">group_adjust_blocks</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group_no</span><span class="p">,</span> <span class="n">gdp</span><span class="p">,</span> <span class="n">gdp_bh</span><span class="p">,</span> <span class="o">-</span><span class="n">num</span><span class="p">);</span>
	<span class="n">percpu_counter_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_freeblocks_counter</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>

	<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_SYNCHRONOUS</span><span class="p">)</span>
		<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>

	<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="n">dquot_free_block_nodirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">*</span><span class="n">count</span><span class="o">-</span><span class="n">num</span><span class="p">);</span>
	<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret_block</span><span class="p">;</span>

<span class="nl">io_error:</span>
	<span class="o">*</span><span class="n">errp</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Undo the block allocation</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">performed_allocation</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dquot_free_block_nodirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">*</span><span class="n">count</span><span class="p">);</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ext2_fsblk_t</span> <span class="nf">ext2_new_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ext2_new_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">errp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef EXT2FS_DEBUG</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">nibblemap</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ext2_count_free</span> <span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numchars</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numchars</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">nibblemap</span><span class="p">[</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">]</span> <span class="o">+</span>
			<span class="n">nibblemap</span><span class="p">[(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">];</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sum</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif  </span><span class="cm">/*  EXT2FS_DEBUG  */</span><span class="cp"></span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ext2_count_free_blocks</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext2_group_desc</span> <span class="o">*</span> <span class="n">desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">desc_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#ifdef EXT2FS_DEBUG</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bitmap_count</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext2_super_block</span> <span class="o">*</span><span class="n">es</span><span class="p">;</span>

	<span class="n">es</span> <span class="o">=</span> <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="p">;</span>
	<span class="n">desc_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bitmap_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_groups_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bitmap_bh</span><span class="p">;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">ext2_get_group_desc</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">desc_count</span> <span class="o">+=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">);</span>
		<span class="n">bitmap_bh</span> <span class="o">=</span> <span class="n">read_block_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap_bh</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		
		<span class="n">x</span> <span class="o">=</span> <span class="n">ext2_count_free</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
		<span class="n">printk</span> <span class="p">(</span><span class="s">&quot;group %d: stored = %d, counted = %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">),</span> <span class="n">x</span><span class="p">);</span>
		<span class="n">bitmap_count</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap_bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ext2_count_free_blocks: stored = %lu, computed = %lu, %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_free_blocks_count</span><span class="p">),</span>
		<span class="n">desc_count</span><span class="p">,</span> <span class="n">bitmap_count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bitmap_count</span><span class="p">;</span>
<span class="cp">#else</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_groups_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">desc</span> <span class="o">=</span> <span class="n">ext2_get_group_desc</span> <span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
                        <span class="k">continue</span><span class="p">;</span>
                <span class="n">desc_count</span> <span class="o">+=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bg_free_blocks_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">desc_count</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">test_root</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">num</span><span class="p">)</span>
		<span class="n">num</span> <span class="o">*=</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">num</span> <span class="o">==</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext2_group_sparse</span><span class="p">(</span><span class="kt">int</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">test_root</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="n">test_root</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">test_root</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="mi">7</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext2_bg_has_super - number of blocks used by the superblock in group</span>
<span class="cm"> *	@sb: superblock for filesystem</span>
<span class="cm"> *	@group: group number to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the number of blocks used by the superblock (primary or backup)</span>
<span class="cm"> *	in this group.  Currently this will be only 0 or 1.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext2_bg_has_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT2_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span><span class="n">EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER</span><span class="p">)</span><span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">ext2_group_sparse</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ext2_bg_num_gdb - number of blocks used by the group table in group</span>
<span class="cm"> *	@sb: superblock for filesystem</span>
<span class="cm"> *	@group: group number to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the number of blocks used by the group descriptor table</span>
<span class="cm"> *	(primary or backup) in this group.  In the future there may be a</span>
<span class="cm"> *	different number of descriptor blocks in each group.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ext2_bg_num_gdb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ext2_bg_has_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span> <span class="o">?</span> <span class="n">EXT2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_gdb_count</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
