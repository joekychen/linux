<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › binfmt_flat.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>binfmt_flat.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************/</span>
<span class="cm">/*</span>
<span class="cm"> *  linux/fs/binfmt_flat.c</span>
<span class="cm"> *</span>
<span class="cm"> *	Copyright (C) 2000-2003 David McCullough &lt;davidm@snapgear.com&gt;</span>
<span class="cm"> *	Copyright (C) 2002 Greg Ungerer &lt;gerg@snapgear.com&gt;</span>
<span class="cm"> *	Copyright (C) 2002 SnapGear, by Paul Dale &lt;pauli@snapgear.com&gt;</span>
<span class="cm"> *	Copyright (C) 2000, 2001 Lineo, by David McCullough &lt;davidm@lineo.com&gt;</span>
<span class="cm"> *  based heavily on:</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/fs/binfmt_aout.c:</span>
<span class="cm"> *      Copyright (C) 1991, 1992, 1996  Linus Torvalds</span>
<span class="cm"> *  linux/fs/binfmt_flat.c for 2.0 kernel</span>
<span class="cm"> *	    Copyright (C) 1998  Kenneth Albanowski &lt;kjahds@kjahds.com&gt;</span>
<span class="cm"> *	JAN/99 -- coded full program relocation (gerg@snapgear.com)</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/user.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/binfmts.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/flat.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="cm">/****************************************************************************/</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define DEBUG 1</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define	DBG_FLT(a...)	printk(a)</span>
<span class="cp">#else</span>
<span class="cp">#define	DBG_FLT(a...)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * User data (data section and bss) needs to be aligned.</span>
<span class="cm"> * We pick 0x20 here because it is the max value elf2flt has always</span>
<span class="cm"> * used in producing FLAT files, and because it seems to be large</span>
<span class="cm"> * enough to make all the gcc alignment related tests happy.</span>
<span class="cm"> */</span>
<span class="cp">#define FLAT_DATA_ALIGN	(0x20)</span>

<span class="cm">/*</span>
<span class="cm"> * User data (stack) also needs to be aligned.</span>
<span class="cm"> * Here we can be a bit looser than the data sections since this</span>
<span class="cm"> * needs to only meet arch ABI requirements.</span>
<span class="cm"> */</span>
<span class="cp">#define FLAT_STACK_ALIGN	max_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)</span>

<span class="cp">#define RELOC_FAILED 0xff00ff01		</span><span class="cm">/* Relocation incorrect somewhere */</span><span class="cp"></span>
<span class="cp">#define UNLOADED_LIB 0x7ff000ff		</span><span class="cm">/* Placeholder for unused library */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">lib_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_code</span><span class="p">;</span>		<span class="cm">/* Start of text segment */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_data</span><span class="p">;</span>		<span class="cm">/* Start of data segment */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_brk</span><span class="p">;</span>		<span class="cm">/* End of data segment */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">text_len</span><span class="p">;</span>			<span class="cm">/* Length of text segment */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry</span><span class="p">;</span>			<span class="cm">/* Start address for this module */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">build_date</span><span class="p">;</span>		<span class="cm">/* When this one was compiled */</span>
		<span class="kt">short</span> <span class="n">loaded</span><span class="p">;</span>				<span class="cm">/* Has this library been loaded? */</span>
	<span class="p">}</span> <span class="n">lib_list</span><span class="p">[</span><span class="n">MAX_SHARED_LIBS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_BINFMT_SHARED_FLAT</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">load_flat_shared_library</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lib_info</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">load_flat_binary</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span> <span class="n">regs</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">flat_core_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">coredump_params</span> <span class="o">*</span><span class="n">cprm</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">linux_binfmt</span> <span class="n">flat_format</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">load_binary</span>	<span class="o">=</span> <span class="n">load_flat_binary</span><span class="p">,</span>
	<span class="p">.</span><span class="n">core_dump</span>	<span class="o">=</span> <span class="n">flat_core_dump</span><span class="p">,</span>
	<span class="p">.</span><span class="n">min_coredump</span>	<span class="o">=</span> <span class="n">PAGE_SIZE</span>
<span class="p">};</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Routine writes a core dump image in the current directory.</span>
<span class="cm"> * Currently only a stub-function.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">flat_core_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">coredump_params</span> <span class="o">*</span><span class="n">cprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Process %s:%d received signr %d and should have core dumped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">cprm</span><span class="o">-&gt;</span><span class="n">signr</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************/</span>
<span class="cm">/*</span>
<span class="cm"> * create_flat_tables() parses the env- and arg-strings in new user</span>
<span class="cm"> * memory and creates the pointer tables from them, and puts their</span>
<span class="cm"> * addresses on the &quot;stack&quot;, returning the new stack pointer value.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">create_flat_tables</span><span class="p">(</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span> <span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">argv</span><span class="p">,</span><span class="o">*</span><span class="n">envp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">sp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">argc</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">envc</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">envc</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">-=</span> <span class="p">(</span><span class="n">envc</span> <span class="o">+</span> <span class="n">argc</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">flat_argvp_envp_on_stack</span><span class="p">()</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sp</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">FLAT_STACK_ALIGN</span><span class="p">);</span>
	<span class="n">argv</span> <span class="o">=</span> <span class="n">sp</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">flat_argvp_envp_on_stack</span><span class="p">()</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">envp</span> <span class="o">=</span> <span class="n">argv</span> <span class="o">+</span> <span class="p">(</span><span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flat_argvp_envp_on_stack</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">put_user</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">envp</span><span class="p">,</span> <span class="n">sp</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">put_user</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">argv</span><span class="p">,</span> <span class="n">sp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">put_user</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">argc</span><span class="o">--&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_user</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="p">,</span> <span class="n">argv</span><span class="o">++</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">get_user</span><span class="p">(</span><span class="n">dummy</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> <span class="n">p</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_user</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_end</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">env_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">envc</span><span class="o">--&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_user</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span> <span class="n">envp</span><span class="o">++</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">get_user</span><span class="p">(</span><span class="n">dummy</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> <span class="n">p</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_user</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">env_end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************/</span>

<span class="cp">#ifdef CONFIG_BINFMT_ZFLAT</span>

<span class="cp">#include &lt;linux/zlib.h&gt;</span>

<span class="cp">#define LBUFSIZE	4000</span>

<span class="cm">/* gzip flag byte */</span>
<span class="cp">#define ASCII_FLAG   0x01 </span><span class="cm">/* bit 0 set: file probably ASCII text */</span><span class="cp"></span>
<span class="cp">#define CONTINUATION 0x02 </span><span class="cm">/* bit 1 set: continuation of multi-part gzip file */</span><span class="cp"></span>
<span class="cp">#define EXTRA_FIELD  0x04 </span><span class="cm">/* bit 2 set: extra field present */</span><span class="cp"></span>
<span class="cp">#define ORIG_NAME    0x08 </span><span class="cm">/* bit 3 set: original file name present */</span><span class="cp"></span>
<span class="cp">#define COMMENT      0x10 </span><span class="cm">/* bit 4 set: file comment present */</span><span class="cp"></span>
<span class="cp">#define ENCRYPTED    0x20 </span><span class="cm">/* bit 5 set: file is encrypted */</span><span class="cp"></span>
<span class="cp">#define RESERVED     0xC0 </span><span class="cm">/* bit 6,7:   reserved */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decompress_exec</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
	<span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">z_stream</span> <span class="n">strm</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">fpos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;decompress_exec(offset=%x,buf=%x,len=%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">offset</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">dst</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">len</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">strm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">strm</span><span class="p">));</span>
	<span class="n">strm</span><span class="p">.</span><span class="n">workspace</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">zlib_inflate_workspacesize</span><span class="p">(),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strm</span><span class="p">.</span><span class="n">workspace</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;binfmt_flat: no memory for decompress workspace</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">LBUFSIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;binfmt_flat: no memory for read buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Read in first chunk of data and parse gzip header. */</span>
	<span class="n">fpos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">LBUFSIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpos</span><span class="p">);</span>

	<span class="n">strm</span><span class="p">.</span><span class="n">next_in</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">strm</span><span class="p">.</span><span class="n">avail_in</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">strm</span><span class="p">.</span><span class="n">total_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>

	<span class="cm">/* Check minimum size -- gzip header */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;binfmt_flat: file too small?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check gzip magic number */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mo">037</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mo">0213</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mo">0236</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;binfmt_flat: unknown compression magic?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check gzip method */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;binfmt_flat: unknown compression method?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_buf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check gzip flags */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">ENCRYPTED</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">CONTINUATION</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RESERVED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;binfmt_flat: unknown flags?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">EXTRA_FIELD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">buf</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">LBUFSIZE</span> <span class="o">&lt;=</span> <span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;binfmt_flat: buffer overflow (EXTRA)?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_buf</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">ORIG_NAME</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">LBUFSIZE</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="n">ret</span><span class="o">++</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">LBUFSIZE</span> <span class="o">==</span> <span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;binfmt_flat: buffer overflow (ORIG_NAME)?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_buf</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">COMMENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">LBUFSIZE</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="n">ret</span><span class="o">++</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">LBUFSIZE</span> <span class="o">==</span> <span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;binfmt_flat: buffer overflow (COMMENT)?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_buf</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">strm</span><span class="p">.</span><span class="n">next_in</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">strm</span><span class="p">.</span><span class="n">avail_in</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">strm</span><span class="p">.</span><span class="n">next_out</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
	<span class="n">strm</span><span class="p">.</span><span class="n">avail_out</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">strm</span><span class="p">.</span><span class="n">total_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">zlib_inflateInit2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">strm</span><span class="p">,</span> <span class="o">-</span><span class="n">MAX_WBITS</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Z_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;binfmt_flat: zlib init failed?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">zlib_inflate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">strm</span><span class="p">,</span> <span class="n">Z_NO_FLUSH</span><span class="p">))</span> <span class="o">==</span> <span class="n">Z_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">LBUFSIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">strm</span><span class="p">.</span><span class="n">next_in</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="n">strm</span><span class="p">.</span><span class="n">avail_in</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">strm</span><span class="p">.</span><span class="n">total_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;binfmt_flat: decompression failed (%d), %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ret</span><span class="p">,</span> <span class="n">strm</span><span class="p">.</span><span class="n">msg</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_zlib</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_zlib:</span>
	<span class="n">zlib_inflateEnd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">strm</span><span class="p">);</span>
<span class="nl">out_free_buf:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">strm</span><span class="p">.</span><span class="n">workspace</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_BINFMT_ZFLAT */</span><span class="cp"></span>

<span class="cm">/****************************************************************************/</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">calc_reloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lib_info</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">curid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">internalp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_brk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">text_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_code</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_BINFMT_SHARED_FLAT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">curid</span><span class="p">;</span>	<span class="cm">/* Relocs of 0 are always self referring */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>	<span class="cm">/* Find ID for this reloc */</span>
		<span class="n">r</span> <span class="o">&amp;=</span> <span class="mh">0x00ffffff</span><span class="p">;</span>	<span class="cm">/* Trim ID off here */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">MAX_SHARED_LIBS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BINFMT_FLAT: reference 0x%x to shared library %d&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">r</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curid</span> <span class="o">!=</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">internalp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BINFMT_FLAT: reloc address 0x%x not in same module &quot;</span>
					<span class="s">&quot;(%d != %d)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">r</span><span class="p">,</span> <span class="n">curid</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">loaded</span> <span class="o">&amp;&amp;</span>
				<span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">load_flat_shared_library</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BINFMT_FLAT: failed to load library %d&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Check versioning information (i.e. time stamps) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">build_date</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">curid</span><span class="p">].</span><span class="n">build_date</span> <span class="o">&amp;&amp;</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">curid</span><span class="p">].</span><span class="n">build_date</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">build_date</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BINFMT_FLAT: library %d is younger than %d&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">curid</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">start_brk</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">start_brk</span><span class="p">;</span>
	<span class="n">start_data</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">start_data</span><span class="p">;</span>
	<span class="n">start_code</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">start_code</span><span class="p">;</span>
	<span class="n">text_len</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">text_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flat_reloc_valid</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">start_brk</span> <span class="o">-</span> <span class="n">start_data</span> <span class="o">+</span> <span class="n">text_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BINFMT_FLAT: reloc outside program 0x%x (0 - 0x%x/0x%x)&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">r</span><span class="p">,(</span><span class="kt">int</span><span class="p">)(</span><span class="n">start_brk</span><span class="o">-</span><span class="n">start_data</span><span class="o">+</span><span class="n">text_len</span><span class="p">),(</span><span class="kt">int</span><span class="p">)</span><span class="n">text_len</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">text_len</span><span class="p">)</span>			<span class="cm">/* In text segment */</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">start_code</span><span class="p">;</span>
	<span class="k">else</span>					<span class="cm">/* In data segment */</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">text_len</span> <span class="o">+</span> <span class="n">start_data</span><span class="p">;</span>

	<span class="cm">/* Range checked already above so doing the range tests is redundant...*/</span>
	<span class="k">return</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

<span class="nl">failed:</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, killing %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
	<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">RELOC_FAILED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************/</span>

<span class="kt">void</span> <span class="nf">old_reloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rl</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">segment</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;TEXT&quot;</span><span class="p">,</span> <span class="s">&quot;DATA&quot;</span><span class="p">,</span> <span class="s">&quot;BSS&quot;</span><span class="p">,</span> <span class="s">&quot;*UNKNOWN*&quot;</span> <span class="p">};</span>
<span class="cp">#endif</span>
	<span class="n">flat_v2_reloc_t</span>	<span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	
	<span class="n">r</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">rl</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_COLDFIRE)</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_code</span> <span class="o">+</span> <span class="n">r</span><span class="p">.</span><span class="n">reloc</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_data</span> <span class="o">+</span> <span class="n">r</span><span class="p">.</span><span class="n">reloc</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Relocation of variable at DATASEG+%x &quot;</span>
		<span class="s">&quot;(address %p, currently %x) into segment %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">r</span><span class="p">.</span><span class="n">reloc</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">segment</span><span class="p">[</span><span class="n">r</span><span class="p">.</span><span class="n">reloc</span><span class="p">.</span><span class="n">type</span><span class="p">]);</span>
<span class="cp">#endif</span>
	
	<span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">reloc</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OLD_FLAT_RELOC_TYPE_TEXT</span>:
		<span class="o">*</span><span class="n">ptr</span> <span class="o">+=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_code</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OLD_FLAT_RELOC_TYPE_DATA</span>:
		<span class="o">*</span><span class="n">ptr</span> <span class="o">+=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OLD_FLAT_RELOC_TYPE_BSS</span>:
		<span class="o">*</span><span class="n">ptr</span> <span class="o">+=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">end_data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BINFMT_FLAT: Unknown relocation type=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">reloc</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Relocation became %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>		

<span class="cm">/****************************************************************************/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_flat_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span> <span class="n">bprm</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lib_info</span> <span class="o">*</span><span class="n">libinfo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">extra_stack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">flat_hdr</span> <span class="o">*</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">textpos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">datapos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">realdatastart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">text_len</span><span class="p">,</span> <span class="n">data_len</span><span class="p">,</span> <span class="n">bss_len</span><span class="p">,</span> <span class="n">stack_len</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="n">memp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memp_size</span><span class="p">,</span> <span class="n">extra</span><span class="p">,</span> <span class="n">rlim</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">reloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rev</span><span class="p">,</span> <span class="n">relocs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">fpos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_code</span><span class="p">,</span> <span class="n">end_code</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">flat_hdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>		<span class="cm">/* exec-header */</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">text_len</span>  <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_start</span><span class="p">);</span>
	<span class="n">data_len</span>  <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_end</span><span class="p">)</span> <span class="o">-</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_start</span><span class="p">);</span>
	<span class="n">bss_len</span>   <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bss_end</span><span class="p">)</span> <span class="o">-</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_end</span><span class="p">);</span>
	<span class="n">stack_len</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">stack_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extra_stack</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stack_len</span> <span class="o">+=</span> <span class="o">*</span><span class="n">extra_stack</span><span class="p">;</span>
		<span class="o">*</span><span class="n">extra_stack</span> <span class="o">=</span> <span class="n">stack_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">relocs</span>    <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">reloc_count</span><span class="p">);</span>
	<span class="n">flags</span>     <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">rev</span>       <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">,</span> <span class="s">&quot;bFLT&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Previously, here was a printk to tell people</span>
<span class="cm">		 *   &quot;BINFMT_FLAT: bad header magic&quot;.</span>
<span class="cm">		 * But for the kernel which also use ELF FD-PIC format, this</span>
<span class="cm">		 * error message is confusing.</span>
<span class="cm">		 * because a lot of people do not manage to produce good</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAT_FLAG_KTRACE</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BINFMT_FLAT: Loading file: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rev</span> <span class="o">!=</span> <span class="n">FLAT_VERSION</span> <span class="o">&amp;&amp;</span> <span class="n">rev</span> <span class="o">!=</span> <span class="n">OLD_FLAT_VERSION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BINFMT_FLAT: bad flat file version 0x%x (supported &quot;</span>
			<span class="s">&quot;0x%lx and 0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rev</span><span class="p">,</span> <span class="n">FLAT_VERSION</span><span class="p">,</span> <span class="n">OLD_FLAT_VERSION</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="cm">/* Don&#39;t allow old format executables to use shared libraries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rev</span> <span class="o">==</span> <span class="n">OLD_FLAT_VERSION</span> <span class="o">&amp;&amp;</span> <span class="n">id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BINFMT_FLAT: shared libraries are not available before rev 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">FLAT_VERSION</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * fix up the flags for the older format,  there were all kinds</span>
<span class="cm">	 * of endian hacks,  this only works for the simple cases</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rev</span> <span class="o">==</span> <span class="n">OLD_FLAT_VERSION</span> <span class="o">&amp;&amp;</span> <span class="n">flat_old_ram_flag</span><span class="p">(</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">FLAT_FLAG_RAM</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_BINFMT_ZFLAT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FLAT_FLAG_GZIP</span><span class="o">|</span><span class="n">FLAT_FLAG_GZDATA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Support for ZFLAT executables is not enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check initial limits. This avoids letting people circumvent</span>
<span class="cm">	 * size limits imposed on them by creating programs with large</span>
<span class="cm">	 * arrays in the data or bss.</span>
<span class="cm">	 */</span>
	<span class="n">rlim</span> <span class="o">=</span> <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_DATA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rlim</span> <span class="o">&gt;=</span> <span class="n">RLIM_INFINITY</span><span class="p">)</span>
		<span class="n">rlim</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data_len</span> <span class="o">+</span> <span class="n">bss_len</span> <span class="o">&gt;</span> <span class="n">rlim</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Flush all traces of the currently running executable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">flush_old_exec</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* OK, This is the point of no return */</span>
		<span class="n">set_personality</span><span class="p">(</span><span class="n">PER_LINUX_32BIT</span><span class="p">);</span>
		<span class="n">setup_new_exec</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * calculate the extra space we need to map in</span>
<span class="cm">	 */</span>
	<span class="n">extra</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">bss_len</span> <span class="o">+</span> <span class="n">stack_len</span><span class="p">,</span>
			<span class="n">relocs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * there are a couple of cases here,  the separate code/data</span>
<span class="cm">	 * case,  and then the fully copied to RAM case which lumps</span>
<span class="cm">	 * it all together.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FLAT_FLAG_RAM</span><span class="o">|</span><span class="n">FLAT_FLAG_GZIP</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * this should give us a ROM ptr,  but if it doesn&#39;t we don&#39;t</span>
<span class="cm">		 * really care</span>
<span class="cm">		 */</span>
		<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;BINFMT_FLAT: ROM mapping of file (we hope)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">textpos</span> <span class="o">=</span> <span class="n">vm_mmap</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">text_len</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_EXEC</span><span class="p">,</span>
				  <span class="n">MAP_PRIVATE</span><span class="o">|</span><span class="n">MAP_EXECUTABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">textpos</span> <span class="o">||</span> <span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">textpos</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">textpos</span><span class="p">)</span>
				<span class="n">textpos</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unable to mmap process text, errno %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="n">textpos</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">textpos</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">data_len</span> <span class="o">+</span> <span class="n">extra</span> <span class="o">+</span> <span class="n">MAX_SHARED_LIBS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
		<span class="n">realdatastart</span> <span class="o">=</span> <span class="n">vm_mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
			<span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="o">|</span><span class="n">PROT_EXEC</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">realdatastart</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">realdatastart</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">realdatastart</span><span class="p">)</span>
				<span class="n">realdatastart</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unable to allocate RAM for process data, errno %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="n">realdatastart</span><span class="p">);</span>
			<span class="n">vm_munmap</span><span class="p">(</span><span class="n">textpos</span><span class="p">,</span> <span class="n">text_len</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">realdatastart</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">datapos</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">realdatastart</span> <span class="o">+</span>
				<span class="n">MAX_SHARED_LIBS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
				<span class="n">FLAT_DATA_ALIGN</span><span class="p">);</span>

		<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;BINFMT_FLAT: Allocated data+bss+stack (%d bytes): %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">data_len</span> <span class="o">+</span> <span class="n">bss_len</span> <span class="o">+</span> <span class="n">stack_len</span><span class="p">),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">datapos</span><span class="p">);</span>

		<span class="n">fpos</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_start</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_BINFMT_ZFLAT</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAT_FLAG_GZDATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">decompress_exec</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="n">fpos</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">datapos</span><span class="p">,</span> 
						 <span class="n">data_len</span> <span class="o">+</span> <span class="p">(</span><span class="n">relocs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
		<span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">datapos</span><span class="p">,</span>
					<span class="n">data_len</span> <span class="o">+</span> <span class="p">(</span><span class="n">relocs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)),</span> <span class="o">&amp;</span><span class="n">fpos</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unable to read data+bss, errno %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="n">result</span><span class="p">);</span>
			<span class="n">vm_munmap</span><span class="p">(</span><span class="n">textpos</span><span class="p">,</span> <span class="n">text_len</span><span class="p">);</span>
			<span class="n">vm_munmap</span><span class="p">(</span><span class="n">realdatastart</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">reloc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">datapos</span><span class="o">+</span><span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">reloc_start</span><span class="p">)</span><span class="o">-</span><span class="n">text_len</span><span class="p">));</span>
		<span class="n">memp</span> <span class="o">=</span> <span class="n">realdatastart</span><span class="p">;</span>
		<span class="n">memp_size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">text_len</span> <span class="o">+</span> <span class="n">data_len</span> <span class="o">+</span> <span class="n">extra</span> <span class="o">+</span> <span class="n">MAX_SHARED_LIBS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
		<span class="n">textpos</span> <span class="o">=</span> <span class="n">vm_mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
			<span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_EXEC</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">textpos</span> <span class="o">||</span> <span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">textpos</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">textpos</span><span class="p">)</span>
				<span class="n">textpos</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unable to allocate RAM for process text/data, errno %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="n">textpos</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">textpos</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">realdatastart</span> <span class="o">=</span> <span class="n">textpos</span> <span class="o">+</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_start</span><span class="p">);</span>
		<span class="n">datapos</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">realdatastart</span> <span class="o">+</span>
				<span class="n">MAX_SHARED_LIBS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
				<span class="n">FLAT_DATA_ALIGN</span><span class="p">);</span>

		<span class="n">reloc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">(</span><span class="n">datapos</span> <span class="o">+</span> <span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">reloc_start</span><span class="p">)</span> <span class="o">-</span> <span class="n">text_len</span><span class="p">));</span>
		<span class="n">memp</span> <span class="o">=</span> <span class="n">textpos</span><span class="p">;</span>
		<span class="n">memp_size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BINFMT_ZFLAT</span>
		<span class="cm">/*</span>
<span class="cm">		 * load it all in and treat it like a RAM load from now on</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAT_FLAG_GZIP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">decompress_exec</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">flat_hdr</span><span class="p">),</span>
					 <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">textpos</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">flat_hdr</span><span class="p">)),</span>
					 <span class="p">(</span><span class="n">text_len</span> <span class="o">+</span> <span class="n">data_len</span> <span class="o">+</span> <span class="p">(</span><span class="n">relocs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span>
						  <span class="o">-</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">flat_hdr</span><span class="p">)),</span>
					 <span class="mi">0</span><span class="p">);</span>
			<span class="n">memmove</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">datapos</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">realdatastart</span><span class="p">,</span>
					<span class="n">data_len</span> <span class="o">+</span> <span class="p">(</span><span class="n">relocs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAT_FLAG_GZDATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fpos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">textpos</span><span class="p">,</span> <span class="n">text_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpos</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
				<span class="n">result</span> <span class="o">=</span> <span class="n">decompress_exec</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="n">text_len</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">datapos</span><span class="p">,</span>
						 <span class="n">data_len</span> <span class="o">+</span> <span class="p">(</span><span class="n">relocs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="p">{</span>
			<span class="n">fpos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">textpos</span><span class="p">,</span> <span class="n">text_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpos</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">fpos</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_start</span><span class="p">);</span>
				<span class="n">result</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">datapos</span><span class="p">,</span>
					<span class="n">data_len</span> <span class="o">+</span> <span class="p">(</span><span class="n">relocs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)),</span> <span class="o">&amp;</span><span class="n">fpos</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unable to read code+data+bss, errno %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="n">result</span><span class="p">);</span>
			<span class="n">vm_munmap</span><span class="p">(</span><span class="n">textpos</span><span class="p">,</span> <span class="n">text_len</span> <span class="o">+</span> <span class="n">data_len</span> <span class="o">+</span> <span class="n">extra</span> <span class="o">+</span>
				<span class="n">MAX_SHARED_LIBS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAT_FLAG_KTRACE</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Mapping is %x, Entry point is %x, data_start is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">textpos</span><span class="p">,</span> <span class="mh">0x00ffffff</span><span class="o">&amp;</span><span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">),</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data_start</span><span class="p">));</span>

	<span class="cm">/* The main program needs a little extra setup in the task structure */</span>
	<span class="n">start_code</span> <span class="o">=</span> <span class="n">textpos</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">flat_hdr</span><span class="p">);</span>
	<span class="n">end_code</span> <span class="o">=</span> <span class="n">textpos</span> <span class="o">+</span> <span class="n">text_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_code</span> <span class="o">=</span> <span class="n">start_code</span><span class="p">;</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">end_code</span> <span class="o">=</span> <span class="n">end_code</span><span class="p">;</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_data</span> <span class="o">=</span> <span class="n">datapos</span><span class="p">;</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">end_data</span> <span class="o">=</span> <span class="n">datapos</span> <span class="o">+</span> <span class="n">data_len</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * set up the brk stuff, uses any slack left in data/bss/stack</span>
<span class="cm">		 * allocation.  We put the brk after the bss (between the bss</span>
<span class="cm">		 * and stack) like other platforms.</span>
<span class="cm">		 * Userspace code relies on the stack pointer starting out at</span>
<span class="cm">		 * an address right at the end of a page.</span>
<span class="cm">		 */</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_brk</span> <span class="o">=</span> <span class="n">datapos</span> <span class="o">+</span> <span class="n">data_len</span> <span class="o">+</span> <span class="n">bss_len</span><span class="p">;</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">=</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_brk</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">end_brk</span> <span class="o">=</span> <span class="n">memp</span> <span class="o">+</span> <span class="n">memp_size</span> <span class="o">-</span> <span class="n">stack_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAT_FLAG_KTRACE</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s %s: TEXT=%x-%x DATA=%x-%x BSS=%x-%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">id</span> <span class="o">?</span> <span class="s">&quot;Lib&quot;</span> <span class="o">:</span> <span class="s">&quot;Load&quot;</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">start_code</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">end_code</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">datapos</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">datapos</span> <span class="o">+</span> <span class="n">data_len</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">datapos</span> <span class="o">+</span> <span class="n">data_len</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(((</span><span class="n">datapos</span> <span class="o">+</span> <span class="n">data_len</span> <span class="o">+</span> <span class="n">bss_len</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">));</span>

	<span class="n">text_len</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">flat_hdr</span><span class="p">);</span> <span class="cm">/* the real code len */</span>

	<span class="cm">/* Store the current module values into the global library structure */</span>
	<span class="n">libinfo</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">start_code</span> <span class="o">=</span> <span class="n">start_code</span><span class="p">;</span>
	<span class="n">libinfo</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">start_data</span> <span class="o">=</span> <span class="n">datapos</span><span class="p">;</span>
	<span class="n">libinfo</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">start_brk</span> <span class="o">=</span> <span class="n">datapos</span> <span class="o">+</span> <span class="n">data_len</span> <span class="o">+</span> <span class="n">bss_len</span><span class="p">;</span>
	<span class="n">libinfo</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">text_len</span> <span class="o">=</span> <span class="n">text_len</span><span class="p">;</span>
	<span class="n">libinfo</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">loaded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">libinfo</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x00ffffff</span> <span class="o">&amp;</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">))</span> <span class="o">+</span> <span class="n">textpos</span><span class="p">;</span>
	<span class="n">libinfo</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">build_date</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">build_date</span><span class="p">);</span>
	
	<span class="cm">/*</span>
<span class="cm">	 * We just load the allocations into some temporary memory to</span>
<span class="cm">	 * help simplify all this mumbo jumbo</span>
<span class="cm">	 *</span>
<span class="cm">	 * We&#39;ve got two different sections of relocation entries.</span>
<span class="cm">	 * The first is the GOT which resides at the beginning of the data segment</span>
<span class="cm">	 * and is terminated with a -1.  This one can be relocated in place.</span>
<span class="cm">	 * The second is the extra relocation entries tacked after the image&#39;s</span>
<span class="cm">	 * data segment. These require a little more processing as the entry is</span>
<span class="cm">	 * really an offset into the image which contains an offset into the</span>
<span class="cm">	 * image.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAT_FLAG_GOTPIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">rp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">datapos</span><span class="p">;</span> <span class="o">*</span><span class="n">rp</span> <span class="o">!=</span> <span class="mh">0xffffffff</span><span class="p">;</span> <span class="n">rp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">rp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">addr</span> <span class="o">=</span> <span class="n">calc_reloc</span><span class="p">(</span><span class="o">*</span><span class="n">rp</span><span class="p">,</span> <span class="n">libinfo</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="n">RELOC_FAILED</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now run through the relocation entries.</span>
<span class="cm">	 * We&#39;ve got to be careful here as C++ produces relocatable zero</span>
<span class="cm">	 * entries in the constructor and destructor tables which are then</span>
<span class="cm">	 * tested for being not zero (which will always occur unless we&#39;re</span>
<span class="cm">	 * based from address zero).  This causes an endless loop as __start</span>
<span class="cm">	 * is at zero.  The solution used is to not relocate zero addresses.</span>
<span class="cm">	 * This has the negative side effect of not allowing a global data</span>
<span class="cm">	 * reference to be statically initialised to _stext (I&#39;ve moved</span>
<span class="cm">	 * __start to address 4 so that is okay).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rev</span> <span class="o">&gt;</span> <span class="n">OLD_FLAT_VERSION</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">persistent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">relocs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">relval</span><span class="p">;</span>

			<span class="cm">/* Get the address of the pointer to be</span>
<span class="cm">			   relocated (of course, the address has to be</span>
<span class="cm">			   relocated first).  */</span>
			<span class="n">relval</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">reloc</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flat_set_persistent</span> <span class="p">(</span><span class="n">relval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">persistent</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">flat_get_relocate_addr</span><span class="p">(</span><span class="n">relval</span><span class="p">);</span>
			<span class="n">rp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">calc_reloc</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">libinfo</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rp</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">RELOC_FAILED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Get the pointer&#39;s value.  */</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">flat_get_addr_from_rp</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">relval</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">persistent</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Do the relocation.  PIC relocs in the data section are</span>
<span class="cm">				 * already in target order</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAT_FLAG_GOTPIC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">addr</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
				<span class="n">addr</span> <span class="o">=</span> <span class="n">calc_reloc</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">libinfo</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="n">RELOC_FAILED</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* Write back the relocated pointer.  */</span>
				<span class="n">flat_put_addr_at_rp</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">relval</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">relocs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">old_reloc</span><span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">reloc</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>
	
	<span class="n">flush_icache_range</span><span class="p">(</span><span class="n">start_code</span><span class="p">,</span> <span class="n">end_code</span><span class="p">);</span>

	<span class="cm">/* zero the BSS,  BRK and stack areas */</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">datapos</span> <span class="o">+</span> <span class="n">data_len</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bss_len</span> <span class="o">+</span> 
			<span class="p">(</span><span class="n">memp</span> <span class="o">+</span> <span class="n">memp_size</span> <span class="o">-</span> <span class="n">stack_len</span> <span class="o">-</span>		<span class="cm">/* end brk */</span>
			<span class="n">libinfo</span><span class="o">-&gt;</span><span class="n">lib_list</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">start_brk</span><span class="p">)</span> <span class="o">+</span>	<span class="cm">/* start brk */</span>
			<span class="n">stack_len</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/****************************************************************************/</span>
<span class="cp">#ifdef CONFIG_BINFMT_SHARED_FLAT</span>

<span class="cm">/*</span>
<span class="cm"> * Load a shared library into memory.  The library gets its own data</span>
<span class="cm"> * segment (including bss) but not argv/argc/environ.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_flat_shared_library</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lib_info</span> <span class="o">*</span><span class="n">libs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">linux_binprm</span> <span class="n">bprm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bprm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bprm</span><span class="p">));</span>

	<span class="cm">/* Create the file name */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;/lib/lib%d.so&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

	<span class="cm">/* Open the file up */</span>
	<span class="n">bprm</span><span class="p">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">bprm</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">open_exec</span><span class="p">(</span><span class="n">bprm</span><span class="p">.</span><span class="n">filename</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">bprm</span><span class="p">.</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">bprm</span><span class="p">.</span><span class="n">file</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">bprm</span><span class="p">.</span><span class="n">cred</span> <span class="o">=</span> <span class="n">prepare_exec_creds</span><span class="p">();</span>
	<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bprm</span><span class="p">.</span><span class="n">cred</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t really care about recalculating credentials at this point</span>
<span class="cm">	 * as we&#39;re past the point of no return and are dealing with shared</span>
<span class="cm">	 * libraries.</span>
<span class="cm">	 */</span>
	<span class="n">bprm</span><span class="p">.</span><span class="n">cred_prepared</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">prepare_binprm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bprm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">load_flat_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bprm</span><span class="p">,</span> <span class="n">libs</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">abort_creds</span><span class="p">(</span><span class="n">bprm</span><span class="p">.</span><span class="n">cred</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">allow_write_access</span><span class="p">(</span><span class="n">bprm</span><span class="p">.</span><span class="n">file</span><span class="p">);</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">bprm</span><span class="p">.</span><span class="n">file</span><span class="p">);</span>

	<span class="k">return</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_BINFMT_SHARED_FLAT */</span><span class="cp"></span>
<span class="cm">/****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * These are the functions used to load flat style executables and shared</span>
<span class="cm"> * libraries.  There is no binary dependent code anywhere else.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_flat_binary</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span> <span class="n">bprm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span> <span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lib_info</span> <span class="n">libinfo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">libinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">libinfo</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * We have to add the size of our arguments to our stack size</span>
<span class="cm">	 * otherwise it&#39;s too easy for users to create stack overflows</span>
<span class="cm">	 * by passing in a huge argument list.  And yes,  we have to be</span>
<span class="cm">	 * pedantic and include space for the argv/envp array as it may have</span>
<span class="cm">	 * a lot of entries.</span>
<span class="cm">	 */</span>
<span class="cp">#define TOP_OF_ARGS (PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *))</span>
	<span class="n">stack_len</span> <span class="o">=</span> <span class="n">TOP_OF_ARGS</span> <span class="o">-</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>             <span class="cm">/* the strings */</span>
	<span class="n">stack_len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span> <span class="cm">/* the argv array */</span>
	<span class="n">stack_len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">envc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span> <span class="cm">/* the envp array */</span>
	<span class="n">stack_len</span> <span class="o">+=</span> <span class="n">FLAT_STACK_ALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* reserve for upcoming alignment */</span>
	
	<span class="n">res</span> <span class="o">=</span> <span class="n">load_flat_file</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">libinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stack_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	
	<span class="cm">/* Update data segment pointers for all libraries */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_SHARED_LIBS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">libinfo</span><span class="p">.</span><span class="n">lib_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">loaded</span><span class="p">)</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">MAX_SHARED_LIBS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))[(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">libinfo</span><span class="p">.</span><span class="n">lib_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start_data</span><span class="p">)]</span> <span class="o">=</span>
					<span class="p">(</span><span class="n">libinfo</span><span class="p">.</span><span class="n">lib_list</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">loaded</span><span class="p">)</span><span class="o">?</span>
						<span class="n">libinfo</span><span class="p">.</span><span class="n">lib_list</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">start_data</span><span class="o">:</span><span class="n">UNLOADED_LIB</span><span class="p">;</span>

	<span class="n">install_exec_creds</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>

	<span class="n">set_binfmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flat_format</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">end_brk</span> <span class="o">+</span> <span class="n">stack_len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;p=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/* copy the arg pages onto the stack, this could be more efficient :-) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">TOP_OF_ARGS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="o">*</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">--</span><span class="n">p</span> <span class="o">=</span>
			<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">page_address</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="n">PAGE_SIZE</span><span class="p">]))[</span><span class="n">i</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">create_flat_tables</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bprm</span><span class="p">);</span>
	
	<span class="cm">/* Fake some return addresses to ensure the call chain will</span>
<span class="cm">	 * initialise library in order for us.  We are required to call</span>
<span class="cm">	 * lib 1 first, then 2, ... and finally the main program (id 0).</span>
<span class="cm">	 */</span>
	<span class="n">start_addr</span> <span class="o">=</span> <span class="n">libinfo</span><span class="p">.</span><span class="n">lib_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">entry</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_BINFMT_SHARED_FLAT</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">MAX_SHARED_LIBS</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">libinfo</span><span class="p">.</span><span class="n">lib_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">loaded</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Push previos first to call address */</span>
			<span class="o">--</span><span class="n">sp</span><span class="p">;</span>	<span class="n">put_user</span><span class="p">(</span><span class="n">start_addr</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
			<span class="n">start_addr</span> <span class="o">=</span> <span class="n">libinfo</span><span class="p">.</span><span class="n">lib_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	
	<span class="cm">/* Stash our initial stack pointer into the mm structure */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_stack</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">)</span><span class="n">sp</span><span class="p">;</span>

<span class="cp">#ifdef FLAT_PLAT_INIT</span>
	<span class="n">FLAT_PLAT_INIT</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">DBG_FLT</span><span class="p">(</span><span class="s">&quot;start_thread(regs=0x%x, entry=0x%x, start_stack=0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">regs</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">start_addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_stack</span><span class="p">);</span>
	
	<span class="n">start_thread</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_stack</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_flat_binfmt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">register_binfmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flat_format</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************/</span>

<span class="n">core_initcall</span><span class="p">(</span><span class="n">init_flat_binfmt</span><span class="p">);</span>

<span class="cm">/****************************************************************************/</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
