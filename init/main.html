<!DOCTYPE html>
<html><head><title>joekychen/linux » init › main.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>main.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/init/main.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  GK 2/5/95  -  Changed to support mounting root fs via NFS</span>
<span class="cm"> *  Added initrd &amp; change_root: Werner Almesberger &amp; Hans Lermen, Feb &#39;96</span>
<span class="cm"> *  Moan early if gcc is old, avoiding bogus kernels - Paul Gortmaker, May &#39;96</span>
<span class="cm"> *  Simplified starting of init:  Michael A. Griffith &lt;grif@acm.org&gt; </span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/stackprotector.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/initrd.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/start_kernel.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/profile.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/cpuset.h&gt;</span>
<span class="cp">#include &lt;linux/cgroup.h&gt;</span>
<span class="cp">#include &lt;linux/efi.h&gt;</span>
<span class="cp">#include &lt;linux/tick.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/taskstats_kern.h&gt;</span>
<span class="cp">#include &lt;linux/delayacct.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/rmap.h&gt;</span>
<span class="cp">#include &lt;linux/mempolicy.h&gt;</span>
<span class="cp">#include &lt;linux/key.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/page_cgroup.h&gt;</span>
<span class="cp">#include &lt;linux/debug_locks.h&gt;</span>
<span class="cp">#include &lt;linux/debugobjects.h&gt;</span>
<span class="cp">#include &lt;linux/lockdep.h&gt;</span>
<span class="cp">#include &lt;linux/kmemleak.h&gt;</span>
<span class="cp">#include &lt;linux/pid_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/kgdb.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/async.h&gt;</span>
<span class="cp">#include &lt;linux/kmemcheck.h&gt;</span>
<span class="cp">#include &lt;linux/sfi.h&gt;</span>
<span class="cp">#include &lt;linux/shmem_fs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/perf_event.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/bugs.h&gt;</span>
<span class="cp">#include &lt;asm/setup.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>

<span class="cp">#ifdef CONFIG_X86_LOCAL_APIC</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">kernel_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">init_IRQ</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fork_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mca_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sbus_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prio_tree_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">radix_tree_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_DEBUG_RODATA</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mark_rodata_ro</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_TC</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Debug helper: via this flag we know that we are in &#39;early bootup code&#39;</span>
<span class="cm"> * where only the boot processor is running with IRQ disabled.  This means</span>
<span class="cm"> * two things - IRQ must not be enabled before the flag is cleared and some</span>
<span class="cm"> * operations which are not allowed with IRQ disabled are allowed while the</span>
<span class="cm"> * flag is set.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">early_boot_irqs_disabled</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">system_states</span> <span class="n">system_state</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">system_state</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Boot command-line arguments</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_INIT_ARGS CONFIG_INIT_ENV_ARG_LIMIT</span>
<span class="cp">#define MAX_INIT_ENVS CONFIG_INIT_ENV_ARG_LIMIT</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">time_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cm">/* Default late time init is NULL. archs can override this later. */</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__initdata</span> <span class="n">late_time_init</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">softirq_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Untouched command line saved by arch-specific code. */</span>
<span class="kt">char</span> <span class="n">__initdata</span> <span class="n">boot_command_line</span><span class="p">[</span><span class="n">COMMAND_LINE_SIZE</span><span class="p">];</span>
<span class="cm">/* Untouched saved command line (eg. for /proc) */</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">saved_command_line</span><span class="p">;</span>
<span class="cm">/* Command line for parameter parsing */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">static_command_line</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">execute_command</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ramdisk_execute_command</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * If set, this is an indication to the drivers that reset the underlying</span>
<span class="cm"> * device before going ahead with the initialization otherwise driver might</span>
<span class="cm"> * rely on the BIOS and skip the reset operation.</span>
<span class="cm"> *</span>
<span class="cm"> * This is useful if kernel is booting in an unreliable environment.</span>
<span class="cm"> * For ex. kdump situaiton where previous kernel has crashed, BIOS has been</span>
<span class="cm"> * skipped and devices will be in unknown state.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reset_devices</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">reset_devices</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_reset_devices</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reset_devices</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;reset_devices&quot;</span><span class="p">,</span> <span class="n">set_reset_devices</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv_init</span><span class="p">[</span><span class="n">MAX_INIT_ARGS</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;init&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">};</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">envp_init</span><span class="p">[</span><span class="n">MAX_INIT_ENVS</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;HOME=/&quot;</span><span class="p">,</span> <span class="s">&quot;TERM=linux&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">panic_later</span><span class="p">,</span> <span class="o">*</span><span class="n">panic_param</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">obs_kernel_param</span> <span class="n">__setup_start</span><span class="p">[],</span> <span class="n">__setup_end</span><span class="p">[];</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">obsolete_checksetup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">obs_kernel_param</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">had_early_param</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">__setup_start</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parameqn</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">early</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Already done in parse_early_param?</span>
<span class="cm">				 * (Needs exact match on param part).</span>
<span class="cm">				 * Keep iterating, as we can have early</span>
<span class="cm">				 * params and __setups of same names 8( */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">||</span> <span class="n">line</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;=&#39;</span><span class="p">)</span>
					<span class="n">had_early_param</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">setup_func</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Parameter %s is obsolete,&quot;</span>
				       <span class="s">&quot; ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">setup_func</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">__setup_end</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">had_early_param</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This should be approx 2 Bo*oMips to start (note initial shift), and will</span>
<span class="cm"> * still work even if initially too large, it will just take slightly longer</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">loops_per_jiffy</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">12</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">loops_per_jiffy</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">debug_kernel</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">console_loglevel</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">quiet_kernel</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">console_loglevel</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;debug&quot;</span><span class="p">,</span> <span class="n">debug_kernel</span><span class="p">);</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;quiet&quot;</span><span class="p">,</span> <span class="n">quiet_kernel</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">loglevel</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">newlevel</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only update loglevel value when a correct setting was passed,</span>
<span class="cm">	 * to prevent blind crashes (when loglevel being set to 0) that</span>
<span class="cm">	 * are quite hard to debug</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newlevel</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">console_loglevel</span> <span class="o">=</span> <span class="n">newlevel</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;loglevel&quot;</span><span class="p">,</span> <span class="n">loglevel</span><span class="p">);</span>

<span class="cm">/* Change NUL term back to &quot;=&quot;, to make &quot;param&quot; the whole string. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">repair_env_string</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* param=val or param=&quot;val&quot;? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">param</span><span class="o">+</span><span class="n">strlen</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">val</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;=&#39;</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">param</span><span class="o">+</span><span class="n">strlen</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">val</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;=&#39;</span><span class="p">;</span>
			<span class="n">memmove</span><span class="p">(</span><span class="n">val</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">val</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unknown boot options get handed to init, unless they look like</span>
<span class="cm"> * unused parameters (modprobe will find them in /proc/cmdline).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">unknown_bootoption</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">repair_env_string</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">unused</span><span class="p">);</span>

	<span class="cm">/* Handle obsolete-style parameters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obsolete_checksetup</span><span class="p">(</span><span class="n">param</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Unused module parameter. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span> <span class="o">||</span> <span class="n">strchr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">panic_later</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Environment option */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">envp_init</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MAX_INIT_ENVS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">panic_later</span> <span class="o">=</span> <span class="s">&quot;Too many boot env vars at `%s&#39;&quot;</span><span class="p">;</span>
				<span class="n">panic_param</span> <span class="o">=</span> <span class="n">param</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">envp_init</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span> <span class="o">-</span> <span class="n">param</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">envp_init</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Command line option */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">argv_init</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MAX_INIT_ARGS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">panic_later</span> <span class="o">=</span> <span class="s">&quot;Too many boot init vars at `%s&#39;&quot;</span><span class="p">;</span>
				<span class="n">panic_param</span> <span class="o">=</span> <span class="n">param</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">argv_init</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">execute_command</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * In case LILO is going to boot us with default command line,</span>
<span class="cm">	 * it prepends &quot;auto&quot; before the whole cmdline which makes</span>
<span class="cm">	 * the shell think it should execute a script with such name.</span>
<span class="cm">	 * So we ignore all arguments entered _before_ init=... [MJ]</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_INIT_ARGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">argv_init</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;init=&quot;</span><span class="p">,</span> <span class="n">init_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">rdinit_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ramdisk_execute_command</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
	<span class="cm">/* See &quot;auto&quot; comment in init_setup */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_INIT_ARGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">argv_init</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;rdinit=&quot;</span><span class="p">,</span> <span class="n">rdinit_setup</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_SMP</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">setup_max_cpus</span> <span class="o">=</span> <span class="n">NR_CPUS</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_X86_LOCAL_APIC</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">smp_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">APIC_init_uniprocessor</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define smp_init()	do { } while (0)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setup_nr_cpu_ids</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">smp_prepare_cpus</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxcpus</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * We need to store the untouched command line for future reference.</span>
<span class="cm"> * We also need to store the touched command line since the parameter</span>
<span class="cm"> * parsing is performed in place, and we should allow a component to</span>
<span class="cm"> * store reference of name/value for future reference.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_command_line</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">command_line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">saved_command_line</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="n">strlen</span> <span class="p">(</span><span class="n">boot_command_line</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">static_command_line</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="n">strlen</span> <span class="p">(</span><span class="n">command_line</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">strcpy</span> <span class="p">(</span><span class="n">saved_command_line</span><span class="p">,</span> <span class="n">boot_command_line</span><span class="p">);</span>
	<span class="n">strcpy</span> <span class="p">(</span><span class="n">static_command_line</span><span class="p">,</span> <span class="n">command_line</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We need to finalize in a non-__init function or else race conditions</span>
<span class="cm"> * between the root thread and the init thread may cause start_kernel to</span>
<span class="cm"> * be reaped by free_initmem before the root thread has proceeded to</span>
<span class="cm"> * cpu_idle.</span>
<span class="cm"> *</span>
<span class="cm"> * gcc-3.4 accidentally inlines this function, so use noinline.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">__initdata</span> <span class="n">DECLARE_COMPLETION</span><span class="p">(</span><span class="n">kthreadd_done</span><span class="p">);</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="n">__init_refok</span> <span class="nf">rest_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>

	<span class="n">rcu_scheduler_starting</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * We need to spawn init first so that it obtains pid 1, however</span>
<span class="cm">	 * the init task will end up wanting to create kthreads, which, if</span>
<span class="cm">	 * we schedule it before we create kthreadd, will OOPS.</span>
<span class="cm">	 */</span>
	<span class="n">kernel_thread</span><span class="p">(</span><span class="n">kernel_init</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CLONE_FS</span> <span class="o">|</span> <span class="n">CLONE_SIGHAND</span><span class="p">);</span>
	<span class="n">numa_default_policy</span><span class="p">();</span>
	<span class="n">pid</span> <span class="o">=</span> <span class="n">kernel_thread</span><span class="p">(</span><span class="n">kthreadd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CLONE_FS</span> <span class="o">|</span> <span class="n">CLONE_FILES</span><span class="p">);</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">kthreadd_task</span> <span class="o">=</span> <span class="n">find_task_by_pid_ns</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_pid_ns</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kthreadd_done</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The boot idle thread must execute schedule()</span>
<span class="cm">	 * at least once to get things moving:</span>
<span class="cm">	 */</span>
	<span class="n">init_idle_bootup_task</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">schedule_preempt_disabled</span><span class="p">();</span>
	<span class="cm">/* Call into cpu_idle with preempt disabled */</span>
	<span class="n">cpu_idle</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Check for early params. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">do_early_param</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">obs_kernel_param</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">__setup_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">__setup_end</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">early</span> <span class="o">&amp;&amp;</span> <span class="n">parameq</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s">&quot;console&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		     <span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;earlycon&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">setup_func</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				       <span class="s">&quot;Malformed early option &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* We accept everything at this stage. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">parse_early_options</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cmdline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">parse_args</span><span class="p">(</span><span class="s">&quot;early options&quot;</span><span class="p">,</span> <span class="n">cmdline</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">do_early_param</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Arch code calls this early on, or if not, just before other parsing. */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">parse_early_param</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">char</span> <span class="n">tmp_cmdline</span><span class="p">[</span><span class="n">COMMAND_LINE_SIZE</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* All fall through to do_early_param. */</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">tmp_cmdline</span><span class="p">,</span> <span class="n">boot_command_line</span><span class="p">,</span> <span class="n">COMMAND_LINE_SIZE</span><span class="p">);</span>
	<span class="n">parse_early_options</span><span class="p">(</span><span class="n">tmp_cmdline</span><span class="p">);</span>
	<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Activate the first processor.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">boot_cpu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="cm">/* Mark the boot cpu &quot;present&quot;, &quot;online&quot; etc for SMP and UP case */</span>
	<span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">set_cpu_active</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">set_cpu_present</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="n">__weak</span> <span class="nf">smp_setup_processor_id</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="n">__weak</span> <span class="nf">thread_info_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set up kernel memory allocators</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">mm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * page_cgroup requires contiguous pages,</span>
<span class="cm">	 * bigger than MAX_ORDER unless SPARSEMEM.</span>
<span class="cm">	 */</span>
	<span class="n">page_cgroup_init_flatmem</span><span class="p">();</span>
	<span class="n">mem_init</span><span class="p">();</span>
	<span class="n">kmem_cache_init</span><span class="p">();</span>
	<span class="n">percpu_init_late</span><span class="p">();</span>
	<span class="n">pgtable_cache_init</span><span class="p">();</span>
	<span class="n">vmalloc_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">start_kernel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span> <span class="n">command_line</span><span class="p">;</span>
	<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="n">__start___param</span><span class="p">[],</span> <span class="n">__stop___param</span><span class="p">[];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to run as early as possible, to initialize the</span>
<span class="cm">	 * lockdep hash:</span>
<span class="cm">	 */</span>
	<span class="n">lockdep_init</span><span class="p">();</span>
	<span class="n">smp_setup_processor_id</span><span class="p">();</span>
	<span class="n">debug_objects_early_init</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up the the initial canary ASAP:</span>
<span class="cm">	 */</span>
	<span class="n">boot_init_stack_canary</span><span class="p">();</span>

	<span class="n">cgroup_init_early</span><span class="p">();</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">early_boot_irqs_disabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupts are still disabled. Do necessary setups, then</span>
<span class="cm"> * enable them</span>
<span class="cm"> */</span>
	<span class="n">tick_init</span><span class="p">();</span>
	<span class="n">boot_cpu_init</span><span class="p">();</span>
	<span class="n">page_address_init</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">linux_banner</span><span class="p">);</span>
	<span class="n">setup_arch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">command_line</span><span class="p">);</span>
	<span class="n">mm_init_owner</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_task</span><span class="p">);</span>
	<span class="n">mm_init_cpumask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">);</span>
	<span class="n">setup_command_line</span><span class="p">(</span><span class="n">command_line</span><span class="p">);</span>
	<span class="n">setup_nr_cpu_ids</span><span class="p">();</span>
	<span class="n">setup_per_cpu_areas</span><span class="p">();</span>
	<span class="n">smp_prepare_boot_cpu</span><span class="p">();</span>	<span class="cm">/* arch-specific boot-cpu hooks */</span>

	<span class="n">build_all_zonelists</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">page_alloc_init</span><span class="p">();</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Kernel command line: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">boot_command_line</span><span class="p">);</span>
	<span class="n">parse_early_param</span><span class="p">();</span>
	<span class="n">parse_args</span><span class="p">(</span><span class="s">&quot;Booting kernel&quot;</span><span class="p">,</span> <span class="n">static_command_line</span><span class="p">,</span> <span class="n">__start___param</span><span class="p">,</span>
		   <span class="n">__stop___param</span> <span class="o">-</span> <span class="n">__start___param</span><span class="p">,</span>
		   <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unknown_bootoption</span><span class="p">);</span>

	<span class="n">jump_label_init</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * These use large bootmem allocations and must precede</span>
<span class="cm">	 * kmem_cache_init()</span>
<span class="cm">	 */</span>
	<span class="n">setup_log_buf</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">pidhash_init</span><span class="p">();</span>
	<span class="n">vfs_caches_init_early</span><span class="p">();</span>
	<span class="n">sort_main_extable</span><span class="p">();</span>
	<span class="n">trap_init</span><span class="p">();</span>
	<span class="n">mm_init</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up the scheduler prior starting any interrupts (such as the</span>
<span class="cm">	 * timer interrupt). Full topology setup happens at smp_init()</span>
<span class="cm">	 * time - but meanwhile we still have a functioning scheduler.</span>
<span class="cm">	 */</span>
	<span class="n">sched_init</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Disable preemption - early bootup scheduling is extremely</span>
<span class="cm">	 * fragile until we cpu_idle() for the first time.</span>
<span class="cm">	 */</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;start_kernel(): bug: interrupts were &quot;</span>
				<span class="s">&quot;enabled *very* early, fixing it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">idr_init_cache</span><span class="p">();</span>
	<span class="n">perf_event_init</span><span class="p">();</span>
	<span class="n">rcu_init</span><span class="p">();</span>
	<span class="n">radix_tree_init</span><span class="p">();</span>
	<span class="cm">/* init some links before init_ISA_irqs() */</span>
	<span class="n">early_irq_init</span><span class="p">();</span>
	<span class="n">init_IRQ</span><span class="p">();</span>
	<span class="n">prio_tree_init</span><span class="p">();</span>
	<span class="n">init_timers</span><span class="p">();</span>
	<span class="n">hrtimers_init</span><span class="p">();</span>
	<span class="n">softirq_init</span><span class="p">();</span>
	<span class="n">timekeeping_init</span><span class="p">();</span>
	<span class="n">time_init</span><span class="p">();</span>
	<span class="n">profile_init</span><span class="p">();</span>
	<span class="n">call_function_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">())</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;start_kernel(): bug: interrupts were &quot;</span>
				 <span class="s">&quot;enabled early</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">early_boot_irqs_disabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">kmem_cache_init_late</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * HACK ALERT! This is early. We&#39;re enabling the console before</span>
<span class="cm">	 * we&#39;ve done PCI setups etc, and console_init() must be aware of</span>
<span class="cm">	 * this. But we do want output early, in case something goes wrong.</span>
<span class="cm">	 */</span>
	<span class="n">console_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">panic_later</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="n">panic_later</span><span class="p">,</span> <span class="n">panic_param</span><span class="p">);</span>

	<span class="n">lockdep_info</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to run this when irqs are enabled, because it wants</span>
<span class="cm">	 * to self-test [hard/soft]-irqs on/off lock inversion bugs</span>
<span class="cm">	 * too:</span>
<span class="cm">	 */</span>
	<span class="n">locking_selftest</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">initrd_start</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">initrd_below_start_ok</span> <span class="o">&amp;&amp;</span>
	    <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">initrd_start</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">min_low_pfn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - &quot;</span>
		    <span class="s">&quot;disabling it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">initrd_start</span><span class="p">)),</span>
		    <span class="n">min_low_pfn</span><span class="p">);</span>
		<span class="n">initrd_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">page_cgroup_init</span><span class="p">();</span>
	<span class="n">debug_objects_mem_init</span><span class="p">();</span>
	<span class="n">kmemleak_init</span><span class="p">();</span>
	<span class="n">setup_per_cpu_pageset</span><span class="p">();</span>
	<span class="n">numa_policy_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">late_time_init</span><span class="p">)</span>
		<span class="n">late_time_init</span><span class="p">();</span>
	<span class="n">sched_clock_init</span><span class="p">();</span>
	<span class="n">calibrate_delay</span><span class="p">();</span>
	<span class="n">pidmap_init</span><span class="p">();</span>
	<span class="n">anon_vma_init</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_X86</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">efi_enabled</span><span class="p">)</span>
		<span class="n">efi_enter_virtual_mode</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">thread_info_cache_init</span><span class="p">();</span>
	<span class="n">cred_init</span><span class="p">();</span>
	<span class="n">fork_init</span><span class="p">(</span><span class="n">totalram_pages</span><span class="p">);</span>
	<span class="n">proc_caches_init</span><span class="p">();</span>
	<span class="n">buffer_init</span><span class="p">();</span>
	<span class="n">key_init</span><span class="p">();</span>
	<span class="n">security_init</span><span class="p">();</span>
	<span class="n">dbg_late_init</span><span class="p">();</span>
	<span class="n">vfs_caches_init</span><span class="p">(</span><span class="n">totalram_pages</span><span class="p">);</span>
	<span class="n">signals_init</span><span class="p">();</span>
	<span class="cm">/* rootfs populating might need page-writeback */</span>
	<span class="n">page_writeback_init</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="n">proc_root_init</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">cgroup_init</span><span class="p">();</span>
	<span class="n">cpuset_init</span><span class="p">();</span>
	<span class="n">taskstats_init_early</span><span class="p">();</span>
	<span class="n">delayacct_init</span><span class="p">();</span>

	<span class="n">check_bugs</span><span class="p">();</span>

	<span class="n">acpi_early_init</span><span class="p">();</span> <span class="cm">/* before LAPIC and SMP init */</span>
	<span class="n">sfi_init_late</span><span class="p">();</span>

	<span class="n">ftrace_init</span><span class="p">();</span>

	<span class="cm">/* Do the rest non-__init&#39;ed, we&#39;re now alive */</span>
	<span class="n">rest_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Call all constructor functions linked into the kernel. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">do_ctors</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_CONSTRUCTORS</span>
	<span class="n">ctor_fn_t</span> <span class="o">*</span><span class="n">fn</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctor_fn_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">__ctors_start</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">fn</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ctor_fn_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">__ctors_end</span><span class="p">;</span> <span class="n">fn</span><span class="o">++</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="n">initcall_debug</span><span class="p">;</span>
<span class="n">core_param</span><span class="p">(</span><span class="n">initcall_debug</span><span class="p">,</span> <span class="n">initcall_debug</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">msgbuf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">do_one_initcall_debug</span><span class="p">(</span><span class="n">initcall_t</span> <span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">calltime</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">rettime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">duration</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;calling  %pF @ %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
	<span class="n">calltime</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">fn</span><span class="p">();</span>
	<span class="n">rettime</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">rettime</span><span class="p">,</span> <span class="n">calltime</span><span class="p">);</span>
	<span class="n">duration</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;initcall %pF returned %d after %lld usecs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span>
		<span class="n">ret</span><span class="p">,</span> <span class="n">duration</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">do_one_initcall</span><span class="p">(</span><span class="n">initcall_t</span> <span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">preempt_count</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">initcall_debug</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_one_initcall_debug</span><span class="p">(</span><span class="n">fn</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">fn</span><span class="p">();</span>

	<span class="n">msgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span> <span class="o">&amp;&amp;</span> <span class="n">initcall_debug</span><span class="p">)</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">msgbuf</span><span class="p">,</span> <span class="s">&quot;error code %d &quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">!=</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">msgbuf</span><span class="p">,</span> <span class="s">&quot;preemption imbalance &quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msgbuf</span><span class="p">));</span>
		<span class="n">preempt_count</span><span class="p">()</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqs_disabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">msgbuf</span><span class="p">,</span> <span class="s">&quot;disabled interrupts &quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msgbuf</span><span class="p">));</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;initcall %pF returned with %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">msgbuf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">extern</span> <span class="n">initcall_t</span> <span class="n">__initcall_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="n">initcall_t</span> <span class="n">__initcall0_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="n">initcall_t</span> <span class="n">__initcall1_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="n">initcall_t</span> <span class="n">__initcall2_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="n">initcall_t</span> <span class="n">__initcall3_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="n">initcall_t</span> <span class="n">__initcall4_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="n">initcall_t</span> <span class="n">__initcall5_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="n">initcall_t</span> <span class="n">__initcall6_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="n">initcall_t</span> <span class="n">__initcall7_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="n">initcall_t</span> <span class="n">__initcall_end</span><span class="p">[];</span>

<span class="k">static</span> <span class="n">initcall_t</span> <span class="o">*</span><span class="n">initcall_levels</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__initcall0_start</span><span class="p">,</span>
	<span class="n">__initcall1_start</span><span class="p">,</span>
	<span class="n">__initcall2_start</span><span class="p">,</span>
	<span class="n">__initcall3_start</span><span class="p">,</span>
	<span class="n">__initcall4_start</span><span class="p">,</span>
	<span class="n">__initcall5_start</span><span class="p">,</span>
	<span class="n">__initcall6_start</span><span class="p">,</span>
	<span class="n">__initcall7_start</span><span class="p">,</span>
	<span class="n">__initcall_end</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">initcall_level_names</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;early&quot;</span><span class="p">,</span>
	<span class="s">&quot;core&quot;</span><span class="p">,</span>
	<span class="s">&quot;postcore&quot;</span><span class="p">,</span>
	<span class="s">&quot;arch&quot;</span><span class="p">,</span>
	<span class="s">&quot;subsys&quot;</span><span class="p">,</span>
	<span class="s">&quot;fs&quot;</span><span class="p">,</span>
	<span class="s">&quot;device&quot;</span><span class="p">,</span>
	<span class="s">&quot;late&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">do_initcall_level</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="n">__start___param</span><span class="p">[],</span> <span class="n">__stop___param</span><span class="p">[];</span>
	<span class="n">initcall_t</span> <span class="o">*</span><span class="n">fn</span><span class="p">;</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">static_command_line</span><span class="p">,</span> <span class="n">saved_command_line</span><span class="p">);</span>
	<span class="n">parse_args</span><span class="p">(</span><span class="n">initcall_level_names</span><span class="p">[</span><span class="n">level</span><span class="p">],</span>
		   <span class="n">static_command_line</span><span class="p">,</span> <span class="n">__start___param</span><span class="p">,</span>
		   <span class="n">__stop___param</span> <span class="o">-</span> <span class="n">__start___param</span><span class="p">,</span>
		   <span class="n">level</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
		   <span class="o">&amp;</span><span class="n">repair_env_string</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">fn</span> <span class="o">=</span> <span class="n">initcall_levels</span><span class="p">[</span><span class="n">level</span><span class="p">];</span> <span class="n">fn</span> <span class="o">&lt;</span> <span class="n">initcall_levels</span><span class="p">[</span><span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="n">fn</span><span class="o">++</span><span class="p">)</span>
		<span class="n">do_one_initcall</span><span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">do_initcalls</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">initcall_levels</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span>
		<span class="n">do_initcall_level</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ok, the machine is now initialized. None of the devices</span>
<span class="cm"> * have been touched yet, but the CPU subsystem is up and</span>
<span class="cm"> * running, and memory and process management works.</span>
<span class="cm"> *</span>
<span class="cm"> * Now we can finally start doing some real work..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">do_basic_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpuset_init_smp</span><span class="p">();</span>
	<span class="n">usermodehelper_init</span><span class="p">();</span>
	<span class="n">shmem_init</span><span class="p">();</span>
	<span class="n">driver_init</span><span class="p">();</span>
	<span class="n">init_irq_proc</span><span class="p">();</span>
	<span class="n">do_ctors</span><span class="p">();</span>
	<span class="n">usermodehelper_enable</span><span class="p">();</span>
	<span class="n">do_initcalls</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">do_pre_smp_initcalls</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">initcall_t</span> <span class="o">*</span><span class="n">fn</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">fn</span> <span class="o">=</span> <span class="n">__initcall_start</span><span class="p">;</span> <span class="n">fn</span> <span class="o">&lt;</span> <span class="n">__initcall0_start</span><span class="p">;</span> <span class="n">fn</span><span class="o">++</span><span class="p">)</span>
		<span class="n">do_one_initcall</span><span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">run_init_process</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">init_filename</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">argv_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">init_filename</span><span class="p">;</span>
	<span class="n">kernel_execve</span><span class="p">(</span><span class="n">init_filename</span><span class="p">,</span> <span class="n">argv_init</span><span class="p">,</span> <span class="n">envp_init</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is a non __init function. Force it to be noinline otherwise gcc</span>
<span class="cm"> * makes it inline to init() and it becomes part of init.text section</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">init_post</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* need to finish all async __init code before freeing the memory */</span>
	<span class="n">async_synchronize_full</span><span class="p">();</span>
	<span class="n">free_initmem</span><span class="p">();</span>
	<span class="n">mark_rodata_ro</span><span class="p">();</span>
	<span class="n">system_state</span> <span class="o">=</span> <span class="n">SYSTEM_RUNNING</span><span class="p">;</span>
	<span class="n">numa_default_policy</span><span class="p">();</span>


	<span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SIGNAL_UNKILLABLE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ramdisk_execute_command</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">run_init_process</span><span class="p">(</span><span class="n">ramdisk_execute_command</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Failed to execute %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ramdisk_execute_command</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We try each of these until one succeeds.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The Bourne shell can be used instead of init if we are</span>
<span class="cm">	 * trying to recover a really broken machine.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">execute_command</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">run_init_process</span><span class="p">(</span><span class="n">execute_command</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Failed to execute %s.  Attempting &quot;</span>
					<span class="s">&quot;defaults...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">execute_command</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">run_init_process</span><span class="p">(</span><span class="s">&quot;/sbin/init&quot;</span><span class="p">);</span>
	<span class="n">run_init_process</span><span class="p">(</span><span class="s">&quot;/etc/init&quot;</span><span class="p">);</span>
	<span class="n">run_init_process</span><span class="p">(</span><span class="s">&quot;/bin/init&quot;</span><span class="p">);</span>
	<span class="n">run_init_process</span><span class="p">(</span><span class="s">&quot;/bin/sh&quot;</span><span class="p">);</span>

	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;No init found.  Try passing init= option to kernel. &quot;</span>
	      <span class="s">&quot;See Linux Documentation/init.txt for guidance.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">kernel_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Wait until kthreadd is all set-up.</span>
<span class="cm">	 */</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kthreadd_done</span><span class="p">);</span>

	<span class="cm">/* Now the scheduler is fully set up and can do blocking allocations */</span>
	<span class="n">gfp_allowed_mask</span> <span class="o">=</span> <span class="n">__GFP_BITS_MASK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * init can allocate pages on any node</span>
<span class="cm">	 */</span>
	<span class="n">set_mems_allowed</span><span class="p">(</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]);</span>
	<span class="cm">/*</span>
<span class="cm">	 * init can run on any cpu.</span>
<span class="cm">	 */</span>
	<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">cpu_all_mask</span><span class="p">);</span>

	<span class="n">cad_pid</span> <span class="o">=</span> <span class="n">task_pid</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="n">smp_prepare_cpus</span><span class="p">(</span><span class="n">setup_max_cpus</span><span class="p">);</span>

	<span class="n">do_pre_smp_initcalls</span><span class="p">();</span>
	<span class="n">lockup_detector_init</span><span class="p">();</span>

	<span class="n">smp_init</span><span class="p">();</span>
	<span class="n">sched_init_smp</span><span class="p">();</span>

	<span class="n">do_basic_setup</span><span class="p">();</span>

	<span class="cm">/* Open the /dev/console on the rootfs, this should never fail */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sys_open</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="s">&quot;/dev/console&quot;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Warning: unable to open an initial console.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">sys_dup</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">sys_dup</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * check if there is an early userspace init.  If yes, let it do all</span>
<span class="cm">	 * the work</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ramdisk_execute_command</span><span class="p">)</span>
		<span class="n">ramdisk_execute_command</span> <span class="o">=</span> <span class="s">&quot;/init&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sys_access</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">ramdisk_execute_command</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ramdisk_execute_command</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">prepare_namespace</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ok, we have completed the initial bootup, and</span>
<span class="cm">	 * we&#39;re essentially up and running. Get rid of the</span>
<span class="cm">	 * initmem segments and start the user-mode stuff..</span>
<span class="cm">	 */</span>

	<span class="n">init_post</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
