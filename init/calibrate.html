<!DOCTYPE html>
<html><head><title>joekychen/linux » init › calibrate.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>calibrate.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* calibrate.c: default delay calibration</span>
<span class="cm"> *</span>
<span class="cm"> * Excised from init/main.c</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lpj_fine</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">preset_lpj</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">lpj_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preset_lpj</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;lpj=&quot;</span><span class="p">,</span> <span class="n">lpj_setup</span><span class="p">);</span>

<span class="cp">#ifdef ARCH_HAS_READ_CURRENT_TIMER</span>

<span class="cm">/* This routine uses the read_current_timer() routine and gets the</span>
<span class="cm"> * loops per jiffy directly, instead of guessing it using delay().</span>
<span class="cm"> * Also, this code tries to handle non-maskable asynchronous events</span>
<span class="cm"> * (like SMIs)</span>
<span class="cm"> */</span>
<span class="cp">#define DELAY_CALIBRATION_TICKS			((HZ &lt; 100) ? 1 : (HZ/100))</span>
<span class="cp">#define MAX_DIRECT_CALIBRATION_RETRIES		5</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__cpuinit</span> <span class="nf">calibrate_delay_direct</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pre_start</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">post_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pre_end</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">post_end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_jiffies</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timer_rate_min</span><span class="p">,</span> <span class="n">timer_rate_max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">good_timer_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">good_timer_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">measured_times</span><span class="p">[</span><span class="n">MAX_DIRECT_CALIBRATION_RETRIES</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* index of measured_times with max/min values or not set */</span>
	<span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_current_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pre_start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A simple loop like</span>
<span class="cm">	 *	while ( jiffies &lt; start_jiffies+1)</span>
<span class="cm">	 *		start = read_current_timer();</span>
<span class="cm">	 * will not do. As we don&#39;t really know whether jiffy switch</span>
<span class="cm">	 * happened first or timer_value was read first. And some asynchronous</span>
<span class="cm">	 * event can happen between these two events introducing errors in lpj.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So, we do</span>
<span class="cm">	 * 1. pre_start &lt;- When we are sure that jiffy switch hasn&#39;t happened</span>
<span class="cm">	 * 2. check jiffy switch</span>
<span class="cm">	 * 3. start &lt;- timer value before or after jiffy switch</span>
<span class="cm">	 * 4. post_start &lt;- When we are sure that jiffy switch has happened</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note, we don&#39;t know anything about order of 2 and 3.</span>
<span class="cm">	 * Now, by looking at post_start and pre_start difference, we can</span>
<span class="cm">	 * check whether any asynchronous event happened or not</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_DIRECT_CALIBRATION_RETRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pre_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">read_current_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>
		<span class="n">start_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">time_before_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">start_jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pre_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
			<span class="n">read_current_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">read_current_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">post_start</span><span class="p">);</span>

		<span class="n">pre_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">post_start</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">time_before_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">start_jiffies</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span>
					       <span class="n">DELAY_CALIBRATION_TICKS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pre_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
			<span class="n">read_current_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">read_current_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">post_end</span><span class="p">);</span>

		<span class="n">timer_rate_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">post_end</span> <span class="o">-</span> <span class="n">pre_start</span><span class="p">)</span> <span class="o">/</span>
					<span class="n">DELAY_CALIBRATION_TICKS</span><span class="p">;</span>
		<span class="n">timer_rate_min</span> <span class="o">=</span> <span class="p">(</span><span class="n">pre_end</span> <span class="o">-</span> <span class="n">post_start</span><span class="p">)</span> <span class="o">/</span>
					<span class="n">DELAY_CALIBRATION_TICKS</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the upper limit and lower limit of the timer_rate is</span>
<span class="cm">		 * &gt;= 12.5% apart, redo calibration.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">post_end</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;calibrate_delay_direct() ignoring &quot;</span>
					<span class="s">&quot;timer_rate as we had a TSC wrap around&quot;</span>
					<span class="s">&quot; start=%lu &gt;=post_end=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">start</span><span class="p">,</span> <span class="n">post_end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">post_end</span> <span class="o">&amp;&amp;</span> <span class="n">pre_start</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pre_end</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">timer_rate_max</span> <span class="o">-</span> <span class="n">timer_rate_min</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">timer_rate_max</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">good_timer_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">good_timer_sum</span> <span class="o">+=</span> <span class="n">timer_rate_max</span><span class="p">;</span>
			<span class="n">measured_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">timer_rate_max</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">timer_rate_max</span> <span class="o">&gt;</span> <span class="n">measured_times</span><span class="p">[</span><span class="n">max</span><span class="p">])</span>
				<span class="n">max</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">timer_rate_max</span> <span class="o">&lt;</span> <span class="n">measured_times</span><span class="p">[</span><span class="n">min</span><span class="p">])</span>
				<span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">measured_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the maximum &amp; minimum - if they differ too much throw out the</span>
<span class="cm">	 * one with the largest difference from the mean and try again...</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">good_timer_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">estimate</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxdiff</span><span class="p">;</span>

		<span class="cm">/* compute the estimate */</span>
		<span class="n">estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">good_timer_sum</span><span class="o">/</span><span class="n">good_timer_count</span><span class="p">);</span>
		<span class="n">maxdiff</span> <span class="o">=</span> <span class="n">estimate</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

		<span class="cm">/* if range is within 12% let&#39;s take it */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">measured_times</span><span class="p">[</span><span class="n">max</span><span class="p">]</span> <span class="o">-</span> <span class="n">measured_times</span><span class="p">[</span><span class="n">min</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">maxdiff</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">estimate</span><span class="p">;</span>

		<span class="cm">/* ok - drop the worse value and try again... */</span>
		<span class="n">good_timer_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">good_timer_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">measured_times</span><span class="p">[</span><span class="n">max</span><span class="p">]</span> <span class="o">-</span> <span class="n">estimate</span><span class="p">)</span> <span class="o">&lt;</span>
				<span class="p">(</span><span class="n">estimate</span> <span class="o">-</span> <span class="n">measured_times</span><span class="p">[</span><span class="n">min</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;calibrate_delay_direct() dropping &quot;</span>
					<span class="s">&quot;min bogoMips estimate %d = %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">min</span><span class="p">,</span> <span class="n">measured_times</span><span class="p">[</span><span class="n">min</span><span class="p">]);</span>
			<span class="n">measured_times</span><span class="p">[</span><span class="n">min</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">min</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;calibrate_delay_direct() dropping &quot;</span>
					<span class="s">&quot;max bogoMips estimate %d = %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">max</span><span class="p">,</span> <span class="n">measured_times</span><span class="p">[</span><span class="n">max</span><span class="p">]);</span>
			<span class="n">measured_times</span><span class="p">[</span><span class="n">max</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_DIRECT_CALIBRATION_RETRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">measured_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">good_timer_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">good_timer_sum</span> <span class="o">+=</span> <span class="n">measured_times</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">measured_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">measured_times</span><span class="p">[</span><span class="n">min</span><span class="p">])</span>
				<span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">measured_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">measured_times</span><span class="p">[</span><span class="n">max</span><span class="p">])</span>
				<span class="n">max</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;calibrate_delay_direct() failed to get a good &quot;</span>
	       <span class="s">&quot;estimate for loops_per_jiffy.</span><span class="se">\n</span><span class="s">Probably due to long platform &quot;</span>
		<span class="s">&quot;interrupts. Consider using </span><span class="se">\&quot;</span><span class="s">lpj=</span><span class="se">\&quot;</span><span class="s"> boot option.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__cpuinit</span> <span class="nf">calibrate_delay_direct</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This is the number of bits of precision for the loops_per_jiffy.  Each</span>
<span class="cm"> * time we refine our estimate after the first takes 1.5/HZ seconds, so try</span>
<span class="cm"> * to start with a good estimate.</span>
<span class="cm"> * For the boot cpu we can skip the delay calibration and assign it a value</span>
<span class="cm"> * calculated based on the timer frequency.</span>
<span class="cm"> * For the rest of the CPUs we cannot assume that the timer frequency is same as</span>
<span class="cm"> * the cpu frequency, hence do the calibration for those.</span>
<span class="cm"> */</span>
<span class="cp">#define LPS_PREC 8</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__cpuinit</span> <span class="nf">calibrate_delay_converge</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* First stage - slowly accelerate to find initial bounds */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lpj</span><span class="p">,</span> <span class="n">lpj_base</span><span class="p">,</span> <span class="n">ticks</span><span class="p">,</span> <span class="n">loopadd</span><span class="p">,</span> <span class="n">loopadd_base</span><span class="p">,</span> <span class="n">chop_limit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">trials</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">band</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trial_in_band</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lpj</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">12</span><span class="p">);</span>

	<span class="cm">/* wait for &quot;start of&quot; clock tick */</span>
	<span class="n">ticks</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ticks</span> <span class="o">==</span> <span class="n">jiffies</span><span class="p">)</span>
		<span class="p">;</span> <span class="cm">/* nothing */</span>
	<span class="cm">/* Go .. */</span>
	<span class="n">ticks</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">trial_in_band</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">band</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">++</span><span class="n">band</span><span class="p">;</span>
			<span class="n">trial_in_band</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__delay</span><span class="p">(</span><span class="n">lpj</span> <span class="o">*</span> <span class="n">band</span><span class="p">);</span>
		<span class="n">trials</span> <span class="o">+=</span> <span class="n">band</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ticks</span> <span class="o">==</span> <span class="n">jiffies</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We overshot, so retreat to a clear underestimate. Then estimate</span>
<span class="cm">	 * the largest likely undershoot. This defines our chop bounds.</span>
<span class="cm">	 */</span>
	<span class="n">trials</span> <span class="o">-=</span> <span class="n">band</span><span class="p">;</span>
	<span class="n">loopadd_base</span> <span class="o">=</span> <span class="n">lpj</span> <span class="o">*</span> <span class="n">band</span><span class="p">;</span>
	<span class="n">lpj_base</span> <span class="o">=</span> <span class="n">lpj</span> <span class="o">*</span> <span class="n">trials</span><span class="p">;</span>

<span class="nl">recalibrate:</span>
	<span class="n">lpj</span> <span class="o">=</span> <span class="n">lpj_base</span><span class="p">;</span>
	<span class="n">loopadd</span> <span class="o">=</span> <span class="n">loopadd_base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do a binary approximation to get lpj set to</span>
<span class="cm">	 * equal one clock (up to LPS_PREC bits)</span>
<span class="cm">	 */</span>
	<span class="n">chop_limit</span> <span class="o">=</span> <span class="n">lpj</span> <span class="o">&gt;&gt;</span> <span class="n">LPS_PREC</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">loopadd</span> <span class="o">&gt;</span> <span class="n">chop_limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpj</span> <span class="o">+=</span> <span class="n">loopadd</span><span class="p">;</span>
		<span class="n">ticks</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ticks</span> <span class="o">==</span> <span class="n">jiffies</span><span class="p">)</span>
			<span class="p">;</span> <span class="cm">/* nothing */</span>
		<span class="n">ticks</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">__delay</span><span class="p">(</span><span class="n">lpj</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">!=</span> <span class="n">ticks</span><span class="p">)</span>	<span class="cm">/* longer than 1 tick */</span>
			<span class="n">lpj</span> <span class="o">-=</span> <span class="n">loopadd</span><span class="p">;</span>
		<span class="n">loopadd</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we incremented every single time possible, presume we&#39;ve</span>
<span class="cm">	 * massively underestimated initially, and retry with a higher</span>
<span class="cm">	 * start, and larger range. (Only seen on x86_64, due to SMIs)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpj</span> <span class="o">+</span> <span class="n">loopadd</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">lpj_base</span> <span class="o">+</span> <span class="n">loopadd_base</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpj_base</span> <span class="o">=</span> <span class="n">lpj</span><span class="p">;</span>
		<span class="n">loopadd_base</span> <span class="o">&lt;&lt;=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">recalibrate</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">lpj</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">cpu_loops_per_jiffy</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Check if cpu calibration delay is already known. For example,</span>
<span class="cm"> * some processors with multi-core sockets may have all cores</span>
<span class="cm"> * with the same calibration delay.</span>
<span class="cm"> *</span>
<span class="cm"> * Architectures should override this function if a faster calibration</span>
<span class="cm"> * method is available.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">__cpuinit</span> <span class="n">calibrate_delay_is_known</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">calibrate_delay</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lpj</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">bool</span> <span class="n">printed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_loops_per_jiffy</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpj</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_loops_per_jiffy</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">printed</span><span class="p">)</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Calibrating delay loop (skipped) &quot;</span>
				<span class="s">&quot;already calibrated this CPU&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">preset_lpj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpj</span> <span class="o">=</span> <span class="n">preset_lpj</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">printed</span><span class="p">)</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Calibrating delay loop (skipped) &quot;</span>
				<span class="s">&quot;preset value.. &quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">printed</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">lpj_fine</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpj</span> <span class="o">=</span> <span class="n">lpj_fine</span><span class="p">;</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Calibrating delay loop (skipped), &quot;</span>
			<span class="s">&quot;value calculated using timer frequency.. &quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">lpj</span> <span class="o">=</span> <span class="n">calibrate_delay_is_known</span><span class="p">()))</span> <span class="p">{</span>
		<span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">lpj</span> <span class="o">=</span> <span class="n">calibrate_delay_direct</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">printed</span><span class="p">)</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Calibrating delay using timer &quot;</span>
				<span class="s">&quot;specific routine.. &quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">printed</span><span class="p">)</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Calibrating delay loop... &quot;</span><span class="p">);</span>
		<span class="n">lpj</span> <span class="o">=</span> <span class="n">calibrate_delay_converge</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">cpu_loops_per_jiffy</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">lpj</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">printed</span><span class="p">)</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;%lu.%02lu BogoMIPS (lpj=%lu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">lpj</span><span class="o">/</span><span class="p">(</span><span class="mi">500000</span><span class="o">/</span><span class="n">HZ</span><span class="p">),</span>
			<span class="p">(</span><span class="n">lpj</span><span class="o">/</span><span class="p">(</span><span class="mi">5000</span><span class="o">/</span><span class="n">HZ</span><span class="p">))</span> <span class="o">%</span> <span class="mi">100</span><span class="p">,</span> <span class="n">lpj</span><span class="p">);</span>

	<span class="n">loops_per_jiffy</span> <span class="o">=</span> <span class="n">lpj</span><span class="p">;</span>
	<span class="n">printed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
