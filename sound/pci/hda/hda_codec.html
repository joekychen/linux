<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › pci › hda › hda_codec.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hda_codec.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Universal Interface for Intel High Definition Audio Codec</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004 Takashi Iwai &lt;tiwai@suse.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  This driver is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This driver is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;sound/core.h&gt;</span>
<span class="cp">#include &quot;hda_codec.h&quot;</span>
<span class="cp">#include &lt;sound/asoundef.h&gt;</span>
<span class="cp">#include &lt;sound/tlv.h&gt;</span>
<span class="cp">#include &lt;sound/initval.h&gt;</span>
<span class="cp">#include &lt;sound/jack.h&gt;</span>
<span class="cp">#include &quot;hda_local.h&quot;</span>
<span class="cp">#include &quot;hda_beep.h&quot;</span>
<span class="cp">#include &quot;hda_jack.h&quot;</span>
<span class="cp">#include &lt;sound/hda_hwdep.h&gt;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &quot;hda_trace.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * vendor / preset table</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">hda_vendor_id</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* codec vendor labels */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hda_vendor_id</span> <span class="n">hda_vendor_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mh">0x1002</span><span class="p">,</span> <span class="s">&quot;ATI&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x1013</span><span class="p">,</span> <span class="s">&quot;Cirrus Logic&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x1057</span><span class="p">,</span> <span class="s">&quot;Motorola&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x1095</span><span class="p">,</span> <span class="s">&quot;Silicon Image&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x10de</span><span class="p">,</span> <span class="s">&quot;Nvidia&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x10ec</span><span class="p">,</span> <span class="s">&quot;Realtek&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x1102</span><span class="p">,</span> <span class="s">&quot;Creative&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x1106</span><span class="p">,</span> <span class="s">&quot;VIA&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x111d</span><span class="p">,</span> <span class="s">&quot;IDT&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x11c1</span><span class="p">,</span> <span class="s">&quot;LSI&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x11d4</span><span class="p">,</span> <span class="s">&quot;Analog Devices&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x13f6</span><span class="p">,</span> <span class="s">&quot;C-Media&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x14f1</span><span class="p">,</span> <span class="s">&quot;Conexant&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x17e8</span><span class="p">,</span> <span class="s">&quot;Chrontel&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x1854</span><span class="p">,</span> <span class="s">&quot;LG&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x1aec</span><span class="p">,</span> <span class="s">&quot;Wolfson Microelectronics&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x434d</span><span class="p">,</span> <span class="s">&quot;C-Media&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x8086</span><span class="p">,</span> <span class="s">&quot;Intel&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x8384</span><span class="p">,</span> <span class="s">&quot;SigmaTel&quot;</span> <span class="p">},</span>
	<span class="p">{}</span> <span class="cm">/* terminator */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">preset_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">hda_preset_tables</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">snd_hda_add_codec_preset</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec_preset_list</span> <span class="o">*</span><span class="n">preset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">preset_mutex</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">preset</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hda_preset_tables</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">preset_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_add_codec_preset</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">snd_hda_delete_codec_preset</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec_preset_list</span> <span class="o">*</span><span class="n">preset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">preset_mutex</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">preset</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">preset_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_delete_codec_preset</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SND_HDA_POWER_SAVE</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hda_power_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hda_keep_power_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
<span class="cp">#define hda_codec_is_power_on(codec)	((codec)-&gt;power_on)</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hda_keep_power_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#define hda_codec_is_power_on(codec)	1</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_get_jack_location - Give a location string of the jack</span>
<span class="cm"> * @cfg: pin default config value</span>
<span class="cm"> *</span>
<span class="cm"> * Parse the pin default config value and returns the string of the</span>
<span class="cm"> * jack location, e.g. &quot;Rear&quot;, &quot;Front&quot;, etc.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">snd_hda_get_jack_location</span><span class="p">(</span><span class="n">u32</span> <span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bases</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;N/A&quot;</span><span class="p">,</span> <span class="s">&quot;Rear&quot;</span><span class="p">,</span> <span class="s">&quot;Front&quot;</span><span class="p">,</span> <span class="s">&quot;Left&quot;</span><span class="p">,</span> <span class="s">&quot;Right&quot;</span><span class="p">,</span> <span class="s">&quot;Top&quot;</span><span class="p">,</span> <span class="s">&quot;Bottom&quot;</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">specials_idx</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0x07</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span>
		<span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x19</span><span class="p">,</span>
		<span class="mh">0x37</span><span class="p">,</span> <span class="mh">0x38</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">specials</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;Rear Panel&quot;</span><span class="p">,</span> <span class="s">&quot;Drive Bar&quot;</span><span class="p">,</span>
		<span class="s">&quot;Riser&quot;</span><span class="p">,</span> <span class="s">&quot;HDMI&quot;</span><span class="p">,</span> <span class="s">&quot;ATAPI&quot;</span><span class="p">,</span>
		<span class="s">&quot;Mobile-In&quot;</span><span class="p">,</span> <span class="s">&quot;Mobile-Out&quot;</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">cfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">AC_DEFCFG_LOCATION</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">AC_DEFCFG_LOCATION_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bases</span><span class="p">[</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">specials_idx</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">==</span> <span class="n">specials_idx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">specials</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_get_jack_location</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_get_jack_connectivity - Give a connectivity string of the jack</span>
<span class="cm"> * @cfg: pin default config value</span>
<span class="cm"> *</span>
<span class="cm"> * Parse the pin default config value and returns the string of the</span>
<span class="cm"> * jack connectivity, i.e. external or internal connection.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">snd_hda_get_jack_connectivity</span><span class="p">(</span><span class="n">u32</span> <span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">jack_locations</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;Ext&quot;</span><span class="p">,</span> <span class="s">&quot;Int&quot;</span><span class="p">,</span> <span class="s">&quot;Sep&quot;</span><span class="p">,</span> <span class="s">&quot;Oth&quot;</span> <span class="p">};</span>

	<span class="k">return</span> <span class="n">jack_locations</span><span class="p">[(</span><span class="n">cfg</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">AC_DEFCFG_LOCATION_SHIFT</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_get_jack_connectivity</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_get_jack_type - Give a type string of the jack</span>
<span class="cm"> * @cfg: pin default config value</span>
<span class="cm"> *</span>
<span class="cm"> * Parse the pin default config value and returns the string of the</span>
<span class="cm"> * jack type, i.e. the purpose of the jack, such as Line-Out or CD.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">snd_hda_get_jack_type</span><span class="p">(</span><span class="n">u32</span> <span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">jack_types</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;Line Out&quot;</span><span class="p">,</span> <span class="s">&quot;Speaker&quot;</span><span class="p">,</span> <span class="s">&quot;HP Out&quot;</span><span class="p">,</span> <span class="s">&quot;CD&quot;</span><span class="p">,</span>
		<span class="s">&quot;SPDIF Out&quot;</span><span class="p">,</span> <span class="s">&quot;Digital Out&quot;</span><span class="p">,</span> <span class="s">&quot;Modem Line&quot;</span><span class="p">,</span> <span class="s">&quot;Modem Hand&quot;</span><span class="p">,</span>
		<span class="s">&quot;Line In&quot;</span><span class="p">,</span> <span class="s">&quot;Aux&quot;</span><span class="p">,</span> <span class="s">&quot;Mic&quot;</span><span class="p">,</span> <span class="s">&quot;Telephony&quot;</span><span class="p">,</span>
		<span class="s">&quot;SPDIF In&quot;</span><span class="p">,</span> <span class="s">&quot;Digitial In&quot;</span><span class="p">,</span> <span class="s">&quot;Reserved&quot;</span><span class="p">,</span> <span class="s">&quot;Other&quot;</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">jack_types</span><span class="p">[(</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">AC_DEFCFG_DEVICE</span><span class="p">)</span>
				<span class="o">&gt;&gt;</span> <span class="n">AC_DEFCFG_DEVICE_SHIFT</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_get_jack_type</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Compose a 32bit command word to be sent to the HD-audio controller</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">make_codec_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direct</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">verb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">parm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">direct</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x7f</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">verb</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xfff</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">parm</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xffff</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda-codec: out of range cmd %x:%x:%x:%x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">codec</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">direct</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">verb</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">direct</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">nid</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">verb</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">parm</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send and receive a verb</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">codec_exec_verb</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
 <span class="nl">again:</span>
	<span class="n">snd_hda_power_up</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">cmd_mutex</span><span class="p">);</span>
	<span class="n">trace_hda_send_cmd</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">command</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">get_response</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">trace_hda_get_response</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">cmd_mutex</span><span class="p">);</span>
	<span class="n">snd_hda_power_down</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">res</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">rirb_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">response_reset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printd</span><span class="p">(</span><span class="s">&quot;hda_codec: resetting BUS due to &quot;</span>
				   <span class="s">&quot;fatal communication error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">trace_hda_bus_reset</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
			<span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">bus_reset</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* clear reset-flag when the communication gets recovered */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">bus</span><span class="o">-&gt;</span><span class="n">response_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_read - send a command and get the response</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @nid: NID to send the command</span>
<span class="cm"> * @direct: direct flag</span>
<span class="cm"> * @verb: the verb to send</span>
<span class="cm"> * @parm: the parameter for the verb</span>
<span class="cm"> *</span>
<span class="cm"> * Send a single command and read the corresponding response.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the obtained response value, or -1 for an error.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">snd_hda_codec_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">direct</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">verb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">parm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">make_codec_cmd</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">direct</span><span class="p">,</span> <span class="n">verb</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec_exec_verb</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_read</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_write - send a single command without waiting for response</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @nid: NID to send the command</span>
<span class="cm"> * @direct: direct flag</span>
<span class="cm"> * @verb: the verb to send</span>
<span class="cm"> * @parm: the parameter for the verb</span>
<span class="cm"> *</span>
<span class="cm"> * Send a single command without waiting for response.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_codec_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direct</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">verb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">parm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">make_codec_cmd</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">direct</span><span class="p">,</span> <span class="n">verb</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">codec_exec_verb</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
			       <span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">sync_write</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">res</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_write</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_sequence_write - sequence writes</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @seq: VERB array to send</span>
<span class="cm"> *</span>
<span class="cm"> * Send the commands sequentially from the given array.</span>
<span class="cm"> * The array must be terminated with NID=0.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_hda_sequence_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">hda_verb</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">;</span> <span class="n">seq</span><span class="o">++</span><span class="p">)</span>
		<span class="n">snd_hda_codec_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">verb</span><span class="p">,</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_sequence_write</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_get_sub_nodes - get the range of sub nodes</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @nid: NID to parse</span>
<span class="cm"> * @start_id: the pointer to store the start NID</span>
<span class="cm"> *</span>
<span class="cm"> * Parse the NID and store the start NID of its sub-nodes.</span>
<span class="cm"> * Returns the number of sub-nodes.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_get_sub_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
			  <span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">start_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">parm</span><span class="p">;</span>

	<span class="n">parm</span> <span class="o">=</span> <span class="n">snd_hda_param_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">AC_PAR_NODE_COUNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parm</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">start_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">parm</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7fff</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">parm</span> <span class="o">&amp;</span> <span class="mh">0x7fff</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_get_sub_nodes</span><span class="p">);</span>

<span class="cm">/* look up the cached results */</span>
<span class="k">static</span> <span class="n">hda_nid_t</span> <span class="o">*</span><span class="nf">lookup_conn_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_array</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* read the connection and add to the cache */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_and_add_raw_conns</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hda_nid_t</span> <span class="n">list</span><span class="p">[</span><span class="n">HDA_MAX_CONNECTIONS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">snd_hda_get_raw_connections</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">list</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snd_hda_override_conn_list</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_get_connections - copy connection list</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @nid: NID to parse</span>
<span class="cm"> * @conn_list: connection list array; when NULL, checks only the size</span>
<span class="cm"> * @max_conns: max. number of connections to store</span>
<span class="cm"> *</span>
<span class="cm"> * Parses the connection list of the given widget and stores the list</span>
<span class="cm"> * of NIDs.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of connections, or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_get_connections</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
			    <span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">conn_list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_conns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_array</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">conn_lists</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">added</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

 <span class="nl">again:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* if the connection-list is already cached, read it */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">lookup_conn_list</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn_list</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">max_conns</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: &quot;</span>
				   <span class="s">&quot;Too many connections %d for NID 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">len</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn_list</span> <span class="o">&amp;&amp;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">conn_list</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hda_nid_t</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">added</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">read_and_add_raw_conns</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">added</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_get_connections</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_get_raw_connections - copy connection list without cache</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @nid: NID to parse</span>
<span class="cm"> * @conn_list: connection list array</span>
<span class="cm"> * @max_conns: max. number of connections to store</span>
<span class="cm"> *</span>
<span class="cm"> * Like snd_hda_get_connections(), copy the connection list but without</span>
<span class="cm"> * checking through the connection-list cache.</span>
<span class="cm"> * Currently called only from hda_proc.c, so not exported.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_get_raw_connections</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
				<span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">conn_list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_conns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">parm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">conn_len</span><span class="p">,</span> <span class="n">conns</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">,</span> <span class="n">num_elems</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wcaps</span><span class="p">;</span>
	<span class="n">hda_nid_t</span> <span class="n">prev_nid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">conn_list</span> <span class="o">||</span> <span class="n">max_conns</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">wcaps</span> <span class="o">=</span> <span class="n">get_wcaps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wcaps</span> <span class="o">&amp;</span> <span class="n">AC_WCAP_CONN_LIST</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">get_wcaps_type</span><span class="p">(</span><span class="n">wcaps</span><span class="p">)</span> <span class="o">!=</span> <span class="n">AC_WID_VOL_KNB</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">parm</span> <span class="o">=</span> <span class="n">snd_hda_param_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">AC_PAR_CONNLIST_LEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parm</span> <span class="o">&amp;</span> <span class="n">AC_CLIST_LONG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* long form */</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">num_elems</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* short form */</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">num_elems</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">conn_len</span> <span class="o">=</span> <span class="n">parm</span> <span class="o">&amp;</span> <span class="n">AC_CLIST_LENGTH</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">shift</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">conn_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* no connection */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">conn_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* single connection */</span>
		<span class="n">parm</span> <span class="o">=</span> <span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">AC_VERB_GET_CONNECT_LIST</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parm</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">rirb_error</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">conn_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">parm</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* multi connection */</span>
	<span class="n">conns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">prev_nid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">conn_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">range_val</span><span class="p">;</span>
		<span class="n">hda_nid_t</span> <span class="n">val</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">num_elems</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parm</span> <span class="o">=</span> <span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						  <span class="n">AC_VERB_GET_CONNECT_LIST</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">parm</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">rirb_error</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">range_val</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">parm</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">shift</span><span class="o">-</span><span class="mi">1</span><span class="p">)));</span> <span class="cm">/* ranges */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">parm</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;hda_codec: &quot;</span>
				   <span class="s">&quot;invalid CONNECT_LIST verb %x[%i]:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">nid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">parm</span> <span class="o">&gt;&gt;=</span> <span class="n">shift</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">range_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* ranges between the previous and this one */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_nid</span> <span class="o">||</span> <span class="n">prev_nid</span> <span class="o">&gt;=</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;hda_codec: &quot;</span>
					   <span class="s">&quot;invalid dep_range_val %x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">prev_nid</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">prev_nid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">val</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">conns</span> <span class="o">&gt;=</span> <span class="n">max_conns</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: &quot;</span>
						   <span class="s">&quot;Too many connections %d for NID 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						   <span class="n">conns</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">conn_list</span><span class="p">[</span><span class="n">conns</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">conns</span> <span class="o">&gt;=</span> <span class="n">max_conns</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: &quot;</span>
					   <span class="s">&quot;Too many connections %d for NID 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">conns</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">conn_list</span><span class="p">[</span><span class="n">conns</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prev_nid</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">conns</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">add_conn_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_array</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">snd_array_new</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_override_conn_list - add/modify the connection-list to cache</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @nid: NID to parse</span>
<span class="cm"> * @len: number of connection list entries</span>
<span class="cm"> * @list: the list of connection entries</span>
<span class="cm"> *</span>
<span class="cm"> * Add or modify the given connection-list to the cache.  If the corresponding</span>
<span class="cm"> * cache already exists, invalidate it and append a new one.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_override_conn_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			       <span class="k">const</span> <span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_array</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">conn_lists</span><span class="p">;</span>
	<span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">old_used</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">lookup_conn_list</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* invalidate the old entry */</span>

	<span class="n">old_used</span> <span class="o">=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">add_conn_list</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">nid</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">add_conn_list</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_add</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">add_conn_list</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">goto</span> <span class="n">error_add</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">error_add:</span>
	<span class="n">array</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="n">old_used</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_override_conn_list</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_get_conn_index - get the connection index of the given NID</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @mux: NID containing the list</span>
<span class="cm"> * @nid: NID to select</span>
<span class="cm"> * @recursive: 1 when searching NID recursively, otherwise 0</span>
<span class="cm"> *</span>
<span class="cm"> * Parses the connection list of the widget @mux and checks whether the</span>
<span class="cm"> * widget @nid is present.  If it is, return the connection index.</span>
<span class="cm"> * Otherwise it returns -1.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_get_conn_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">mux</span><span class="p">,</span>
			   <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">recursive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hda_nid_t</span> <span class="n">conn</span><span class="p">[</span><span class="n">HDA_MAX_NUM_INPUTS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nums</span><span class="p">;</span>

	<span class="n">nums</span> <span class="o">=</span> <span class="n">snd_hda_get_connections</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">mux</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">conn</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nid</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">recursive</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">recursive</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="s">&quot;hda_codec: too deep connection for 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">recursive</span><span class="o">++</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">get_wcaps_type</span><span class="p">(</span><span class="n">get_wcaps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">AC_WID_PIN</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">AC_WID_AUD_OUT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">snd_hda_get_conn_index</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nid</span><span class="p">,</span> <span class="n">recursive</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_get_conn_index</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_queue_unsol_event - add an unsolicited event to queue</span>
<span class="cm"> * @bus: the BUS</span>
<span class="cm"> * @res: unsolicited event (lower 32bit of RIRB entry)</span>
<span class="cm"> * @res_ex: codec addr and flags (upper 32bit or RIRB entry)</span>
<span class="cm"> *</span>
<span class="cm"> * Adds the given event to the queue.  The events are processed in</span>
<span class="cm"> * the workqueue asynchronously.  Call this function in the interrupt</span>
<span class="cm"> * hanlder when RIRB receives an unsolicited event.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_queue_unsol_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="n">u32</span> <span class="n">res</span><span class="p">,</span> <span class="n">u32</span> <span class="n">res_ex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_bus_unsolicited</span> <span class="o">*</span><span class="n">unsol</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wp</span><span class="p">;</span>

	<span class="n">trace_hda_unsol_event</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">res_ex</span><span class="p">);</span>
	<span class="n">unsol</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">unsol</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unsol</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">wp</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsol</span><span class="o">-&gt;</span><span class="n">wp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">HDA_UNSOL_QUEUE_SIZE</span><span class="p">;</span>
	<span class="n">unsol</span><span class="o">-&gt;</span><span class="n">wp</span> <span class="o">=</span> <span class="n">wp</span><span class="p">;</span>

	<span class="n">wp</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">unsol</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">wp</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">unsol</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">wp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_ex</span><span class="p">;</span>

	<span class="n">queue_work</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unsol</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_queue_unsol_event</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * process queued unsolicited events</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_unsol_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_bus_unsolicited</span> <span class="o">*</span><span class="n">unsol</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hda_bus_unsolicited</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">unsol</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rp</span><span class="p">,</span> <span class="n">caddr</span><span class="p">,</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">unsol</span><span class="o">-&gt;</span><span class="n">rp</span> <span class="o">!=</span> <span class="n">unsol</span><span class="o">-&gt;</span><span class="n">wp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rp</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsol</span><span class="o">-&gt;</span><span class="n">rp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">HDA_UNSOL_QUEUE_SIZE</span><span class="p">;</span>
		<span class="n">unsol</span><span class="o">-&gt;</span><span class="n">rp</span> <span class="o">=</span> <span class="n">rp</span><span class="p">;</span>
		<span class="n">rp</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">unsol</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">rp</span><span class="p">];</span>
		<span class="n">caddr</span> <span class="o">=</span> <span class="n">unsol</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">[</span><span class="n">rp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">caddr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)))</span> <span class="cm">/* no unsolicited event? */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">codec</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">caddr_tbl</span><span class="p">[</span><span class="n">caddr</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">codec</span> <span class="o">&amp;&amp;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">unsol_event</span><span class="p">)</span>
			<span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">unsol_event</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * initialize unsolicited queue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_unsol_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_bus_unsolicited</span> <span class="o">*</span><span class="n">unsol</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">unsol</span><span class="p">)</span> <span class="cm">/* already initialized */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">unsol</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">unsol</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unsol</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: &quot;</span>
			   <span class="s">&quot;can&#39;t allocate unsolicited queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unsol</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">process_unsol_events</span><span class="p">);</span>
	<span class="n">unsol</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">unsol</span> <span class="o">=</span> <span class="n">unsol</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * destructor</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">snd_hda_codec_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_hda_bus_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">)</span>
		<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">unsol</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">unsol</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_hda_codec_free</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">private_free</span><span class="p">)</span>
		<span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">private_free</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">)</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_hda_bus_dev_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">device_data</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">shutdown</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snd_hda_bus_free</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SND_HDA_HWDEP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_hda_bus_dev_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">device_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_hda_hwdep_add_sysfs</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
		<span class="n">snd_hda_hwdep_add_power_sysfs</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define snd_hda_bus_dev_register	NULL</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_bus_new - create a HDA bus</span>
<span class="cm"> * @card: the card entry</span>
<span class="cm"> * @temp: the template for hda_bus information</span>
<span class="cm"> * @busp: the pointer to store the created bus instance</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="cm">/*__devinit*/</span> <span class="n">snd_hda_bus_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">hda_bus_template</span> <span class="o">*</span><span class="n">temp</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">**</span><span class="n">busp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_device_ops</span> <span class="n">dev_ops</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">dev_register</span> <span class="o">=</span> <span class="n">snd_hda_bus_dev_register</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dev_free</span> <span class="o">=</span> <span class="n">snd_hda_bus_dev_free</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">temp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">command</span> <span class="o">||</span> <span class="o">!</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">get_response</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">busp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">busp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">bus</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bus</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;can&#39;t allocate struct hda_bus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">card</span> <span class="o">=</span> <span class="n">card</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">pci</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">modelname</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">modelname</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">power_save</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">power_save</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">cmd_mutex</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">prepare_mutex</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">);</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq_name</span><span class="p">),</span>
		 <span class="s">&quot;hd-audio%d&quot;</span><span class="p">,</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;cannot create workqueue %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq_name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_device_new</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">SNDRV_DEV_BUS</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_hda_bus_free</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">busp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">busp</span> <span class="o">=</span> <span class="n">bus</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_bus_new</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SND_HDA_GENERIC</span>
<span class="cp">#define is_generic_config(codec) \</span>
<span class="cp">	(codec-&gt;modelname &amp;&amp; !strcmp(codec-&gt;modelname, &quot;generic&quot;))</span>
<span class="cp">#else</span>
<span class="cp">#define is_generic_config(codec)	0</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef MODULE</span>
<span class="cp">#define HDA_MODREQ_MAX_COUNT	2	</span><span class="cm">/* two request_modules()&#39;s */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define HDA_MODREQ_MAX_COUNT	0	</span><span class="cm">/* all presets are statically linked */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * find a matching codec preset</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">hda_codec_preset</span> <span class="o">*</span>
<span class="nf">find_codec_preset</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec_preset_list</span> <span class="o">*</span><span class="n">tbl</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">hda_codec_preset</span> <span class="o">*</span><span class="n">preset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mod_requested</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_generic_config</span><span class="p">(</span><span class="n">codec</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* use the generic parser */</span>

 <span class="nl">again:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">preset_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hda_preset_tables</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: cannot module_get</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">preset</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">preset</span><span class="p">;</span> <span class="n">preset</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span> <span class="n">preset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">preset</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">preset</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">&amp;&amp;</span> <span class="n">preset</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">!=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">preset</span><span class="o">-&gt;</span><span class="n">mfg</span> <span class="o">&amp;&amp;</span> <span class="n">preset</span><span class="o">-&gt;</span><span class="n">mfg</span> <span class="o">!=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">mfg</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mask</span><span class="p">)</span>
				<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">preset</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_id</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">preset</span><span class="o">-&gt;</span><span class="n">rev</span> <span class="o">||</span>
			     <span class="n">preset</span><span class="o">-&gt;</span><span class="n">rev</span> <span class="o">==</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">revision_id</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">preset_mutex</span><span class="p">);</span>
				<span class="n">codec</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">preset</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">preset_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mod_requested</span> <span class="o">&lt;</span> <span class="n">HDA_MODREQ_MAX_COUNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_requested</span><span class="p">)</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;snd-hda-codec-id:%08x&quot;</span><span class="p">,</span>
				 <span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_id</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;snd-hda-codec-id:%04x*&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_id</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="n">request_module</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
		<span class="n">mod_requested</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get_codec_name - store the codec name</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_codec_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">hda_vendor_id</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vendor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vendor_id</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_id</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_name</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">get_chip_name</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">hda_vendor_ids</span><span class="p">;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">vendor_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vendor</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vendor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;Generic %04x&quot;</span><span class="p">,</span> <span class="n">vendor_id</span><span class="p">);</span>
		<span class="n">vendor</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">vendor</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_name</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

 <span class="nl">get_chip_name:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">chip_name</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">preset</span> <span class="o">&amp;&amp;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">preset</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">chip_name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">preset</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;ID %x&quot;</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_id</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">chip_name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">chip_name</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * look for an AFG and MFG nodes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="cm">/*__devinit*/</span> <span class="n">setup_fg_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">total_nodes</span><span class="p">,</span> <span class="n">function_id</span><span class="p">;</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">total_nodes</span> <span class="o">=</span> <span class="n">snd_hda_get_sub_nodes</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">AC_NODE_ROOT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nid</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">total_nodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">nid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">function_id</span> <span class="o">=</span> <span class="n">snd_hda_param_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span>
						<span class="n">AC_PAR_FUNCTION_TYPE</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">function_id</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AC_GRP_AUDIO_FUNCTION</span>:
			<span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
			<span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg_function_id</span> <span class="o">=</span> <span class="n">function_id</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg_unsol</span> <span class="o">=</span> <span class="p">(</span><span class="n">function_id</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AC_GRP_MODEM_FUNCTION</span>:
			<span class="n">codec</span><span class="o">-&gt;</span><span class="n">mfg</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
			<span class="n">codec</span><span class="o">-&gt;</span><span class="n">mfg_function_id</span> <span class="o">=</span> <span class="n">function_id</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">codec</span><span class="o">-&gt;</span><span class="n">mfg_unsol</span> <span class="o">=</span> <span class="p">(</span><span class="n">function_id</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * read widget caps for each widget and store in cache</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">read_widget_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">fg_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">num_nodes</span> <span class="o">=</span> <span class="n">snd_hda_get_sub_nodes</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">fg_node</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">start_nid</span><span class="p">);</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">wcaps</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">num_nodes</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">wcaps</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">nid</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">start_nid</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">num_nodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">nid</span><span class="o">++</span><span class="p">)</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">wcaps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">snd_hda_param_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span>
						     <span class="n">AC_PAR_AUDIO_WIDGET_CAP</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* read all pin default configurations and save codec-&gt;init_pins */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">read_pin_defaults</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">start_nid</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">num_nodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">nid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hda_pincfg</span> <span class="o">*</span><span class="n">pin</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wcaps</span> <span class="o">=</span> <span class="n">get_wcaps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wid_type</span> <span class="o">=</span> <span class="n">get_wcaps_type</span><span class="p">(</span><span class="n">wcaps</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wid_type</span> <span class="o">!=</span> <span class="n">AC_WID_PIN</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">pin</span> <span class="o">=</span> <span class="n">snd_array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">init_pins</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pin</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">pin</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
		<span class="n">pin</span><span class="o">-&gt;</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					      <span class="n">AC_VERB_GET_CONFIG_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">pin</span><span class="o">-&gt;</span><span class="n">ctrl</span> <span class="o">=</span> <span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="n">AC_VERB_GET_PIN_WIDGET_CONTROL</span><span class="p">,</span>
					       <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* look up the given pin config list and return the item matching with NID */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hda_pincfg</span> <span class="o">*</span><span class="n">look_up_pincfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">snd_array</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span>
					 <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hda_pincfg</span> <span class="o">*</span><span class="n">pin</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pin</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">==</span> <span class="n">nid</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">pin</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* write a config value for the given NID */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">set_pincfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_hda_codec_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				    <span class="n">AC_VERB_SET_CONFIG_DEFAULT_BYTES_0</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
				    <span class="n">cfg</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">cfg</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* set the current pin config value for the given NID.</span>
<span class="cm"> * the value is cached, and read via snd_hda_codec_get_pincfg()</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">snd_hda_add_pincfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_array</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
		       <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_pincfg</span> <span class="o">*</span><span class="n">pin</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oldcfg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_wcaps_type</span><span class="p">(</span><span class="n">get_wcaps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">))</span> <span class="o">!=</span> <span class="n">AC_WID_PIN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">oldcfg</span> <span class="o">=</span> <span class="n">snd_hda_codec_get_pincfg</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="n">pin</span> <span class="o">=</span> <span class="n">look_up_pincfg</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pin</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pin</span> <span class="o">=</span> <span class="n">snd_array_new</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pin</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">pin</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pin</span><span class="o">-&gt;</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">;</span>

	<span class="cm">/* change only when needed; e.g. if the pincfg is already present</span>
<span class="cm">	 * in user_pins[], don&#39;t write it</span>
<span class="cm">	 */</span>
	<span class="n">cfg</span> <span class="o">=</span> <span class="n">snd_hda_codec_get_pincfg</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldcfg</span> <span class="o">!=</span> <span class="n">cfg</span><span class="p">)</span>
		<span class="n">set_pincfg</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_set_pincfg - Override a pin default configuration</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @nid: NID to set the pin config</span>
<span class="cm"> * @cfg: the pin default config value</span>
<span class="cm"> *</span>
<span class="cm"> * Override a pin default configuration value in the cache.</span>
<span class="cm"> * This value can be read by snd_hda_codec_get_pincfg() in a higher</span>
<span class="cm"> * priority than the real hardware value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">snd_hda_codec_set_pincfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			     <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snd_hda_add_pincfg</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">driver_pins</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_set_pincfg</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_get_pincfg - Obtain a pin-default configuration</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @nid: NID to get the pin config</span>
<span class="cm"> *</span>
<span class="cm"> * Get the current pin config value of the given pin NID.</span>
<span class="cm"> * If the pincfg value is cached or overridden via sysfs or driver,</span>
<span class="cm"> * returns the cached value.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">snd_hda_codec_get_pincfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_pincfg</span> <span class="o">*</span><span class="n">pin</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SND_HDA_HWDEP</span>
	<span class="n">pin</span> <span class="o">=</span> <span class="n">look_up_pincfg</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">user_pins</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pin</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pin</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">pin</span> <span class="o">=</span> <span class="n">look_up_pincfg</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">driver_pins</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pin</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pin</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">;</span>
	<span class="n">pin</span> <span class="o">=</span> <span class="n">look_up_pincfg</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">init_pins</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pin</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pin</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_get_pincfg</span><span class="p">);</span>

<span class="cm">/* restore all current pin configs */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_pincfgs</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">init_pins</span><span class="p">.</span><span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hda_pincfg</span> <span class="o">*</span><span class="n">pin</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">init_pins</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">set_pincfg</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">pin</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span>
			   <span class="n">snd_hda_codec_get_pincfg</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">pin</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_shutup_pins - Shut up all pins</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> *</span>
<span class="cm"> * Clear all pin controls to shup up before suspend for avoiding click noise.</span>
<span class="cm"> * The controls aren&#39;t cached so that they can be resumed properly.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_hda_shutup_pins</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="cm">/* don&#39;t shut up pins when unloading the driver; otherwise it breaks</span>
<span class="cm">	 * the default pin setup at the next load of the driver</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">init_pins</span><span class="p">.</span><span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hda_pincfg</span> <span class="o">*</span><span class="n">pin</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">init_pins</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="cm">/* use read here for syncing after issuing each verb */</span>
		<span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">pin</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				   <span class="n">AC_VERB_SET_PIN_WIDGET_CONTROL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">pins_shutup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_shutup_pins</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/* Restore the pin controls cleared previously via snd_hda_shutup_pins() */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_shutup_pins</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">pins_shutup</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">init_pins</span><span class="p">.</span><span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hda_pincfg</span> <span class="o">*</span><span class="n">pin</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">init_pins</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">snd_hda_codec_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">pin</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				    <span class="n">AC_VERB_SET_PIN_WIDGET_CONTROL</span><span class="p">,</span>
				    <span class="n">pin</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">pins_shutup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">init_hda_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_cache_rec</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">record_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">free_hda_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_cache_rec</span> <span class="o">*</span><span class="n">cache</span><span class="p">);</span>

<span class="cm">/* restore the initial pin cfgs and release all pincfg lists */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_init_pincfgs</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* first free driver_pins and user_pins, then call restore_pincfg</span>
<span class="cm">	 * so that only the values in init_pins are restored</span>
<span class="cm">	 */</span>
	<span class="n">snd_array_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">driver_pins</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SND_HDA_HWDEP</span>
	<span class="n">snd_array_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">user_pins</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">restore_pincfgs</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">snd_array_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">init_pins</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * audio-converter setup caches</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hda_cvt_setup</span> <span class="p">{</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">stream_tag</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">channel_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">format_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">active</span><span class="p">;</span>	<span class="cm">/* cvt is currently used */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dirty</span><span class="p">;</span>	<span class="cm">/* setups should be cleared */</span>
<span class="p">};</span>

<span class="cm">/* get or create a cache entry for the given audio converter NID */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hda_cvt_setup</span> <span class="o">*</span>
<span class="nf">get_hda_cvt_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_cvt_setup</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">cvt_setups</span><span class="p">.</span><span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">cvt_setups</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">==</span> <span class="n">nid</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">snd_array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">cvt_setups</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * codec destructor</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snd_hda_codec_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">snd_hda_jack_tbl_clear</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">restore_init_pincfgs</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SND_HDA_POWER_SAVE</span>
	<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_work</span><span class="p">);</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">snd_array_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">mixers</span><span class="p">);</span>
	<span class="n">snd_array_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">nids</span><span class="p">);</span>
	<span class="n">snd_array_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">cvt_setups</span><span class="p">);</span>
	<span class="n">snd_array_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">conn_lists</span><span class="p">);</span>
	<span class="n">snd_array_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_out</span><span class="p">);</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">caddr_tbl</span><span class="p">[</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">free</span><span class="p">)</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="n">free_hda_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">amp_cache</span><span class="p">);</span>
	<span class="n">free_hda_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">cmd_cache</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">chip_name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">modelname</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">wcaps</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hda_set_power_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">fg</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">power_state</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_new - create a HDA codec</span>
<span class="cm"> * @bus: the bus to assign</span>
<span class="cm"> * @codec_addr: the codec address</span>
<span class="cm"> * @codecp: the pointer to store the generated codec</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="cm">/*__devinit*/</span> <span class="n">snd_hda_codec_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">codec_addr</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">**</span><span class="n">codecp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">component</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">codec_addr</span> <span class="o">&gt;</span> <span class="n">HDA_MAX_CODEC_ADDRESS</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">caddr_tbl</span><span class="p">[</span><span class="n">codec_addr</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: &quot;</span>
			   <span class="s">&quot;address 0x%x is already occupied</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">codec_addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">codec</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">codec</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;can&#39;t allocate struct hda_codec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">codec_addr</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_mutex</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
	<span class="n">init_hda_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">amp_cache</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_amp_info</span><span class="p">));</span>
	<span class="n">init_hda_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">cmd_cache</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_cache_head</span><span class="p">));</span>
	<span class="n">snd_array_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">mixers</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_nid_item</span><span class="p">),</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">snd_array_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">nids</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_nid_item</span><span class="p">),</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">snd_array_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">init_pins</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_pincfg</span><span class="p">),</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">snd_array_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">driver_pins</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_pincfg</span><span class="p">),</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">snd_array_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">cvt_setups</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_cvt_setup</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">snd_array_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">conn_lists</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hda_nid_t</span><span class="p">),</span> <span class="mi">64</span><span class="p">);</span>
	<span class="n">snd_array_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_out</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_spdif_out</span><span class="p">),</span> <span class="mi">16</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SND_HDA_POWER_SAVE</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_work</span><span class="p">,</span> <span class="n">hda_power_work</span><span class="p">);</span>
	<span class="cm">/* snd_hda_codec_new() marks the codec as power-up, and leave it as is.</span>
<span class="cm">	 * the caller has to power down appropriatley after initialization</span>
<span class="cm">	 * phase.</span>
<span class="cm">	 */</span>
	<span class="n">hda_keep_power_on</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">modelname</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">modelname</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">modelname</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">modelname</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_hda_codec_free</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">);</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">caddr_tbl</span><span class="p">[</span><span class="n">codec_addr</span><span class="p">]</span> <span class="o">=</span> <span class="n">codec</span><span class="p">;</span>

	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_id</span> <span class="o">=</span> <span class="n">snd_hda_param_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">AC_NODE_ROOT</span><span class="p">,</span>
					      <span class="n">AC_PAR_VENDOR_ID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="cm">/* read again, hopefully the access method was corrected</span>
<span class="cm">		 * in the last read...</span>
<span class="cm">		 */</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_id</span> <span class="o">=</span> <span class="n">snd_hda_param_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">AC_NODE_ROOT</span><span class="p">,</span>
						      <span class="n">AC_PAR_VENDOR_ID</span><span class="p">);</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">subsystem_id</span> <span class="o">=</span> <span class="n">snd_hda_param_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">AC_NODE_ROOT</span><span class="p">,</span>
						 <span class="n">AC_PAR_SUBSYSTEM_ID</span><span class="p">);</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">revision_id</span> <span class="o">=</span> <span class="n">snd_hda_param_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">AC_NODE_ROOT</span><span class="p">,</span>
						<span class="n">AC_PAR_REV_ID</span><span class="p">);</span>

	<span class="n">setup_fg_nodes</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">mfg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;hda_codec: no AFG or MFG node found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">read_widget_caps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">?</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">:</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">mfg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: cannot malloc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">read_pin_defaults</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">subsystem_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hda_nid_t</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">?</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">:</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">mfg</span><span class="p">;</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">subsystem_id</span> <span class="o">=</span>
			<span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">AC_VERB_GET_SUBSYSTEM_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* power-up all before initialization */</span>
	<span class="n">hda_set_power_state</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span>
			    <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">?</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">:</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">mfg</span><span class="p">,</span>
			    <span class="n">AC_PWRST_D0</span><span class="p">);</span>

	<span class="n">snd_hda_codec_proc_new</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>

	<span class="n">snd_hda_create_hwdep</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="s">&quot;HDA:%08x,%08x,%08x&quot;</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_id</span><span class="p">,</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">subsystem_id</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">revision_id</span><span class="p">);</span>
	<span class="n">snd_component_add</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">component</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">codecp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">codecp</span> <span class="o">=</span> <span class="n">codec</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">error:</span>
	<span class="n">snd_hda_codec_free</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_new</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_configure - (Re-)configure the HD-audio codec</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> *</span>
<span class="cm"> * Start parsing of the given codec tree and (re-)initialize the whole</span>
<span class="cm"> * patch instance.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_codec_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">preset</span> <span class="o">=</span> <span class="n">find_codec_preset</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_name</span> <span class="o">||</span> <span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">chip_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">get_codec_name</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_generic_config</span><span class="p">(</span><span class="n">codec</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_parse_generic_codec</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">patched</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">preset</span> <span class="o">&amp;&amp;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">preset</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">preset</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">patched</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* call the default parser */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_parse_generic_codec</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda-codec: No codec parser is available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

 <span class="nl">patched:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">unsol_event</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">init_unsol_queue</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="cm">/* audio codec should override the mixer name */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">||</span> <span class="o">!*</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">mixername</span><span class="p">))</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">mixername</span><span class="p">,</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">mixername</span><span class="p">),</span>
			 <span class="s">&quot;%s %s&quot;</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">vendor_name</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">chip_name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_configure</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_setup_stream - set up the codec for streaming</span>
<span class="cm"> * @codec: the CODEC to set up</span>
<span class="cm"> * @nid: the NID to set up</span>
<span class="cm"> * @stream_tag: stream tag to pass, it&#39;s between 0x1 and 0xf.</span>
<span class="cm"> * @channel_id: channel id to pass, zero based.</span>
<span class="cm"> * @format: stream format.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_hda_codec_setup_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">stream_tag</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">channel_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">format</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_cvt_setup</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oldval</span><span class="p">,</span> <span class="n">newval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;hda_codec_setup_stream: &quot;</span>
		    <span class="s">&quot;NID=0x%x, stream=0x%x, channel=%d, format=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">nid</span><span class="p">,</span> <span class="n">stream_tag</span><span class="p">,</span> <span class="n">channel_id</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">get_hda_cvt_setup</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* update the stream-id if changed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">stream_tag</span> <span class="o">!=</span> <span class="n">stream_tag</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">channel_id</span> <span class="o">!=</span> <span class="n">channel_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oldval</span> <span class="o">=</span> <span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AC_VERB_GET_CONV</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">newval</span> <span class="o">=</span> <span class="p">(</span><span class="n">stream_tag</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">channel_id</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldval</span> <span class="o">!=</span> <span class="n">newval</span><span class="p">)</span>
			<span class="n">snd_hda_codec_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					    <span class="n">AC_VERB_SET_CHANNEL_STREAMID</span><span class="p">,</span>
					    <span class="n">newval</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">stream_tag</span> <span class="o">=</span> <span class="n">stream_tag</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">channel_id</span> <span class="o">=</span> <span class="n">channel_id</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* update the format-id if changed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">format_id</span> <span class="o">!=</span> <span class="n">format</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oldval</span> <span class="o">=</span> <span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					    <span class="n">AC_VERB_GET_STREAM_FORMAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldval</span> <span class="o">!=</span> <span class="n">format</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">snd_hda_codec_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					    <span class="n">AC_VERB_SET_STREAM_FORMAT</span><span class="p">,</span>
					    <span class="n">format</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">format_id</span> <span class="o">=</span> <span class="n">format</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* make other inactive cvts with the same stream-tag dirty */</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">get_wcaps_type</span><span class="p">(</span><span class="n">get_wcaps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">));</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cvt_setups</span><span class="p">.</span><span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cvt_setups</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">stream_tag</span> <span class="o">==</span> <span class="n">stream_tag</span> <span class="o">&amp;&amp;</span>
			    <span class="n">get_wcaps_type</span><span class="p">(</span><span class="n">get_wcaps</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">))</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_setup_stream</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">really_cleanup_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hda_cvt_setup</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __snd_hda_codec_cleanup_stream - clean up the codec for closing</span>
<span class="cm"> * @codec: the CODEC to clean up</span>
<span class="cm"> * @nid: the NID to clean up</span>
<span class="cm"> * @do_now: really clean up the stream instead of clearing the active flag</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__snd_hda_codec_cleanup_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">do_now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_cvt_setup</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">no_sticky_stream</span><span class="p">)</span>
		<span class="n">do_now</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;hda_codec_cleanup_stream: NID=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">get_hda_cvt_setup</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* here we just clear the active flag when do_now isn&#39;t set;</span>
<span class="cm">		 * actual clean-ups will be done later in</span>
<span class="cm">		 * purify_inactive_streams() called from snd_hda_codec_prpapre()</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_now</span><span class="p">)</span>
			<span class="n">really_cleanup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">__snd_hda_codec_cleanup_stream</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">really_cleanup_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hda_cvt_setup</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">stream_tag</span> <span class="o">||</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">channel_id</span><span class="p">)</span>
		<span class="n">snd_hda_codec_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AC_VERB_SET_CHANNEL_STREAMID</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">format_id</span><span class="p">)</span>
		<span class="n">snd_hda_codec_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AC_VERB_SET_STREAM_FORMAT</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">));</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* clean up the all conflicting obsolete streams */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">purify_inactive_streams</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cvt_setups</span><span class="p">.</span><span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">hda_cvt_setup</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cvt_setups</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span>
				<span class="n">really_cleanup_stream</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/* clean up all streams; called from suspend */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hda_cleanup_all_streams</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">cvt_setups</span><span class="p">.</span><span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hda_cvt_setup</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">cvt_setups</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">stream_tag</span><span class="p">)</span>
			<span class="n">really_cleanup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * amp access functions</span>
<span class="cm"> */</span>

<span class="cm">/* FIXME: more better hash key? */</span>
<span class="cp">#define HDA_HASH_KEY(nid, dir, idx) (u32)((nid) + ((idx) &lt;&lt; 16) + ((dir) &lt;&lt; 24))</span>
<span class="cp">#define HDA_HASH_PINCAP_KEY(nid) (u32)((nid) + (0x02 &lt;&lt; 24))</span>
<span class="cp">#define HDA_HASH_PARPCM_KEY(nid) (u32)((nid) + (0x03 &lt;&lt; 24))</span>
<span class="cp">#define HDA_HASH_PARSTR_KEY(nid) (u32)((nid) + (0x04 &lt;&lt; 24))</span>
<span class="cp">#define INFO_AMP_CAPS	(1&lt;&lt;0)</span>
<span class="cp">#define INFO_AMP_VOL(ch)	(1 &lt;&lt; (1 + (ch)))</span>

<span class="cm">/* initialize the hash table */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="cm">/*__devinit*/</span> <span class="n">init_hda_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_cache_rec</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">record_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cache</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">));</span>
	<span class="n">snd_array_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">record_size</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">free_hda_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_cache_rec</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_array_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* query the hash.  allocate an entry if not found. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hda_cache_head</span>  <span class="o">*</span><span class="n">get_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_cache_rec</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">key</span> <span class="o">%</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">hda_cache_head</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">info</span><span class="p">;</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* query the hash.  allocate an entry if not found. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hda_cache_head</span>  <span class="o">*</span><span class="n">get_alloc_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_cache_rec</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
					      <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_cache_head</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">get_hash</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">idx</span><span class="p">,</span> <span class="n">cur</span><span class="p">;</span>
		<span class="cm">/* add a new hash entry */</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">snd_array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">snd_array_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">key</span> <span class="o">%</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">info</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* query and allocate an amp hash entry */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hda_amp_info</span> <span class="o">*</span>
<span class="n">get_alloc_amp_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hda_amp_info</span> <span class="o">*</span><span class="p">)</span><span class="n">get_alloc_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">amp_cache</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* overwrite the value with the key in the caps hash */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">write_caps_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_amp_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">get_alloc_amp_hash</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">amp_caps</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">val</span> <span class="o">|=</span> <span class="n">INFO_AMP_CAPS</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* query the value from the caps hash; if not found, fetch the current</span>
<span class="cm"> * value from the given function and store in the hash</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="n">query_caps_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="p">,</span> <span class="n">hda_nid_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_amp_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">get_alloc_amp_hash</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">INFO_AMP_CAPS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span> <span class="cm">/* for reentrance */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
		<span class="n">write_caps_hash</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">amp_caps</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">read_amp_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">get_wcaps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AC_WCAP_AMP_OVRD</span><span class="p">))</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snd_hda_param_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span>
				  <span class="n">direction</span> <span class="o">==</span> <span class="n">HDA_OUTPUT</span> <span class="o">?</span>
				  <span class="n">AC_PAR_AMP_OUT_CAP</span> <span class="o">:</span> <span class="n">AC_PAR_AMP_IN_CAP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * query_amp_caps - query AMP capabilities</span>
<span class="cm"> * @codec: the HD-auio codec</span>
<span class="cm"> * @nid: the NID to query</span>
<span class="cm"> * @direction: either #HDA_INPUT or #HDA_OUTPUT</span>
<span class="cm"> *</span>
<span class="cm"> * Query AMP capabilities for the given widget and direction.</span>
<span class="cm"> * Returns the obtained capability bits.</span>
<span class="cm"> *</span>
<span class="cm"> * When cap bits have been already read, this doesn&#39;t read again but</span>
<span class="cm"> * returns the cached value.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="n">query_amp_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">query_caps_hash</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span>
			       <span class="n">HDA_HASH_KEY</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			       <span class="n">read_amp_cap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">query_amp_caps</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_override_amp_caps - Override the AMP capabilities</span>
<span class="cm"> * @codec: the CODEC to clean up</span>
<span class="cm"> * @nid: the NID to clean up</span>
<span class="cm"> * @direction: either #HDA_INPUT or #HDA_OUTPUT</span>
<span class="cm"> * @caps: the capability bits to set</span>
<span class="cm"> *</span>
<span class="cm"> * Override the cached AMP caps bits value by the given one.</span>
<span class="cm"> * This function is useful if the driver needs to adjust the AMP ranges,</span>
<span class="cm"> * e.g. limit to 0dB, etc.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if successful or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_override_amp_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">caps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">write_caps_hash</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">HDA_HASH_KEY</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">caps</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_override_amp_caps</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">read_pin_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snd_hda_param_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">AC_PAR_PIN_CAP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_query_pin_caps - Query PIN capabilities</span>
<span class="cm"> * @codec: the HD-auio codec</span>
<span class="cm"> * @nid: the NID to query</span>
<span class="cm"> *</span>
<span class="cm"> * Query PIN capabilities for the given widget.</span>
<span class="cm"> * Returns the obtained capability bits.</span>
<span class="cm"> *</span>
<span class="cm"> * When cap bits have been already read, this doesn&#39;t read again but</span>
<span class="cm"> * returns the cached value.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">snd_hda_query_pin_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">query_caps_hash</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HDA_HASH_PINCAP_KEY</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span>
			       <span class="n">read_pin_cap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_query_pin_caps</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_override_pin_caps - Override the pin capabilities</span>
<span class="cm"> * @codec: the CODEC</span>
<span class="cm"> * @nid: the NID to override</span>
<span class="cm"> * @caps: the capability bits to set</span>
<span class="cm"> *</span>
<span class="cm"> * Override the cached PIN capabilitiy bits value by the given one.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if successful or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_override_pin_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">caps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">write_caps_hash</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">HDA_HASH_PINCAP_KEY</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span> <span class="n">caps</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_override_pin_caps</span><span class="p">);</span>

<span class="cm">/* read or sync the hash value with the current value;</span>
<span class="cm"> * call within hash_mutex</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hda_amp_info</span> <span class="o">*</span>
<span class="nf">update_amp_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ch</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_amp_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">parm</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">val_read</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

 <span class="nl">retry:</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">get_alloc_amp_hash</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">HDA_HASH_KEY</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">index</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">INFO_AMP_VOL</span><span class="p">(</span><span class="n">ch</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val_read</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
			<span class="n">parm</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">?</span> <span class="n">AC_AMP_GET_RIGHT</span> <span class="o">:</span> <span class="n">AC_AMP_GET_LEFT</span><span class="p">;</span>
			<span class="n">parm</span> <span class="o">|=</span> <span class="n">direction</span> <span class="o">==</span> <span class="n">HDA_OUTPUT</span> <span class="o">?</span>
				<span class="n">AC_AMP_GET_OUTPUT</span> <span class="o">:</span> <span class="n">AC_AMP_GET_INPUT</span><span class="p">;</span>
			<span class="n">parm</span> <span class="o">|=</span> <span class="n">index</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="n">AC_VERB_GET_AMP_GAIN_MUTE</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
			<span class="n">val</span> <span class="o">&amp;=</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">val_read</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">val</span> <span class="o">|=</span> <span class="n">INFO_AMP_VOL</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">info</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * write the current volume in info to the h/w</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_vol_mute</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hda_amp_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			 <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">parm</span><span class="p">;</span>

	<span class="n">parm</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">?</span> <span class="n">AC_AMP_SET_RIGHT</span> <span class="o">:</span> <span class="n">AC_AMP_SET_LEFT</span><span class="p">;</span>
	<span class="n">parm</span> <span class="o">|=</span> <span class="n">direction</span> <span class="o">==</span> <span class="n">HDA_OUTPUT</span> <span class="o">?</span> <span class="n">AC_AMP_SET_OUTPUT</span> <span class="o">:</span> <span class="n">AC_AMP_SET_INPUT</span><span class="p">;</span>
	<span class="n">parm</span> <span class="o">|=</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">AC_AMP_SET_INDEX_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">HDA_AMP_MUTE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">amp_caps</span> <span class="o">&amp;</span> <span class="n">AC_AMPCAP_MUTE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">amp_caps</span> <span class="o">&amp;</span> <span class="n">AC_AMPCAP_MIN_MUTE</span><span class="p">))</span>
		<span class="p">;</span> <span class="cm">/* set the zero value as a fake mute */</span>
	<span class="k">else</span>
		<span class="n">parm</span> <span class="o">|=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">snd_hda_codec_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AC_VERB_SET_AMP_GAIN_MUTE</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_amp_read - Read AMP value</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> * @nid: NID to read the AMP value</span>
<span class="cm"> * @ch: channel (left=0 or right=1)</span>
<span class="cm"> * @direction: #HDA_INPUT or #HDA_OUTPUT</span>
<span class="cm"> * @index: the index value (only for input direction)</span>
<span class="cm"> *</span>
<span class="cm"> * Read AMP value.  The volume is between 0 to 0x7f, 0x80 = mute bit.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_codec_amp_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ch</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_amp_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">update_amp_hash</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">[</span><span class="n">ch</span><span class="p">];</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_amp_read</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_amp_update - update the AMP value</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> * @nid: NID to read the AMP value</span>
<span class="cm"> * @ch: channel (left=0 or right=1)</span>
<span class="cm"> * @direction: #HDA_INPUT or #HDA_OUTPUT</span>
<span class="cm"> * @idx: the index value (only for input direction)</span>
<span class="cm"> * @mask: bit mask to set</span>
<span class="cm"> * @val: the bits value to set</span>
<span class="cm"> *</span>
<span class="cm"> * Update the AMP value with a bit mask.</span>
<span class="cm"> * Returns 0 if the value is unchanged, 1 if changed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_codec_amp_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ch</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_amp_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xff</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">update_amp_hash</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">hash_mutex</span><span class="p">);</span>
	<span class="n">put_vol_mute</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_amp_update</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_amp_stereo - update the AMP stereo values</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> * @nid: NID to read the AMP value</span>
<span class="cm"> * @direction: #HDA_INPUT or #HDA_OUTPUT</span>
<span class="cm"> * @idx: the index value (only for input direction)</span>
<span class="cm"> * @mask: bit mask to set</span>
<span class="cm"> * @val: the bits value to set</span>
<span class="cm"> *</span>
<span class="cm"> * Update the AMP values like snd_hda_codec_amp_update(), but for a</span>
<span class="cm"> * stereo widget with the same mask and value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_codec_amp_stereo</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xff</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ch</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">ch</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">snd_hda_codec_amp_update</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span>
						<span class="n">idx</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_amp_stereo</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_resume_amp - Resume all AMP commands from the cache</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> *</span>
<span class="cm"> * Resume the all amp commands from the cache.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_hda_codec_resume_amp</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_amp_info</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">amp_cache</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">amp_cache</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">buffer</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">key</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">key</span><span class="p">;</span>
		<span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">ch</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">key</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ch</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">ch</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">INFO_AMP_VOL</span><span class="p">(</span><span class="n">ch</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">put_vol_mute</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span>
				     <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">[</span><span class="n">ch</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_resume_amp</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">get_amp_max_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">caps</span> <span class="o">=</span> <span class="n">query_amp_caps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="cm">/* get num steps */</span>
	<span class="n">caps</span> <span class="o">=</span> <span class="p">(</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">AC_AMPCAP_NUM_STEPS</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">AC_AMPCAP_NUM_STEPS_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&lt;</span> <span class="n">caps</span><span class="p">)</span>
		<span class="n">caps</span> <span class="o">-=</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">caps</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_mixer_amp_volume_info - Info callback for a standard AMP mixer</span>
<span class="cm"> *</span>
<span class="cm"> * The control element is supposed to have the private_value field</span>
<span class="cm"> * set up via HDA_COMPOSE_AMP_VAL*() or related macros.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_mixer_amp_volume_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">get_amp_nid</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">chs</span> <span class="o">=</span> <span class="n">get_amp_channels</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">get_amp_direction</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">get_amp_offset</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_INTEGER</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">chs</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">get_amp_max_value</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;hda_codec: &quot;</span>
		       <span class="s">&quot;num_steps = 0 for NID=0x%x (ctl = %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span>
		       <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_mixer_amp_volume_info</span><span class="p">);</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">read_amp_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
	       <span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">snd_hda_codec_amp_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="n">HDA_AMP_VOLMASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">ofs</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">-=</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">update_amp_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="cm">/* ofs = 0: raw max value */</span>
	<span class="n">maxval</span> <span class="o">=</span> <span class="n">get_amp_max_value</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">maxval</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">maxval</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snd_hda_codec_amp_update</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span>
					<span class="n">HDA_AMP_VOLMASK</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_mixer_amp_volume_get - Get callback for a standard AMP mixer volume</span>
<span class="cm"> *</span>
<span class="cm"> * The control element is supposed to have the private_value field</span>
<span class="cm"> * set up via HDA_COMPOSE_AMP_VAL*() or related macros.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_mixer_amp_volume_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">get_amp_nid</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">chs</span> <span class="o">=</span> <span class="n">get_amp_channels</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">get_amp_direction</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_amp_index</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">get_amp_offset</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">long</span> <span class="o">*</span><span class="n">valp</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chs</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">*</span><span class="n">valp</span><span class="o">++</span> <span class="o">=</span> <span class="n">read_amp_value</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chs</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="o">*</span><span class="n">valp</span> <span class="o">=</span> <span class="n">read_amp_value</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_mixer_amp_volume_get</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_mixer_amp_volume_put - Put callback for a standard AMP mixer volume</span>
<span class="cm"> *</span>
<span class="cm"> * The control element is supposed to have the private_value field</span>
<span class="cm"> * set up via HDA_COMPOSE_AMP_VAL*() or related macros.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_mixer_amp_volume_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">get_amp_nid</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">chs</span> <span class="o">=</span> <span class="n">get_amp_channels</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">get_amp_direction</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_amp_index</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">get_amp_offset</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">long</span> <span class="o">*</span><span class="n">valp</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">snd_hda_power_up</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chs</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">change</span> <span class="o">=</span> <span class="n">update_amp_value</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="o">*</span><span class="n">valp</span><span class="p">);</span>
		<span class="n">valp</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chs</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">change</span> <span class="o">|=</span> <span class="n">update_amp_value</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="o">*</span><span class="n">valp</span><span class="p">);</span>
	<span class="n">snd_hda_power_down</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">change</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_mixer_amp_volume_put</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_mixer_amp_volume_put - TLV callback for a standard AMP mixer volume</span>
<span class="cm"> *</span>
<span class="cm"> * The control element is supposed to have the private_value field</span>
<span class="cm"> * set up via HDA_COMPOSE_AMP_VAL*() or related macros.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_mixer_amp_tlv</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op_flag</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">_tlv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">get_amp_nid</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">get_amp_direction</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">get_amp_offset</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">min_mute</span> <span class="o">=</span> <span class="n">get_amp_min_mute</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">caps</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">caps</span> <span class="o">=</span> <span class="n">query_amp_caps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="n">val2</span> <span class="o">=</span> <span class="p">(</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">AC_AMPCAP_STEP_SIZE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">AC_AMPCAP_STEP_SIZE_SHIFT</span><span class="p">;</span>
	<span class="n">val2</span> <span class="o">=</span> <span class="p">(</span><span class="n">val2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">25</span><span class="p">;</span>
	<span class="n">val1</span> <span class="o">=</span> <span class="o">-</span><span class="p">((</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">AC_AMPCAP_OFFSET</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">AC_AMPCAP_OFFSET_SHIFT</span><span class="p">);</span>
	<span class="n">val1</span> <span class="o">+=</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="n">val1</span> <span class="o">=</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">val1</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">val2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">min_mute</span> <span class="o">||</span> <span class="p">(</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">AC_AMPCAP_MIN_MUTE</span><span class="p">))</span>
		<span class="n">val2</span> <span class="o">|=</span> <span class="n">TLV_DB_SCALE_MUTE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">SNDRV_CTL_TLVT_DB_SCALE</span><span class="p">,</span> <span class="n">_tlv</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span> <span class="n">_tlv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">val1</span><span class="p">,</span> <span class="n">_tlv</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">val2</span><span class="p">,</span> <span class="n">_tlv</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_mixer_amp_tlv</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_set_vmaster_tlv - Set TLV for a virtual master control</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> * @nid: NID of a reference widget</span>
<span class="cm"> * @dir: #HDA_INPUT or #HDA_OUTPUT</span>
<span class="cm"> * @tlv: TLV data to be stored, at least 4 elements</span>
<span class="cm"> *</span>
<span class="cm"> * Set (static) TLV data for a virtual master volume using the AMP caps</span>
<span class="cm"> * obtained from the reference NID.</span>
<span class="cm"> * The volume range is recalculated as if the max volume is 0dB.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_hda_set_vmaster_tlv</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">tlv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">caps</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nums</span><span class="p">,</span> <span class="n">step</span><span class="p">;</span>

	<span class="n">caps</span> <span class="o">=</span> <span class="n">query_amp_caps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="n">nums</span> <span class="o">=</span> <span class="p">(</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">AC_AMPCAP_NUM_STEPS</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">AC_AMPCAP_NUM_STEPS_SHIFT</span><span class="p">;</span>
	<span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">AC_AMPCAP_STEP_SIZE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">AC_AMPCAP_STEP_SIZE_SHIFT</span><span class="p">;</span>
	<span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">25</span><span class="p">;</span>
	<span class="n">tlv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SNDRV_CTL_TLVT_DB_SCALE</span><span class="p">;</span>
	<span class="n">tlv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">tlv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">nums</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>
	<span class="n">tlv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_set_vmaster_tlv</span><span class="p">);</span>

<span class="cm">/* find a mixer control element with the given name */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span>
<span class="nf">_snd_hda_find_mixer_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_id</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">id</span><span class="p">));</span>
	<span class="n">id</span><span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">;</span>
	<span class="n">id</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">name</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snd_ctl_find_id</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_find_mixer_ctl - Find a mixer control element with the given name</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> * @name: ctl id name string</span>
<span class="cm"> *</span>
<span class="cm"> * Get the control element with the given id string and IFACE_MIXER.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="nf">snd_hda_find_mixer_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_snd_hda_find_mixer_ctl</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_find_mixer_ctl</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_empty_mixer_ctl_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 16 ctlrs should be large enough */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_snd_hda_find_mixer_ctl</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_ctl_add - Add a control element and assign to the codec</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> * @nid: corresponding NID (optional)</span>
<span class="cm"> * @kctl: the control element to assign</span>
<span class="cm"> *</span>
<span class="cm"> * Add the given control element to an array inside the codec instance.</span>
<span class="cm"> * All control elements belonging to a codec are supposed to be added</span>
<span class="cm"> * by this function so that a proper clean-up works at the free or</span>
<span class="cm"> * reconfiguration time.</span>
<span class="cm"> *</span>
<span class="cm"> * If non-zero @nid is passed, the NID is assigned to the control element.</span>
<span class="cm"> * The assignment is shown in the codec proc file.</span>
<span class="cm"> *</span>
<span class="cm"> * snd_hda_ctl_add() checks the control subdev id field whether</span>
<span class="cm"> * #HDA_SUBDEV_NID_FLAG bit is set.  If set (and @nid is zero), the lower</span>
<span class="cm"> * bits value is taken as the NID to assign. The #HDA_NID_ITEM_AMP bit</span>
<span class="cm"> * specifies if kctl-&gt;private_value is a HDA amplifier value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_ctl_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_nid_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kctl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">subdevice</span> <span class="o">&amp;</span> <span class="n">HDA_SUBDEV_AMP_FLAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">HDA_NID_ITEM_AMP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">nid</span> <span class="o">=</span> <span class="n">get_amp_nid_</span><span class="p">(</span><span class="n">kctl</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">kctl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">subdevice</span> <span class="o">&amp;</span> <span class="n">HDA_SUBDEV_NID_FLAG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">kctl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">subdevice</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kctl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">subdevice</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HDA_SUBDEV_NID_FLAG</span><span class="o">|</span><span class="n">HDA_SUBDEV_AMP_FLAG</span><span class="p">))</span>
		<span class="n">kctl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">subdevice</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_ctl_add</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">kctl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">snd_array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">mixers</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">kctl</span> <span class="o">=</span> <span class="n">kctl</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_ctl_add</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_add_nid - Assign a NID to a control element</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> * @nid: corresponding NID (optional)</span>
<span class="cm"> * @kctl: the control element to assign</span>
<span class="cm"> * @index: index to kctl</span>
<span class="cm"> *</span>
<span class="cm"> * Add the given control element to an array inside the codec instance.</span>
<span class="cm"> * This function is used when #snd_hda_ctl_add cannot be used for 1:1</span>
<span class="cm"> * NID:KCTL mapping - for example &quot;Capture Source&quot; selector.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_add_nid</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kctl</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_nid_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">item</span> <span class="o">=</span> <span class="n">snd_array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">nids</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">item</span><span class="o">-&gt;</span><span class="n">kctl</span> <span class="o">=</span> <span class="n">kctl</span><span class="p">;</span>
		<span class="n">item</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">item</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda-codec: no NID for mapping control %s:%d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">kctl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">kctl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_add_nid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_ctls_clear - Clear all controls assigned to the given codec</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_hda_ctls_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_nid_item</span> <span class="o">*</span><span class="n">items</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">mixers</span><span class="p">.</span><span class="n">list</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">mixers</span><span class="p">.</span><span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">snd_ctl_remove</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">kctl</span><span class="p">);</span>
	<span class="n">snd_array_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">mixers</span><span class="p">);</span>
	<span class="n">snd_array_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">nids</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* pseudo device locking</span>
<span class="cm"> * toggle card-&gt;shutdown to allow/disallow the device access (as a hack)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_lock_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">files_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">shutdown</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">ctl_files</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_clear</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pcm</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">pcm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pcm</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">num_pcms</span><span class="p">;</span> <span class="n">pcm</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">hda_pcm</span> <span class="o">*</span><span class="n">cpcm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">pcm_info</span><span class="p">[</span><span class="n">pcm</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">substream_opened</span> <span class="o">||</span>
			    <span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">substream_opened</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_clear</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">files_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">err_clear:</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">shutdown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">err_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">files_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_lock_devices</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">snd_hda_unlock_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">;</span>

	<span class="n">card</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">files_lock</span><span class="p">);</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">shutdown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">files_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_unlock_devices</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_reset - Clear all objects assigned to the codec</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> *</span>
<span class="cm"> * This frees the all PCM and control elements assigned to the codec, and</span>
<span class="cm"> * clears the caches and restores the pin default configurations.</span>
<span class="cm"> *</span>
<span class="cm"> * When a device is being used, it returns -EBSY.  If successfully freed,</span>
<span class="cm"> * returns zero.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_codec_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_hda_lock_devices</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* OK, let it free */</span>

<span class="cp">#ifdef CONFIG_SND_HDA_POWER_SAVE</span>
	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_work</span><span class="p">);</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_transition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">snd_hda_ctls_clear</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="cm">/* relase PCMs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">num_pcms</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">pcm_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pcm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_device_free</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">pcm_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pcm</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">pcm_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">device</span><span class="p">,</span>
				  <span class="n">bus</span><span class="o">-&gt;</span><span class="n">pcm_dev_bits</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">free</span><span class="p">)</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">snd_hda_jack_tbl_clear</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">proc_widget_hook</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">spec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">free_hda_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">amp_cache</span><span class="p">);</span>
	<span class="n">free_hda_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">cmd_cache</span><span class="p">);</span>
	<span class="n">init_hda_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">amp_cache</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_amp_info</span><span class="p">));</span>
	<span class="n">init_hda_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">cmd_cache</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_cache_head</span><span class="p">));</span>
	<span class="cm">/* free only driver_pins so that init_pins + user_pins are restored */</span>
	<span class="n">snd_array_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">driver_pins</span><span class="p">);</span>
	<span class="n">restore_pincfgs</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">snd_array_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">cvt_setups</span><span class="p">);</span>
	<span class="n">snd_array_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_out</span><span class="p">);</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">num_pcms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">pcm_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">preset</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">));</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">slave_dig_outs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_status_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* allow device access again */</span>
	<span class="n">snd_hda_unlock_devices</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">map_slave_func_t</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* apply the function to all matching slave ctls in the mixer list */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">map_slaves</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">slaves</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">suffix</span><span class="p">,</span> <span class="n">map_slave_func_t</span> <span class="n">func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_nid_item</span> <span class="o">*</span><span class="n">items</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">items</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">mixers</span><span class="p">.</span><span class="n">list</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">mixers</span><span class="p">.</span><span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">sctl</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">kctl</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sctl</span> <span class="o">||</span> <span class="o">!</span><span class="n">sctl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">name</span> <span class="o">||</span>
		    <span class="n">sctl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">iface</span> <span class="o">!=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">slaves</span><span class="p">;</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">tmpname</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sctl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">name</span><span class="p">)];</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">suffix</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">snprintf</span><span class="p">(</span><span class="n">tmpname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmpname</span><span class="p">),</span> <span class="s">&quot;%s %s&quot;</span><span class="p">,</span>
					 <span class="n">name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">);</span>
				<span class="n">name</span> <span class="o">=</span> <span class="n">tmpname</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sctl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sctl</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_slave_present</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">sctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* guess the value corresponding to 0dB */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_kctl_0dB_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">_tlv</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">tlv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kctl</span><span class="o">-&gt;</span><span class="n">vd</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">access</span> <span class="o">&amp;</span> <span class="n">SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME: set_fs() hack for obtaining user-space TLV data */</span>
		<span class="n">mm_segment_t</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
		<span class="n">set_fs</span><span class="p">(</span><span class="n">get_ds</span><span class="p">());</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kctl</span><span class="o">-&gt;</span><span class="n">tlv</span><span class="p">.</span><span class="n">c</span><span class="p">(</span><span class="n">kctl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_tlv</span><span class="p">),</span> <span class="n">_tlv</span><span class="p">))</span>
			<span class="n">tlv</span> <span class="o">=</span> <span class="n">_tlv</span><span class="p">;</span>
		<span class="n">set_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">kctl</span><span class="o">-&gt;</span><span class="n">vd</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">access</span> <span class="o">&amp;</span> <span class="n">SNDRV_CTL_ELEM_ACCESS_TLV_READ</span><span class="p">)</span>
		<span class="n">tlv</span> <span class="o">=</span> <span class="n">kctl</span><span class="o">-&gt;</span><span class="n">tlv</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlv</span> <span class="o">&amp;&amp;</span> <span class="n">tlv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">SNDRV_CTL_TLVT_DB_SCALE</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="o">-</span><span class="n">tlv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">tlv</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* call kctl-&gt;put with the given value(s) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">put_kctl_with_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kctl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">;</span>
	<span class="n">ucontrol</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ucontrol</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ucontrol</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">kctl</span><span class="o">-&gt;</span><span class="n">put</span><span class="p">(</span><span class="n">kctl</span><span class="p">,</span> <span class="n">ucontrol</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ucontrol</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* initialize the slave volume with 0dB */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_slave_0dB</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">get_kctl_0dB_offset</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">put_kctl_with_value</span><span class="p">(</span><span class="n">slave</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* unmute the slave */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_slave_unmute</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">put_kctl_with_value</span><span class="p">(</span><span class="n">slave</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_add_vmaster - create a virtual master control and add slaves</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> * @name: vmaster control name</span>
<span class="cm"> * @tlv: TLV data (optional)</span>
<span class="cm"> * @slaves: slave control names (optional)</span>
<span class="cm"> * @suffix: suffix string to each slave name (optional)</span>
<span class="cm"> * @init_slave_vol: initialize slaves to unmute/0dB</span>
<span class="cm"> * @ctl_ret: store the vmaster kcontrol in return</span>
<span class="cm"> *</span>
<span class="cm"> * Create a virtual master control with the given name.  The TLV data</span>
<span class="cm"> * must be either NULL or a valid data.</span>
<span class="cm"> *</span>
<span class="cm"> * @slaves is a NULL-terminated array of strings, each of which is a</span>
<span class="cm"> * slave control name.  All controls with these names are assigned to</span>
<span class="cm"> * the new virtual master control.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero if successful or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__snd_hda_add_vmaster</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">tlv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">slaves</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">suffix</span><span class="p">,</span> <span class="n">bool</span> <span class="n">init_slave_vol</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">**</span><span class="n">ctl_ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kctl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctl_ret</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ctl_ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">map_slaves</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">slaves</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">check_slave_present</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;No slave found for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kctl</span> <span class="o">=</span> <span class="n">snd_ctl_make_virtual_master</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tlv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kctl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_ctl_add</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kctl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">map_slaves</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">slaves</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">map_slave_func_t</span><span class="p">)</span><span class="n">snd_ctl_add_slave</span><span class="p">,</span> <span class="n">kctl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* init with master mute &amp; zero volume */</span>
	<span class="n">put_kctl_with_value</span><span class="p">(</span><span class="n">kctl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">init_slave_vol</span><span class="p">)</span>
		<span class="n">map_slaves</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">slaves</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span>
			   <span class="n">tlv</span> <span class="o">?</span> <span class="n">init_slave_0dB</span> <span class="o">:</span> <span class="n">init_slave_unmute</span><span class="p">,</span> <span class="n">kctl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctl_ret</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ctl_ret</span> <span class="o">=</span> <span class="n">kctl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">__snd_hda_add_vmaster</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * mute-LED control using vmaster</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmaster_mute_mode_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">texts</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;Off&quot;</span><span class="p">,</span> <span class="s">&quot;On&quot;</span><span class="p">,</span> <span class="s">&quot;Follow Master&quot;</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_ENUMERATED</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">texts</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmaster_mute_mode_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_vmaster_mute_hook</span> <span class="o">*</span><span class="n">hook</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">hook</span><span class="o">-&gt;</span><span class="n">mute_mode</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmaster_mute_mode_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_vmaster_mute_hook</span> <span class="o">*</span><span class="n">hook</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_mode</span> <span class="o">=</span> <span class="n">hook</span><span class="o">-&gt;</span><span class="n">mute_mode</span><span class="p">;</span>

	<span class="n">hook</span><span class="o">-&gt;</span><span class="n">mute_mode</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hook</span><span class="o">-&gt;</span><span class="n">mute_mode</span> <span class="o">&gt;</span> <span class="n">HDA_VMUTE_FOLLOW_MASTER</span><span class="p">)</span>
		<span class="n">hook</span><span class="o">-&gt;</span><span class="n">mute_mode</span> <span class="o">=</span> <span class="n">HDA_VMUTE_FOLLOW_MASTER</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_mode</span> <span class="o">==</span> <span class="n">hook</span><span class="o">-&gt;</span><span class="n">mute_mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">snd_hda_sync_vmaster_hook</span><span class="p">(</span><span class="n">hook</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">vmaster_mute_mode</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Mute-LED Mode&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">vmaster_mute_mode_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">vmaster_mute_mode_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span> <span class="o">=</span> <span class="n">vmaster_mute_mode_put</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Add a mute-LED hook with the given vmaster switch kctl</span>
<span class="cm"> * &quot;Mute-LED Mode&quot; control is automatically created and associated with</span>
<span class="cm"> * the given hook.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_add_vmaster_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">hda_vmaster_mute_hook</span> <span class="o">*</span><span class="n">hook</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="n">expose_enum_ctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hook</span><span class="o">-&gt;</span><span class="n">hook</span> <span class="o">||</span> <span class="o">!</span><span class="n">hook</span><span class="o">-&gt;</span><span class="n">sw_kctl</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">snd_ctl_add_vmaster_hook</span><span class="p">(</span><span class="n">hook</span><span class="o">-&gt;</span><span class="n">sw_kctl</span><span class="p">,</span> <span class="n">hook</span><span class="o">-&gt;</span><span class="n">hook</span><span class="p">,</span> <span class="n">codec</span><span class="p">);</span>
	<span class="n">hook</span><span class="o">-&gt;</span><span class="n">codec</span> <span class="o">=</span> <span class="n">codec</span><span class="p">;</span>
	<span class="n">hook</span><span class="o">-&gt;</span><span class="n">mute_mode</span> <span class="o">=</span> <span class="n">HDA_VMUTE_FOLLOW_MASTER</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">expose_enum_ctl</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kctl</span> <span class="o">=</span> <span class="n">snd_ctl_new1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmaster_mute_mode</span><span class="p">,</span> <span class="n">hook</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kctl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snd_hda_ctl_add</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kctl</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_add_vmaster_hook</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Call the hook with the current value for synchronization</span>
<span class="cm"> * Should be called in init callback</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_hda_sync_vmaster_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_vmaster_mute_hook</span> <span class="o">*</span><span class="n">hook</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hook</span><span class="o">-&gt;</span><span class="n">hook</span> <span class="o">||</span> <span class="o">!</span><span class="n">hook</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hook</span><span class="o">-&gt;</span><span class="n">mute_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HDA_VMUTE_FOLLOW_MASTER</span>:
		<span class="n">snd_ctl_sync_vmaster_hook</span><span class="p">(</span><span class="n">hook</span><span class="o">-&gt;</span><span class="n">sw_kctl</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">hook</span><span class="o">-&gt;</span><span class="n">hook</span><span class="p">(</span><span class="n">hook</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">,</span> <span class="n">hook</span><span class="o">-&gt;</span><span class="n">mute_mode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_sync_vmaster_hook</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * snd_hda_mixer_amp_switch_info - Info callback for a standard AMP mixer switch</span>
<span class="cm"> *</span>
<span class="cm"> * The control element is supposed to have the private_value field</span>
<span class="cm"> * set up via HDA_COMPOSE_AMP_VAL*() or related macros.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_mixer_amp_switch_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">chs</span> <span class="o">=</span> <span class="n">get_amp_channels</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_BOOLEAN</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">chs</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_mixer_amp_switch_info</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_mixer_amp_switch_get - Get callback for a standard AMP mixer switch</span>
<span class="cm"> *</span>
<span class="cm"> * The control element is supposed to have the private_value field</span>
<span class="cm"> * set up via HDA_COMPOSE_AMP_VAL*() or related macros.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_mixer_amp_switch_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">get_amp_nid</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">chs</span> <span class="o">=</span> <span class="n">get_amp_channels</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">get_amp_direction</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_amp_index</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">long</span> <span class="o">*</span><span class="n">valp</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chs</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">*</span><span class="n">valp</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">snd_hda_codec_amp_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="o">&amp;</span>
			   <span class="n">HDA_AMP_MUTE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chs</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="o">*</span><span class="n">valp</span> <span class="o">=</span> <span class="p">(</span><span class="n">snd_hda_codec_amp_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="o">&amp;</span>
			 <span class="n">HDA_AMP_MUTE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_mixer_amp_switch_get</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_mixer_amp_switch_put - Put callback for a standard AMP mixer switch</span>
<span class="cm"> *</span>
<span class="cm"> * The control element is supposed to have the private_value field</span>
<span class="cm"> * set up via HDA_COMPOSE_AMP_VAL*() or related macros.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_mixer_amp_switch_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">get_amp_nid</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">chs</span> <span class="o">=</span> <span class="n">get_amp_channels</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">get_amp_direction</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_amp_index</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">long</span> <span class="o">*</span><span class="n">valp</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">snd_hda_power_up</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chs</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">change</span> <span class="o">=</span> <span class="n">snd_hda_codec_amp_update</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span>
						  <span class="n">HDA_AMP_MUTE</span><span class="p">,</span>
						  <span class="o">*</span><span class="n">valp</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">HDA_AMP_MUTE</span><span class="p">);</span>
		<span class="n">valp</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chs</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">change</span> <span class="o">|=</span> <span class="n">snd_hda_codec_amp_update</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span>
						   <span class="n">HDA_AMP_MUTE</span><span class="p">,</span>
						   <span class="o">*</span><span class="n">valp</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">HDA_AMP_MUTE</span><span class="p">);</span>
	<span class="n">hda_call_check_power_status</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="n">snd_hda_power_down</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">change</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_mixer_amp_switch_put</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SND_HDA_INPUT_BEEP</span>
<span class="cm">/**</span>
<span class="cm"> * snd_hda_mixer_amp_switch_put_beep - Put callback for a beep AMP switch</span>
<span class="cm"> *</span>
<span class="cm"> * This function calls snd_hda_enable_beep_device(), which behaves differently</span>
<span class="cm"> * depending on beep_mode option.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_mixer_amp_switch_put_beep</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">long</span> <span class="o">*</span><span class="n">valp</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>

	<span class="n">snd_hda_enable_beep_device</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">*</span><span class="n">valp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snd_hda_mixer_amp_switch_put</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">,</span> <span class="n">ucontrol</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_mixer_amp_switch_put_beep</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SND_HDA_INPUT_BEEP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * bound volume controls</span>
<span class="cm"> *</span>
<span class="cm"> * bind multiple volumes (# indices, from 0)</span>
<span class="cm"> */</span>

<span class="cp">#define AMP_VAL_IDX_SHIFT	19</span>
<span class="cp">#define AMP_VAL_IDX_MASK	(0x0f&lt;&lt;19)</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_mixer_bind_switch_get - Get callback for a bound volume control</span>
<span class="cm"> *</span>
<span class="cm"> * The control element is supposed to have the private_value field</span>
<span class="cm"> * set up via HDA_BIND_MUTE*() macros.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_mixer_bind_switch_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_mutex</span><span class="p">);</span>
	<span class="n">pval</span> <span class="o">=</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>
	<span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span> <span class="o">=</span> <span class="n">pval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AMP_VAL_IDX_MASK</span><span class="p">;</span> <span class="cm">/* index 0 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_mixer_amp_switch_get</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">,</span> <span class="n">ucontrol</span><span class="p">);</span>
	<span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span> <span class="o">=</span> <span class="n">pval</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_mixer_bind_switch_get</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_mixer_bind_switch_put - Put callback for a bound volume control</span>
<span class="cm"> *</span>
<span class="cm"> * The control element is supposed to have the private_value field</span>
<span class="cm"> * set up via HDA_BIND_MUTE*() macros.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_mixer_bind_switch_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_mutex</span><span class="p">);</span>
	<span class="n">pval</span> <span class="o">=</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>
	<span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">pval</span> <span class="o">&amp;</span> <span class="n">AMP_VAL_IDX_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">AMP_VAL_IDX_SHIFT</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">indices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">pval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AMP_VAL_IDX_MASK</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">AMP_VAL_IDX_SHIFT</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_mixer_amp_switch_put</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">,</span> <span class="n">ucontrol</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">change</span> <span class="o">|=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span> <span class="o">=</span> <span class="n">pval</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="n">change</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_mixer_bind_switch_put</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_mixer_bind_ctls_info - Info callback for a generic bound control</span>
<span class="cm"> *</span>
<span class="cm"> * The control element is supposed to have the private_value field</span>
<span class="cm"> * set up via HDA_BIND_VOL() or HDA_BIND_SW() macros.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_mixer_bind_ctls_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hda_bind_ctls</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_mutex</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hda_bind_ctls</span> <span class="o">*</span><span class="p">)</span><span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>
	<span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span> <span class="o">=</span> <span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">,</span> <span class="n">uinfo</span><span class="p">);</span>
	<span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_mixer_bind_ctls_info</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_mixer_bind_ctls_get - Get callback for a generic bound control</span>
<span class="cm"> *</span>
<span class="cm"> * The control element is supposed to have the private_value field</span>
<span class="cm"> * set up via HDA_BIND_VOL() or HDA_BIND_SW() macros.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_mixer_bind_ctls_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hda_bind_ctls</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_mutex</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hda_bind_ctls</span> <span class="o">*</span><span class="p">)</span><span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>
	<span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span> <span class="o">=</span> <span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">,</span> <span class="n">ucontrol</span><span class="p">);</span>
	<span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_mixer_bind_ctls_get</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_mixer_bind_ctls_put - Put callback for a generic bound control</span>
<span class="cm"> *</span>
<span class="cm"> * The control element is supposed to have the private_value field</span>
<span class="cm"> * set up via HDA_BIND_VOL() or HDA_BIND_SW() macros.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_mixer_bind_ctls_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hda_bind_ctls</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vals</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_mutex</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hda_bind_ctls</span> <span class="o">*</span><span class="p">)</span><span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vals</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">;</span> <span class="o">*</span><span class="n">vals</span><span class="p">;</span> <span class="n">vals</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span> <span class="o">=</span> <span class="o">*</span><span class="n">vals</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">put</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">,</span> <span class="n">ucontrol</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">change</span> <span class="o">|=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="n">change</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_mixer_bind_ctls_put</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_mixer_bind_tlv - TLV callback for a generic bound control</span>
<span class="cm"> *</span>
<span class="cm"> * The control element is supposed to have the private_value field</span>
<span class="cm"> * set up via HDA_BIND_VOL() macro.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_mixer_bind_tlv</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op_flag</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">tlv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hda_bind_ctls</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_mutex</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hda_bind_ctls</span> <span class="o">*</span><span class="p">)</span><span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>
	<span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span> <span class="o">=</span> <span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tlv</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">,</span> <span class="n">op_flag</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">tlv</span><span class="p">);</span>
	<span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_mixer_bind_tlv</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">hda_ctl_ops</span> <span class="n">snd_hda_bind_vol</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">snd_hda_mixer_amp_volume_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">snd_hda_mixer_amp_volume_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span> <span class="o">=</span> <span class="n">snd_hda_mixer_amp_volume_put</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlv</span> <span class="o">=</span> <span class="n">snd_hda_mixer_amp_tlv</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_bind_vol</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">hda_ctl_ops</span> <span class="n">snd_hda_bind_sw</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">snd_hda_mixer_amp_switch_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">snd_hda_mixer_amp_switch_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span> <span class="o">=</span> <span class="n">snd_hda_mixer_amp_switch_put</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlv</span> <span class="o">=</span> <span class="n">snd_hda_mixer_amp_tlv</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_bind_sw</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * SPDIF out controls</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_hda_spdif_mask_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_IEC958</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_hda_spdif_cmask_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">IEC958_AES0_PROFESSIONAL</span> <span class="o">|</span>
					   <span class="n">IEC958_AES0_NONAUDIO</span> <span class="o">|</span>
					   <span class="n">IEC958_AES0_CON_EMPHASIS_5015</span> <span class="o">|</span>
					   <span class="n">IEC958_AES0_CON_NOT_COPYRIGHT</span><span class="p">;</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">IEC958_AES1_CON_CATEGORY</span> <span class="o">|</span>
					   <span class="n">IEC958_AES1_CON_ORIGINAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_hda_spdif_pmask_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">IEC958_AES0_PROFESSIONAL</span> <span class="o">|</span>
					   <span class="n">IEC958_AES0_NONAUDIO</span> <span class="o">|</span>
					   <span class="n">IEC958_AES0_PRO_EMPHASIS_5015</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_hda_spdif_default_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_spdif_out</span> <span class="o">*</span><span class="n">spdif</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="n">spdif</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_out</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">spdif</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">spdif</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">spdif</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">spdif</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* convert from SPDIF status bits to HDA SPDIF bits</span>
<span class="cm"> * bit 0 (DigEn) is always set zero (to be filled later)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">convert_from_spdif_status</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbits</span> <span class="o">&amp;</span> <span class="n">IEC958_AES0_PROFESSIONAL</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">AC_DIG1_PROFESSIONAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbits</span> <span class="o">&amp;</span> <span class="n">IEC958_AES0_NONAUDIO</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">AC_DIG1_NONAUDIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbits</span> <span class="o">&amp;</span> <span class="n">IEC958_AES0_PROFESSIONAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sbits</span> <span class="o">&amp;</span> <span class="n">IEC958_AES0_PRO_EMPHASIS</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">IEC958_AES0_PRO_EMPHASIS_5015</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">AC_DIG1_EMPHASIS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sbits</span> <span class="o">&amp;</span> <span class="n">IEC958_AES0_CON_EMPHASIS</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">IEC958_AES0_CON_EMPHASIS_5015</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">AC_DIG1_EMPHASIS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sbits</span> <span class="o">&amp;</span> <span class="n">IEC958_AES0_CON_NOT_COPYRIGHT</span><span class="p">))</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">AC_DIG1_COPYRIGHT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbits</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IEC958_AES1_CON_ORIGINAL</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">))</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">AC_DIG1_LEVEL</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">sbits</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IEC958_AES1_CON_CATEGORY</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* convert to SPDIF status bits from HDA SPDIF bits</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">convert_to_spdif_status</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sbits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_DIG1_NONAUDIO</span><span class="p">)</span>
		<span class="n">sbits</span> <span class="o">|=</span> <span class="n">IEC958_AES0_NONAUDIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_DIG1_PROFESSIONAL</span><span class="p">)</span>
		<span class="n">sbits</span> <span class="o">|=</span> <span class="n">IEC958_AES0_PROFESSIONAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbits</span> <span class="o">&amp;</span> <span class="n">IEC958_AES0_PROFESSIONAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbits</span> <span class="o">&amp;</span> <span class="n">AC_DIG1_EMPHASIS</span><span class="p">)</span>
			<span class="n">sbits</span> <span class="o">|=</span> <span class="n">IEC958_AES0_PRO_EMPHASIS_5015</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_DIG1_EMPHASIS</span><span class="p">)</span>
			<span class="n">sbits</span> <span class="o">|=</span> <span class="n">IEC958_AES0_CON_EMPHASIS_5015</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_DIG1_COPYRIGHT</span><span class="p">))</span>
			<span class="n">sbits</span> <span class="o">|=</span> <span class="n">IEC958_AES0_CON_NOT_COPYRIGHT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_DIG1_LEVEL</span><span class="p">)</span>
			<span class="n">sbits</span> <span class="o">|=</span> <span class="p">(</span><span class="n">IEC958_AES1_CON_ORIGINAL</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">sbits</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x7f</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sbits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* set digital convert verbs both for the given NID and its slaves */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_dig_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">verb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>

	<span class="n">snd_hda_codec_write_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">verb</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">d</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">slave_dig_outs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span> <span class="n">d</span><span class="o">++</span><span class="p">)</span>
		<span class="n">snd_hda_codec_write_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">verb</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_dig_out_convert</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">dig1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dig2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dig1</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">set_dig_out</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">AC_VERB_SET_DIGI_CONVERT_1</span><span class="p">,</span> <span class="n">dig1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dig2</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">set_dig_out</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">AC_VERB_SET_DIGI_CONVERT_2</span><span class="p">,</span> <span class="n">dig2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_hda_spdif_default_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_spdif_out</span> <span class="o">*</span><span class="n">spdif</span><span class="p">;</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">change</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="n">spdif</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_out</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">nid</span> <span class="o">=</span> <span class="n">spdif</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">;</span>
	<span class="n">spdif</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">convert_from_spdif_status</span><span class="p">(</span><span class="n">spdif</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">change</span> <span class="o">=</span> <span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span> <span class="o">!=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">change</span> <span class="o">&amp;&amp;</span> <span class="n">nid</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">set_dig_out_convert</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">change</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define snd_hda_spdif_out_switch_info	snd_ctl_boolean_mono_info</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_hda_spdif_out_switch_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_spdif_out</span> <span class="o">*</span><span class="n">spdif</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="n">spdif</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_out</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span> <span class="o">&amp;</span> <span class="n">AC_DIG1_ENABLE</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_spdif_ctls</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">dig1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dig2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_dig_out_convert</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">dig1</span><span class="p">,</span> <span class="n">dig2</span><span class="p">);</span>
	<span class="cm">/* unmute amp switch (if any) */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">get_wcaps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AC_WCAP_OUT_AMP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">dig1</span> <span class="o">&amp;</span> <span class="n">AC_DIG1_ENABLE</span><span class="p">))</span>
		<span class="n">snd_hda_codec_amp_stereo</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">HDA_OUTPUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					    <span class="n">HDA_AMP_MUTE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_hda_spdif_out_switch_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_spdif_out</span> <span class="o">*</span><span class="n">spdif</span><span class="p">;</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">change</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="n">spdif</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_out</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">nid</span> <span class="o">=</span> <span class="n">spdif</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AC_DIG1_ENABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">AC_DIG1_ENABLE</span><span class="p">;</span>
	<span class="n">change</span> <span class="o">=</span> <span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span> <span class="o">!=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">change</span> <span class="o">&amp;&amp;</span> <span class="n">nid</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">set_spdif_ctls</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">change</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">dig_mixes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">access</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_ACCESS_READ</span><span class="p">,</span>
		<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">SNDRV_CTL_NAME_IEC958</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">PLAYBACK</span><span class="p">,</span> <span class="n">CON_MASK</span><span class="p">),</span>
		<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">snd_hda_spdif_mask_info</span><span class="p">,</span>
		<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">snd_hda_spdif_cmask_get</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">access</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_ACCESS_READ</span><span class="p">,</span>
		<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">SNDRV_CTL_NAME_IEC958</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">PLAYBACK</span><span class="p">,</span> <span class="n">PRO_MASK</span><span class="p">),</span>
		<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">snd_hda_spdif_mask_info</span><span class="p">,</span>
		<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">snd_hda_spdif_pmask_get</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">SNDRV_CTL_NAME_IEC958</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">PLAYBACK</span><span class="p">,</span> <span class="n">DEFAULT</span><span class="p">),</span>
		<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">snd_hda_spdif_mask_info</span><span class="p">,</span>
		<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">snd_hda_spdif_default_get</span><span class="p">,</span>
		<span class="p">.</span><span class="n">put</span> <span class="o">=</span> <span class="n">snd_hda_spdif_default_put</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">SNDRV_CTL_NAME_IEC958</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">PLAYBACK</span><span class="p">,</span> <span class="n">SWITCH</span><span class="p">),</span>
		<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">snd_hda_spdif_out_switch_info</span><span class="p">,</span>
		<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">snd_hda_spdif_out_switch_get</span><span class="p">,</span>
		<span class="p">.</span><span class="n">put</span> <span class="o">=</span> <span class="n">snd_hda_spdif_out_switch_put</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span> <span class="cm">/* end */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_create_spdif_out_ctls - create Output SPDIF-related controls</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @nid: audio out widget NID</span>
<span class="cm"> *</span>
<span class="cm"> * Creates controls related with the SPDIF output.</span>
<span class="cm"> * Called from each patch supporting the SPDIF out.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_create_spdif_out_ctls</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				  <span class="n">hda_nid_t</span> <span class="n">associated_nid</span><span class="p">,</span>
				  <span class="n">hda_nid_t</span> <span class="n">cvt_nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kctl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="o">*</span><span class="n">dig_mix</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_spdif_out</span> <span class="o">*</span><span class="n">spdif</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">find_empty_mixer_ctl_idx</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="s">&quot;IEC958 Playback Switch&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: too many IEC958 outputs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spdif</span> <span class="o">=</span> <span class="n">snd_array_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_out</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">dig_mix</span> <span class="o">=</span> <span class="n">dig_mixes</span><span class="p">;</span> <span class="n">dig_mix</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span> <span class="n">dig_mix</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kctl</span> <span class="o">=</span> <span class="n">snd_ctl_new1</span><span class="p">(</span><span class="n">dig_mix</span><span class="p">,</span> <span class="n">codec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kctl</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">kctl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
		<span class="n">kctl</span><span class="o">-&gt;</span><span class="n">private_value</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_out</span><span class="p">.</span><span class="n">used</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_ctl_add</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">associated_nid</span><span class="p">,</span> <span class="n">kctl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spdif</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="n">cvt_nid</span><span class="p">;</span>
	<span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span> <span class="o">=</span> <span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">cvt_nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					 <span class="n">AC_VERB_GET_DIGI_CONVERT_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spdif</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">convert_to_spdif_status</span><span class="p">(</span><span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_create_spdif_out_ctls</span><span class="p">);</span>

<span class="cm">/* get the hda_spdif_out entry from the given NID</span>
<span class="cm"> * call within spdif_mutex lock</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hda_spdif_out</span> <span class="o">*</span><span class="nf">snd_hda_spdif_out_of_nid</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
					       <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_out</span><span class="p">.</span><span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hda_spdif_out</span> <span class="o">*</span><span class="n">spdif</span> <span class="o">=</span>
				<span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_out</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spdif</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">==</span> <span class="n">nid</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">spdif</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_spdif_out_of_nid</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">snd_hda_spdif_ctls_unassign</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_spdif_out</span> <span class="o">*</span><span class="n">spdif</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="n">spdif</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_out</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">spdif</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_spdif_ctls_unassign</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">snd_hda_spdif_ctls_assign</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_spdif_out</span> <span class="o">*</span><span class="n">spdif</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="n">spdif</span> <span class="o">=</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_out</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spdif</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">!=</span> <span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spdif</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span><span class="p">;</span>
		<span class="n">set_spdif_ctls</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_spdif_ctls_assign</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * SPDIF sharing with analog output</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">spdif_share_sw_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">share_spdif</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spdif_share_sw_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="n">mout</span><span class="o">-&gt;</span><span class="n">share_spdif</span> <span class="o">=</span> <span class="o">!!</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">spdif_share_sw</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;IEC958 Default PCM Playback Switch&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">snd_ctl_boolean_mono_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">spdif_share_sw_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span> <span class="o">=</span> <span class="n">spdif_share_sw_put</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_create_spdif_share_sw - create Default PCM switch</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @mout: multi-out instance</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_create_spdif_share_sw</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_nid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* ATTENTION: here mout is passed as private_data, instead of codec */</span>
	<span class="k">return</span> <span class="n">snd_hda_ctl_add</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_nid</span><span class="p">,</span>
			      <span class="n">snd_ctl_new1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spdif_share_sw</span><span class="p">,</span> <span class="n">mout</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_create_spdif_share_sw</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * SPDIF input</span>
<span class="cm"> */</span>

<span class="cp">#define snd_hda_spdif_in_switch_info	snd_hda_spdif_out_switch_info</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_hda_spdif_in_switch_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_in_enable</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_hda_spdif_in_switch_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="o">!!</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">change</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="n">change</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_in_enable</span> <span class="o">!=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">change</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_in_enable</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">snd_hda_codec_write_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">AC_VERB_SET_DIGI_CONVERT_1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">change</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_hda_spdif_in_status_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sbits</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AC_VERB_GET_DIGI_CONVERT_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">sbits</span> <span class="o">=</span> <span class="n">convert_to_spdif_status</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sbits</span><span class="p">;</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sbits</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sbits</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">iec958</span><span class="p">.</span><span class="n">status</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">sbits</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">dig_in_ctls</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">SNDRV_CTL_NAME_IEC958</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">CAPTURE</span><span class="p">,</span> <span class="n">SWITCH</span><span class="p">),</span>
		<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">snd_hda_spdif_in_switch_info</span><span class="p">,</span>
		<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">snd_hda_spdif_in_switch_get</span><span class="p">,</span>
		<span class="p">.</span><span class="n">put</span> <span class="o">=</span> <span class="n">snd_hda_spdif_in_switch_put</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">access</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_ACCESS_READ</span><span class="p">,</span>
		<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">SNDRV_CTL_NAME_IEC958</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">CAPTURE</span><span class="p">,</span> <span class="n">DEFAULT</span><span class="p">),</span>
		<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">snd_hda_spdif_mask_info</span><span class="p">,</span>
		<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">snd_hda_spdif_in_status_get</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span> <span class="cm">/* end */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_create_spdif_in_ctls - create Input SPDIF-related controls</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @nid: audio in widget NID</span>
<span class="cm"> *</span>
<span class="cm"> * Creates controls related with the SPDIF input.</span>
<span class="cm"> * Called from each patch supporting the SPDIF in.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_create_spdif_in_ctls</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kctl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="o">*</span><span class="n">dig_mix</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">find_empty_mixer_ctl_idx</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="s">&quot;IEC958 Capture Switch&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: too many IEC958 inputs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">dig_mix</span> <span class="o">=</span> <span class="n">dig_in_ctls</span><span class="p">;</span> <span class="n">dig_mix</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span> <span class="n">dig_mix</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kctl</span> <span class="o">=</span> <span class="n">snd_ctl_new1</span><span class="p">(</span><span class="n">dig_mix</span><span class="p">,</span> <span class="n">codec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kctl</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">kctl</span><span class="o">-&gt;</span><span class="n">private_value</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_ctl_add</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">kctl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_in_enable</span> <span class="o">=</span>
		<span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				   <span class="n">AC_VERB_GET_DIGI_CONVERT_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">AC_DIG1_ENABLE</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_create_spdif_in_ctls</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/*</span>
<span class="cm"> * command cache</span>
<span class="cm"> */</span>

<span class="cm">/* build a 32bit cache key with the widget id and the command parameter */</span>
<span class="cp">#define build_cmd_cache_key(nid, verb)	((verb &lt;&lt; 8) | nid)</span>
<span class="cp">#define get_cmd_cache_nid(key)		((key) &amp; 0xff)</span>
<span class="cp">#define get_cmd_cache_cmd(key)		(((key) &gt;&gt; 8) &amp; 0xffff)</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_write_cache - send a single command with caching</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @nid: NID to send the command</span>
<span class="cm"> * @direct: direct flag</span>
<span class="cm"> * @verb: the verb to send</span>
<span class="cm"> * @parm: the parameter for the verb</span>
<span class="cm"> *</span>
<span class="cm"> * Send a single command without waiting for response.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_codec_write_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">direct</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">verb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">parm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_codec_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">direct</span><span class="p">,</span> <span class="n">verb</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hda_cache_head</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/* parm may contain the verb stuff for get/set amp */</span>
	<span class="n">verb</span> <span class="o">=</span> <span class="n">verb</span> <span class="o">|</span> <span class="p">(</span><span class="n">parm</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">parm</span> <span class="o">&amp;=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">build_cmd_cache_key</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">verb</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">cmd_mutex</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">get_alloc_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">cmd_cache</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">parm</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">cmd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_write_cache</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_update_cache - check cache and write the cmd only when needed</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @nid: NID to send the command</span>
<span class="cm"> * @direct: direct flag</span>
<span class="cm"> * @verb: the verb to send</span>
<span class="cm"> * @parm: the parameter for the verb</span>
<span class="cm"> *</span>
<span class="cm"> * This function works like snd_hda_codec_write_cache(), but it doesn&#39;t send</span>
<span class="cm"> * command if the parameter is already identical with the cached value.</span>
<span class="cm"> * If not, it sends the command and refreshes the cache.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_codec_update_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">direct</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">verb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">parm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_cache_head</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">;</span>

	<span class="cm">/* parm may contain the verb stuff for get/set amp */</span>
	<span class="n">verb</span> <span class="o">=</span> <span class="n">verb</span> <span class="o">|</span> <span class="p">(</span><span class="n">parm</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">parm</span> <span class="o">&amp;=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">build_cmd_cache_key</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">verb</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">cmd_mutex</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">cmd_cache</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">parm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">cmd_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">cmd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snd_hda_codec_write_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">direct</span><span class="p">,</span> <span class="n">verb</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_update_cache</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_codec_resume_cache - Resume the all commands from the cache</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> *</span>
<span class="cm"> * Execute all verbs recorded in the command caches to resume.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_hda_codec_resume_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_cache_head</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">cmd_cache</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">cmd_cache</span><span class="p">.</span><span class="n">buf</span><span class="p">.</span><span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">buffer</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">key</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">snd_hda_codec_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">get_cmd_cache_nid</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				    <span class="n">get_cmd_cache_cmd</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_resume_cache</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_sequence_write_cache - sequence writes with caching</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @seq: VERB array to send</span>
<span class="cm"> *</span>
<span class="cm"> * Send the commands sequentially from the given array.</span>
<span class="cm"> * Thte commands are recorded on cache for power-save and resume.</span>
<span class="cm"> * The array must be terminated with NID=0.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_hda_sequence_write_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">hda_verb</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">;</span> <span class="n">seq</span><span class="o">++</span><span class="p">)</span>
		<span class="n">snd_hda_codec_write_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">verb</span><span class="p">,</span>
					  <span class="n">seq</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_sequence_write_cache</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">snd_hda_codec_set_power_to_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">fg</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">power_state</span><span class="p">,</span>
				    <span class="n">bool</span> <span class="n">eapd_workaround</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">start_nid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">num_nodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">nid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wcaps</span> <span class="o">=</span> <span class="n">get_wcaps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wcaps</span> <span class="o">&amp;</span> <span class="n">AC_WCAP_POWER</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* don&#39;t power down the widget if it controls eapd and</span>
<span class="cm">		 * EAPD_BTLENABLE is set.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eapd_workaround</span> <span class="o">&amp;&amp;</span> <span class="n">power_state</span> <span class="o">==</span> <span class="n">AC_PWRST_D3</span> <span class="o">&amp;&amp;</span>
		    <span class="n">get_wcaps_type</span><span class="p">(</span><span class="n">wcaps</span><span class="p">)</span> <span class="o">==</span> <span class="n">AC_WID_PIN</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">snd_hda_query_pin_caps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AC_PINCAP_EAPD</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">eapd</span> <span class="o">=</span> <span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">AC_VERB_GET_EAPD_BTLENABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eapd</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">snd_hda_codec_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AC_VERB_SET_POWER_STATE</span><span class="p">,</span>
				    <span class="n">power_state</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">power_state</span> <span class="o">==</span> <span class="n">AC_PWRST_D0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_time</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
		<span class="cm">/* wait until the codec reachs to D0 */</span>
		<span class="n">end_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">fg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						   <span class="n">AC_VERB_GET_POWER_STATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">power_state</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_set_power_to_all</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * set power state of the codec</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hda_set_power_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">fg</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">power_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">set_power_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">set_power_state</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">fg</span><span class="p">,</span> <span class="n">power_state</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* this delay seems necessary to avoid click noise at power-down */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">power_state</span> <span class="o">==</span> <span class="n">AC_PWRST_D3</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">fg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AC_VERB_SET_POWER_STATE</span><span class="p">,</span>
			    <span class="n">power_state</span><span class="p">);</span>
	<span class="n">snd_hda_codec_set_power_to_all</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">fg</span><span class="p">,</span> <span class="n">power_state</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SND_HDA_HWDEP</span>
<span class="cm">/* execute additional init verbs */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hda_exec_init_verbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">init_verbs</span><span class="p">.</span><span class="n">list</span><span class="p">)</span>
		<span class="n">snd_hda_sequence_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">init_verbs</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hda_exec_init_verbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/*</span>
<span class="cm"> * call suspend and power-down; used both from PM and power-save</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hda_call_codec_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">suspend</span><span class="p">)</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">suspend</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">PMSG_SUSPEND</span><span class="p">);</span>
	<span class="n">hda_cleanup_all_streams</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">hda_set_power_state</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span>
			    <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">?</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">:</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">mfg</span><span class="p">,</span>
			    <span class="n">AC_PWRST_D3</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SND_HDA_POWER_SAVE</span>
	<span class="n">cancel_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_work</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
	<span class="n">snd_hda_update_power_acct</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">trace_hda_power_down</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_transition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kick up codec; used both from PM and power-save</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hda_call_codec_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* set as if powered on for avoiding re-entering the resume</span>
<span class="cm">	 * in the resume / power-save sequence</span>
<span class="cm">	 */</span>
	<span class="n">hda_keep_power_on</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">hda_set_power_state</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span>
			    <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">?</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">:</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">mfg</span><span class="p">,</span>
			    <span class="n">AC_PWRST_D0</span><span class="p">);</span>
	<span class="n">restore_pincfgs</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span> <span class="cm">/* restore all current pin configs */</span>
	<span class="n">restore_shutup_pins</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">hda_exec_init_verbs</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">snd_hda_jack_set_dirty_all</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">resume</span><span class="p">)</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">resume</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">init</span><span class="p">)</span>
			<span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
		<span class="n">snd_hda_codec_resume_amp</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
		<span class="n">snd_hda_codec_resume_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">snd_hda_power_down</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span> <span class="cm">/* flag down before returning */</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>


<span class="cm">/**</span>
<span class="cm"> * snd_hda_build_controls - build mixer controls</span>
<span class="cm"> * @bus: the BUS</span>
<span class="cm"> *</span>
<span class="cm"> * Creates mixer controls for each codec included in the bus.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, otherwise a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="cm">/*__devinit*/</span> <span class="n">snd_hda_build_controls</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_codec_build_controls</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: cannot build controls &quot;</span>
			       <span class="s">&quot;for #%d (error %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_codec_reset</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				       <span class="s">&quot;hda_codec: cannot revert codec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_build_controls</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">snd_hda_codec_build_controls</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hda_exec_init_verbs</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="cm">/* continue to initialize... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">init</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">build_controls</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">build_controls</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * stream formats</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hda_rate_tbl</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hz</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alsa_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hda_fmt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* rate = base * mult / div */</span>
<span class="cp">#define HDA_RATE(base, mult, div) \</span>
<span class="cp">	(AC_FMT_BASE_##base##K | (((mult) - 1) &lt;&lt; AC_FMT_MULT_SHIFT) | \</span>
<span class="cp">	 (((div) - 1) &lt;&lt; AC_FMT_DIV_SHIFT))</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hda_rate_tbl</span> <span class="n">rate_bits</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* rate in Hz, ALSA rate bitmask, HDA format value */</span>

	<span class="cm">/* autodetected value used in snd_hda_query_supported_pcm */</span>
	<span class="p">{</span> <span class="mi">8000</span><span class="p">,</span> <span class="n">SNDRV_PCM_RATE_8000</span><span class="p">,</span> <span class="n">HDA_RATE</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">11025</span><span class="p">,</span> <span class="n">SNDRV_PCM_RATE_11025</span><span class="p">,</span> <span class="n">HDA_RATE</span><span class="p">(</span><span class="mi">44</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">16000</span><span class="p">,</span> <span class="n">SNDRV_PCM_RATE_16000</span><span class="p">,</span> <span class="n">HDA_RATE</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">22050</span><span class="p">,</span> <span class="n">SNDRV_PCM_RATE_22050</span><span class="p">,</span> <span class="n">HDA_RATE</span><span class="p">(</span><span class="mi">44</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">32000</span><span class="p">,</span> <span class="n">SNDRV_PCM_RATE_32000</span><span class="p">,</span> <span class="n">HDA_RATE</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">44100</span><span class="p">,</span> <span class="n">SNDRV_PCM_RATE_44100</span><span class="p">,</span> <span class="n">HDA_RATE</span><span class="p">(</span><span class="mi">44</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">48000</span><span class="p">,</span> <span class="n">SNDRV_PCM_RATE_48000</span><span class="p">,</span> <span class="n">HDA_RATE</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">88200</span><span class="p">,</span> <span class="n">SNDRV_PCM_RATE_88200</span><span class="p">,</span> <span class="n">HDA_RATE</span><span class="p">(</span><span class="mi">44</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">96000</span><span class="p">,</span> <span class="n">SNDRV_PCM_RATE_96000</span><span class="p">,</span> <span class="n">HDA_RATE</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">176400</span><span class="p">,</span> <span class="n">SNDRV_PCM_RATE_176400</span><span class="p">,</span> <span class="n">HDA_RATE</span><span class="p">(</span><span class="mi">44</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">192000</span><span class="p">,</span> <span class="n">SNDRV_PCM_RATE_192000</span><span class="p">,</span> <span class="n">HDA_RATE</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">},</span>
<span class="cp">#define AC_PAR_PCM_RATE_BITS	11</span>
	<span class="cm">/* up to bits 10, 384kHZ isn&#39;t supported properly */</span>

	<span class="cm">/* not autodetected value */</span>
	<span class="p">{</span> <span class="mi">9600</span><span class="p">,</span> <span class="n">SNDRV_PCM_RATE_KNOT</span><span class="p">,</span> <span class="n">HDA_RATE</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="p">},</span>

	<span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="cm">/* terminator */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_calc_stream_format - calculate format bitset</span>
<span class="cm"> * @rate: the sample rate</span>
<span class="cm"> * @channels: the number of channels</span>
<span class="cm"> * @format: the PCM format (SNDRV_PCM_FORMAT_XXX)</span>
<span class="cm"> * @maxbps: the max. bps</span>
<span class="cm"> *</span>
<span class="cm"> * Calculate the format bitset from the given rate, channels and th PCM format.</span>
<span class="cm"> *</span>
<span class="cm"> * Return zero if invalid.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">snd_hda_calc_stream_format</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channels</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">format</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxbps</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">spdif_ctls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rate_bits</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rate_bits</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hz</span> <span class="o">==</span> <span class="n">rate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">rate_bits</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hda_fmt</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rate_bits</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;invalid rate %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channels</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">channels</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;invalid channels %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channels</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">channels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">snd_pcm_format_width</span><span class="p">(</span><span class="n">format</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="n">val</span> <span class="o">|=</span> <span class="n">AC_FMT_BITS_8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">16</span>:
		<span class="n">val</span> <span class="o">|=</span> <span class="n">AC_FMT_BITS_16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">20</span>:
	<span class="k">case</span> <span class="mi">24</span>:
	<span class="k">case</span> <span class="mi">32</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">maxbps</span> <span class="o">&gt;=</span> <span class="mi">32</span> <span class="o">||</span> <span class="n">format</span> <span class="o">==</span> <span class="n">SNDRV_PCM_FORMAT_FLOAT_LE</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">AC_FMT_BITS_32</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maxbps</span> <span class="o">&gt;=</span> <span class="mi">24</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">AC_FMT_BITS_24</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">AC_FMT_BITS_20</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;invalid format width %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">snd_pcm_format_width</span><span class="p">(</span><span class="n">format</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spdif_ctls</span> <span class="o">&amp;</span> <span class="n">AC_DIG1_NONAUDIO</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">AC_FMT_TYPE_NON_PCM</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_calc_stream_format</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_pcm_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">!=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">get_wcaps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AC_WCAP_FORMAT_OVRD</span><span class="p">))</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">snd_hda_param_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">AC_PAR_PCM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">snd_hda_param_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span><span class="p">,</span> <span class="n">AC_PAR_PCM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">query_pcm_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">query_caps_hash</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HDA_HASH_PARPCM_KEY</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span>
			       <span class="n">get_pcm_param</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_stream_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">streams</span> <span class="o">=</span> <span class="n">snd_hda_param_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">AC_PAR_STREAM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">streams</span> <span class="o">||</span> <span class="n">streams</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">streams</span> <span class="o">=</span> <span class="n">snd_hda_param_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">afg</span><span class="p">,</span> <span class="n">AC_PAR_STREAM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">streams</span> <span class="o">||</span> <span class="n">streams</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">streams</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">query_stream_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">query_caps_hash</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HDA_HASH_PARSTR_KEY</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span>
			       <span class="n">get_stream_param</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_query_supported_pcm - query the supported PCM rates and formats</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @nid: NID to query</span>
<span class="cm"> * @ratesp: the pointer to store the detected rate bitflags</span>
<span class="cm"> * @formatsp: the pointer to store the detected formats</span>
<span class="cm"> * @bpsp: the pointer to store the detected format widths</span>
<span class="cm"> *</span>
<span class="cm"> * Queries the supported PCM rates and formats.  The NULL @ratesp, @formatsp</span>
<span class="cm"> * or @bsps argument is ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, otherwise a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_query_supported_pcm</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
				<span class="n">u32</span> <span class="o">*</span><span class="n">ratesp</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">formatsp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bpsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">wcaps</span><span class="p">;</span>

	<span class="n">wcaps</span> <span class="o">=</span> <span class="n">get_wcaps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">query_pcm_param</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ratesp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">rates</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AC_PAR_PCM_RATE_BITS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
				<span class="n">rates</span> <span class="o">|=</span> <span class="n">rate_bits</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">alsa_bits</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rates</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: rates == 0 &quot;</span>
				   <span class="s">&quot;(nid=0x%x, val=0x%x, ovrd=%i)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">nid</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
					<span class="p">(</span><span class="n">wcaps</span> <span class="o">&amp;</span> <span class="n">AC_WCAP_FORMAT_OVRD</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">ratesp</span> <span class="o">=</span> <span class="n">rates</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">formatsp</span> <span class="o">||</span> <span class="n">bpsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">formats</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">streams</span><span class="p">,</span> <span class="n">bps</span><span class="p">;</span>

		<span class="n">streams</span> <span class="o">=</span> <span class="n">query_stream_param</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">streams</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="n">bps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">streams</span> <span class="o">&amp;</span> <span class="n">AC_SUPFMT_PCM</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_SUPPCM_BITS_8</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">formats</span> <span class="o">|=</span> <span class="n">SNDRV_PCM_FMTBIT_U8</span><span class="p">;</span>
				<span class="n">bps</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_SUPPCM_BITS_16</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">formats</span> <span class="o">|=</span> <span class="n">SNDRV_PCM_FMTBIT_S16_LE</span><span class="p">;</span>
				<span class="n">bps</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wcaps</span> <span class="o">&amp;</span> <span class="n">AC_WCAP_DIGITAL</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_SUPPCM_BITS_32</span><span class="p">)</span>
					<span class="n">formats</span> <span class="o">|=</span> <span class="n">SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AC_SUPPCM_BITS_20</span><span class="o">|</span><span class="n">AC_SUPPCM_BITS_24</span><span class="p">))</span>
					<span class="n">formats</span> <span class="o">|=</span> <span class="n">SNDRV_PCM_FMTBIT_S32_LE</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_SUPPCM_BITS_24</span><span class="p">)</span>
					<span class="n">bps</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_SUPPCM_BITS_20</span><span class="p">)</span>
					<span class="n">bps</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AC_SUPPCM_BITS_20</span><span class="o">|</span><span class="n">AC_SUPPCM_BITS_24</span><span class="o">|</span>
					  <span class="n">AC_SUPPCM_BITS_32</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">formats</span> <span class="o">|=</span> <span class="n">SNDRV_PCM_FMTBIT_S32_LE</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_SUPPCM_BITS_32</span><span class="p">)</span>
					<span class="n">bps</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_SUPPCM_BITS_24</span><span class="p">)</span>
					<span class="n">bps</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_SUPPCM_BITS_20</span><span class="p">)</span>
					<span class="n">bps</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#if 0</span><span class="c"> /* FIXME: CS4206 doesn&#39;t work, which is the only codec supporting float */</span>
<span class="c">		if (streams &amp; AC_SUPFMT_FLOAT32) {</span>
<span class="c">			formats |= SNDRV_PCM_FMTBIT_FLOAT_LE;</span>
<span class="c">			if (!bps)</span>
<span class="c">				bps = 32;</span>
<span class="c">		}</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">streams</span> <span class="o">==</span> <span class="n">AC_SUPFMT_AC3</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* should be exclusive */</span>
			<span class="cm">/* temporary hack: we have still no proper support</span>
<span class="cm">			 * for the direct AC3 stream...</span>
<span class="cm">			 */</span>
			<span class="n">formats</span> <span class="o">|=</span> <span class="n">SNDRV_PCM_FMTBIT_U8</span><span class="p">;</span>
			<span class="n">bps</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">formats</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: formats == 0 &quot;</span>
				   <span class="s">&quot;(nid=0x%x, val=0x%x, ovrd=%i, &quot;</span>
				   <span class="s">&quot;streams=0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">nid</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
					<span class="p">(</span><span class="n">wcaps</span> <span class="o">&amp;</span> <span class="n">AC_WCAP_FORMAT_OVRD</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">streams</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">formatsp</span><span class="p">)</span>
			<span class="o">*</span><span class="n">formatsp</span> <span class="o">=</span> <span class="n">formats</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bpsp</span><span class="p">)</span>
			<span class="o">*</span><span class="n">bpsp</span> <span class="o">=</span> <span class="n">bps</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_query_supported_pcm</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_is_supported_format - Check the validity of the format</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> * @nid: NID to check</span>
<span class="cm"> * @format: the HD-audio format value to check</span>
<span class="cm"> *</span>
<span class="cm"> * Check whether the given node supports the format value.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if supported, 0 if not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_is_supported_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">format</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">stream</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">query_pcm_param</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rate</span> <span class="o">=</span> <span class="n">format</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AC_PAR_PCM_RATE_BITS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rate_bits</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hda_fmt</span> <span class="o">==</span> <span class="n">rate</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">AC_PAR_PCM_RATE_BITS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">stream</span> <span class="o">=</span> <span class="n">query_stream_param</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stream</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span> <span class="o">&amp;</span> <span class="n">AC_SUPFMT_PCM</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">format</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x00</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_SUPPCM_BITS_8</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x10</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_SUPPCM_BITS_16</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x20</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_SUPPCM_BITS_20</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x30</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_SUPPCM_BITS_24</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x40</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_SUPPCM_BITS_32</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* FIXME: check for float32 and AC3? */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_is_supported_format</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * PCM stuff</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hda_pcm_default_open_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hda_pcm_default_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_tag</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">format</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_hda_codec_setup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="n">stream_tag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hda_pcm_default_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_hda_codec_cleanup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_pcm_default_values</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* query support PCM information from the given NID */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rates</span> <span class="o">||</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">formats</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_query_supported_pcm</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">rates</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rates</span><span class="p">,</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">formats</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">formats</span><span class="p">,</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">maxbps</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">maxbps</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">open</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">hda_pcm_default_open_close</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">close</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">close</span> <span class="o">=</span> <span class="n">hda_pcm_default_open_close</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">prepare</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">prepare</span> <span class="o">=</span> <span class="n">hda_pcm_default_prepare</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">cleanup</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">cleanup</span> <span class="o">=</span> <span class="n">hda_pcm_default_cleanup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * codec prepare/cleanup entries</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_codec_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">format</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">prepare_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">hinfo</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">substream</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">purify_inactive_streams</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">prepare_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_prepare</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">snd_hda_codec_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">prepare_mutex</span><span class="p">);</span>
	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">cleanup</span><span class="p">(</span><span class="n">hinfo</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="n">substream</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">prepare_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_codec_cleanup</span><span class="p">);</span>

<span class="cm">/* global */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">snd_hda_pcm_type_name</span><span class="p">[</span><span class="n">HDA_PCM_NTYPES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;Audio&quot;</span><span class="p">,</span> <span class="s">&quot;SPDIF&quot;</span><span class="p">,</span> <span class="s">&quot;HDMI&quot;</span><span class="p">,</span> <span class="s">&quot;Modem&quot;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * get the empty PCM device number to assign</span>
<span class="cm"> *</span>
<span class="cm"> * note the max device number is limited by HDA_MAX_PCMS, currently 10</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_empty_pcm_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* audio device indices; not linear to keep compatibility */</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">audio_idx</span><span class="p">[</span><span class="n">HDA_PCM_NTYPES</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">HDA_PCM_TYPE_AUDIO</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">},</span>
		<span class="p">[</span><span class="n">HDA_PCM_TYPE_SPDIF</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">},</span>
		<span class="p">[</span><span class="n">HDA_PCM_TYPE_HDMI</span><span class="p">]</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">},</span>
		<span class="p">[</span><span class="n">HDA_PCM_TYPE_MODEM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">},</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">HDA_PCM_NTYPES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Invalid PCM type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">audio_idx</span><span class="p">[</span><span class="n">type</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">audio_idx</span><span class="p">[</span><span class="n">type</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">pcm_dev_bits</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">audio_idx</span><span class="p">[</span><span class="n">type</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>

	<span class="cm">/* non-fixed slots starting from 10 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">pcm_dev_bits</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Too many %s devices</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">snd_hda_pcm_type_name</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * attach a new PCM stream</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_hda_attach_pcm</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hda_pcm</span> <span class="o">*</span><span class="n">pcm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stream</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">stream</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">stream</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">stream</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">[</span><span class="n">stream</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">substreams</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">set_pcm_default_values</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">attach_pcm</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="n">pcm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* assign all PCMs of the given codec */</span>
<span class="kt">int</span> <span class="nf">snd_hda_codec_build_pcms</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pcm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">num_pcms</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">build_pcms</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">build_pcms</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: cannot build PCMs&quot;</span>
			       <span class="s">&quot;for #%d (error %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_codec_reset</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				       <span class="s">&quot;hda_codec: cannot revert codec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pcm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pcm</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">num_pcms</span><span class="p">;</span> <span class="n">pcm</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hda_pcm</span> <span class="o">*</span><span class="n">cpcm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">pcm_info</span><span class="p">[</span><span class="n">pcm</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">dev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">substreams</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">substreams</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span> <span class="cm">/* no substreams assigned */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span> <span class="o">=</span> <span class="n">get_empty_pcm_device</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">pcm_type</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span> <span class="cm">/* no fatal error */</span>
			<span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_attach_pcm</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">cpcm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: cannot attach &quot;</span>
				       <span class="s">&quot;PCM stream %d for codec #%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">dev</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span> <span class="cm">/* no fatal error */</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_build_pcms - build PCM information</span>
<span class="cm"> * @bus: the BUS</span>
<span class="cm"> *</span>
<span class="cm"> * Create PCM information for each codec included in the bus.</span>
<span class="cm"> *</span>
<span class="cm"> * The build_pcms codec patch is requested to set up codec-&gt;num_pcms and</span>
<span class="cm"> * codec-&gt;pcm_info properly.  The array is referred by the top-level driver</span>
<span class="cm"> * to create its PCM instances.</span>
<span class="cm"> * The allocated codec-&gt;pcm_info should be released in codec-&gt;patch_ops.free</span>
<span class="cm"> * callback.</span>
<span class="cm"> *</span>
<span class="cm"> * At least, substreams, channels_min and channels_max must be filled for</span>
<span class="cm"> * each stream.  substreams = 0 indicates that the stream doesn&#39;t exist.</span>
<span class="cm"> * When rates and/or formats are zero, the supported values are queried</span>
<span class="cm"> * from the given nid.  The nid is used also by the default ops.prepare</span>
<span class="cm"> * and ops.cleanup callbacks.</span>
<span class="cm"> *</span>
<span class="cm"> * The driver needs to call ops.open in its open callback.  Similarly,</span>
<span class="cm"> * ops.close is supposed to be called in the close callback.</span>
<span class="cm"> * ops.prepare should be called in the prepare or hw_params callback</span>
<span class="cm"> * with the proper parameters for set up.</span>
<span class="cm"> * ops.cleanup should be called in hw_free for clean up of streams.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if successful, or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">snd_hda_build_pcms</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_codec_build_pcms</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_build_pcms</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_check_board_config - compare the current codec with the config table</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @num_configs: number of config enums</span>
<span class="cm"> * @models: array of model name strings</span>
<span class="cm"> * @tbl: configuration table, terminated by null entries</span>
<span class="cm"> *</span>
<span class="cm"> * Compares the modelname or PCI subsystem id of the current codec with the</span>
<span class="cm"> * given configuration table.  If a matching entry is found, returns its</span>
<span class="cm"> * config value (supposed to be 0 or positive).</span>
<span class="cm"> *</span>
<span class="cm"> * If no entries are matching, the function returns a negative value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_check_board_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">num_configs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">models</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_pci_quirk</span> <span class="o">*</span><span class="n">tbl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">modelname</span> <span class="o">&amp;&amp;</span> <span class="n">models</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_configs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">models</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">modelname</span><span class="p">,</span> <span class="n">models</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">snd_printd</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;hda_codec: model &#39;%s&#39; is &quot;</span>
					   <span class="s">&quot;selected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">models</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">pci</span> <span class="o">||</span> <span class="o">!</span><span class="n">tbl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">tbl</span> <span class="o">=</span> <span class="n">snd_pci_quirk_lookup</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span> <span class="n">tbl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tbl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">num_configs</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SND_DEBUG_VERBOSE</span>
		<span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">model</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">models</span><span class="p">)</span>
			<span class="n">model</span> <span class="o">=</span> <span class="n">models</span><span class="p">[</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">model</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;#%d&quot;</span><span class="p">,</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
			<span class="n">model</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;hda_codec: model &#39;%s&#39; is selected &quot;</span>
			    <span class="s">&quot;for config %x:%x (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">model</span><span class="p">,</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">subvendor</span><span class="p">,</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">subdevice</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">?</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;Unknown device&quot;</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_check_board_config</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_check_board_codec_sid_config - compare the current codec</span>
<span class="cm">					subsystem ID with the</span>
<span class="cm">					config table</span>

<span class="cm">	   This is important for Gateway notebooks with SB450 HDA Audio</span>
<span class="cm">	   where the vendor ID of the PCI device is:</span>
<span class="cm">		ATI Technologies Inc SB450 HDA Audio [1002:437b]</span>
<span class="cm">	   and the vendor/subvendor are found only at the codec.</span>

<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @num_configs: number of config enums</span>
<span class="cm"> * @models: array of model name strings</span>
<span class="cm"> * @tbl: configuration table, terminated by null entries</span>
<span class="cm"> *</span>
<span class="cm"> * Compares the modelname or PCI subsystem id of the current codec with the</span>
<span class="cm"> * given configuration table.  If a matching entry is found, returns its</span>
<span class="cm"> * config value (supposed to be 0 or positive).</span>
<span class="cm"> *</span>
<span class="cm"> * If no entries are matching, the function returns a negative value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_check_board_codec_sid_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">num_configs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">models</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_pci_quirk</span> <span class="o">*</span><span class="n">tbl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_pci_quirk</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="cm">/* Search for codec ID */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">tbl</span><span class="p">;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">subvendor</span><span class="p">;</span> <span class="n">q</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xffff0000</span> <span class="o">|</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">subdevice_mask</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">subdevice</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">subvendor</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">subsystem_id</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">subvendor</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">tbl</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">num_configs</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SND_DEBUG_VERBOSE</span>
		<span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">model</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">models</span><span class="p">)</span>
			<span class="n">model</span> <span class="o">=</span> <span class="n">models</span><span class="p">[</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">model</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;#%d&quot;</span><span class="p">,</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
			<span class="n">model</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;hda_codec: model &#39;%s&#39; is selected &quot;</span>
			    <span class="s">&quot;for config %x:%x (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">model</span><span class="p">,</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">subvendor</span><span class="p">,</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">subdevice</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">?</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;Unknown device&quot;</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="n">tbl</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_check_board_codec_sid_config</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_add_new_ctls - create controls from the array</span>
<span class="cm"> * @codec: the HDA codec</span>
<span class="cm"> * @knew: the array of struct snd_kcontrol_new</span>
<span class="cm"> *</span>
<span class="cm"> * This helper function creates and add new controls in the given array.</span>
<span class="cm"> * The array must be terminated with an empty entry as terminator.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_add_new_ctls</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="o">*</span><span class="n">knew</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">knew</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span> <span class="n">knew</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kctl</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">knew</span><span class="o">-&gt;</span><span class="n">iface</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>	<span class="cm">/* skip this codec private value */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="n">kctl</span> <span class="o">=</span> <span class="n">snd_ctl_new1</span><span class="p">(</span><span class="n">knew</span><span class="p">,</span> <span class="n">codec</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kctl</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">kctl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">kctl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_ctl_add</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kctl</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* try first with another device index corresponding to</span>
<span class="cm">			 * the codec addr; if it still fails (or it&#39;s the</span>
<span class="cm">			 * primary codec), then try another control index</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span> <span class="o">&amp;&amp;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
				<span class="n">addr</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idx</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">knew</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">idx</span> <span class="o">=</span> <span class="n">find_empty_mixer_ctl_idx</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span>
							       <span class="n">knew</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_add_new_ctls</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SND_HDA_POWER_SAVE</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hda_power_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hda_codec</span><span class="p">,</span> <span class="n">power_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_transition</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* during power-up sequence? */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_on</span> <span class="o">||</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_transition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>

	<span class="n">hda_call_codec_suspend</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">pm_notify</span><span class="p">)</span>
		<span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">pm_notify</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hda_keep_power_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* update the power on/off account with the current jiffies */</span>
<span class="kt">void</span> <span class="nf">snd_hda_update_power_acct</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_jiffies</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_on</span><span class="p">)</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_on_acct</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_off_acct</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_jiffies</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Transition to powered up, if wait_power_down then wait for a pending</span>
<span class="cm"> * transition to D3 to complete. A pending D3 transition is indicated</span>
<span class="cm"> * with power_transition == -1. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__snd_hda_power_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">bool</span> <span class="n">wait_power_down</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_count</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* Return if power_on or transitioning to power_on, unless currently</span>
<span class="cm">	 * powering down. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_on</span> <span class="o">||</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_transition</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">wait_power_down</span> <span class="o">&amp;&amp;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_transition</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>

	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_work</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
	<span class="n">trace_hda_power_up</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">snd_hda_update_power_acct</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_transition</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* avoid reentrance */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">pm_notify</span><span class="p">)</span>
		<span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">pm_notify</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">hda_call_codec_resume</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_transition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_power_up - Power-up the codec</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> *</span>
<span class="cm"> * Increment the power-up counter and power up the hardware really when</span>
<span class="cm"> * not turned on yet.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_hda_power_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__snd_hda_power_up</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_power_up</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_power_up_d3wait - Power-up the codec after waiting for any pending</span>
<span class="cm"> *   D3 transition to complete.  This differs from snd_hda_power_up() when</span>
<span class="cm"> *   power_transition == -1.  snd_hda_power_up sees this case as a nop,</span>
<span class="cm"> *   snd_hda_power_up_d3wait waits for the D3 transition to complete then powers</span>
<span class="cm"> *   back up.</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> *</span>
<span class="cm"> * Cancel any power down operation hapenning on the work queue, then power up.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_hda_power_up_d3wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This will cancel and wait for pending power_work to complete. */</span>
	<span class="n">__snd_hda_power_up</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_power_up_d3wait</span><span class="p">);</span>

<span class="cp">#define power_save(codec)	\</span>
<span class="cp">	((codec)-&gt;bus-&gt;power_save ? *(codec)-&gt;bus-&gt;power_save : 0)</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_power_down - Power-down the codec</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> *</span>
<span class="cm"> * Decrement the power-up counter and schedules the power-off work if</span>
<span class="cm"> * the counter rearches to zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_hda_power_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
	<span class="o">--</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_on</span> <span class="o">||</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_count</span> <span class="o">||</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_transition</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">power_save</span><span class="p">(</span><span class="n">codec</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_transition</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* avoid reentrance */</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_work</span><span class="p">,</span>
				<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">power_save</span><span class="p">(</span><span class="n">codec</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">power_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_power_down</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_check_amp_list_power - Check the amp list and update the power</span>
<span class="cm"> * @codec: HD-audio codec</span>
<span class="cm"> * @check: the object containing an AMP list and the status</span>
<span class="cm"> * @nid: NID to check / update</span>
<span class="cm"> *</span>
<span class="cm"> * Check whether the given NID is in the amp list.  If it&#39;s in the list,</span>
<span class="cm"> * check the current AMP status, and update the the power-status according</span>
<span class="cm"> * to the mute status.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is supposed to be set or called from the check_power_status</span>
<span class="cm"> * patch ops.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_check_amp_list_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">hda_loopback_check</span> <span class="o">*</span><span class="n">check</span><span class="p">,</span>
				 <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">hda_amp_list</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check</span><span class="o">-&gt;</span><span class="n">amplist</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">check</span><span class="o">-&gt;</span><span class="n">amplist</span><span class="p">;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nid</span> <span class="o">==</span> <span class="n">nid</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* nothing changed */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">check</span><span class="o">-&gt;</span><span class="n">amplist</span><span class="p">;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ch</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">ch</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">snd_hda_codec_amp_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">,</span>
						   <span class="n">p</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">HDA_AMP_MUTE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check</span><span class="o">-&gt;</span><span class="n">power_on</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">check</span><span class="o">-&gt;</span><span class="n">power_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">snd_hda_power_up</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="o">-&gt;</span><span class="n">power_on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">check</span><span class="o">-&gt;</span><span class="n">power_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">snd_hda_power_down</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_check_amp_list_power</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Channel mode helper</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_ch_mode_info - Info callback helper for the channel mode enum</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_ch_mode_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">hda_channel_mode</span> <span class="o">*</span><span class="n">chmode</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">num_chmodes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_ENUMERATED</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">num_chmodes</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span> <span class="o">&gt;=</span> <span class="n">num_chmodes</span><span class="p">)</span>
		<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span> <span class="o">=</span> <span class="n">num_chmodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%dch&quot;</span><span class="p">,</span>
		<span class="n">chmode</span><span class="p">[</span><span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">].</span><span class="n">channels</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_ch_mode_info</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_ch_mode_get - Get callback helper for the channel mode enum</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_ch_mode_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">hda_channel_mode</span> <span class="o">*</span><span class="n">chmode</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">num_chmodes</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">max_channels</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_chmodes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_channels</span> <span class="o">==</span> <span class="n">chmode</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">channels</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_ch_mode_get</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_ch_mode_put - Put callback helper for the channel mode enum</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_ch_mode_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">hda_channel_mode</span> <span class="o">*</span><span class="n">chmode</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">num_chmodes</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">max_channelsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&gt;=</span> <span class="n">num_chmodes</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">max_channelsp</span> <span class="o">==</span> <span class="n">chmode</span><span class="p">[</span><span class="n">mode</span><span class="p">].</span><span class="n">channels</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* change the current channel setting */</span>
	<span class="o">*</span><span class="n">max_channelsp</span> <span class="o">=</span> <span class="n">chmode</span><span class="p">[</span><span class="n">mode</span><span class="p">].</span><span class="n">channels</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chmode</span><span class="p">[</span><span class="n">mode</span><span class="p">].</span><span class="n">sequence</span><span class="p">)</span>
		<span class="n">snd_hda_sequence_write_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">chmode</span><span class="p">[</span><span class="n">mode</span><span class="p">].</span><span class="n">sequence</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_ch_mode_put</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * input MUX helper</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_input_mux_info_info - Info callback helper for the input-mux enum</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_input_mux_info</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hda_input_mux</span> <span class="o">*</span><span class="n">imux</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_ENUMERATED</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">imux</span><span class="o">-&gt;</span><span class="n">items</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">label</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_input_mux_info</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_input_mux_info_put - Put callback helper for the input-mux enum</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_input_mux_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">hda_input_mux</span> <span class="o">*</span><span class="n">imux</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">,</span>
			  <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cur_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span><span class="p">)</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cur_val</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">snd_hda_codec_write_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AC_VERB_SET_CONNECT_SEL</span><span class="p">,</span>
				  <span class="n">imux</span><span class="o">-&gt;</span><span class="n">items</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">index</span><span class="p">);</span>
	<span class="o">*</span><span class="n">cur_val</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_input_mux_put</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Multi-channel / digital-out PCM helper functions</span>
<span class="cm"> */</span>

<span class="cm">/* setup SPDIF output stream */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_dig_out_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_tag</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">format</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_spdif_out</span> <span class="o">*</span><span class="n">spdif</span> <span class="o">=</span> <span class="n">snd_hda_spdif_out_of_nid</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>

	<span class="cm">/* turn off SPDIF once; otherwise the IEC958 bits won&#39;t be updated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_status_reset</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span> <span class="o">&amp;</span> <span class="n">AC_DIG1_ENABLE</span><span class="p">))</span>
		<span class="n">set_dig_out_convert</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span>
				    <span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AC_DIG1_ENABLE</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span>
				    <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">snd_hda_codec_setup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">stream_tag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">slave_dig_outs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">d</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">slave_dig_outs</span><span class="p">;</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span> <span class="n">d</span><span class="o">++</span><span class="p">)</span>
			<span class="n">snd_hda_codec_setup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">stream_tag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						   <span class="n">format</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* turn on again (if needed) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_status_reset</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span> <span class="o">&amp;</span> <span class="n">AC_DIG1_ENABLE</span><span class="p">))</span>
		<span class="n">set_dig_out_convert</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span>
				    <span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_dig_out_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_hda_codec_cleanup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">slave_dig_outs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">d</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">slave_dig_outs</span><span class="p">;</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span> <span class="n">d</span><span class="o">++</span><span class="p">)</span>
			<span class="n">snd_hda_codec_cleanup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_bus_reboot_notify - call the reboot notifier of each codec</span>
<span class="cm"> * @bus: HD-audio bus</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_hda_bus_reboot_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hda_codec_is_power_on</span><span class="p">(</span><span class="n">codec</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">reboot_notify</span><span class="p">)</span>
			<span class="n">codec</span><span class="o">-&gt;</span><span class="n">patch_ops</span><span class="p">.</span><span class="n">reboot_notify</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_bus_reboot_notify</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_multi_out_dig_open - open the digital out in the exclusive mode</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_multi_out_dig_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_used</span> <span class="o">==</span> <span class="n">HDA_DIG_ANALOG_DUP</span><span class="p">)</span>
		<span class="cm">/* already opened as analog dup; reset it once */</span>
		<span class="n">cleanup_dig_out_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_nid</span><span class="p">);</span>
	<span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_used</span> <span class="o">=</span> <span class="n">HDA_DIG_EXCLUSIVE</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_multi_out_dig_open</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_multi_out_dig_prepare - prepare the digital out stream</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_multi_out_dig_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_tag</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">format</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="n">setup_dig_out_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_nid</span><span class="p">,</span> <span class="n">stream_tag</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_multi_out_dig_prepare</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_multi_out_dig_cleanup - clean-up the digital out stream</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_multi_out_dig_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="n">cleanup_dig_out_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_nid</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_multi_out_dig_cleanup</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_multi_out_dig_close - release the digital out stream</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_multi_out_dig_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_multi_out_dig_close</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_multi_out_analog_open - open analog outputs</span>
<span class="cm"> *</span>
<span class="cm"> * Open analog outputs and set up the hw-constraints.</span>
<span class="cm"> * If the digital outputs can be opened as slave, open the digital</span>
<span class="cm"> * outputs, too.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_multi_out_analog_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">channels_max</span> <span class="o">=</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">max_channels</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_nid</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">analog_rates</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mout</span><span class="o">-&gt;</span><span class="n">analog_rates</span> <span class="o">=</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">rates</span><span class="p">;</span>
			<span class="n">mout</span><span class="o">-&gt;</span><span class="n">analog_formats</span> <span class="o">=</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">formats</span><span class="p">;</span>
			<span class="n">mout</span><span class="o">-&gt;</span><span class="n">analog_maxbps</span> <span class="o">=</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">maxbps</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">rates</span> <span class="o">=</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">analog_rates</span><span class="p">;</span>
			<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">formats</span> <span class="o">=</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">analog_formats</span><span class="p">;</span>
			<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">maxbps</span> <span class="o">=</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">analog_maxbps</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">spdif_rates</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_hda_query_supported_pcm</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_nid</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">spdif_rates</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">spdif_formats</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">spdif_maxbps</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">share_spdif</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">rates</span> <span class="o">&amp;</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">spdif_rates</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">formats</span> <span class="o">&amp;</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">spdif_formats</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">rates</span> <span class="o">&amp;=</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">spdif_rates</span><span class="p">;</span>
				<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">formats</span> <span class="o">&amp;=</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">spdif_formats</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">spdif_maxbps</span> <span class="o">&lt;</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">maxbps</span><span class="p">)</span>
					<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">maxbps</span> <span class="o">=</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">spdif_maxbps</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">mout</span><span class="o">-&gt;</span><span class="n">share_spdif</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="cm">/* FIXME: need notify? */</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">snd_pcm_hw_constraint_step</span><span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">SNDRV_PCM_HW_PARAM_CHANNELS</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_multi_out_analog_open</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_multi_out_analog_prepare - Preapre the analog outputs.</span>
<span class="cm"> *</span>
<span class="cm"> * Set up the i/o for analog out.</span>
<span class="cm"> * When the digital out is available, copy the front out to digital out, too.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_multi_out_analog_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_tag</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">format</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">nids</span> <span class="o">=</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">dac_nids</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chs</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_spdif_out</span> <span class="o">*</span><span class="n">spdif</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="n">spdif</span> <span class="o">=</span> <span class="n">snd_hda_spdif_out_of_nid</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_nid</span> <span class="o">&amp;&amp;</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">share_spdif</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_used</span> <span class="o">!=</span> <span class="n">HDA_DIG_EXCLUSIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chs</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
		    <span class="n">snd_hda_is_supported_format</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_nid</span><span class="p">,</span>
						<span class="n">format</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">spdif</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IEC958_AES0_NONAUDIO</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_used</span> <span class="o">=</span> <span class="n">HDA_DIG_ANALOG_DUP</span><span class="p">;</span>
			<span class="n">setup_dig_out_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_nid</span><span class="p">,</span>
					     <span class="n">stream_tag</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cleanup_dig_out_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_nid</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>

	<span class="cm">/* front */</span>
	<span class="n">snd_hda_codec_setup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nids</span><span class="p">[</span><span class="n">HDA_FRONT</span><span class="p">],</span> <span class="n">stream_tag</span><span class="p">,</span>
				   <span class="mi">0</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">no_share_stream</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mout</span><span class="o">-&gt;</span><span class="n">hp_nid</span> <span class="o">&amp;&amp;</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">hp_nid</span> <span class="o">!=</span> <span class="n">nids</span><span class="p">[</span><span class="n">HDA_FRONT</span><span class="p">])</span>
		<span class="cm">/* headphone out will just decode front left/right (stereo) */</span>
		<span class="n">snd_hda_codec_setup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">hp_nid</span><span class="p">,</span> <span class="n">stream_tag</span><span class="p">,</span>
					   <span class="mi">0</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
	<span class="cm">/* extra outputs copied from front */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">hp_out_nid</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">no_share_stream</span> <span class="o">&amp;&amp;</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">hp_out_nid</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">snd_hda_codec_setup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span>
						   <span class="n">mout</span><span class="o">-&gt;</span><span class="n">hp_out_nid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						   <span class="n">stream_tag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">extra_out_nid</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">no_share_stream</span> <span class="o">&amp;&amp;</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">extra_out_nid</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">snd_hda_codec_setup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span>
						   <span class="n">mout</span><span class="o">-&gt;</span><span class="n">extra_out_nid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						   <span class="n">stream_tag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>

	<span class="cm">/* surrounds */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">num_dacs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chs</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="cm">/* independent out */</span>
			<span class="n">snd_hda_codec_setup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">stream_tag</span><span class="p">,</span>
						   <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">no_share_stream</span><span class="p">)</span> <span class="cm">/* copy front */</span>
			<span class="n">snd_hda_codec_setup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">stream_tag</span><span class="p">,</span>
						   <span class="mi">0</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_multi_out_analog_prepare</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_multi_out_analog_cleanup - clean up the setting for analog out</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_multi_out_analog_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">nids</span> <span class="o">=</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">dac_nids</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">num_dacs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">snd_hda_codec_cleanup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">nids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">hp_nid</span><span class="p">)</span>
		<span class="n">snd_hda_codec_cleanup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">hp_nid</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">hp_out_nid</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">hp_out_nid</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">snd_hda_codec_cleanup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span>
						     <span class="n">mout</span><span class="o">-&gt;</span><span class="n">hp_out_nid</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">extra_out_nid</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">extra_out_nid</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">snd_hda_codec_cleanup_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span>
						     <span class="n">mout</span><span class="o">-&gt;</span><span class="n">extra_out_nid</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_nid</span> <span class="o">&amp;&amp;</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_used</span> <span class="o">==</span> <span class="n">HDA_DIG_ANALOG_DUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cleanup_dig_out_stream</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_nid</span><span class="p">);</span>
		<span class="n">mout</span><span class="o">-&gt;</span><span class="n">dig_out_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">spdif_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_multi_out_analog_cleanup</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_get_default_vref - Get the default (mic) VREF pin bits</span>
<span class="cm"> *</span>
<span class="cm"> * Guess the suitable VREF pin bits to be set as the pin-control value.</span>
<span class="cm"> * Note: the function doesn&#39;t set the AC_PINCTL_IN_EN bit.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">snd_hda_get_default_vref</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pincap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oldval</span><span class="p">;</span>
	<span class="n">oldval</span> <span class="o">=</span> <span class="n">snd_hda_codec_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				    <span class="n">AC_VERB_GET_PIN_WIDGET_CONTROL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pincap</span> <span class="o">=</span> <span class="n">snd_hda_query_pin_caps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
	<span class="n">pincap</span> <span class="o">=</span> <span class="p">(</span><span class="n">pincap</span> <span class="o">&amp;</span> <span class="n">AC_PINCAP_VREF</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">AC_PINCAP_VREF_SHIFT</span><span class="p">;</span>
	<span class="cm">/* Exception: if the default pin setup is vref50, we give it priority */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pincap</span> <span class="o">&amp;</span> <span class="n">AC_PINCAP_VREF_80</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">oldval</span> <span class="o">!=</span> <span class="n">PIN_VREF50</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">AC_PINCTL_VREF_80</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pincap</span> <span class="o">&amp;</span> <span class="n">AC_PINCAP_VREF_50</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">AC_PINCTL_VREF_50</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pincap</span> <span class="o">&amp;</span> <span class="n">AC_PINCAP_VREF_100</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">AC_PINCTL_VREF_100</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pincap</span> <span class="o">&amp;</span> <span class="n">AC_PINCAP_VREF_GRD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">AC_PINCTL_VREF_GRD</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">AC_PINCTL_VREF_HIZ</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_get_default_vref</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">_snd_hda_set_pin_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">pin</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="n">bool</span> <span class="n">cached</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cap</span> <span class="o">=</span> <span class="n">snd_hda_query_pin_caps</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">pin</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_PINCTL_OUT_EN</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">AC_PINCAP_OUT</span><span class="p">))</span>
				<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">AC_PINCTL_OUT_EN</span> <span class="o">|</span> <span class="n">AC_PINCTL_HP_EN</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_PINCTL_HP_EN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="o">!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">AC_PINCAP_HP_DRV</span><span class="p">))</span>
				<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AC_PINCTL_HP_EN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">AC_PINCTL_IN_EN</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">AC_PINCAP_IN</span><span class="p">))</span>
				<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">AC_PINCTL_IN_EN</span> <span class="o">|</span> <span class="n">AC_PINCTL_VREFEN</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cached</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">snd_hda_codec_update_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">AC_VERB_SET_PIN_WIDGET_CONTROL</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">snd_hda_codec_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">AC_VERB_SET_PIN_WIDGET_CONTROL</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">_snd_hda_set_pin_ctl</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_add_imux_item - Add an item to input_mux</span>
<span class="cm"> *</span>
<span class="cm"> * When the same label is used already in the existing items, the number</span>
<span class="cm"> * suffix is appended to the label.  This label index number is stored</span>
<span class="cm"> * to type_idx when non-NULL pointer is given.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_add_imux_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_input_mux</span> <span class="o">*</span><span class="n">imux</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">type_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">label_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span> <span class="o">&gt;=</span> <span class="n">HDA_MAX_NUM_INPUTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_codec: Too many imux items!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">imux</span><span class="o">-&gt;</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">label</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">label</span><span class="p">)))</span>
			<span class="n">label_idx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type_idx</span><span class="p">)</span>
		<span class="o">*</span><span class="n">type_idx</span> <span class="o">=</span> <span class="n">label_idx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">label_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">imux</span><span class="o">-&gt;</span><span class="n">items</span><span class="p">[</span><span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span><span class="p">].</span><span class="n">label</span><span class="p">,</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="n">imux</span><span class="o">-&gt;</span><span class="n">items</span><span class="p">[</span><span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span><span class="p">].</span><span class="n">label</span><span class="p">),</span>
			 <span class="s">&quot;%s %d&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">label_idx</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">imux</span><span class="o">-&gt;</span><span class="n">items</span><span class="p">[</span><span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span><span class="p">].</span><span class="n">label</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">imux</span><span class="o">-&gt;</span><span class="n">items</span><span class="p">[</span><span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span><span class="p">].</span><span class="n">label</span><span class="p">));</span>
	<span class="n">imux</span><span class="o">-&gt;</span><span class="n">items</span><span class="p">[</span><span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span><span class="p">].</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">imux</span><span class="o">-&gt;</span><span class="n">num_items</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_add_imux_item</span><span class="p">);</span>


<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/*</span>
<span class="cm"> * power management</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_suspend - suspend the codecs</span>
<span class="cm"> * @bus: the HDA bus</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hda_codec_is_power_on</span><span class="p">(</span><span class="n">codec</span><span class="p">))</span>
			<span class="n">hda_call_codec_suspend</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_suspend</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_resume - resume the codecs</span>
<span class="cm"> * @bus: the HDA bus</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is defined only when POWER_SAVE isn&#39;t set.</span>
<span class="cm"> * In the power-save mode, the codec is resumed dynamically.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_hda_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hda_call_codec_resume</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_hda_resume</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * generic arrays</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * snd_array_new - get a new element from the given array</span>
<span class="cm"> * @array: the array object</span>
<span class="cm"> *</span>
<span class="cm"> * Get a new element from the given array.  If it exceeds the</span>
<span class="cm"> * pre-allocated array size, re-allocate the array.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns NULL if allocation failed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">snd_array_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_array</span> <span class="o">*</span><span class="n">array</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">&gt;=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">alloced</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">alloced</span> <span class="o">+</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">alloc_align</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">elem_size</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">oldsize</span> <span class="o">=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">alloced</span> <span class="o">*</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">elem_size</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">nlist</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="mi">4096</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">nlist</span> <span class="o">=</span> <span class="n">krealloc</span><span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nlist</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">nlist</span> <span class="o">+</span> <span class="n">oldsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">oldsize</span><span class="p">);</span>
		<span class="n">array</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="n">nlist</span><span class="p">;</span>
		<span class="n">array</span><span class="o">-&gt;</span><span class="n">alloced</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">snd_array_elem</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">used</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_array_new</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_array_free - free the given array elements</span>
<span class="cm"> * @array: the array object</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_array_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_array</span> <span class="o">*</span><span class="n">array</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">array</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">array</span><span class="o">-&gt;</span><span class="n">alloced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">array</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_array_free</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_print_pcm_bits - Print the supported PCM fmt bits to the string buffer</span>
<span class="cm"> * @pcm: PCM caps bits</span>
<span class="cm"> * @buf: the string buffer to write</span>
<span class="cm"> * @buflen: the max buffer length</span>
<span class="cm"> *</span>
<span class="cm"> * used by hda_proc.c and hda_eld.c</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">snd_print_pcm_bits</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcm</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">32</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">bits</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcm</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AC_SUPPCM_BITS_8</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
			<span class="n">j</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">buflen</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span>  <span class="s">&quot; %d&quot;</span><span class="p">,</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="cm">/* necessary when j == 0 */</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_HDA</span><span class="p">(</span><span class="n">snd_print_pcm_bits</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;HDA codec core&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
