<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › pci › hda › hda_intel.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hda_intel.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *  hda_intel.c - Implementation of primary alsa driver code base</span>
<span class="cm"> *                for Intel HD Audio.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright(c) 2004 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2004 Takashi Iwai &lt;tiwai@suse.de&gt;</span>
<span class="cm"> *                     PeiSen Hou &lt;pshou@realtek.com.tw&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> *  under the terms of the GNU General Public License as published by the Free</span>
<span class="cm"> *  Software Foundation; either version 2 of the License, or (at your option)</span>
<span class="cm"> *  any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> *  more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> *  this program; if not, write to the Free Software Foundation, Inc., 59</span>
<span class="cm"> *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *  CONTACTS:</span>
<span class="cm"> *</span>
<span class="cm"> *  Matt Jared		matt.jared@intel.com</span>
<span class="cm"> *  Andy Kopp		andy.kopp@intel.com</span>
<span class="cm"> *  Dan Kogan		dan.d.kogan@intel.com</span>
<span class="cm"> *</span>
<span class="cm"> *  CHANGES:</span>
<span class="cm"> *</span>
<span class="cm"> *  2004.12.01	Major rewrite by tiwai, merged the work of pshou</span>
<span class="cm"> * </span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#ifdef CONFIG_X86</span>
<span class="cm">/* for snoop control */</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;sound/core.h&gt;</span>
<span class="cp">#include &lt;sound/initval.h&gt;</span>
<span class="cp">#include &lt;linux/vgaarb.h&gt;</span>
<span class="cp">#include &lt;linux/vga_switcheroo.h&gt;</span>
<span class="cp">#include &quot;hda_codec.h&quot;</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">index</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="n">SNDRV_DEFAULT_IDX</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="n">SNDRV_DEFAULT_STR</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="n">SNDRV_DEFAULT_ENABLE_PNP</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">model</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">position_fix</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bdl_pos_adj</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">0</span> <span class="p">...</span> <span class="p">(</span><span class="n">SNDRV_CARDS</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">probe_mask</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">0</span> <span class="p">...</span> <span class="p">(</span><span class="n">SNDRV_CARDS</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">probe_only</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">];</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">single_cmd</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">enable_msi</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SND_HDA_PATCH_LOADER</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">patch</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SND_HDA_INPUT_BEEP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">beep_mode</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">0</span> <span class="p">...</span> <span class="p">(</span><span class="n">SNDRV_CARDS</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span>
					<span class="n">CONFIG_SND_HDA_INPUT_BEEP_MODE</span><span class="p">};</span>
<span class="cp">#endif</span>

<span class="n">module_param_array</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s">&quot;Index value for Intel HD audio interface.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="s">&quot;ID string for Intel HD audio interface.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">enable</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">enable</span><span class="p">,</span> <span class="s">&quot;Enable Intel HD audio interface.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s">&quot;Use the given board model.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">position_fix</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">position_fix</span><span class="p">,</span> <span class="s">&quot;DMA pointer read method.&quot;</span>
		 <span class="s">&quot;(0 = auto, 1 = LPIB, 2 = POSBUF, 3 = VIACOMBO, 4 = COMBO).&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">bdl_pos_adj</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">bdl_pos_adj</span><span class="p">,</span> <span class="s">&quot;BDL position adjustment offset.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">probe_mask</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">probe_mask</span><span class="p">,</span> <span class="s">&quot;Bitmask to probe codecs (default = -1).&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">probe_only</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">probe_only</span><span class="p">,</span> <span class="s">&quot;Only probing and no codec initialization.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">single_cmd</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">single_cmd</span><span class="p">,</span> <span class="s">&quot;Use single command to communicate with codecs &quot;</span>
		 <span class="s">&quot;(for debugging only).&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">enable_msi</span><span class="p">,</span> <span class="n">bint</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">enable_msi</span><span class="p">,</span> <span class="s">&quot;Enable Message Signaled Interrupt (MSI)&quot;</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SND_HDA_PATCH_LOADER</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="s">&quot;Patch file for Intel HD audio interface.&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SND_HDA_INPUT_BEEP</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">beep_mode</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">beep_mode</span><span class="p">,</span> <span class="s">&quot;Select HDA Beep registration mode &quot;</span>
			    <span class="s">&quot;(0=off, 1=on, 2=mute switch on/off) (default=1).&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SND_HDA_POWER_SAVE</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">power_save</span> <span class="o">=</span> <span class="n">CONFIG_SND_HDA_POWER_SAVE_DEFAULT</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">power_save</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">power_save</span><span class="p">,</span> <span class="s">&quot;Automatic power-saving timeout &quot;</span>
		 <span class="s">&quot;(in second, 0 = disable).&quot;</span><span class="p">);</span>

<span class="cm">/* reset the HD-audio controller in power save mode.</span>
<span class="cm"> * this may give more power-saving, but will take longer time to</span>
<span class="cm"> * wake up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">power_save_controller</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">power_save_controller</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">power_save_controller</span><span class="p">,</span> <span class="s">&quot;Reset controller in power save mode.&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">align_buffer_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">align_buffer_size</span><span class="p">,</span> <span class="n">bint</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">align_buffer_size</span><span class="p">,</span>
		<span class="s">&quot;Force buffer and period sizes to be multiple of 128 bytes.&quot;</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">hda_snoop</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">snoop</span><span class="p">,</span> <span class="n">hda_snoop</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">snoop</span><span class="p">,</span> <span class="s">&quot;Enable/disable snooping&quot;</span><span class="p">);</span>
<span class="cp">#define azx_snoop(chip)		(chip)-&gt;snoop</span>
<span class="cp">#else</span>
<span class="cp">#define hda_snoop		true</span>
<span class="cp">#define azx_snoop(chip)		true</span>
<span class="cp">#endif</span>


<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_SUPPORTED_DEVICE</span><span class="p">(</span><span class="s">&quot;{{Intel, ICH6},&quot;</span>
			 <span class="s">&quot;{Intel, ICH6M},&quot;</span>
			 <span class="s">&quot;{Intel, ICH7},&quot;</span>
			 <span class="s">&quot;{Intel, ESB2},&quot;</span>
			 <span class="s">&quot;{Intel, ICH8},&quot;</span>
			 <span class="s">&quot;{Intel, ICH9},&quot;</span>
			 <span class="s">&quot;{Intel, ICH10},&quot;</span>
			 <span class="s">&quot;{Intel, PCH},&quot;</span>
			 <span class="s">&quot;{Intel, CPT},&quot;</span>
			 <span class="s">&quot;{Intel, PPT},&quot;</span>
			 <span class="s">&quot;{Intel, LPT},&quot;</span>
			 <span class="s">&quot;{Intel, PBG},&quot;</span>
			 <span class="s">&quot;{Intel, SCH},&quot;</span>
			 <span class="s">&quot;{ATI, SB450},&quot;</span>
			 <span class="s">&quot;{ATI, SB600},&quot;</span>
			 <span class="s">&quot;{ATI, RS600},&quot;</span>
			 <span class="s">&quot;{ATI, RS690},&quot;</span>
			 <span class="s">&quot;{ATI, RS780},&quot;</span>
			 <span class="s">&quot;{ATI, R600},&quot;</span>
			 <span class="s">&quot;{ATI, RV630},&quot;</span>
			 <span class="s">&quot;{ATI, RV610},&quot;</span>
			 <span class="s">&quot;{ATI, RV670},&quot;</span>
			 <span class="s">&quot;{ATI, RV635},&quot;</span>
			 <span class="s">&quot;{ATI, RV620},&quot;</span>
			 <span class="s">&quot;{ATI, RV770},&quot;</span>
			 <span class="s">&quot;{VIA, VT8251},&quot;</span>
			 <span class="s">&quot;{VIA, VT8237A},&quot;</span>
			 <span class="s">&quot;{SiS, SIS966},&quot;</span>
			 <span class="s">&quot;{ULI, M5461}}&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Intel HDA driver&quot;</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SND_VERBOSE_PRINTK</span>
<span class="cp">#define SFX	</span><span class="cm">/* nop */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define SFX	&quot;hda-intel: &quot;</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_PM) &amp;&amp; defined(CONFIG_VGA_SWITCHEROO)</span>
<span class="cp">#ifdef CONFIG_SND_HDA_CODEC_HDMI</span>
<span class="cp">#define SUPPORT_VGA_SWITCHEROO</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * registers</span>
<span class="cm"> */</span>
<span class="cp">#define ICH6_REG_GCAP			0x00</span>
<span class="cp">#define   ICH6_GCAP_64OK	(1 &lt;&lt; 0)   </span><span class="cm">/* 64bit address support */</span><span class="cp"></span>
<span class="cp">#define   ICH6_GCAP_NSDO	(3 &lt;&lt; 1)   </span><span class="cm">/* # of serial data out signals */</span><span class="cp"></span>
<span class="cp">#define   ICH6_GCAP_BSS		(31 &lt;&lt; 3)  </span><span class="cm">/* # of bidirectional streams */</span><span class="cp"></span>
<span class="cp">#define   ICH6_GCAP_ISS		(15 &lt;&lt; 8)  </span><span class="cm">/* # of input streams */</span><span class="cp"></span>
<span class="cp">#define   ICH6_GCAP_OSS		(15 &lt;&lt; 12) </span><span class="cm">/* # of output streams */</span><span class="cp"></span>
<span class="cp">#define ICH6_REG_VMIN			0x02</span>
<span class="cp">#define ICH6_REG_VMAJ			0x03</span>
<span class="cp">#define ICH6_REG_OUTPAY			0x04</span>
<span class="cp">#define ICH6_REG_INPAY			0x06</span>
<span class="cp">#define ICH6_REG_GCTL			0x08</span>
<span class="cp">#define   ICH6_GCTL_RESET	(1 &lt;&lt; 0)   </span><span class="cm">/* controller reset */</span><span class="cp"></span>
<span class="cp">#define   ICH6_GCTL_FCNTRL	(1 &lt;&lt; 1)   </span><span class="cm">/* flush control */</span><span class="cp"></span>
<span class="cp">#define   ICH6_GCTL_UNSOL	(1 &lt;&lt; 8)   </span><span class="cm">/* accept unsol. response enable */</span><span class="cp"></span>
<span class="cp">#define ICH6_REG_WAKEEN			0x0c</span>
<span class="cp">#define ICH6_REG_STATESTS		0x0e</span>
<span class="cp">#define ICH6_REG_GSTS			0x10</span>
<span class="cp">#define   ICH6_GSTS_FSTS	(1 &lt;&lt; 1)   </span><span class="cm">/* flush status */</span><span class="cp"></span>
<span class="cp">#define ICH6_REG_INTCTL			0x20</span>
<span class="cp">#define ICH6_REG_INTSTS			0x24</span>
<span class="cp">#define ICH6_REG_WALLCLK		0x30	</span><span class="cm">/* 24Mhz source */</span><span class="cp"></span>
<span class="cp">#define ICH6_REG_OLD_SSYNC		0x34	</span><span class="cm">/* SSYNC for old ICH */</span><span class="cp"></span>
<span class="cp">#define ICH6_REG_SSYNC			0x38</span>
<span class="cp">#define ICH6_REG_CORBLBASE		0x40</span>
<span class="cp">#define ICH6_REG_CORBUBASE		0x44</span>
<span class="cp">#define ICH6_REG_CORBWP			0x48</span>
<span class="cp">#define ICH6_REG_CORBRP			0x4a</span>
<span class="cp">#define   ICH6_CORBRP_RST	(1 &lt;&lt; 15)  </span><span class="cm">/* read pointer reset */</span><span class="cp"></span>
<span class="cp">#define ICH6_REG_CORBCTL		0x4c</span>
<span class="cp">#define   ICH6_CORBCTL_RUN	(1 &lt;&lt; 1)   </span><span class="cm">/* enable DMA */</span><span class="cp"></span>
<span class="cp">#define   ICH6_CORBCTL_CMEIE	(1 &lt;&lt; 0)   </span><span class="cm">/* enable memory error irq */</span><span class="cp"></span>
<span class="cp">#define ICH6_REG_CORBSTS		0x4d</span>
<span class="cp">#define   ICH6_CORBSTS_CMEI	(1 &lt;&lt; 0)   </span><span class="cm">/* memory error indication */</span><span class="cp"></span>
<span class="cp">#define ICH6_REG_CORBSIZE		0x4e</span>

<span class="cp">#define ICH6_REG_RIRBLBASE		0x50</span>
<span class="cp">#define ICH6_REG_RIRBUBASE		0x54</span>
<span class="cp">#define ICH6_REG_RIRBWP			0x58</span>
<span class="cp">#define   ICH6_RIRBWP_RST	(1 &lt;&lt; 15)  </span><span class="cm">/* write pointer reset */</span><span class="cp"></span>
<span class="cp">#define ICH6_REG_RINTCNT		0x5a</span>
<span class="cp">#define ICH6_REG_RIRBCTL		0x5c</span>
<span class="cp">#define   ICH6_RBCTL_IRQ_EN	(1 &lt;&lt; 0)   </span><span class="cm">/* enable IRQ */</span><span class="cp"></span>
<span class="cp">#define   ICH6_RBCTL_DMA_EN	(1 &lt;&lt; 1)   </span><span class="cm">/* enable DMA */</span><span class="cp"></span>
<span class="cp">#define   ICH6_RBCTL_OVERRUN_EN	(1 &lt;&lt; 2)   </span><span class="cm">/* enable overrun irq */</span><span class="cp"></span>
<span class="cp">#define ICH6_REG_RIRBSTS		0x5d</span>
<span class="cp">#define   ICH6_RBSTS_IRQ	(1 &lt;&lt; 0)   </span><span class="cm">/* response irq */</span><span class="cp"></span>
<span class="cp">#define   ICH6_RBSTS_OVERRUN	(1 &lt;&lt; 2)   </span><span class="cm">/* overrun irq */</span><span class="cp"></span>
<span class="cp">#define ICH6_REG_RIRBSIZE		0x5e</span>

<span class="cp">#define ICH6_REG_IC			0x60</span>
<span class="cp">#define ICH6_REG_IR			0x64</span>
<span class="cp">#define ICH6_REG_IRS			0x68</span>
<span class="cp">#define   ICH6_IRS_VALID	(1&lt;&lt;1)</span>
<span class="cp">#define   ICH6_IRS_BUSY		(1&lt;&lt;0)</span>

<span class="cp">#define ICH6_REG_DPLBASE		0x70</span>
<span class="cp">#define ICH6_REG_DPUBASE		0x74</span>
<span class="cp">#define   ICH6_DPLBASE_ENABLE	0x1	</span><span class="cm">/* Enable position buffer */</span><span class="cp"></span>

<span class="cm">/* SD offset: SDI0=0x80, SDI1=0xa0, ... SDO3=0x160 */</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">SDI0</span><span class="p">,</span> <span class="n">SDI1</span><span class="p">,</span> <span class="n">SDI2</span><span class="p">,</span> <span class="n">SDI3</span><span class="p">,</span> <span class="n">SDO0</span><span class="p">,</span> <span class="n">SDO1</span><span class="p">,</span> <span class="n">SDO2</span><span class="p">,</span> <span class="n">SDO3</span> <span class="p">};</span>

<span class="cm">/* stream register offsets from stream base */</span>
<span class="cp">#define ICH6_REG_SD_CTL			0x00</span>
<span class="cp">#define ICH6_REG_SD_STS			0x03</span>
<span class="cp">#define ICH6_REG_SD_LPIB		0x04</span>
<span class="cp">#define ICH6_REG_SD_CBL			0x08</span>
<span class="cp">#define ICH6_REG_SD_LVI			0x0c</span>
<span class="cp">#define ICH6_REG_SD_FIFOW		0x0e</span>
<span class="cp">#define ICH6_REG_SD_FIFOSIZE		0x10</span>
<span class="cp">#define ICH6_REG_SD_FORMAT		0x12</span>
<span class="cp">#define ICH6_REG_SD_BDLPL		0x18</span>
<span class="cp">#define ICH6_REG_SD_BDLPU		0x1c</span>

<span class="cm">/* PCI space */</span>
<span class="cp">#define ICH6_PCIREG_TCSEL	0x44</span>

<span class="cm">/*</span>
<span class="cm"> * other constants</span>
<span class="cm"> */</span>

<span class="cm">/* max number of SDs */</span>
<span class="cm">/* ICH, ATI and VIA have 4 playback and 4 capture */</span>
<span class="cp">#define ICH6_NUM_CAPTURE	4</span>
<span class="cp">#define ICH6_NUM_PLAYBACK	4</span>

<span class="cm">/* ULI has 6 playback and 5 capture */</span>
<span class="cp">#define ULI_NUM_CAPTURE		5</span>
<span class="cp">#define ULI_NUM_PLAYBACK	6</span>

<span class="cm">/* ATI HDMI has 1 playback and 0 capture */</span>
<span class="cp">#define ATIHDMI_NUM_CAPTURE	0</span>
<span class="cp">#define ATIHDMI_NUM_PLAYBACK	1</span>

<span class="cm">/* TERA has 4 playback and 3 capture */</span>
<span class="cp">#define TERA_NUM_CAPTURE	3</span>
<span class="cp">#define TERA_NUM_PLAYBACK	4</span>

<span class="cm">/* this number is statically defined for simplicity */</span>
<span class="cp">#define MAX_AZX_DEV		16</span>

<span class="cm">/* max number of fragments - we may use more if allocating more pages for BDL */</span>
<span class="cp">#define BDL_SIZE		4096</span>
<span class="cp">#define AZX_MAX_BDL_ENTRIES	(BDL_SIZE / 16)</span>
<span class="cp">#define AZX_MAX_FRAG		32</span>
<span class="cm">/* max buffer size - no h/w limit, you can increase as you like */</span>
<span class="cp">#define AZX_MAX_BUF_SIZE	(1024*1024*1024)</span>

<span class="cm">/* RIRB int mask: overrun[2], response[0] */</span>
<span class="cp">#define RIRB_INT_RESPONSE	0x01</span>
<span class="cp">#define RIRB_INT_OVERRUN	0x04</span>
<span class="cp">#define RIRB_INT_MASK		0x05</span>

<span class="cm">/* STATESTS int mask: S3,SD2,SD1,SD0 */</span>
<span class="cp">#define AZX_MAX_CODECS		8</span>
<span class="cp">#define AZX_DEFAULT_CODECS	4</span>
<span class="cp">#define STATESTS_INT_MASK	((1 &lt;&lt; AZX_MAX_CODECS) - 1)</span>

<span class="cm">/* SD_CTL bits */</span>
<span class="cp">#define SD_CTL_STREAM_RESET	0x01	</span><span class="cm">/* stream reset bit */</span><span class="cp"></span>
<span class="cp">#define SD_CTL_DMA_START	0x02	</span><span class="cm">/* stream DMA start bit */</span><span class="cp"></span>
<span class="cp">#define SD_CTL_STRIPE		(3 &lt;&lt; 16)	</span><span class="cm">/* stripe control */</span><span class="cp"></span>
<span class="cp">#define SD_CTL_TRAFFIC_PRIO	(1 &lt;&lt; 18)	</span><span class="cm">/* traffic priority */</span><span class="cp"></span>
<span class="cp">#define SD_CTL_DIR		(1 &lt;&lt; 19)	</span><span class="cm">/* bi-directional stream */</span><span class="cp"></span>
<span class="cp">#define SD_CTL_STREAM_TAG_MASK	(0xf &lt;&lt; 20)</span>
<span class="cp">#define SD_CTL_STREAM_TAG_SHIFT	20</span>

<span class="cm">/* SD_CTL and SD_STS */</span>
<span class="cp">#define SD_INT_DESC_ERR		0x10	</span><span class="cm">/* descriptor error interrupt */</span><span class="cp"></span>
<span class="cp">#define SD_INT_FIFO_ERR		0x08	</span><span class="cm">/* FIFO error interrupt */</span><span class="cp"></span>
<span class="cp">#define SD_INT_COMPLETE		0x04	</span><span class="cm">/* completion interrupt */</span><span class="cp"></span>
<span class="cp">#define SD_INT_MASK		(SD_INT_DESC_ERR|SD_INT_FIFO_ERR|\</span>
<span class="cp">				 SD_INT_COMPLETE)</span>

<span class="cm">/* SD_STS */</span>
<span class="cp">#define SD_STS_FIFO_READY	0x20	</span><span class="cm">/* FIFO ready */</span><span class="cp"></span>

<span class="cm">/* INTCTL and INTSTS */</span>
<span class="cp">#define ICH6_INT_ALL_STREAM	0xff	   </span><span class="cm">/* all stream interrupts */</span><span class="cp"></span>
<span class="cp">#define ICH6_INT_CTRL_EN	0x40000000 </span><span class="cm">/* controller interrupt enable bit */</span><span class="cp"></span>
<span class="cp">#define ICH6_INT_GLOBAL_EN	0x80000000 </span><span class="cm">/* global interrupt enable bit */</span><span class="cp"></span>

<span class="cm">/* below are so far hardcoded - should read registers in future */</span>
<span class="cp">#define ICH6_MAX_CORB_ENTRIES	256</span>
<span class="cp">#define ICH6_MAX_RIRB_ENTRIES	256</span>

<span class="cm">/* position fix mode */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">POS_FIX_AUTO</span><span class="p">,</span>
	<span class="n">POS_FIX_LPIB</span><span class="p">,</span>
	<span class="n">POS_FIX_POSBUF</span><span class="p">,</span>
	<span class="n">POS_FIX_VIACOMBO</span><span class="p">,</span>
	<span class="n">POS_FIX_COMBO</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Defines for ATI HD Audio support in SB450 south bridge */</span>
<span class="cp">#define ATI_SB450_HDAUDIO_MISC_CNTR2_ADDR   0x42</span>
<span class="cp">#define ATI_SB450_HDAUDIO_ENABLE_SNOOP      0x02</span>

<span class="cm">/* Defines for Nvidia HDA support */</span>
<span class="cp">#define NVIDIA_HDA_TRANSREG_ADDR      0x4e</span>
<span class="cp">#define NVIDIA_HDA_ENABLE_COHBITS     0x0f</span>
<span class="cp">#define NVIDIA_HDA_ISTRM_COH          0x4d</span>
<span class="cp">#define NVIDIA_HDA_OSTRM_COH          0x4c</span>
<span class="cp">#define NVIDIA_HDA_ENABLE_COHBIT      0x01</span>

<span class="cm">/* Defines for Intel SCH HDA snoop control */</span>
<span class="cp">#define INTEL_SCH_HDA_DEVC      0x78</span>
<span class="cp">#define INTEL_SCH_HDA_DEVC_NOSNOOP       (0x1&lt;&lt;11)</span>

<span class="cm">/* Define IN stream 0 FIFO size offset in VIA controller */</span>
<span class="cp">#define VIA_IN_STREAM0_FIFO_SIZE_OFFSET	0x90</span>
<span class="cm">/* Define VIA HD Audio Device ID*/</span>
<span class="cp">#define VIA_HDAC_DEVICE_ID		0x3288</span>

<span class="cm">/* HD Audio class code */</span>
<span class="cp">#define PCI_CLASS_MULTIMEDIA_HD_AUDIO	0x0403</span>

<span class="cm">/*</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">azx_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_dma_buffer</span> <span class="n">bdl</span><span class="p">;</span> <span class="cm">/* BDL buffer */</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">posbuf</span><span class="p">;</span>		<span class="cm">/* position buffer pointer */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">;</span>	<span class="cm">/* size of the play buffer in bytes */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">period_bytes</span><span class="p">;</span> <span class="cm">/* size of the period in bytes */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frags</span><span class="p">;</span>	<span class="cm">/* number for period in the play buffer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fifo_size</span><span class="p">;</span>	<span class="cm">/* FIFO size */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_wallclk</span><span class="p">;</span>	<span class="cm">/* start + minimum wallclk */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">period_wallclk</span><span class="p">;</span>	<span class="cm">/* wallclk for period */</span>

	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">sd_addr</span><span class="p">;</span>	<span class="cm">/* stream descriptor pointer */</span>

	<span class="n">u32</span> <span class="n">sd_int_sta_mask</span><span class="p">;</span>	<span class="cm">/* stream int status mask */</span>

	<span class="cm">/* pcm support */</span>
	<span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">;</span>	<span class="cm">/* assigned substream,</span>
<span class="cm">						 * set in PCM open</span>
<span class="cm">						 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">format_val</span><span class="p">;</span>	<span class="cm">/* format value to be set in the</span>
<span class="cm">					 * controller and the codec</span>
<span class="cm">					 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">stream_tag</span><span class="p">;</span>	<span class="cm">/* assigned stream */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">index</span><span class="p">;</span>		<span class="cm">/* stream index */</span>
	<span class="kt">int</span> <span class="n">assigned_key</span><span class="p">;</span>		<span class="cm">/* last device# key assigned to */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opened</span> <span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">running</span> <span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_pending</span> <span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * For VIA:</span>
<span class="cm">	 *  A flag to ensure DMA position is 0</span>
<span class="cm">	 *  when link position is not greater than FIFO size</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">insufficient</span> <span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wc_marked</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* CORB/RIRB */</span>
<span class="k">struct</span> <span class="n">azx_rb</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>		<span class="cm">/* CORB/RIRB buffer</span>
<span class="cm">				 * Each CORB entry is 4byte, RIRB is 8byte</span>
<span class="cm">				 */</span>
	<span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">;</span>	<span class="cm">/* physical address of CORB/RIRB buffer */</span>
	<span class="cm">/* for RIRB */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">rp</span><span class="p">,</span> <span class="n">wp</span><span class="p">;</span>	<span class="cm">/* read/write pointers */</span>
	<span class="kt">int</span> <span class="n">cmds</span><span class="p">[</span><span class="n">AZX_MAX_CODECS</span><span class="p">];</span>	<span class="cm">/* number of pending requests */</span>
	<span class="n">u32</span> <span class="n">res</span><span class="p">[</span><span class="n">AZX_MAX_CODECS</span><span class="p">];</span>	<span class="cm">/* last read value */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">azx_pcm</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm</span> <span class="o">*</span><span class="n">pcm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">azx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dev_index</span><span class="p">;</span>

	<span class="cm">/* chip type specific */</span>
	<span class="kt">int</span> <span class="n">driver_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">driver_caps</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">playback_streams</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">playback_index_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">capture_streams</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">capture_index_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_streams</span><span class="p">;</span>

	<span class="cm">/* pci resources */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">remap_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="cm">/* locks */</span>
	<span class="n">spinlock_t</span> <span class="n">reg_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">open_mutex</span><span class="p">;</span>

	<span class="cm">/* streams (x num_streams) */</span>
	<span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">;</span>

	<span class="cm">/* PCM */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pcm_list</span><span class="p">;</span> <span class="cm">/* azx_pcm list */</span>

	<span class="cm">/* HD codec */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">codec_mask</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">codec_probe_mask</span><span class="p">;</span> <span class="cm">/* copied from probe_mask option */</span>
	<span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">beep_mode</span><span class="p">;</span>

	<span class="cm">/* CORB/RIRB */</span>
	<span class="k">struct</span> <span class="n">azx_rb</span> <span class="n">corb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">azx_rb</span> <span class="n">rirb</span><span class="p">;</span>

	<span class="cm">/* CORB/RIRB and position buffers */</span>
	<span class="k">struct</span> <span class="n">snd_dma_buffer</span> <span class="n">rb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_dma_buffer</span> <span class="n">posbuf</span><span class="p">;</span>

	<span class="cm">/* flags */</span>
	<span class="kt">int</span> <span class="n">position_fix</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* for both playback/capture streams */</span>
	<span class="kt">int</span> <span class="n">poll_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">running</span> <span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">initialized</span> <span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">single_cmd</span> <span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">polling_mode</span> <span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msi</span> <span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_pending_warned</span> <span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">probing</span> <span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* codec probing phase */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">snoop</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">align_buffer_size</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">region_requested</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* VGA-switcheroo setup */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">use_vga_switcheroo</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">init_failed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* delayed init failed */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">disabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* disabled by VGA-switcher */</span>

	<span class="cm">/* for debugging */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_cmd</span><span class="p">[</span><span class="n">AZX_MAX_CODECS</span><span class="p">];</span>

	<span class="cm">/* for pending irqs */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">irq_pending_work</span><span class="p">;</span>

	<span class="cm">/* reboot notifier (for mysterious hangup problem at power-down) */</span>
	<span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">reboot_notifier</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* driver types */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">AZX_DRIVER_ICH</span><span class="p">,</span>
	<span class="n">AZX_DRIVER_PCH</span><span class="p">,</span>
	<span class="n">AZX_DRIVER_SCH</span><span class="p">,</span>
	<span class="n">AZX_DRIVER_ATI</span><span class="p">,</span>
	<span class="n">AZX_DRIVER_ATIHDMI</span><span class="p">,</span>
	<span class="n">AZX_DRIVER_ATIHDMI_NS</span><span class="p">,</span>
	<span class="n">AZX_DRIVER_VIA</span><span class="p">,</span>
	<span class="n">AZX_DRIVER_SIS</span><span class="p">,</span>
	<span class="n">AZX_DRIVER_ULI</span><span class="p">,</span>
	<span class="n">AZX_DRIVER_NVIDIA</span><span class="p">,</span>
	<span class="n">AZX_DRIVER_TERA</span><span class="p">,</span>
	<span class="n">AZX_DRIVER_CTX</span><span class="p">,</span>
	<span class="n">AZX_DRIVER_CTHDA</span><span class="p">,</span>
	<span class="n">AZX_DRIVER_GENERIC</span><span class="p">,</span>
	<span class="n">AZX_NUM_DRIVERS</span><span class="p">,</span> <span class="cm">/* keep this as last entry */</span>
<span class="p">};</span>

<span class="cm">/* driver quirks (capabilities) */</span>
<span class="cm">/* bits 0-7 are used for indicating driver type */</span>
<span class="cp">#define AZX_DCAPS_NO_TCSEL	(1 &lt;&lt; 8)	</span><span class="cm">/* No Intel TCSEL bit */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_NO_MSI	(1 &lt;&lt; 9)	</span><span class="cm">/* No MSI support */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_ATI_SNOOP	(1 &lt;&lt; 10)	</span><span class="cm">/* ATI snoop enable */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_NVIDIA_SNOOP	(1 &lt;&lt; 11)	</span><span class="cm">/* Nvidia snoop enable */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_SCH_SNOOP	(1 &lt;&lt; 12)	</span><span class="cm">/* SCH/PCH snoop enable */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_RIRB_DELAY	(1 &lt;&lt; 13)	</span><span class="cm">/* Long delay in read loop */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_RIRB_PRE_DELAY (1 &lt;&lt; 14)	</span><span class="cm">/* Put a delay before read */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_CTX_WORKAROUND (1 &lt;&lt; 15)	</span><span class="cm">/* X-Fi workaround */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_POSFIX_LPIB	(1 &lt;&lt; 16)	</span><span class="cm">/* Use LPIB as default */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_POSFIX_VIA	(1 &lt;&lt; 17)	</span><span class="cm">/* Use VIACOMBO as default */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_NO_64BIT	(1 &lt;&lt; 18)	</span><span class="cm">/* No 64bit address */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_SYNC_WRITE	(1 &lt;&lt; 19)	</span><span class="cm">/* sync each cmd write */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_OLD_SSYNC	(1 &lt;&lt; 20)	</span><span class="cm">/* Old SSYNC reg for ICH */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_BUFSIZE	(1 &lt;&lt; 21)	</span><span class="cm">/* no buffer size alignment */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_ALIGN_BUFSIZE	(1 &lt;&lt; 22)	</span><span class="cm">/* buffer size alignment */</span><span class="cp"></span>
<span class="cp">#define AZX_DCAPS_4K_BDLE_BOUNDARY (1 &lt;&lt; 23)	</span><span class="cm">/* BDLE in 4k boundary */</span><span class="cp"></span>

<span class="cm">/* quirks for ATI SB / AMD Hudson */</span>
<span class="cp">#define AZX_DCAPS_PRESET_ATI_SB \</span>
<span class="cp">	(AZX_DCAPS_ATI_SNOOP | AZX_DCAPS_NO_TCSEL | \</span>
<span class="cp">	 AZX_DCAPS_SYNC_WRITE | AZX_DCAPS_POSFIX_LPIB)</span>

<span class="cm">/* quirks for ATI/AMD HDMI */</span>
<span class="cp">#define AZX_DCAPS_PRESET_ATI_HDMI \</span>
<span class="cp">	(AZX_DCAPS_NO_TCSEL | AZX_DCAPS_SYNC_WRITE | AZX_DCAPS_POSFIX_LPIB)</span>

<span class="cm">/* quirks for Nvidia */</span>
<span class="cp">#define AZX_DCAPS_PRESET_NVIDIA \</span>
<span class="cp">	(AZX_DCAPS_NVIDIA_SNOOP | AZX_DCAPS_RIRB_DELAY | AZX_DCAPS_NO_MSI |\</span>
<span class="cp">	 AZX_DCAPS_ALIGN_BUFSIZE)</span>

<span class="cp">#define AZX_DCAPS_PRESET_CTHDA \</span>
<span class="cp">	(AZX_DCAPS_NO_MSI | AZX_DCAPS_POSFIX_LPIB | AZX_DCAPS_4K_BDLE_BOUNDARY)</span>

<span class="cm">/*</span>
<span class="cm"> * VGA-switcher support</span>
<span class="cm"> */</span>
<span class="cp">#ifdef SUPPORT_VGA_SWITCHEROO</span>
<span class="cp">#define DELAYED_INIT_MARK</span>
<span class="cp">#define DELAYED_INITDATA_MARK</span>
<span class="cp">#define use_vga_switcheroo(chip)	((chip)-&gt;use_vga_switcheroo)</span>
<span class="cp">#else</span>
<span class="cp">#define DELAYED_INIT_MARK	__devinit</span>
<span class="cp">#define DELAYED_INITDATA_MARK	__devinitdata</span>
<span class="cp">#define use_vga_switcheroo(chip)	0</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver_short_names</span><span class="p">[]</span> <span class="n">DELAYED_INITDATA_MARK</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">AZX_DRIVER_ICH</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HDA Intel&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">AZX_DRIVER_PCH</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HDA Intel PCH&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">AZX_DRIVER_SCH</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HDA Intel MID&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">AZX_DRIVER_ATI</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HDA ATI SB&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">AZX_DRIVER_ATIHDMI</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HDA ATI HDMI&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">AZX_DRIVER_ATIHDMI_NS</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HDA ATI HDMI&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">AZX_DRIVER_VIA</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HDA VIA VT82xx&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">AZX_DRIVER_SIS</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HDA SIS966&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">AZX_DRIVER_ULI</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HDA ULI M5461&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">AZX_DRIVER_NVIDIA</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HDA NVidia&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">AZX_DRIVER_TERA</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HDA Teradici&quot;</span><span class="p">,</span> 
	<span class="p">[</span><span class="n">AZX_DRIVER_CTX</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HDA Creative&quot;</span><span class="p">,</span> 
	<span class="p">[</span><span class="n">AZX_DRIVER_CTHDA</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HDA Creative&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">AZX_DRIVER_GENERIC</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HD-Audio Generic&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * macros for easy use</span>
<span class="cm"> */</span>
<span class="cp">#define azx_writel(chip,reg,value) \</span>
<span class="cp">	writel(value, (chip)-&gt;remap_addr + ICH6_REG_##reg)</span>
<span class="cp">#define azx_readl(chip,reg) \</span>
<span class="cp">	readl((chip)-&gt;remap_addr + ICH6_REG_##reg)</span>
<span class="cp">#define azx_writew(chip,reg,value) \</span>
<span class="cp">	writew(value, (chip)-&gt;remap_addr + ICH6_REG_##reg)</span>
<span class="cp">#define azx_readw(chip,reg) \</span>
<span class="cp">	readw((chip)-&gt;remap_addr + ICH6_REG_##reg)</span>
<span class="cp">#define azx_writeb(chip,reg,value) \</span>
<span class="cp">	writeb(value, (chip)-&gt;remap_addr + ICH6_REG_##reg)</span>
<span class="cp">#define azx_readb(chip,reg) \</span>
<span class="cp">	readb((chip)-&gt;remap_addr + ICH6_REG_##reg)</span>

<span class="cp">#define azx_sd_writel(dev,reg,value) \</span>
<span class="cp">	writel(value, (dev)-&gt;sd_addr + ICH6_REG_##reg)</span>
<span class="cp">#define azx_sd_readl(dev,reg) \</span>
<span class="cp">	readl((dev)-&gt;sd_addr + ICH6_REG_##reg)</span>
<span class="cp">#define azx_sd_writew(dev,reg,value) \</span>
<span class="cp">	writew(value, (dev)-&gt;sd_addr + ICH6_REG_##reg)</span>
<span class="cp">#define azx_sd_readw(dev,reg) \</span>
<span class="cp">	readw((dev)-&gt;sd_addr + ICH6_REG_##reg)</span>
<span class="cp">#define azx_sd_writeb(dev,reg,value) \</span>
<span class="cp">	writeb(value, (dev)-&gt;sd_addr + ICH6_REG_##reg)</span>
<span class="cp">#define azx_sd_readb(dev,reg) \</span>
<span class="cp">	readb((dev)-&gt;sd_addr + ICH6_REG_##reg)</span>

<span class="cm">/* for pcm support */</span>
<span class="cp">#define get_azx_dev(substream) (substream-&gt;runtime-&gt;private_data)</span>

<span class="cp">#ifdef CONFIG_X86</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__mark_pages_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">bool</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">azx_snoop</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;&amp;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span>
			<span class="n">set_memory_wc</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">set_memory_wb</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mark_pages_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_dma_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				 <span class="n">bool</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__mark_pages_wc</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">,</span> <span class="n">on</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mark_runtime_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">,</span> <span class="n">bool</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">wc_marked</span> <span class="o">!=</span> <span class="n">on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__mark_pages_wc</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span><span class="p">,</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_bytes</span><span class="p">,</span> <span class="n">on</span><span class="p">);</span>
		<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">wc_marked</span> <span class="o">=</span> <span class="n">on</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cm">/* NOP for other archs */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mark_pages_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_dma_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				 <span class="n">bool</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mark_runtime_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">,</span> <span class="n">bool</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">azx_acquire_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">do_disconnect</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">azx_send_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * Interface for HD codec</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * CORB / RIRB interface</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_alloc_cmd_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* single page (at least 4096 bytes) must suffice for both ringbuffes */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_dma_alloc_pages</span><span class="p">(</span><span class="n">SNDRV_DMA_TYPE_DEV</span><span class="p">,</span>
				  <span class="n">snd_dma_pci_data</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">),</span>
				  <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span> <span class="s">&quot;cannot allocate CORB/RIRB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mark_pages_wc</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_init_cmd_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="cm">/* CORB set up */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">corb</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">corb</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">area</span><span class="p">;</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CORBLBASE</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">corb</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CORBUBASE</span><span class="p">,</span> <span class="n">upper_32_bits</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">corb</span><span class="p">.</span><span class="n">addr</span><span class="p">));</span>

	<span class="cm">/* set the corb size to 256 entries (ULI requires explicitly) */</span>
	<span class="n">azx_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CORBSIZE</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">);</span>
	<span class="cm">/* set the corb write pointer to 0 */</span>
	<span class="n">azx_writew</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CORBWP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* reset the corb hw read pointer */</span>
	<span class="n">azx_writew</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CORBRP</span><span class="p">,</span> <span class="n">ICH6_CORBRP_RST</span><span class="p">);</span>
	<span class="cm">/* enable corb dma */</span>
	<span class="n">azx_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CORBCTL</span><span class="p">,</span> <span class="n">ICH6_CORBCTL_RUN</span><span class="p">);</span>

	<span class="cm">/* RIRB set up */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">addr</span> <span class="o">+</span> <span class="mi">2048</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">area</span> <span class="o">+</span> <span class="mi">2048</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">wp</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">rp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">cmds</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">cmds</span><span class="p">));</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RIRBLBASE</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RIRBUBASE</span><span class="p">,</span> <span class="n">upper_32_bits</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">addr</span><span class="p">));</span>

	<span class="cm">/* set the rirb size to 256 entries (ULI requires explicitly) */</span>
	<span class="n">azx_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RIRBSIZE</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">);</span>
	<span class="cm">/* reset the rirb hw write pointer */</span>
	<span class="n">azx_writew</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RIRBWP</span><span class="p">,</span> <span class="n">ICH6_RIRBWP_RST</span><span class="p">);</span>
	<span class="cm">/* set N=1, get RIRB response interrupt for new entry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_CTX_WORKAROUND</span><span class="p">)</span>
		<span class="n">azx_writew</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RINTCNT</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">azx_writew</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RINTCNT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* enable rirb dma and response irq */</span>
	<span class="n">azx_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RIRBCTL</span><span class="p">,</span> <span class="n">ICH6_RBCTL_DMA_EN</span> <span class="o">|</span> <span class="n">ICH6_RBCTL_IRQ_EN</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_free_cmd_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="cm">/* disable ringbuffer DMAs */</span>
	<span class="n">azx_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RIRBCTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">azx_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CORBCTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">azx_command_addr</span><span class="p">(</span><span class="n">u32</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">cmd</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">AZX_MAX_CODECS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_BUG</span><span class="p">();</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">azx_response_addr</span><span class="p">(</span><span class="n">u32</span> <span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">res</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">AZX_MAX_CODECS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_BUG</span><span class="p">();</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* send a command */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_corb_send_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">azx_command_addr</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wp</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>

	<span class="cm">/* add command to corb */</span>
	<span class="n">wp</span> <span class="o">=</span> <span class="n">azx_readb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CORBWP</span><span class="p">);</span>
	<span class="n">wp</span><span class="o">++</span><span class="p">;</span>
	<span class="n">wp</span> <span class="o">%=</span> <span class="n">ICH6_MAX_CORB_ENTRIES</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">cmds</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">corb</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">wp</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CORBWP</span><span class="p">,</span> <span class="n">wp</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define ICH6_RIRB_EX_UNSOL_EV	(1&lt;&lt;4)</span>

<span class="cm">/* retrieve RIRB entry - called from interrupt handler */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_update_rirb</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rp</span><span class="p">,</span> <span class="n">wp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">res</span><span class="p">,</span> <span class="n">res_ex</span><span class="p">;</span>

	<span class="n">wp</span> <span class="o">=</span> <span class="n">azx_readb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RIRBWP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wp</span> <span class="o">==</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">wp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">wp</span> <span class="o">=</span> <span class="n">wp</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">rp</span> <span class="o">!=</span> <span class="n">wp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">rp</span><span class="o">++</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">rp</span> <span class="o">%=</span> <span class="n">ICH6_MAX_RIRB_ENTRIES</span><span class="p">;</span>

		<span class="n">rp</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">rp</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* an RIRB entry is 8-bytes */</span>
		<span class="n">res_ex</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">rp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">rp</span><span class="p">]);</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">azx_response_addr</span><span class="p">(</span><span class="n">res_ex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res_ex</span> <span class="o">&amp;</span> <span class="n">ICH6_RIRB_EX_UNSOL_EV</span><span class="p">)</span>
			<span class="n">snd_hda_queue_unsol_event</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">res_ex</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">cmds</span><span class="p">[</span><span class="n">addr</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">res</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
			<span class="n">smp_wmb</span><span class="p">();</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">cmds</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span> <span class="s">&quot;spurious response %#x:%#x, &quot;</span>
				   <span class="s">&quot;last cmd=%#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">res</span><span class="p">,</span> <span class="n">res_ex</span><span class="p">,</span>
				   <span class="n">chip</span><span class="o">-&gt;</span><span class="n">last_cmd</span><span class="p">[</span><span class="n">addr</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* receive a response */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">azx_rirb_get_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">loopcounter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_poll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">again:</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">loopcounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;</span> <span class="n">loopcounter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">polling_mode</span> <span class="o">||</span> <span class="n">do_poll</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
			<span class="n">azx_update_rirb</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">cmds</span><span class="p">[</span><span class="n">addr</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">smp_rmb</span><span class="p">();</span>
			<span class="n">bus</span><span class="o">-&gt;</span><span class="n">rirb_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_poll</span><span class="p">)</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">poll_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">res</span><span class="p">[</span><span class="n">addr</span><span class="p">];</span> <span class="cm">/* the last value */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">needs_damn_long_delay</span> <span class="o">||</span> <span class="n">loopcounter</span> <span class="o">&gt;</span> <span class="mi">3000</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="cm">/* temporary workaround */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">polling_mode</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">poll_count</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;azx_get_response timeout, &quot;</span>
			   <span class="s">&quot;polling the codec once: last cmd=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">chip</span><span class="o">-&gt;</span><span class="n">last_cmd</span><span class="p">[</span><span class="n">addr</span><span class="p">]);</span>
		<span class="n">do_poll</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">poll_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">polling_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">SFX</span> <span class="s">&quot;azx_get_response timeout, &quot;</span>
			   <span class="s">&quot;switching to polling mode: last cmd=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">chip</span><span class="o">-&gt;</span><span class="n">last_cmd</span><span class="p">[</span><span class="n">addr</span><span class="p">]);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">polling_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">msi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">SFX</span> <span class="s">&quot;No response from codec, &quot;</span>
			   <span class="s">&quot;disabling MSI: last cmd=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">chip</span><span class="o">-&gt;</span><span class="n">last_cmd</span><span class="p">[</span><span class="n">addr</span><span class="p">]);</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">msi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">azx_acquire_irq</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bus</span><span class="o">-&gt;</span><span class="n">rirb_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">probing</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If this critical timeout happens during the codec probing</span>
<span class="cm">		 * phase, this is likely an access to a non-existing codec</span>
<span class="cm">		 * slot.  Better to return an error and reset the system.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* a fatal communication error; need either to reset or to fallback</span>
<span class="cm">	 * to the single_cmd mode</span>
<span class="cm">	 */</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">rirb_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">allow_bus_reset</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">response_reset</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">in_reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bus</span><span class="o">-&gt;</span><span class="n">response_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* give a chance to retry */</span>
	<span class="p">}</span>

	<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda_intel: azx_get_response timeout, &quot;</span>
		   <span class="s">&quot;switching to single_cmd mode: last cmd=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">chip</span><span class="o">-&gt;</span><span class="n">last_cmd</span><span class="p">[</span><span class="n">addr</span><span class="p">]);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">single_cmd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">response_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* release CORB/RIRB */</span>
	<span class="n">azx_free_cmd_io</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="cm">/* disable unsolicited responses */</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">GCTL</span><span class="p">,</span> <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">GCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ICH6_GCTL_UNSOL</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use the single immediate command instead of CORB/RIRB for simplicity</span>
<span class="cm"> *</span>
<span class="cm"> * Note: according to Intel, this is not preferred use.  The command was</span>
<span class="cm"> *       intended for the BIOS only, and may get confused with unsolicited</span>
<span class="cm"> *       responses.  So, we shouldn&#39;t use it for normal operation from the</span>
<span class="cm"> *       driver.</span>
<span class="cm"> *       I left the codes, however, for debugging/testing purposes.</span>
<span class="cm"> */</span>

<span class="cm">/* receive a response */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_single_wait_for_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">timeout</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check IRV busy bit */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">azx_readw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ICH6_IRS_VALID</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* reuse rirb.res as the response return value */</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">res</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">=</span> <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IR</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;get_response timeout: IRS=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">azx_readw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRS</span><span class="p">));</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">res</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* send a command */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_single_send_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">azx_command_addr</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>

	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">rirb_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">timeout</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check ICB busy bit */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">azx_readw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ICH6_IRS_BUSY</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* Clear IRV valid bit */</span>
			<span class="n">azx_writew</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRS</span><span class="p">,</span> <span class="n">azx_readw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRS</span><span class="p">)</span> <span class="o">|</span>
				   <span class="n">ICH6_IRS_VALID</span><span class="p">);</span>
			<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IC</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">azx_writew</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRS</span><span class="p">,</span> <span class="n">azx_readw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRS</span><span class="p">)</span> <span class="o">|</span>
				   <span class="n">ICH6_IRS_BUSY</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">azx_single_wait_for_response</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;send_cmd timeout: IRS=0x%x, val=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">azx_readw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRS</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* receive a response */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">azx_single_get_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">rirb</span><span class="p">.</span><span class="n">res</span><span class="p">[</span><span class="n">addr</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The below are the main callbacks from hda_codec.</span>
<span class="cm"> *</span>
<span class="cm"> * They are just the skeleton to call sub-callbacks according to the</span>
<span class="cm"> * current setting of chip-&gt;single_cmd.</span>
<span class="cm"> */</span>

<span class="cm">/* send a command */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_send_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">last_cmd</span><span class="p">[</span><span class="n">azx_command_addr</span><span class="p">(</span><span class="n">val</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">single_cmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">azx_single_send_cmd</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">azx_corb_send_cmd</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* get a response */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">azx_get_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">single_cmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">azx_single_get_response</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">azx_rirb_get_response</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SND_HDA_POWER_SAVE</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">azx_power_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* reset codec link */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">full_reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">full_reset</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">__skip</span><span class="p">;</span>

	<span class="cm">/* clear STATESTS */</span>
	<span class="n">azx_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STATESTS</span><span class="p">,</span> <span class="n">STATESTS_INT_MASK</span><span class="p">);</span>

	<span class="cm">/* reset controller */</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">GCTL</span><span class="p">,</span> <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">GCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ICH6_GCTL_RESET</span><span class="p">);</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">azx_readb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">GCTL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">count</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* delay for &gt;= 100us for codec PLL to settle per spec</span>
<span class="cm">	 * Rev 0.9 section 5.5.1</span>
<span class="cm">	 */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Bring controller out of reset */</span>
	<span class="n">azx_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">GCTL</span><span class="p">,</span> <span class="n">azx_readb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">GCTL</span><span class="p">)</span> <span class="o">|</span> <span class="n">ICH6_GCTL_RESET</span><span class="p">);</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">azx_readb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">GCTL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">count</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Brent Chartrand said to wait &gt;= 540us for codecs to initialize */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

      <span class="nl">__skip:</span>
	<span class="cm">/* check to see if controller is ready */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">azx_readb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">GCTL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;azx_reset: controller not ready!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Accept unsolicited responses */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">single_cmd</span><span class="p">)</span>
		<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">GCTL</span><span class="p">,</span> <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">GCTL</span><span class="p">)</span> <span class="o">|</span>
			   <span class="n">ICH6_GCTL_UNSOL</span><span class="p">);</span>

	<span class="cm">/* detect codecs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_mask</span> <span class="o">=</span> <span class="n">azx_readw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STATESTS</span><span class="p">);</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;codec_mask = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Lowlevel interface</span>
<span class="cm"> */</span>  

<span class="cm">/* enable interrupts */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_int_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* enable controller CIE and GIE */</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">INTCTL</span><span class="p">,</span> <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">INTCTL</span><span class="p">)</span> <span class="o">|</span>
		   <span class="n">ICH6_INT_CTRL_EN</span> <span class="o">|</span> <span class="n">ICH6_INT_GLOBAL_EN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* disable interrupts */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_int_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* disable interrupts in stream descriptor */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">num_streams</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">azx_sd_writeb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">,</span>
			      <span class="n">azx_sd_readb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SD_INT_MASK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* disable SIE for all streams */</span>
	<span class="n">azx_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">INTCTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* disable controller CIE and GIE */</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">INTCTL</span><span class="p">,</span> <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">INTCTL</span><span class="p">)</span> <span class="o">&amp;</span>
		   <span class="o">~</span><span class="p">(</span><span class="n">ICH6_INT_CTRL_EN</span> <span class="o">|</span> <span class="n">ICH6_INT_GLOBAL_EN</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* clear interrupts */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_int_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* clear stream status */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">num_streams</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">azx_sd_writeb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_STS</span><span class="p">,</span> <span class="n">SD_INT_MASK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* clear STATESTS */</span>
	<span class="n">azx_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STATESTS</span><span class="p">,</span> <span class="n">STATESTS_INT_MASK</span><span class="p">);</span>

	<span class="cm">/* clear rirb status */</span>
	<span class="n">azx_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RIRBSTS</span><span class="p">,</span> <span class="n">RIRB_INT_MASK</span><span class="p">);</span>

	<span class="cm">/* clear int status */</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">INTSTS</span><span class="p">,</span> <span class="n">ICH6_INT_CTRL_EN</span> <span class="o">|</span> <span class="n">ICH6_INT_ALL_STREAM</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* start a stream */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_stream_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Before stream start, initialize parameter</span>
<span class="cm">	 */</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">insufficient</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* enable SIE */</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">INTCTL</span><span class="p">,</span>
		   <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">INTCTL</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">));</span>
	<span class="cm">/* set DMA start and interrupt mask */</span>
	<span class="n">azx_sd_writeb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">,</span> <span class="n">azx_sd_readb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">)</span> <span class="o">|</span>
		      <span class="n">SD_CTL_DMA_START</span> <span class="o">|</span> <span class="n">SD_INT_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* stop DMA */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_stream_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">azx_sd_writeb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">,</span> <span class="n">azx_sd_readb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">)</span> <span class="o">&amp;</span>
		      <span class="o">~</span><span class="p">(</span><span class="n">SD_CTL_DMA_START</span> <span class="o">|</span> <span class="n">SD_INT_MASK</span><span class="p">));</span>
	<span class="n">azx_sd_writeb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_STS</span><span class="p">,</span> <span class="n">SD_INT_MASK</span><span class="p">);</span> <span class="cm">/* to be sure */</span>
<span class="p">}</span>

<span class="cm">/* stop a stream */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_stream_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">azx_stream_clear</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">);</span>
	<span class="cm">/* disable SIE */</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">INTCTL</span><span class="p">,</span>
		   <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">INTCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * reset and start the controller registers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_init_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">full_reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">initialized</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* reset controller */</span>
	<span class="n">azx_reset</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">full_reset</span><span class="p">);</span>

	<span class="cm">/* initialize interrupts */</span>
	<span class="n">azx_int_clear</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="n">azx_int_enable</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* initialize the codec command I/O */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">single_cmd</span><span class="p">)</span>
		<span class="n">azx_init_cmd_io</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* program the position buffer */</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DPLBASE</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">posbuf</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DPUBASE</span><span class="p">,</span> <span class="n">upper_32_bits</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">posbuf</span><span class="p">.</span><span class="n">addr</span><span class="p">));</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * initialize the PCI registers</span>
<span class="cm"> */</span>
<span class="cm">/* update bits in a PCI register byte */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_pci_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_init_pci</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Clear bits 0-2 of PCI register TCSEL (at offset 0x44)</span>
<span class="cm">	 * TCSEL == Traffic Class Select Register, which sets PCI express QOS</span>
<span class="cm">	 * Ensuring these bits are 0 clears playback static on some HD Audio</span>
<span class="cm">	 * codecs.</span>
<span class="cm">	 * The PCI register TCSEL is defined in the Intel manuals.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_NO_TCSEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;Clearing TCSEL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">update_pci_byte</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span> <span class="n">ICH6_PCIREG_TCSEL</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* For ATI SB450/600/700/800/900 and AMD Hudson azalia HD audio,</span>
<span class="cm">	 * we need to enable snoop.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_ATI_SNOOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;Setting ATI snoop: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">azx_snoop</span><span class="p">(</span><span class="n">chip</span><span class="p">));</span>
		<span class="n">update_pci_byte</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span>
				<span class="n">ATI_SB450_HDAUDIO_MISC_CNTR2_ADDR</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span>
				<span class="n">azx_snoop</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">?</span> <span class="n">ATI_SB450_HDAUDIO_ENABLE_SNOOP</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* For NVIDIA HDA, enable snoop */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_NVIDIA_SNOOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;Setting Nvidia snoop: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">azx_snoop</span><span class="p">(</span><span class="n">chip</span><span class="p">));</span>
		<span class="n">update_pci_byte</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span>
				<span class="n">NVIDIA_HDA_TRANSREG_ADDR</span><span class="p">,</span>
				<span class="mh">0x0f</span><span class="p">,</span> <span class="n">NVIDIA_HDA_ENABLE_COHBITS</span><span class="p">);</span>
		<span class="n">update_pci_byte</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span>
				<span class="n">NVIDIA_HDA_ISTRM_COH</span><span class="p">,</span>
				<span class="mh">0x01</span><span class="p">,</span> <span class="n">NVIDIA_HDA_ENABLE_COHBIT</span><span class="p">);</span>
		<span class="n">update_pci_byte</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span>
				<span class="n">NVIDIA_HDA_OSTRM_COH</span><span class="p">,</span>
				<span class="mh">0x01</span><span class="p">,</span> <span class="n">NVIDIA_HDA_ENABLE_COHBIT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Enable SCH/PCH snoop if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_SCH_SNOOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">snoop</span><span class="p">;</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span> <span class="n">INTEL_SCH_HDA_DEVC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snoop</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">azx_snoop</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">snoop</span> <span class="o">&amp;</span> <span class="n">INTEL_SCH_HDA_DEVC_NOSNOOP</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">azx_snoop</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">snoop</span> <span class="o">&amp;</span> <span class="n">INTEL_SCH_HDA_DEVC_NOSNOOP</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">snoop</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INTEL_SCH_HDA_DEVC_NOSNOOP</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">azx_snoop</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
				<span class="n">snoop</span> <span class="o">|=</span> <span class="n">INTEL_SCH_HDA_DEVC_NOSNOOP</span><span class="p">;</span>
			<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span> <span class="n">INTEL_SCH_HDA_DEVC</span><span class="p">,</span> <span class="n">snoop</span><span class="p">);</span>
			<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span>
				<span class="n">INTEL_SCH_HDA_DEVC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snoop</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;SCH snoop: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">snoop</span> <span class="o">&amp;</span> <span class="n">INTEL_SCH_HDA_DEVC_NOSNOOP</span><span class="p">)</span>
				<span class="o">?</span> <span class="s">&quot;Disabled&quot;</span> <span class="o">:</span> <span class="s">&quot;Enabled&quot;</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">azx_position_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * interrupt handler</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">azx_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sd_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ok</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">INTSTS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">num_streams</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">azx_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">sd_int_sta_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sd_status</span> <span class="o">=</span> <span class="n">azx_sd_readb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_STS</span><span class="p">);</span>
			<span class="n">azx_sd_writeb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_STS</span><span class="p">,</span> <span class="n">SD_INT_MASK</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">substream</span> <span class="o">||</span> <span class="o">!</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">||</span>
			    <span class="o">!</span><span class="p">(</span><span class="n">sd_status</span> <span class="o">&amp;</span> <span class="n">SD_INT_COMPLETE</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/* check whether this IRQ is really acceptable */</span>
			<span class="n">ok</span> <span class="o">=</span> <span class="n">azx_position_ok</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ok</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">irq_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
				<span class="n">snd_pcm_period_elapsed</span><span class="p">(</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">);</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ok</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* bogus IRQ, process it later */</span>
				<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">irq_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">queue_work</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">workq</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_pending_work</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* clear rirb int */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">azx_readb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RIRBSTS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RIRB_INT_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RIRB_INT_RESPONSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_RIRB_PRE_DELAY</span><span class="p">)</span>
				<span class="n">udelay</span><span class="p">(</span><span class="mi">80</span><span class="p">);</span>
			<span class="n">azx_update_rirb</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">azx_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RIRBSTS</span><span class="p">,</span> <span class="n">RIRB_INT_MASK</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* clear state status int */</span>
<span class="c">	if (azx_readb(chip, STATESTS) &amp; 0x04)</span>
<span class="c">		azx_writeb(chip, STATESTS, 0x04);</span>
<span class="cp">#endif</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * set up a BDL entry</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_bdle</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">**</span><span class="n">bdlp</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">with_ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">bdl</span> <span class="o">=</span> <span class="o">*</span><span class="n">bdlp</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">chunk</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">frags</span> <span class="o">&gt;=</span> <span class="n">AZX_MAX_BDL_ENTRIES</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">addr</span> <span class="o">=</span> <span class="n">snd_pcm_sgbuf_get_addr</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
		<span class="cm">/* program the address field of the BDL entry */</span>
		<span class="n">bdl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">bdl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">upper_32_bits</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="cm">/* program the size field of the BDL entry */</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="n">snd_pcm_sgbuf_get_chunk_size</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="cm">/* one BDLE cannot cross 4K boundary on CTHDA chips */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_4K_BDLE_BOUNDARY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">remain</span> <span class="o">=</span> <span class="mh">0x1000</span> <span class="o">-</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">&gt;</span> <span class="n">remain</span><span class="p">)</span>
				<span class="n">chunk</span> <span class="o">=</span> <span class="n">remain</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bdl</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
		<span class="cm">/* program the IOC to enable interrupt</span>
<span class="cm">		 * only when the whole fragment is processed</span>
<span class="cm">		 */</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">chunk</span><span class="p">;</span>
		<span class="n">bdl</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">||</span> <span class="o">!</span><span class="n">with_ioc</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x01</span><span class="p">);</span>
		<span class="n">bdl</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">frags</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ofs</span> <span class="o">+=</span> <span class="n">chunk</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">bdlp</span> <span class="o">=</span> <span class="n">bdl</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ofs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * set up BDL entries</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_setup_periods</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">bdl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">period_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos_adj</span><span class="p">;</span>

	<span class="cm">/* reset BDL address */</span>
	<span class="n">azx_sd_writel</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_BDLPL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">azx_sd_writel</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_BDLPU</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">period_bytes</span> <span class="o">=</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_bytes</span><span class="p">;</span>
	<span class="n">periods</span> <span class="o">=</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">bufsize</span> <span class="o">/</span> <span class="n">period_bytes</span><span class="p">;</span>

	<span class="cm">/* program the initial BDL entries */</span>
	<span class="n">bdl</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">bdl</span><span class="p">.</span><span class="n">area</span><span class="p">;</span>
	<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">frags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pos_adj</span> <span class="o">=</span> <span class="n">bdl_pos_adj</span><span class="p">[</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">dev_index</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos_adj</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">pos_align</span> <span class="o">=</span> <span class="n">pos_adj</span><span class="p">;</span>
		<span class="n">pos_adj</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos_adj</span> <span class="o">*</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">+</span> <span class="mi">47999</span><span class="p">)</span> <span class="o">/</span> <span class="mi">48000</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos_adj</span><span class="p">)</span>
			<span class="n">pos_adj</span> <span class="o">=</span> <span class="n">pos_align</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pos_adj</span> <span class="o">=</span> <span class="p">((</span><span class="n">pos_adj</span> <span class="o">+</span> <span class="n">pos_align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">pos_align</span><span class="p">)</span> <span class="o">*</span>
				<span class="n">pos_align</span><span class="p">;</span>
		<span class="n">pos_adj</span> <span class="o">=</span> <span class="n">frames_to_bytes</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">pos_adj</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos_adj</span> <span class="o">&gt;=</span> <span class="n">period_bytes</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">SFX</span> <span class="s">&quot;Too big adjustment %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">bdl_pos_adj</span><span class="p">[</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">dev_index</span><span class="p">]);</span>
			<span class="n">pos_adj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ofs</span> <span class="o">=</span> <span class="n">setup_bdle</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">substream</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">bdl</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">pos_adj</span><span class="p">,</span>
					 <span class="o">!</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">no_period_wakeup</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pos_adj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">periods</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">periods</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pos_adj</span><span class="p">)</span>
			<span class="n">ofs</span> <span class="o">=</span> <span class="n">setup_bdle</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">substream</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdl</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span>
					 <span class="n">period_bytes</span> <span class="o">-</span> <span class="n">pos_adj</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ofs</span> <span class="o">=</span> <span class="n">setup_bdle</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">substream</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdl</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span>
					 <span class="n">period_bytes</span><span class="p">,</span>
					 <span class="o">!</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">no_period_wakeup</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">error:</span>
	<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span> <span class="s">&quot;Too many BDL entries: buffer=%d, period=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">bufsize</span><span class="p">,</span> <span class="n">period_bytes</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* reset stream */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_stream_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">azx_stream_clear</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">);</span>

	<span class="n">azx_sd_writeb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">,</span> <span class="n">azx_sd_readb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">)</span> <span class="o">|</span>
		      <span class="n">SD_CTL_STREAM_RESET</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">val</span> <span class="o">=</span> <span class="n">azx_sd_readb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">SD_CTL_STREAM_RESET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="o">--</span><span class="n">timeout</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SD_CTL_STREAM_RESET</span><span class="p">;</span>
	<span class="n">azx_sd_writeb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
	<span class="cm">/* waiting for hardware to report that the stream is out of reset */</span>
	<span class="k">while</span> <span class="p">(((</span><span class="n">val</span> <span class="o">=</span> <span class="n">azx_sd_readb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">SD_CTL_STREAM_RESET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="o">--</span><span class="n">timeout</span><span class="p">)</span>
		<span class="p">;</span>

	<span class="cm">/* reset first position - may not be synced with hw at this time */</span>
	<span class="o">*</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">posbuf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * set up the SD for streaming</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_setup_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="cm">/* make sure the run bit is zero for SD */</span>
	<span class="n">azx_stream_clear</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">);</span>
	<span class="cm">/* program the stream_tag */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">azx_sd_readl</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SD_CTL_STREAM_TAG_MASK</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">stream_tag</span> <span class="o">&lt;&lt;</span> <span class="n">SD_CTL_STREAM_TAG_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">azx_snoop</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">SD_CTL_TRAFFIC_PRIO</span><span class="p">;</span>
	<span class="n">azx_sd_writel</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/* program the length of samples in cyclic buffer */</span>
	<span class="n">azx_sd_writel</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CBL</span><span class="p">,</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">bufsize</span><span class="p">);</span>

	<span class="cm">/* program the stream format */</span>
	<span class="cm">/* this value needs to be the same as the one programmed */</span>
	<span class="n">azx_sd_writew</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_FORMAT</span><span class="p">,</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">format_val</span><span class="p">);</span>

	<span class="cm">/* program the stream LVI (last valid index) of the BDL */</span>
	<span class="n">azx_sd_writew</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_LVI</span><span class="p">,</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">frags</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* program the BDL address */</span>
	<span class="cm">/* lower BDL address */</span>
	<span class="n">azx_sd_writel</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_BDLPL</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">bdl</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
	<span class="cm">/* upper BDL address */</span>
	<span class="n">azx_sd_writel</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_BDLPU</span><span class="p">,</span> <span class="n">upper_32_bits</span><span class="p">(</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">bdl</span><span class="p">.</span><span class="n">addr</span><span class="p">));</span>

	<span class="cm">/* enable the position buffer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">position_fix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">POS_FIX_LPIB</span> <span class="o">||</span>
	    <span class="n">chip</span><span class="o">-&gt;</span><span class="n">position_fix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">POS_FIX_LPIB</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DPLBASE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ICH6_DPLBASE_ENABLE</span><span class="p">))</span>
			<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DPLBASE</span><span class="p">,</span>
				<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">posbuf</span><span class="p">.</span><span class="n">addr</span> <span class="o">|</span> <span class="n">ICH6_DPLBASE_ENABLE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* set the interrupt enable bits in the descriptor control register */</span>
	<span class="n">azx_sd_writel</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">,</span>
		      <span class="n">azx_sd_readl</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">)</span> <span class="o">|</span> <span class="n">SD_INT_MASK</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Probe the given codec address</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">probe_codec</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">AC_NODE_ROOT</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">AC_VERB_PARAMETERS</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">AC_PAR_VENDOR_ID</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">cmd_mutex</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">probing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">azx_send_cmd</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">azx_get_response</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">probing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">cmd_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">snd_printdd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;codec #%d probed OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">azx_attach_pcm_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">hda_pcm</span> <span class="o">*</span><span class="n">cpcm</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">azx_stop_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_bus_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">in_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">azx_stop_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="n">azx_init_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">azx_pcm</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">snd_pcm_suspend_all</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="p">);</span>
		<span class="n">snd_hda_suspend</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
		<span class="n">snd_hda_resume</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">in_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Codec initialization</span>
<span class="cm"> */</span>

<span class="cm">/* number of codec slots for each chipset: 0 = default slots (i.e. 4) */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">azx_max_codecs</span><span class="p">[</span><span class="n">AZX_NUM_DRIVERS</span><span class="p">]</span> <span class="n">DELAYED_INITDATA_MARK</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">AZX_DRIVER_NVIDIA</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="p">[</span><span class="n">AZX_DRIVER_TERA</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">DELAYED_INIT_MARK</span> <span class="nf">azx_codec_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_bus_template</span> <span class="n">bus_temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">codecs</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_slots</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus_temp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bus_temp</span><span class="p">));</span>
	<span class="n">bus_temp</span><span class="p">.</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">bus_temp</span><span class="p">.</span><span class="n">modelname</span> <span class="o">=</span> <span class="n">model</span><span class="p">;</span>
	<span class="n">bus_temp</span><span class="p">.</span><span class="n">pci</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">;</span>
	<span class="n">bus_temp</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">azx_send_cmd</span><span class="p">;</span>
	<span class="n">bus_temp</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_response</span> <span class="o">=</span> <span class="n">azx_get_response</span><span class="p">;</span>
	<span class="n">bus_temp</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">attach_pcm</span> <span class="o">=</span> <span class="n">azx_attach_pcm_stream</span><span class="p">;</span>
	<span class="n">bus_temp</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">bus_reset</span> <span class="o">=</span> <span class="n">azx_bus_reset</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SND_HDA_POWER_SAVE</span>
	<span class="n">bus_temp</span><span class="p">.</span><span class="n">power_save</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">power_save</span><span class="p">;</span>
	<span class="n">bus_temp</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">pm_notify</span> <span class="o">=</span> <span class="n">azx_power_notify</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_bus_new</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_RIRB_DELAY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;Enable delay in RIRB handling</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">needs_damn_long_delay</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">codecs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">max_slots</span> <span class="o">=</span> <span class="n">azx_max_codecs</span><span class="p">[</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_type</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_slots</span><span class="p">)</span>
		<span class="n">max_slots</span> <span class="o">=</span> <span class="n">AZX_DEFAULT_CODECS</span><span class="p">;</span>

	<span class="cm">/* First try to probe all given codec slots */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">max_slots</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_probe_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">probe_codec</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Some BIOSen give you wrong codec addresses</span>
<span class="cm">				 * that don&#39;t exist</span>
<span class="cm">				 */</span>
				<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">SFX</span>
					   <span class="s">&quot;Codec #%d probe error; &quot;</span>
					   <span class="s">&quot;disabling it...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">);</span>
				<span class="cm">/* More badly, accessing to a non-existing</span>
<span class="cm">				 * codec often screws up the controller chip,</span>
<span class="cm">				 * and disturbs the further communications.</span>
<span class="cm">				 * Thus if an error occurs during probing,</span>
<span class="cm">				 * better to reset the controller chip to</span>
<span class="cm">				 * get back to the sanity state.</span>
<span class="cm">				 */</span>
				<span class="n">azx_stop_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
				<span class="n">azx_init_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* AMD chipsets often cause the communication stalls upon certain</span>
<span class="cm">	 * sequence like the pin-detection.  It seems that forcing the synced</span>
<span class="cm">	 * access works around the stall.  Grrr...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_SYNC_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;Enable sync_write for stable communication</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">sync_write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">allow_bus_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Then create codec instances */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">max_slots</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_probe_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_codec_new</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">codec</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">codec</span><span class="o">-&gt;</span><span class="n">beep_mode</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">beep_mode</span><span class="p">;</span>
			<span class="n">codecs</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codecs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span> <span class="s">&quot;no codecs initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* configure each codec instance */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">azx_codec_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_hda_codec_configure</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * PCM support</span>
<span class="cm"> */</span>

<span class="cm">/* assign a stream for the PCM */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span>
<span class="nf">azx_assign_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nums</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* make a non-zero unique key for the substream */</span>
	<span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_index_offset</span><span class="p">;</span>
		<span class="n">nums</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_streams</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_index_offset</span><span class="p">;</span>
		<span class="n">nums</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_streams</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">dev</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">[</span><span class="n">dev</span><span class="p">].</span><span class="n">opened</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">[</span><span class="n">dev</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">assigned_key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">opened</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">assigned_key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* release the assigned stream */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">azx_release_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">opened</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_hardware</span> <span class="n">azx_pcm_hw</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span>			<span class="p">(</span><span class="n">SNDRV_PCM_INFO_MMAP</span> <span class="o">|</span>
				 <span class="n">SNDRV_PCM_INFO_INTERLEAVED</span> <span class="o">|</span>
				 <span class="n">SNDRV_PCM_INFO_BLOCK_TRANSFER</span> <span class="o">|</span>
				 <span class="n">SNDRV_PCM_INFO_MMAP_VALID</span> <span class="o">|</span>
				 <span class="cm">/* No full-resume yet implemented */</span>
				 <span class="cm">/* SNDRV_PCM_INFO_RESUME |*/</span>
				 <span class="n">SNDRV_PCM_INFO_PAUSE</span> <span class="o">|</span>
				 <span class="n">SNDRV_PCM_INFO_SYNC_START</span> <span class="o">|</span>
				 <span class="n">SNDRV_PCM_INFO_NO_PERIOD_WAKEUP</span><span class="p">),</span>
	<span class="p">.</span><span class="n">formats</span> <span class="o">=</span>		<span class="n">SNDRV_PCM_FMTBIT_S16_LE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rates</span> <span class="o">=</span>		<span class="n">SNDRV_PCM_RATE_48000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rate_min</span> <span class="o">=</span>		<span class="mi">48000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rate_max</span> <span class="o">=</span>		<span class="mi">48000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">channels_min</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">channels_max</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buffer_bytes_max</span> <span class="o">=</span>	<span class="n">AZX_MAX_BUF_SIZE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">period_bytes_min</span> <span class="o">=</span>	<span class="mi">128</span><span class="p">,</span>
	<span class="p">.</span><span class="n">period_bytes_max</span> <span class="o">=</span>	<span class="n">AZX_MAX_BUF_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">periods_min</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">periods_max</span> <span class="o">=</span>		<span class="n">AZX_MAX_FRAG</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fifo_size</span> <span class="o">=</span>		<span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_pcm_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx_pcm</span> <span class="o">*</span><span class="n">apcm</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">hinfo</span> <span class="o">=</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">hinfo</span><span class="p">[</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">buff_step</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>
	<span class="n">azx_dev</span> <span class="o">=</span> <span class="n">azx_assign_device</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">substream</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">azx_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span> <span class="o">=</span> <span class="n">azx_pcm_hw</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">channels_min</span> <span class="o">=</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">channels_min</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">channels_max</span> <span class="o">=</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">channels_max</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">formats</span> <span class="o">=</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">formats</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">rates</span> <span class="o">=</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">rates</span><span class="p">;</span>
	<span class="n">snd_pcm_limit_hw_rates</span><span class="p">(</span><span class="n">runtime</span><span class="p">);</span>
	<span class="n">snd_pcm_hw_constraint_integer</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_PERIODS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">align_buffer_size</span><span class="p">)</span>
		<span class="cm">/* constrain buffer sizes to be multiple of 128</span>
<span class="cm">		   bytes. This is more efficient in terms of memory</span>
<span class="cm">		   access but isn&#39;t required by the HDA spec and</span>
<span class="cm">		   prevents users from specifying exact period/buffer</span>
<span class="cm">		   sizes. For example for 44.1kHz, a period size set</span>
<span class="cm">		   to 20ms will be rounded to 19.59ms. */</span>
		<span class="n">buff_step</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/* Don&#39;t enforce steps on buffer sizes, still need to</span>
<span class="cm">		   be multiple of 4 bytes (HDA spec). Tested on Intel</span>
<span class="cm">		   HDA controllers, may not work on all devices where</span>
<span class="cm">		   option needs to be disabled */</span>
		<span class="n">buff_step</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">snd_pcm_hw_constraint_step</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_BUFFER_BYTES</span><span class="p">,</span>
				   <span class="n">buff_step</span><span class="p">);</span>
	<span class="n">snd_pcm_hw_constraint_step</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_PERIOD_BYTES</span><span class="p">,</span>
				   <span class="n">buff_step</span><span class="p">);</span>
	<span class="n">snd_hda_power_up_d3wait</span><span class="p">(</span><span class="n">apcm</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">hinfo</span><span class="p">,</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">,</span> <span class="n">substream</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">azx_release_device</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">);</span>
		<span class="n">snd_hda_power_down</span><span class="p">(</span><span class="n">apcm</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">snd_pcm_limit_hw_rates</span><span class="p">(</span><span class="n">runtime</span><span class="p">);</span>
	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">channels_min</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">channels_max</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">formats</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">rates</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">azx_release_device</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">);</span>
		<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="n">hinfo</span><span class="p">,</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">,</span> <span class="n">substream</span><span class="p">);</span>
		<span class="n">snd_hda_power_down</span><span class="p">(</span><span class="n">apcm</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">substream</span> <span class="o">=</span> <span class="n">substream</span><span class="p">;</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">azx_dev</span><span class="p">;</span>
	<span class="n">snd_pcm_set_sync</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_pcm_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx_pcm</span> <span class="o">*</span><span class="n">apcm</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">hinfo</span> <span class="o">=</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">hinfo</span><span class="p">[</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span> <span class="o">=</span> <span class="n">get_azx_dev</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">substream</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">azx_release_device</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">);</span>
	<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="n">hinfo</span><span class="p">,</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">,</span> <span class="n">substream</span><span class="p">);</span>
	<span class="n">snd_hda_power_down</span><span class="p">(</span><span class="n">apcm</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_pcm_hw_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">hw_params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx_pcm</span> <span class="o">*</span><span class="n">apcm</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span> <span class="o">=</span> <span class="n">get_azx_dev</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mark_runtime_wc</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">bufsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">format_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">snd_pcm_lib_malloc_pages</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span>
					<span class="n">params_buffer_bytes</span><span class="p">(</span><span class="n">hw_params</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mark_runtime_wc</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_pcm_hw_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx_pcm</span> <span class="o">*</span><span class="n">apcm</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span> <span class="o">=</span> <span class="n">get_azx_dev</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">hinfo</span> <span class="o">=</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">hinfo</span><span class="p">[</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">];</span>

	<span class="cm">/* reset BDL address */</span>
	<span class="n">azx_sd_writel</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_BDLPL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">azx_sd_writel</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_BDLPU</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">azx_sd_writel</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">bufsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">format_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">snd_hda_codec_cleanup</span><span class="p">(</span><span class="n">apcm</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">,</span> <span class="n">hinfo</span><span class="p">,</span> <span class="n">substream</span><span class="p">);</span>

	<span class="n">mark_runtime_wc</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snd_pcm_lib_free_pages</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_pcm_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx_pcm</span> <span class="o">*</span><span class="n">apcm</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span> <span class="o">=</span> <span class="n">get_azx_dev</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">hinfo</span> <span class="o">=</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">hinfo</span><span class="p">[</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">,</span> <span class="n">period_bytes</span><span class="p">,</span> <span class="n">format_val</span><span class="p">,</span> <span class="n">stream_tag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_spdif_out</span> <span class="o">*</span><span class="n">spdif</span> <span class="o">=</span>
		<span class="n">snd_hda_spdif_out_of_nid</span><span class="p">(</span><span class="n">apcm</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">,</span> <span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">nid</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ctls</span> <span class="o">=</span> <span class="n">spdif</span> <span class="o">?</span> <span class="n">spdif</span><span class="o">-&gt;</span><span class="n">ctls</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">azx_stream_reset</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">);</span>
	<span class="n">format_val</span> <span class="o">=</span> <span class="n">snd_hda_calc_stream_format</span><span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span>
						<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">,</span>
						<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">,</span>
						<span class="n">hinfo</span><span class="o">-&gt;</span><span class="n">maxbps</span><span class="p">,</span>
						<span class="n">ctls</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">format_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span>
			   <span class="s">&quot;invalid format_val, rate=%d, ch=%d, format=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">,</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bufsize</span> <span class="o">=</span> <span class="n">snd_pcm_lib_buffer_bytes</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="n">period_bytes</span> <span class="o">=</span> <span class="n">snd_pcm_lib_period_bytes</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>

	<span class="n">snd_printdd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;azx_pcm_prepare: bufsize=0x%x, format=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">bufsize</span><span class="p">,</span> <span class="n">format_val</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bufsize</span> <span class="o">!=</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">bufsize</span> <span class="o">||</span>
	    <span class="n">period_bytes</span> <span class="o">!=</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_bytes</span> <span class="o">||</span>
	    <span class="n">format_val</span> <span class="o">!=</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">format_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">bufsize</span> <span class="o">=</span> <span class="n">bufsize</span><span class="p">;</span>
		<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_bytes</span> <span class="o">=</span> <span class="n">period_bytes</span><span class="p">;</span>
		<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">format_val</span> <span class="o">=</span> <span class="n">format_val</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">azx_setup_periods</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">substream</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* wallclk has 24Mhz clock source */</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_wallclk</span> <span class="o">=</span> <span class="p">(((</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">period_size</span> <span class="o">*</span> <span class="mi">24000</span><span class="p">)</span> <span class="o">/</span>
						<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">azx_setup_controller</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">)</span>
		<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">fifo_size</span> <span class="o">=</span> <span class="n">azx_sd_readw</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_FIFOSIZE</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">fifo_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">stream_tag</span> <span class="o">=</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">stream_tag</span><span class="p">;</span>
	<span class="cm">/* CA-IBG chips need the playback stream starting from 1 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_CTX_WORKAROUND</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">stream_tag</span> <span class="o">&gt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_streams</span><span class="p">)</span>
		<span class="n">stream_tag</span> <span class="o">-=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_streams</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snd_hda_codec_prepare</span><span class="p">(</span><span class="n">apcm</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">,</span> <span class="n">hinfo</span><span class="p">,</span> <span class="n">stream_tag</span><span class="p">,</span>
				     <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">format_val</span><span class="p">,</span> <span class="n">substream</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_pcm_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx_pcm</span> <span class="o">*</span><span class="n">apcm</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rstart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">nsync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sbits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nwait</span><span class="p">,</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_START</span>:
		<span class="n">rstart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_PAUSE_RELEASE</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_RESUME</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_PAUSE_PUSH</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_SUSPEND</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_STOP</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">snd_pcm_group_for_each_entry</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substream</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">card</span> <span class="o">!=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">azx_dev</span> <span class="o">=</span> <span class="n">get_azx_dev</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">sbits</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="n">nsync</span><span class="o">++</span><span class="p">;</span>
		<span class="n">snd_pcm_trigger_done</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substream</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nsync</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* first, set SYNC bits of corresponding streams */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_OLD_SSYNC</span><span class="p">)</span>
			<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">OLD_SSYNC</span><span class="p">,</span>
				   <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">OLD_SSYNC</span><span class="p">)</span> <span class="o">|</span> <span class="n">sbits</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">SSYNC</span><span class="p">,</span> <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">SSYNC</span><span class="p">)</span> <span class="o">|</span> <span class="n">sbits</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">snd_pcm_group_for_each_entry</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substream</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">card</span> <span class="o">!=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">azx_dev</span> <span class="o">=</span> <span class="n">get_azx_dev</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">start_wallclk</span> <span class="o">=</span> <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">WALLCLK</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rstart</span><span class="p">)</span>
				<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">start_wallclk</span> <span class="o">-=</span>
						<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_wallclk</span><span class="p">;</span>
			<span class="n">azx_stream_start</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">azx_stream_stop</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsync</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* wait until all FIFOs get ready */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">timeout</span><span class="p">;</span> <span class="n">timeout</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nwait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">snd_pcm_group_for_each_entry</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substream</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">card</span> <span class="o">!=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">azx_dev</span> <span class="o">=</span> <span class="n">get_azx_dev</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">azx_sd_readb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_STS</span><span class="p">)</span> <span class="o">&amp;</span>
				      <span class="n">SD_STS_FIFO_READY</span><span class="p">))</span>
					<span class="n">nwait</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nwait</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* wait until all RUN bits are cleared */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">timeout</span><span class="p">;</span> <span class="n">timeout</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nwait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">snd_pcm_group_for_each_entry</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substream</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">card</span> <span class="o">!=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">azx_dev</span> <span class="o">=</span> <span class="n">get_azx_dev</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">azx_sd_readb</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_CTL</span><span class="p">)</span> <span class="o">&amp;</span>
				    <span class="n">SD_CTL_DMA_START</span><span class="p">)</span>
					<span class="n">nwait</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nwait</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nsync</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="cm">/* reset SYNC bits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_OLD_SSYNC</span><span class="p">)</span>
			<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">OLD_SSYNC</span><span class="p">,</span>
				   <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">OLD_SSYNC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">sbits</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">SSYNC</span><span class="p">,</span> <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">SSYNC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">sbits</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* get the current DMA position with correction on VIA chips */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">azx_via_get_position</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">link_pos</span><span class="p">,</span> <span class="n">mini_pos</span><span class="p">,</span> <span class="n">bound_pos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mod_link_pos</span><span class="p">,</span> <span class="n">mod_dma_pos</span><span class="p">,</span> <span class="n">mod_mini_pos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fifo_size</span><span class="p">;</span>

	<span class="n">link_pos</span> <span class="o">=</span> <span class="n">azx_sd_readl</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_LPIB</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Playback, no problem using link position */</span>
		<span class="k">return</span> <span class="n">link_pos</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Capture */</span>
	<span class="cm">/* For new chipset,</span>
<span class="cm">	 * use mod to get the DMA position just like old chipset</span>
<span class="cm">	 */</span>
	<span class="n">mod_dma_pos</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">posbuf</span><span class="p">);</span>
	<span class="n">mod_dma_pos</span> <span class="o">%=</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_bytes</span><span class="p">;</span>

	<span class="cm">/* azx_dev-&gt;fifo_size can&#39;t get FIFO size of in stream.</span>
<span class="cm">	 * Get from base address + offset.</span>
<span class="cm">	 */</span>
	<span class="n">fifo_size</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">remap_addr</span> <span class="o">+</span> <span class="n">VIA_IN_STREAM0_FIFO_SIZE_OFFSET</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">insufficient</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Link position never gather than FIFO size */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">link_pos</span> <span class="o">&lt;=</span> <span class="n">fifo_size</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">insufficient</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link_pos</span> <span class="o">&lt;=</span> <span class="n">fifo_size</span><span class="p">)</span>
		<span class="n">mini_pos</span> <span class="o">=</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">bufsize</span> <span class="o">+</span> <span class="n">link_pos</span> <span class="o">-</span> <span class="n">fifo_size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mini_pos</span> <span class="o">=</span> <span class="n">link_pos</span> <span class="o">-</span> <span class="n">fifo_size</span><span class="p">;</span>

	<span class="cm">/* Find nearest previous boudary */</span>
	<span class="n">mod_mini_pos</span> <span class="o">=</span> <span class="n">mini_pos</span> <span class="o">%</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_bytes</span><span class="p">;</span>
	<span class="n">mod_link_pos</span> <span class="o">=</span> <span class="n">link_pos</span> <span class="o">%</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_bytes</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod_link_pos</span> <span class="o">&gt;=</span> <span class="n">fifo_size</span><span class="p">)</span>
		<span class="n">bound_pos</span> <span class="o">=</span> <span class="n">link_pos</span> <span class="o">-</span> <span class="n">mod_link_pos</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mod_dma_pos</span> <span class="o">&gt;=</span> <span class="n">mod_mini_pos</span><span class="p">)</span>
		<span class="n">bound_pos</span> <span class="o">=</span> <span class="n">mini_pos</span> <span class="o">-</span> <span class="n">mod_mini_pos</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">bound_pos</span> <span class="o">=</span> <span class="n">mini_pos</span> <span class="o">-</span> <span class="n">mod_mini_pos</span> <span class="o">+</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_bytes</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bound_pos</span> <span class="o">&gt;=</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">bufsize</span><span class="p">)</span>
			<span class="n">bound_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate real DMA position we want */</span>
	<span class="k">return</span> <span class="n">bound_pos</span> <span class="o">+</span> <span class="n">mod_dma_pos</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">azx_get_position</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">,</span>
				     <span class="n">bool</span> <span class="n">with_check</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">position_fix</span><span class="p">[</span><span class="n">stream</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">POS_FIX_LPIB</span>:
		<span class="cm">/* read LPIB */</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">azx_sd_readl</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_LPIB</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">POS_FIX_VIACOMBO</span>:
		<span class="n">pos</span> <span class="o">=</span> <span class="n">azx_via_get_position</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* use the position buffer */</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">posbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">with_check</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">position_fix</span><span class="p">[</span><span class="n">stream</span><span class="p">]</span> <span class="o">==</span> <span class="n">POS_FIX_AUTO</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">==</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				       <span class="s">&quot;hda-intel: Invalid position buffer, &quot;</span>
				       <span class="s">&quot;using LPIB read method instead.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">position_fix</span><span class="p">[</span><span class="n">stream</span><span class="p">]</span> <span class="o">=</span> <span class="n">POS_FIX_LPIB</span><span class="p">;</span>
				<span class="n">pos</span> <span class="o">=</span> <span class="n">azx_sd_readl</span><span class="p">(</span><span class="n">azx_dev</span><span class="p">,</span> <span class="n">SD_LPIB</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">position_fix</span><span class="p">[</span><span class="n">stream</span><span class="p">]</span> <span class="o">=</span> <span class="n">POS_FIX_POSBUF</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">bufsize</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">snd_pcm_uframes_t</span> <span class="nf">azx_pcm_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx_pcm</span> <span class="o">*</span><span class="n">apcm</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span> <span class="o">=</span> <span class="n">get_azx_dev</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bytes_to_frames</span><span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">,</span>
			       <span class="n">azx_get_position</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check whether the current DMA position is acceptable for updating</span>
<span class="cm"> * periods.  Returns non-zero if it&#39;s OK.</span>
<span class="cm"> *</span>
<span class="cm"> * Many HD-audio controllers appear pretty inaccurate about</span>
<span class="cm"> * the update-IRQ timing.  The IRQ is issued before actually the</span>
<span class="cm"> * data is processed.  So, we need to process it afterwords in a</span>
<span class="cm"> * workqueue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_position_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">wallclk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stream</span><span class="p">;</span>

	<span class="n">wallclk</span> <span class="o">=</span> <span class="n">azx_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">WALLCLK</span><span class="p">)</span> <span class="o">-</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">start_wallclk</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wallclk</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_wallclk</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* bogus (too early) interrupt */</span>

	<span class="n">stream</span> <span class="o">=</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">;</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">azx_get_position</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_bytes</span><span class="p">,</span>
		      <span class="s">&quot;hda-intel: zero azx_dev-&gt;period_bytes&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* this shouldn&#39;t happen! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wallclk</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_wallclk</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span>
	    <span class="n">pos</span> <span class="o">%</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_bytes</span> <span class="o">&gt;</span> <span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">period_bytes</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
		<span class="cm">/* NG - it&#39;s below the first next period boundary */</span>
		<span class="k">return</span> <span class="n">bdl_pos_adj</span><span class="p">[</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">dev_index</span><span class="p">]</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">start_wallclk</span> <span class="o">+=</span> <span class="n">wallclk</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* OK, it&#39;s fine */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The work for pending PCM period updates.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_irq_pending_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">azx</span><span class="p">,</span> <span class="n">irq_pending_work</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">pending</span><span class="p">,</span> <span class="n">ok</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_pending_warned</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;hda-intel: IRQ timing workaround is activated &quot;</span>
		       <span class="s">&quot;for card #%d. Suggest a bigger bdl_pos_adj.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_pending_warned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">num_streams</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">irq_pending</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">substream</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">ok</span> <span class="o">=</span> <span class="n">azx_position_ok</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">azx_dev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ok</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">irq_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
				<span class="n">snd_pcm_period_elapsed</span><span class="p">(</span><span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">);</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ok</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* too early */</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">pending</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pending</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* clear irq_pending flags and assure no on-going workq */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_clear_irq_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">num_streams</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">irq_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_X86</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_pcm_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">area</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx_pcm</span> <span class="o">*</span><span class="n">apcm</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">apcm</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">azx_snoop</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
		<span class="n">area</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">pgprot_writecombine</span><span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snd_pcm_lib_default_mmap</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span> <span class="n">area</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define azx_pcm_mmap	NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_ops</span> <span class="n">azx_pcm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">azx_pcm_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span> <span class="n">azx_pcm_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span> <span class="n">snd_pcm_lib_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_params</span> <span class="o">=</span> <span class="n">azx_pcm_hw_params</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_free</span> <span class="o">=</span> <span class="n">azx_pcm_hw_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare</span> <span class="o">=</span> <span class="n">azx_pcm_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="n">azx_pcm_trigger</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pointer</span> <span class="o">=</span> <span class="n">azx_pcm_pointer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">azx_pcm_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="n">snd_pcm_sgbuf_ops_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_pcm_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm</span> <span class="o">*</span><span class="n">pcm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx_pcm</span> <span class="o">*</span><span class="n">apcm</span> <span class="o">=</span> <span class="n">pcm</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apcm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apcm</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">apcm</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define MAX_PREALLOC_SIZE	(32 * 1024 * 1024)</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">azx_attach_pcm_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">hda_pcm</span> <span class="o">*</span><span class="n">cpcm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm</span> <span class="o">*</span><span class="n">pcm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">azx_pcm</span> <span class="o">*</span><span class="n">apcm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pcm_dev</span> <span class="o">=</span> <span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">apcm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">apcm</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">pcm_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span> <span class="s">&quot;PCM %d already exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcm_dev</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_pcm_new</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pcm_dev</span><span class="p">,</span>
			  <span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">].</span><span class="n">substreams</span><span class="p">,</span>
			  <span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">].</span><span class="n">substreams</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">pcm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
	<span class="n">apcm</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">apcm</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apcm</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">apcm</span><span class="o">-&gt;</span><span class="n">chip</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">apcm</span><span class="o">-&gt;</span><span class="n">pcm</span> <span class="o">=</span> <span class="n">pcm</span><span class="p">;</span>
	<span class="n">apcm</span><span class="o">-&gt;</span><span class="n">codec</span> <span class="o">=</span> <span class="n">codec</span><span class="p">;</span>
	<span class="n">pcm</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">apcm</span><span class="p">;</span>
	<span class="n">pcm</span><span class="o">-&gt;</span><span class="n">private_free</span> <span class="o">=</span> <span class="n">azx_pcm_free</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">pcm_type</span> <span class="o">==</span> <span class="n">HDA_PCM_TYPE_MODEM</span><span class="p">)</span>
		<span class="n">pcm</span><span class="o">-&gt;</span><span class="n">dev_class</span> <span class="o">=</span> <span class="n">SNDRV_PCM_CLASS_MODEM</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">apcm</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm_list</span><span class="p">);</span>
	<span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">pcm</span> <span class="o">=</span> <span class="n">pcm</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">apcm</span><span class="o">-&gt;</span><span class="n">hinfo</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpcm</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">substreams</span><span class="p">)</span>
			<span class="n">snd_pcm_set_ops</span><span class="p">(</span><span class="n">pcm</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">azx_pcm_ops</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* buffer pre-allocation */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">CONFIG_SND_HDA_PREALLOC_SIZE</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">MAX_PREALLOC_SIZE</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">MAX_PREALLOC_SIZE</span><span class="p">;</span>
	<span class="n">snd_pcm_lib_preallocate_pages_for_all</span><span class="p">(</span><span class="n">pcm</span><span class="p">,</span> <span class="n">SNDRV_DMA_TYPE_DEV_SG</span><span class="p">,</span>
					      <span class="n">snd_dma_pci_data</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">),</span>
					      <span class="n">size</span><span class="p">,</span> <span class="n">MAX_PREALLOC_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mixer creation - all stuff is implemented in hda module</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">azx_mixer_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snd_hda_build_controls</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * initialize SD streams</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">azx_init_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* initialize each stream (aka device)</span>
<span class="cm">	 * assign the starting bdl address to each stream (device)</span>
<span class="cm">	 * and initialize</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">num_streams</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">azx_dev</span> <span class="o">*</span><span class="n">azx_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">posbuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">posbuf</span><span class="p">.</span><span class="n">area</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
		<span class="cm">/* offset: SDI0=0x80, SDI1=0xa0, ... SDO3=0x160 */</span>
		<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">sd_addr</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">remap_addr</span> <span class="o">+</span> <span class="p">(</span><span class="mh">0x20</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mh">0x80</span><span class="p">);</span>
		<span class="cm">/* int mask: SDI0=0x01, SDI1=0x02, ... SDO3=0x80 */</span>
		<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">sd_int_sta_mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/* stream tag: must be non-zero and unique */</span>
		<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">azx_dev</span><span class="o">-&gt;</span><span class="n">stream_tag</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_acquire_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">do_disconnect</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">azx_interrupt</span><span class="p">,</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">msi</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			<span class="n">KBUILD_MODNAME</span><span class="p">,</span> <span class="n">chip</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda-intel: unable to grab IRQ %d, &quot;</span>
		       <span class="s">&quot;disabling device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_disconnect</span><span class="p">)</span>
			<span class="n">snd_card_disconnect</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">pci_intx</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">msi</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_stop_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">initialized</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* disable interrupts */</span>
	<span class="n">azx_int_disable</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="n">azx_int_clear</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* disable CORB/RIRB */</span>
	<span class="n">azx_free_cmd_io</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* disable position buffer */</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DPLBASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">azx_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DPUBASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">initialized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SND_HDA_POWER_SAVE</span>
<span class="cm">/* power-up/down the controller */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_power_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">power_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">power_on</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">power_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">power_on</span><span class="p">)</span>
		<span class="n">azx_init_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">&amp;&amp;</span> <span class="n">power_save_controller</span> <span class="o">&amp;&amp;</span>
		 <span class="o">!</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">power_keep_link_on</span><span class="p">)</span>
		<span class="n">azx_stop_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SND_HDA_POWER_SAVE */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/*</span>
<span class="cm"> * power management</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">azx_pcm</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">snd_power_change_state</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">SNDRV_CTL_POWER_D3hot</span><span class="p">);</span>
	<span class="n">azx_clear_irq_pending</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">snd_pcm_suspend_all</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">initialized</span><span class="p">)</span>
		<span class="n">snd_hda_suspend</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">azx_stop_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">msi</span><span class="p">)</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pci</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;hda-intel: pci_enable_device failed, &quot;</span>
		       <span class="s">&quot;disabling device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">snd_card_disconnect</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">msi</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">pci</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">msi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">azx_acquire_irq</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">azx_init_pci</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="n">azx_init_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">snd_hda_resume</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">snd_power_change_state</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">SNDRV_CTL_POWER_D0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * reboot notifier for hang-up problem at power-down</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">azx</span><span class="p">,</span> <span class="n">reboot_notifier</span><span class="p">);</span>
	<span class="n">snd_hda_bus_reboot_notify</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">azx_stop_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_notifier_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">reboot_notifier</span><span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">azx_halt</span><span class="p">;</span>
	<span class="n">register_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reboot_notifier</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_notifier_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reboot_notifier</span><span class="p">.</span><span class="n">notifier_call</span><span class="p">)</span>
		<span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reboot_notifier</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">DELAYED_INIT_MARK</span> <span class="n">azx_first_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">DELAYED_INIT_MARK</span> <span class="n">azx_probe_continue</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>

<span class="cp">#ifdef SUPPORT_VGA_SWITCHEROO</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="n">__devinit</span> <span class="o">*</span><span class="n">get_bound_vga</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">azx_vs_set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">vga_switcheroo_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">disabled</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">init_failed</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">disabled</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">VGA_SWITCHEROO_OFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">disabled</span> <span class="o">==</span> <span class="n">disabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">disabled</span> <span class="o">=</span> <span class="n">disabled</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">SFX</span>
				   <span class="s">&quot;%s: Start delayed initialization</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">pci_name</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">azx_first_init</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
			    <span class="n">azx_probe_continue</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span>
					   <span class="s">&quot;%s: initialization error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">pci_name</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">));</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">init_failed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">SFX</span>
			   <span class="s">&quot;%s %s via VGA-switcheroo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">disabled</span> <span class="o">?</span> <span class="s">&quot;Disabling&quot;</span> <span class="o">:</span> <span class="s">&quot;Enabling&quot;</span><span class="p">,</span>
			   <span class="n">pci_name</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">disabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">azx_suspend</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">PMSG_FREEZE</span><span class="p">);</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">disabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">snd_hda_lock_devices</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">snd_hda_unlock_devices</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">disabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">azx_resume</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">azx_vs_can_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">init_failed</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">disabled</span> <span class="o">||</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_hda_lock_devices</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">snd_hda_unlock_devices</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">init_vga_switcheroo</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">get_bound_vga</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">SFX</span>
			   <span class="s">&quot;%s: Handle VGA-switcheroo audio client</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">pci_name</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">));</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">use_vga_switcheroo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vga_switcheroo_client_ops</span> <span class="n">azx_vs_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">set_gpu_state</span> <span class="o">=</span> <span class="n">azx_vs_set_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_switch</span> <span class="o">=</span> <span class="n">azx_vs_can_switch</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">register_vga_switcheroo</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">use_vga_switcheroo</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* FIXME: currently only handling DIS controller</span>
<span class="cm">	 * is there any machine with two switchable HDMI audio controllers?</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">vga_switcheroo_register_audio_client</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">azx_vs_ops</span><span class="p">,</span>
						    <span class="n">VGA_SWITCHEROO_DIS</span><span class="p">,</span>
						    <span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define init_vga_switcheroo(chip)		</span><span class="cm">/* NOP */</span><span class="cp"></span>
<span class="cp">#define register_vga_switcheroo(chip)		0</span>
<span class="cp">#define check_hdmi_disabled(pci)	false</span>
<span class="cp">#endif </span><span class="cm">/* SUPPORT_VGA_SWITCHER */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * destructor</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">azx_notifier_unregister</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_vga_switcheroo</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">disabled</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span>
			<span class="n">snd_hda_unlock_devices</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
		<span class="n">vga_switcheroo_unregister_client</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">azx_clear_irq_pending</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">num_streams</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">azx_stream_stop</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">azx_stop_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">msi</span><span class="p">)</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">remap_addr</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">remap_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">num_streams</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bdl</span><span class="p">.</span><span class="n">area</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mark_pages_wc</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bdl</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
				<span class="n">snd_dma_free_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bdl</span><span class="p">);</span>
			<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">area</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mark_pages_wc</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">snd_dma_free_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">posbuf</span><span class="p">.</span><span class="n">area</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mark_pages_wc</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">posbuf</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">snd_dma_free_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">posbuf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">region_requested</span><span class="p">)</span>
		<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">azx_dev_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">azx_free</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">device_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef SUPPORT_VGA_SWITCHEROO</span>
<span class="cm">/*</span>
<span class="cm"> * Check of disabled HDMI controller by vga-switcheroo</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="n">__devinit</span> <span class="o">*</span><span class="nf">get_bound_vga</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/* check only discrete GPU */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_VENDOR_ID_ATI</span>:
	<span class="k">case</span> <span class="n">PCI_VENDOR_ID_AMD</span>:
	<span class="k">case</span> <span class="n">PCI_VENDOR_ID_NVIDIA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">pci_get_domain_bus_and_slot</span><span class="p">(</span><span class="n">pci_domain_nr</span><span class="p">(</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">),</span>
							<span class="n">pci</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCI_CLASS_DISPLAY_VGA</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
				<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__devinit</span> <span class="nf">check_hdmi_disabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">vga_inactive</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">get_bound_vga</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vga_switcheroo_get_client_state</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">VGA_SWITCHEROO_OFF</span><span class="p">)</span>
			<span class="n">vga_inactive</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">vga_inactive</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* SUPPORT_VGA_SWITCHEROO */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * white/black-listing for position_fix</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pci_quirk</span> <span class="n">position_fix_list</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1028</span><span class="p">,</span> <span class="mh">0x01cc</span><span class="p">,</span> <span class="s">&quot;Dell D820&quot;</span><span class="p">,</span> <span class="n">POS_FIX_LPIB</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1028</span><span class="p">,</span> <span class="mh">0x01de</span><span class="p">,</span> <span class="s">&quot;Dell Precision 390&quot;</span><span class="p">,</span> <span class="n">POS_FIX_LPIB</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x103c</span><span class="p">,</span> <span class="mh">0x306d</span><span class="p">,</span> <span class="s">&quot;HP dv3&quot;</span><span class="p">,</span> <span class="n">POS_FIX_LPIB</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1043</span><span class="p">,</span> <span class="mh">0x813d</span><span class="p">,</span> <span class="s">&quot;ASUS P5AD2&quot;</span><span class="p">,</span> <span class="n">POS_FIX_LPIB</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1043</span><span class="p">,</span> <span class="mh">0x81b3</span><span class="p">,</span> <span class="s">&quot;ASUS&quot;</span><span class="p">,</span> <span class="n">POS_FIX_LPIB</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1043</span><span class="p">,</span> <span class="mh">0x81e7</span><span class="p">,</span> <span class="s">&quot;ASUS M2V&quot;</span><span class="p">,</span> <span class="n">POS_FIX_LPIB</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x104d</span><span class="p">,</span> <span class="mh">0x9069</span><span class="p">,</span> <span class="s">&quot;Sony VPCS11V9E&quot;</span><span class="p">,</span> <span class="n">POS_FIX_LPIB</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x10de</span><span class="p">,</span> <span class="mh">0xcb89</span><span class="p">,</span> <span class="s">&quot;Macbook Pro 7,1&quot;</span><span class="p">,</span> <span class="n">POS_FIX_LPIB</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1297</span><span class="p">,</span> <span class="mh">0x3166</span><span class="p">,</span> <span class="s">&quot;Shuttle&quot;</span><span class="p">,</span> <span class="n">POS_FIX_LPIB</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1458</span><span class="p">,</span> <span class="mh">0xa022</span><span class="p">,</span> <span class="s">&quot;ga-ma770-ud3&quot;</span><span class="p">,</span> <span class="n">POS_FIX_LPIB</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1462</span><span class="p">,</span> <span class="mh">0x1002</span><span class="p">,</span> <span class="s">&quot;MSI Wind U115&quot;</span><span class="p">,</span> <span class="n">POS_FIX_LPIB</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1565</span><span class="p">,</span> <span class="mh">0x8218</span><span class="p">,</span> <span class="s">&quot;Biostar Microtech&quot;</span><span class="p">,</span> <span class="n">POS_FIX_LPIB</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1849</span><span class="p">,</span> <span class="mh">0x0888</span><span class="p">,</span> <span class="s">&quot;775Dual-VSTA&quot;</span><span class="p">,</span> <span class="n">POS_FIX_LPIB</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x2503</span><span class="p">,</span> <span class="s">&quot;DG965OT AAD63733-203&quot;</span><span class="p">,</span> <span class="n">POS_FIX_LPIB</span><span class="p">),</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">check_position_fix</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fix</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_pci_quirk</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">fix</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">POS_FIX_LPIB</span>:
	<span class="k">case</span> <span class="n">POS_FIX_POSBUF</span>:
	<span class="k">case</span> <span class="n">POS_FIX_VIACOMBO</span>:
	<span class="k">case</span> <span class="n">POS_FIX_COMBO</span>:
		<span class="k">return</span> <span class="n">fix</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">q</span> <span class="o">=</span> <span class="n">snd_pci_quirk_lookup</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span> <span class="n">position_fix_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;hda_intel: position_fix set to %d &quot;</span>
		       <span class="s">&quot;for device %04x:%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">q</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">subvendor</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">subdevice</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check VIA/ATI HD Audio Controller exist */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_POSFIX_VIA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;Using VIACOMBO position fix</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">POS_FIX_VIACOMBO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_POSFIX_LPIB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;Using LPIB position fix</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">POS_FIX_LPIB</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">POS_FIX_AUTO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * black-lists for probe_mask</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pci_quirk</span> <span class="n">probe_mask_list</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* Thinkpad often breaks the controller communication when accessing</span>
<span class="cm">	 * to the non-working (or non-existing) modem codec slot.</span>
<span class="cm">	 */</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1014</span><span class="p">,</span> <span class="mh">0x05b7</span><span class="p">,</span> <span class="s">&quot;Thinkpad Z60&quot;</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x17aa</span><span class="p">,</span> <span class="mh">0x2010</span><span class="p">,</span> <span class="s">&quot;Thinkpad X/T/R60&quot;</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x17aa</span><span class="p">,</span> <span class="mh">0x20ac</span><span class="p">,</span> <span class="s">&quot;Thinkpad X/T/R61&quot;</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">),</span>
	<span class="cm">/* broken BIOS */</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1028</span><span class="p">,</span> <span class="mh">0x20ac</span><span class="p">,</span> <span class="s">&quot;Dell Studio Desktop&quot;</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">),</span>
	<span class="cm">/* including bogus ALC268 in slot#2 that conflicts with ALC888 */</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x17c0</span><span class="p">,</span> <span class="mh">0x4085</span><span class="p">,</span> <span class="s">&quot;Medion MD96630&quot;</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">),</span>
	<span class="cm">/* forced codec slots */</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1043</span><span class="p">,</span> <span class="mh">0x1262</span><span class="p">,</span> <span class="s">&quot;ASUS W5Fm&quot;</span><span class="p">,</span> <span class="mh">0x103</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1046</span><span class="p">,</span> <span class="mh">0x1262</span><span class="p">,</span> <span class="s">&quot;ASUS W5F&quot;</span><span class="p">,</span> <span class="mh">0x103</span><span class="p">),</span>
	<span class="cm">/* WinFast VP200 H (Teradici) user reported broken communication */</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x3a21</span><span class="p">,</span> <span class="mh">0x040d</span><span class="p">,</span> <span class="s">&quot;WinFast VP200 H&quot;</span><span class="p">,</span> <span class="mh">0x101</span><span class="p">),</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="cp">#define AZX_FORCE_CODEC_MASK	0x100</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">check_probe_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_pci_quirk</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_probe_mask</span> <span class="o">=</span> <span class="n">probe_mask</span><span class="p">[</span><span class="n">dev</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_probe_mask</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">snd_pci_quirk_lookup</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span> <span class="n">probe_mask_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;hda_intel: probe_mask set to 0x%x &quot;</span>
			       <span class="s">&quot;for device %04x:%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">q</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">subvendor</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">subdevice</span><span class="p">);</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_probe_mask</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* check forced option */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_probe_mask</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_probe_mask</span> <span class="o">&amp;</span> <span class="n">AZX_FORCE_CODEC_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_mask</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_probe_mask</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;hda_intel: codec_mask forced to 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_mask</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * white/black-list for enable_msi</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pci_quirk</span> <span class="n">msi_black_list</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1043</span><span class="p">,</span> <span class="mh">0x81f2</span><span class="p">,</span> <span class="s">&quot;ASUS&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* Athlon64 X2 + nvidia */</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1043</span><span class="p">,</span> <span class="mh">0x81f6</span><span class="p">,</span> <span class="s">&quot;ASUS&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* nvidia */</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1043</span><span class="p">,</span> <span class="mh">0x822d</span><span class="p">,</span> <span class="s">&quot;ASUS&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* Athlon64 X2 + nvidia MCP55 */</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1849</span><span class="p">,</span> <span class="mh">0x0888</span><span class="p">,</span> <span class="s">&quot;ASRock&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* Athlon64 X2 + nvidia */</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0xa0a0</span><span class="p">,</span> <span class="mh">0x0575</span><span class="p">,</span> <span class="s">&quot;Aopen MZ915-M&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* ICH6 */</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">check_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_pci_quirk</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_msi</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">msi</span> <span class="o">=</span> <span class="o">!!</span><span class="n">enable_msi</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">msi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* enable MSI as default */</span>
	<span class="n">q</span> <span class="o">=</span> <span class="n">snd_pci_quirk_lookup</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span> <span class="n">msi_black_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;hda_intel: msi for device %04x:%04x set to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">q</span><span class="o">-&gt;</span><span class="n">subvendor</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">subdevice</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">msi</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* NVidia chipsets seem to cause troubles with MSI */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_NO_MSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;hda_intel: Disabling MSI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">msi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* check the snoop mode availability */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">azx_check_snoop_available</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">snoop</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">snoop</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AZX_DRIVER_VIA</span>:
		<span class="cm">/* force to non-snoop mode for a new VIA controller</span>
<span class="cm">		 * when BIOS is set</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">snoop</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">val</span><span class="p">;</span>
			<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">==</span> <span class="mh">0x30</span><span class="p">)</span>
				<span class="n">snoop</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AZX_DRIVER_ATIHDMI_NS</span>:
		<span class="cm">/* new ATI HDMI requires non-snoop */</span>
		<span class="n">snoop</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snoop</span> <span class="o">!=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">snoop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">SFX</span> <span class="s">&quot;Force to %s mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">snoop</span> <span class="o">?</span> <span class="s">&quot;snoop&quot;</span> <span class="o">:</span> <span class="s">&quot;non-snoop&quot;</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">snoop</span> <span class="o">=</span> <span class="n">snoop</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * constructor</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">azx_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">driver_caps</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">azx</span> <span class="o">**</span><span class="n">rchip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_device_ops</span> <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">dev_free</span> <span class="o">=</span> <span class="n">azx_dev_free</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="o">*</span><span class="n">rchip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">chip</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chip</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span> <span class="s">&quot;cannot allocate chip</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span> <span class="o">=</span> <span class="n">card</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span> <span class="o">=</span> <span class="n">pci</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">=</span> <span class="n">driver_caps</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_type</span> <span class="o">=</span> <span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">check_msi</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dev_index</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_pending_work</span><span class="p">,</span> <span class="n">azx_irq_pending_work</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm_list</span><span class="p">);</span>
	<span class="n">init_vga_switcheroo</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">position_fix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">position_fix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">check_position_fix</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">position_fix</span><span class="p">[</span><span class="n">dev</span><span class="p">]);</span>
	<span class="cm">/* combo mode uses LPIB for playback */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">position_fix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">POS_FIX_COMBO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">position_fix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">POS_FIX_LPIB</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">position_fix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">POS_FIX_AUTO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">check_probe_mask</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">single_cmd</span> <span class="o">=</span> <span class="n">single_cmd</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">snoop</span> <span class="o">=</span> <span class="n">hda_snoop</span><span class="p">;</span>
	<span class="n">azx_check_snoop_available</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bdl_pos_adj</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AZX_DRIVER_ICH</span>:
		<span class="k">case</span> <span class="n">AZX_DRIVER_PCH</span>:
			<span class="n">bdl_pos_adj</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">bdl_pos_adj</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_hdmi_disabled</span><span class="p">(</span><span class="n">pci</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">SFX</span> <span class="s">&quot;VGA controller for %s is disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">pci_name</span><span class="p">(</span><span class="n">pci</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">use_vga_switcheroo</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">SFX</span> <span class="s">&quot;Delaying initialization</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">disabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">ok</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">azx_first_init</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">azx_free</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">ok:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_vga_switcheroo</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span>
			   <span class="s">&quot;Error registering VGA-switcheroo client</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">azx_free</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_device_new</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">SNDRV_DEV_LOWLEVEL</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span> <span class="s">&quot;Error creating device [card]!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">azx_free</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">rchip</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">DELAYED_INIT_MARK</span> <span class="nf">azx_first_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">dev_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">gcap</span><span class="p">;</span>

<span class="cp">#if BITS_PER_LONG != 64</span>
	<span class="cm">/* Fix up base address on ULI M5461 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_type</span> <span class="o">==</span> <span class="n">AZX_DRIVER_ULI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">tmp3</span><span class="p">;</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp3</span><span class="p">);</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="n">tmp3</span> <span class="o">|</span> <span class="mh">0x10</span><span class="p">);</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">PCI_BASE_ADDRESS_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="s">&quot;ICH HD audio&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">region_requested</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">remap_addr</span> <span class="o">=</span> <span class="n">pci_ioremap_bar</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">remap_addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span> <span class="s">&quot;ioremap error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">msi</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">pci</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">msi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">azx_acquire_irq</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">gcap</span> <span class="o">=</span> <span class="n">azx_readw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">GCAP</span><span class="p">);</span>
	<span class="n">snd_printdd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;chipset global capabilities = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gcap</span><span class="p">);</span>

	<span class="cm">/* disable SB600 64bit support for safety */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_ATI</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">p_smbus</span><span class="p">;</span>
		<span class="n">p_smbus</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span>
					 <span class="n">PCI_DEVICE_ID_ATI_SBX00_SMBUS</span><span class="p">,</span>
					 <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p_smbus</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p_smbus</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="mh">0x30</span><span class="p">)</span>
				<span class="n">gcap</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ICH6_GCAP_64OK</span><span class="p">;</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">p_smbus</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* disable 64bit DMA address on some devices */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_NO_64BIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">SFX</span> <span class="s">&quot;Disabling 64bit DMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">gcap</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ICH6_GCAP_64OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* disable buffer size rounding to 128-byte multiples if supported */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">align_buffer_size</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">align_buffer_size</span> <span class="o">=</span> <span class="o">!!</span><span class="n">align_buffer_size</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_BUFSIZE</span><span class="p">)</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">align_buffer_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_caps</span> <span class="o">&amp;</span> <span class="n">AZX_DCAPS_ALIGN_BUFSIZE</span><span class="p">)</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">align_buffer_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">align_buffer_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allow 64bit DMA address if supported by H/W */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">gcap</span> <span class="o">&amp;</span> <span class="n">ICH6_GCAP_64OK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">)))</span>
		<span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* read number of streams from GCAP register instead of using</span>
<span class="cm">	 * hardcoded value</span>
<span class="cm">	 */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_streams</span> <span class="o">=</span> <span class="p">(</span><span class="n">gcap</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_streams</span> <span class="o">=</span> <span class="p">(</span><span class="n">gcap</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_streams</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_streams</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* gcap didn&#39;t give any info, switching to old method */</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AZX_DRIVER_ULI</span>:
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_streams</span> <span class="o">=</span> <span class="n">ULI_NUM_PLAYBACK</span><span class="p">;</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_streams</span> <span class="o">=</span> <span class="n">ULI_NUM_CAPTURE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AZX_DRIVER_ATIHDMI</span>:
		<span class="k">case</span> <span class="n">AZX_DRIVER_ATIHDMI_NS</span>:
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_streams</span> <span class="o">=</span> <span class="n">ATIHDMI_NUM_PLAYBACK</span><span class="p">;</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_streams</span> <span class="o">=</span> <span class="n">ATIHDMI_NUM_CAPTURE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AZX_DRIVER_GENERIC</span>:
		<span class="nl">default:</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_streams</span> <span class="o">=</span> <span class="n">ICH6_NUM_PLAYBACK</span><span class="p">;</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_streams</span> <span class="o">=</span> <span class="n">ICH6_NUM_CAPTURE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_index_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_index_offset</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_streams</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">num_streams</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_streams</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_streams</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">num_streams</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">),</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span> <span class="s">&quot;cannot malloc azx_dev</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">num_streams</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* allocate memory for the BDL for each stream */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">snd_dma_alloc_pages</span><span class="p">(</span><span class="n">SNDRV_DMA_TYPE_DEV</span><span class="p">,</span>
					  <span class="n">snd_dma_pci_data</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">),</span>
					  <span class="n">BDL_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bdl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span> <span class="s">&quot;cannot allocate BDL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mark_pages_wc</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">azx_dev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bdl</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* allocate memory for the position buffer */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_dma_alloc_pages</span><span class="p">(</span><span class="n">SNDRV_DMA_TYPE_DEV</span><span class="p">,</span>
				  <span class="n">snd_dma_pci_data</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">),</span>
				  <span class="n">chip</span><span class="o">-&gt;</span><span class="n">num_streams</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">posbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span> <span class="s">&quot;cannot allocate posbuf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mark_pages_wc</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">posbuf</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="cm">/* allocate CORB/RIRB */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">azx_alloc_cmd_io</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* initialize streams */</span>
	<span class="n">azx_init_stream</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* initialize chip */</span>
	<span class="n">azx_init_pci</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="n">azx_init_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="p">(</span><span class="n">probe_only</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* codec detection */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codec_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span> <span class="s">&quot;no codecs found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="s">&quot;HDA-Intel&quot;</span><span class="p">);</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">shortname</span><span class="p">,</span> <span class="n">driver_short_names</span><span class="p">[</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">driver_type</span><span class="p">],</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">shortname</span><span class="p">));</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">longname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">longname</span><span class="p">),</span>
		 <span class="s">&quot;%s at 0x%lx irq %i&quot;</span><span class="p">,</span>
		 <span class="n">card</span><span class="o">-&gt;</span><span class="n">shortname</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">power_down_all_codecs</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SND_HDA_POWER_SAVE</span>
	<span class="cm">/* The codecs were powered up in snd_hda_codec_new().</span>
<span class="cm">	 * Now all initialization done, so turn them down if possible</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">codec_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_hda_power_down</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">azx_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">pci_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&gt;=</span> <span class="n">SNDRV_CARDS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable</span><span class="p">[</span><span class="n">dev</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_card_create</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">dev</span><span class="p">],</span> <span class="n">id</span><span class="p">[</span><span class="n">dev</span><span class="p">],</span> <span class="n">THIS_MODULE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">card</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span> <span class="s">&quot;Error creating card!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set this here since it&#39;s referred in snd_hda_load_patch() */</span>
	<span class="n">snd_card_set_dev</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">azx_create</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">pci</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">pci_id</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">azx_probe_continue</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">card</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">snd_card_free</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">DELAYED_INIT_MARK</span> <span class="nf">azx_probe_continue</span><span class="p">(</span><span class="k">struct</span> <span class="n">azx</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">dev_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SND_HDA_INPUT_BEEP</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">beep_mode</span> <span class="o">=</span> <span class="n">beep_mode</span><span class="p">[</span><span class="n">dev</span><span class="p">];</span>
<span class="cp">#endif</span>

	<span class="cm">/* create codec instances */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">azx_codec_create</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">model</span><span class="p">[</span><span class="n">dev</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SND_HDA_PATCH_LOADER</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">patch</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">patch</span><span class="p">[</span><span class="n">dev</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">SFX</span> <span class="s">&quot;Applying patch firmware &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">patch</span><span class="p">[</span><span class="n">dev</span><span class="p">]);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_load_patch</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">patch</span><span class="p">[</span><span class="n">dev</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">probe_only</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">azx_codec_configure</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* create PCM streams */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_hda_build_pcms</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="cm">/* create mixer controls */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">azx_mixer_create</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_card_register</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">power_down_all_codecs</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="n">azx_notifier_register</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">init_failed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">azx_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">card</span><span class="p">)</span>
		<span class="n">snd_card_free</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* PCI IDs */</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">azx_ids</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* CPT */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x1c20</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_PCH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_SCH_SNOOP</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_BUFSIZE</span> <span class="p">},</span>
	<span class="cm">/* PBG */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x1d20</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_PCH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_SCH_SNOOP</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_BUFSIZE</span><span class="p">},</span>
	<span class="cm">/* Panther Point */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x1e20</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_PCH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_SCH_SNOOP</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_BUFSIZE</span><span class="p">},</span>
	<span class="cm">/* Lynx Point */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x8c20</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_PCH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_SCH_SNOOP</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_BUFSIZE</span><span class="p">},</span>
	<span class="cm">/* SCH */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x811b</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_SCH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_SCH_SNOOP</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_BUFSIZE</span> <span class="o">|</span> <span class="n">AZX_DCAPS_POSFIX_LPIB</span> <span class="p">},</span> <span class="cm">/* Poulsbo */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x080a</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_SCH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_SCH_SNOOP</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_BUFSIZE</span> <span class="o">|</span> <span class="n">AZX_DCAPS_POSFIX_LPIB</span> <span class="p">},</span> <span class="cm">/* Oaktrail */</span>
	<span class="cm">/* ICH */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x2668</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ICH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_OLD_SSYNC</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_BUFSIZE</span> <span class="p">},</span>  <span class="cm">/* ICH6 */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x27d8</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ICH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_OLD_SSYNC</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_BUFSIZE</span> <span class="p">},</span>  <span class="cm">/* ICH7 */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x269a</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ICH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_OLD_SSYNC</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_BUFSIZE</span> <span class="p">},</span>  <span class="cm">/* ESB2 */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x284b</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ICH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_OLD_SSYNC</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_BUFSIZE</span> <span class="p">},</span>  <span class="cm">/* ICH8 */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x293e</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ICH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_OLD_SSYNC</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_BUFSIZE</span> <span class="p">},</span>  <span class="cm">/* ICH9 */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x293f</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ICH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_OLD_SSYNC</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_BUFSIZE</span> <span class="p">},</span>  <span class="cm">/* ICH9 */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x3a3e</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ICH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_OLD_SSYNC</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_BUFSIZE</span> <span class="p">},</span>  <span class="cm">/* ICH10 */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x8086</span><span class="p">,</span> <span class="mh">0x3a6e</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ICH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_OLD_SSYNC</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_BUFSIZE</span> <span class="p">},</span>  <span class="cm">/* ICH10 */</span>
	<span class="cm">/* Generic Intel */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">PCI_CLASS_MULTIMEDIA_HD_AUDIO</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">class_mask</span> <span class="o">=</span> <span class="mh">0xffffff</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ICH</span> <span class="o">|</span> <span class="n">AZX_DCAPS_BUFSIZE</span> <span class="p">},</span>
	<span class="cm">/* ATI SB 450/600/700/800/900 */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0x437b</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_SB</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0x4383</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_SB</span> <span class="p">},</span>
	<span class="cm">/* AMD Hudson */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1022</span><span class="p">,</span> <span class="mh">0x780d</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_GENERIC</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_SB</span> <span class="p">},</span>
	<span class="cm">/* ATI HDMI */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0x793b</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0x7919</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0x960f</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0x970f</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0xaa00</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0xaa08</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0xaa10</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0xaa18</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0xaa20</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0xaa28</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0xaa30</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0xaa38</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0xaa40</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0xaa48</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0x9902</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI_NS</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0xaaa0</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI_NS</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0xaaa8</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI_NS</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1002</span><span class="p">,</span> <span class="mh">0xaab0</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ATIHDMI_NS</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="cm">/* VIA VT8251/VT8237A */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1106</span><span class="p">,</span> <span class="mh">0x3288</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_VIA</span> <span class="o">|</span> <span class="n">AZX_DCAPS_POSFIX_VIA</span> <span class="p">},</span>
	<span class="cm">/* SIS966 */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1039</span><span class="p">,</span> <span class="mh">0x7502</span><span class="p">),</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_SIS</span> <span class="p">},</span>
	<span class="cm">/* ULI M5461 */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x10b9</span><span class="p">,</span> <span class="mh">0x5461</span><span class="p">),</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_ULI</span> <span class="p">},</span>
	<span class="cm">/* NVIDIA MCP */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NVIDIA</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">PCI_CLASS_MULTIMEDIA_HD_AUDIO</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">class_mask</span> <span class="o">=</span> <span class="mh">0xffffff</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_NVIDIA</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_NVIDIA</span> <span class="p">},</span>
	<span class="cm">/* Teradici */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x6549</span><span class="p">,</span> <span class="mh">0x1200</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_TERA</span> <span class="o">|</span> <span class="n">AZX_DCAPS_NO_64BIT</span> <span class="p">},</span>
	<span class="cm">/* Creative X-Fi (CA0110-IBG) */</span>
	<span class="cm">/* CTHDA chips */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1102</span><span class="p">,</span> <span class="mh">0x0010</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_CTHDA</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_CTHDA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1102</span><span class="p">,</span> <span class="mh">0x0012</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_CTHDA</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_CTHDA</span> <span class="p">},</span>
<span class="cp">#if !defined(CONFIG_SND_CTXFI) &amp;&amp; !defined(CONFIG_SND_CTXFI_MODULE)</span>
	<span class="cm">/* the following entry conflicts with snd-ctxfi driver,</span>
<span class="cm">	 * as ctxfi driver mutates from HD-audio to native mode with</span>
<span class="cm">	 * a special command sequence.</span>
<span class="cm">	 */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_CREATIVE</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">PCI_CLASS_MULTIMEDIA_HD_AUDIO</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">class_mask</span> <span class="o">=</span> <span class="mh">0xffffff</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_CTX</span> <span class="o">|</span> <span class="n">AZX_DCAPS_CTX_WORKAROUND</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_RIRB_PRE_DELAY</span> <span class="o">|</span> <span class="n">AZX_DCAPS_POSFIX_LPIB</span> <span class="p">},</span>
<span class="cp">#else</span>
	<span class="cm">/* this entry seems still valid -- i.e. without emu20kx chip */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x1102</span><span class="p">,</span> <span class="mh">0x0009</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_CTX</span> <span class="o">|</span> <span class="n">AZX_DCAPS_CTX_WORKAROUND</span> <span class="o">|</span>
	  <span class="n">AZX_DCAPS_RIRB_PRE_DELAY</span> <span class="o">|</span> <span class="n">AZX_DCAPS_POSFIX_LPIB</span> <span class="p">},</span>
<span class="cp">#endif</span>
	<span class="cm">/* Vortex86MX */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x17f3</span><span class="p">,</span> <span class="mh">0x3010</span><span class="p">),</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_GENERIC</span> <span class="p">},</span>
	<span class="cm">/* VMware HDAudio */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="mh">0x15ad</span><span class="p">,</span> <span class="mh">0x1977</span><span class="p">),</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_GENERIC</span> <span class="p">},</span>
	<span class="cm">/* AMD/ATI Generic, PCI class code and Vendor ID for HD Audio */</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">PCI_CLASS_MULTIMEDIA_HD_AUDIO</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">class_mask</span> <span class="o">=</span> <span class="mh">0xffffff</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_GENERIC</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">),</span>
	  <span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">PCI_CLASS_MULTIMEDIA_HD_AUDIO</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">class_mask</span> <span class="o">=</span> <span class="mh">0xffffff</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">AZX_DRIVER_GENERIC</span> <span class="o">|</span> <span class="n">AZX_DCAPS_PRESET_ATI_HDMI</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">azx_ids</span><span class="p">);</span>

<span class="cm">/* pci_driver definition */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">azx_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">KBUILD_MODNAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">azx_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">azx_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">azx_remove</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">azx_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">azx_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="n">module_pci_driver</span><span class="p">(</span><span class="n">azx_driver</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
