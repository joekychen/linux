<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › pci › hda › hda_local.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hda_local.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Universal Interface for Intel High Definition Audio Codec</span>
<span class="cm"> *</span>
<span class="cm"> * Local helper functions</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004 Takashi Iwai &lt;tiwai@suse.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> *  under the terms of the GNU General Public License as published by the Free</span>
<span class="cm"> *  Software Foundation; either version 2 of the License, or (at your option)</span>
<span class="cm"> *  any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> *  more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> *  this program; if not, write to the Free Software Foundation, Inc., 59</span>
<span class="cm"> *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __SOUND_HDA_LOCAL_H</span>
<span class="cp">#define __SOUND_HDA_LOCAL_H</span>

<span class="cm">/* We abuse kcontrol_new.subdev field to pass the NID corresponding to</span>
<span class="cm"> * the given new control.  If id.subdev has a bit flag HDA_SUBDEV_NID_FLAG,</span>
<span class="cm"> * snd_hda_ctl_add() takes the lower-bit subdev value as a valid NID.</span>
<span class="cm"> * </span>
<span class="cm"> * Note that the subdevice field is cleared again before the real registration</span>
<span class="cm"> * in snd_hda_ctl_add(), so that this value won&#39;t appear in the outside.</span>
<span class="cm"> */</span>
<span class="cp">#define HDA_SUBDEV_NID_FLAG	(1U &lt;&lt; 31)</span>
<span class="cp">#define HDA_SUBDEV_AMP_FLAG	(1U &lt;&lt; 30)</span>

<span class="cm">/*</span>
<span class="cm"> * for mixer controls</span>
<span class="cm"> */</span>
<span class="cp">#define HDA_COMPOSE_AMP_VAL_OFS(nid,chs,idx,dir,ofs)		\</span>
<span class="cp">	((nid) | ((chs)&lt;&lt;16) | ((dir)&lt;&lt;18) | ((idx)&lt;&lt;19) | ((ofs)&lt;&lt;23))</span>
<span class="cp">#define HDA_AMP_VAL_MIN_MUTE (1&lt;&lt;29)</span>
<span class="cp">#define HDA_COMPOSE_AMP_VAL(nid,chs,idx,dir) \</span>
<span class="cp">	HDA_COMPOSE_AMP_VAL_OFS(nid, chs, idx, dir, 0)</span>
<span class="cm">/* mono volume with index (index=0,1,...) (channel=1,2) */</span>
<span class="cp">#define HDA_CODEC_VOLUME_MONO_IDX(xname, xcidx, nid, channel, xindex, dir, flags) \</span>
<span class="cp">	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xcidx,  \</span>
<span class="cp">	  .subdevice = HDA_SUBDEV_AMP_FLAG, \</span>
<span class="cp">	  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \</span>
<span class="cp">	  	    SNDRV_CTL_ELEM_ACCESS_TLV_READ | \</span>
<span class="cp">	  	    SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK, \</span>
<span class="cp">	  .info = snd_hda_mixer_amp_volume_info, \</span>
<span class="cp">	  .get = snd_hda_mixer_amp_volume_get, \</span>
<span class="cp">	  .put = snd_hda_mixer_amp_volume_put, \</span>
<span class="cp">	  .tlv = { .c = snd_hda_mixer_amp_tlv },		\</span>
<span class="cp">	  .private_value = HDA_COMPOSE_AMP_VAL(nid, channel, xindex, dir) | flags }</span>
<span class="cm">/* stereo volume with index */</span>
<span class="cp">#define HDA_CODEC_VOLUME_IDX(xname, xcidx, nid, xindex, direction) \</span>
<span class="cp">	HDA_CODEC_VOLUME_MONO_IDX(xname, xcidx, nid, 3, xindex, direction, 0)</span>
<span class="cm">/* mono volume */</span>
<span class="cp">#define HDA_CODEC_VOLUME_MONO(xname, nid, channel, xindex, direction) \</span>
<span class="cp">	HDA_CODEC_VOLUME_MONO_IDX(xname, 0, nid, channel, xindex, direction, 0)</span>
<span class="cm">/* stereo volume */</span>
<span class="cp">#define HDA_CODEC_VOLUME(xname, nid, xindex, direction) \</span>
<span class="cp">	HDA_CODEC_VOLUME_MONO(xname, nid, 3, xindex, direction)</span>
<span class="cm">/* stereo volume with min=mute */</span>
<span class="cp">#define HDA_CODEC_VOLUME_MIN_MUTE(xname, nid, xindex, direction) \</span>
<span class="cp">	HDA_CODEC_VOLUME_MONO_IDX(xname, 0, nid, 3, xindex, direction, \</span>
<span class="cp">				  HDA_AMP_VAL_MIN_MUTE)</span>
<span class="cm">/* mono mute switch with index (index=0,1,...) (channel=1,2) */</span>
<span class="cp">#define HDA_CODEC_MUTE_MONO_IDX(xname, xcidx, nid, channel, xindex, direction) \</span>
<span class="cp">	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xcidx, \</span>
<span class="cp">	  .subdevice = HDA_SUBDEV_AMP_FLAG, \</span>
<span class="cp">	  .info = snd_hda_mixer_amp_switch_info, \</span>
<span class="cp">	  .get = snd_hda_mixer_amp_switch_get, \</span>
<span class="cp">	  .put = snd_hda_mixer_amp_switch_put, \</span>
<span class="cp">	  .private_value = HDA_COMPOSE_AMP_VAL(nid, channel, xindex, direction) }</span>
<span class="cm">/* stereo mute switch with index */</span>
<span class="cp">#define HDA_CODEC_MUTE_IDX(xname, xcidx, nid, xindex, direction) \</span>
<span class="cp">	HDA_CODEC_MUTE_MONO_IDX(xname, xcidx, nid, 3, xindex, direction)</span>
<span class="cm">/* mono mute switch */</span>
<span class="cp">#define HDA_CODEC_MUTE_MONO(xname, nid, channel, xindex, direction) \</span>
<span class="cp">	HDA_CODEC_MUTE_MONO_IDX(xname, 0, nid, channel, xindex, direction)</span>
<span class="cm">/* stereo mute switch */</span>
<span class="cp">#define HDA_CODEC_MUTE(xname, nid, xindex, direction) \</span>
<span class="cp">	HDA_CODEC_MUTE_MONO(xname, nid, 3, xindex, direction)</span>
<span class="cp">#ifdef CONFIG_SND_HDA_INPUT_BEEP</span>
<span class="cm">/* special beep mono mute switch with index (index=0,1,...) (channel=1,2) */</span>
<span class="cp">#define HDA_CODEC_MUTE_BEEP_MONO_IDX(xname, xcidx, nid, channel, xindex, direction) \</span>
<span class="cp">	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xcidx, \</span>
<span class="cp">	  .subdevice = HDA_SUBDEV_AMP_FLAG, \</span>
<span class="cp">	  .info = snd_hda_mixer_amp_switch_info, \</span>
<span class="cp">	  .get = snd_hda_mixer_amp_switch_get, \</span>
<span class="cp">	  .put = snd_hda_mixer_amp_switch_put_beep, \</span>
<span class="cp">	  .private_value = HDA_COMPOSE_AMP_VAL(nid, channel, xindex, direction) }</span>
<span class="cp">#else</span>
<span class="cm">/* no digital beep - just the standard one */</span>
<span class="cp">#define HDA_CODEC_MUTE_BEEP_MONO_IDX(xname, xcidx, nid, ch, xidx, dir) \</span>
<span class="cp">	HDA_CODEC_MUTE_MONO_IDX(xname, xcidx, nid, ch, xidx, dir)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SND_HDA_INPUT_BEEP */</span><span class="cp"></span>
<span class="cm">/* special beep mono mute switch */</span>
<span class="cp">#define HDA_CODEC_MUTE_BEEP_MONO(xname, nid, channel, xindex, direction) \</span>
<span class="cp">	HDA_CODEC_MUTE_BEEP_MONO_IDX(xname, 0, nid, channel, xindex, direction)</span>
<span class="cm">/* special beep stereo mute switch */</span>
<span class="cp">#define HDA_CODEC_MUTE_BEEP(xname, nid, xindex, direction) \</span>
<span class="cp">	HDA_CODEC_MUTE_BEEP_MONO(xname, nid, 3, xindex, direction)</span>

<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">snd_hda_pcm_type_name</span><span class="p">[];</span>

<span class="kt">int</span> <span class="n">snd_hda_mixer_amp_volume_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_mixer_amp_volume_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_mixer_amp_volume_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_mixer_amp_tlv</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op_flag</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">tlv</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_mixer_amp_switch_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_mixer_amp_switch_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_mixer_amp_switch_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SND_HDA_INPUT_BEEP</span>
<span class="kt">int</span> <span class="n">snd_hda_mixer_amp_switch_put_beep</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cm">/* lowlevel accessor with caching; use carefully */</span>
<span class="kt">int</span> <span class="n">snd_hda_codec_amp_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ch</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_codec_amp_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ch</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_codec_amp_stereo</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
<span class="kt">void</span> <span class="n">snd_hda_codec_resume_amp</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">snd_hda_set_vmaster_tlv</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">tlv</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">snd_hda_find_mixer_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__snd_hda_add_vmaster</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">tlv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">slaves</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">suffix</span><span class="p">,</span> <span class="n">bool</span> <span class="n">init_slave_vol</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">**</span><span class="n">ctl_ret</span><span class="p">);</span>
<span class="cp">#define snd_hda_add_vmaster(codec, name, tlv, slaves, suffix) \</span>
<span class="cp">	__snd_hda_add_vmaster(codec, name, tlv, slaves, suffix, true, NULL)</span>
<span class="kt">int</span> <span class="n">snd_hda_codec_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">HDA_VMUTE_OFF</span><span class="p">,</span>
	<span class="n">HDA_VMUTE_ON</span><span class="p">,</span>
	<span class="n">HDA_VMUTE_FOLLOW_MASTER</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hda_vmaster_mute_hook</span> <span class="p">{</span>
	<span class="cm">/* below two fields must be filled by the caller of</span>
<span class="cm">	 * snd_hda_add_vmaster_hook() beforehand</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">sw_kctl</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="cm">/* below are initialized automatically */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mute_mode</span><span class="p">;</span> <span class="cm">/* HDA_VMUTE_XXX */</span>
	<span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">snd_hda_add_vmaster_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">hda_vmaster_mute_hook</span> <span class="o">*</span><span class="n">hook</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="n">expose_enum_ctl</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">snd_hda_sync_vmaster_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_vmaster_mute_hook</span> <span class="o">*</span><span class="n">hook</span><span class="p">);</span>

<span class="cm">/* amp value bits */</span>
<span class="cp">#define HDA_AMP_MUTE	0x80</span>
<span class="cp">#define HDA_AMP_UNMUTE	0x00</span>
<span class="cp">#define HDA_AMP_VOLMASK	0x7f</span>

<span class="cm">/* mono switch binding multiple inputs */</span>
<span class="cp">#define HDA_BIND_MUTE_MONO(xname, nid, channel, indices, direction) \</span>
<span class="cp">	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = 0,  \</span>
<span class="cp">	  .info = snd_hda_mixer_amp_switch_info, \</span>
<span class="cp">	  .get = snd_hda_mixer_bind_switch_get, \</span>
<span class="cp">	  .put = snd_hda_mixer_bind_switch_put, \</span>
<span class="cp">	  .private_value = HDA_COMPOSE_AMP_VAL(nid, channel, indices, direction) }</span>

<span class="cm">/* stereo switch binding multiple inputs */</span>
<span class="cp">#define HDA_BIND_MUTE(xname,nid,indices,dir) \</span>
<span class="cp">	HDA_BIND_MUTE_MONO(xname,nid,3,indices,dir)</span>

<span class="kt">int</span> <span class="n">snd_hda_mixer_bind_switch_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_mixer_bind_switch_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>

<span class="cm">/* more generic bound controls */</span>
<span class="k">struct</span> <span class="n">hda_ctl_ops</span> <span class="p">{</span>
	<span class="n">snd_kcontrol_info_t</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="n">snd_kcontrol_get_t</span> <span class="o">*</span><span class="n">get</span><span class="p">;</span>
	<span class="n">snd_kcontrol_put_t</span> <span class="o">*</span><span class="n">put</span><span class="p">;</span>
	<span class="n">snd_kcontrol_tlv_rw_t</span> <span class="o">*</span><span class="n">tlv</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">hda_ctl_ops</span> <span class="n">snd_hda_bind_vol</span><span class="p">;</span>	<span class="cm">/* for bind-volume with TLV */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">hda_ctl_ops</span> <span class="n">snd_hda_bind_sw</span><span class="p">;</span>	<span class="cm">/* for bind-switch */</span>

<span class="k">struct</span> <span class="n">hda_bind_ctls</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hda_ctl_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">values</span><span class="p">[];</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">snd_hda_mixer_bind_ctls_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_mixer_bind_ctls_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_mixer_bind_ctls_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_mixer_bind_tlv</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op_flag</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">tlv</span><span class="p">);</span>

<span class="cp">#define HDA_BIND_VOL(xname, bindrec) \</span>
<span class="cp">	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \</span>
<span class="cp">	  .name = xname, \</span>
<span class="cp">	  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\</span>
<span class="cp">			  SNDRV_CTL_ELEM_ACCESS_TLV_READ |\</span>
<span class="cp">			  SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK,\</span>
<span class="cp">	  .info = snd_hda_mixer_bind_ctls_info,\</span>
<span class="cp">	  .get =  snd_hda_mixer_bind_ctls_get,\</span>
<span class="cp">	  .put = snd_hda_mixer_bind_ctls_put,\</span>
<span class="cp">	  .tlv = { .c = snd_hda_mixer_bind_tlv },\</span>
<span class="cp">	  .private_value = (long) (bindrec) }</span>
<span class="cp">#define HDA_BIND_SW(xname, bindrec) \</span>
<span class="cp">	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\</span>
<span class="cp">	  .name = xname, \</span>
<span class="cp">	  .info = snd_hda_mixer_bind_ctls_info,\</span>
<span class="cp">	  .get =  snd_hda_mixer_bind_ctls_get,\</span>
<span class="cp">	  .put = snd_hda_mixer_bind_ctls_put,\</span>
<span class="cp">	  .private_value = (long) (bindrec) }</span>

<span class="cm">/*</span>
<span class="cm"> * SPDIF I/O</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">snd_hda_create_spdif_out_ctls</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				  <span class="n">hda_nid_t</span> <span class="n">associated_nid</span><span class="p">,</span>
				  <span class="n">hda_nid_t</span> <span class="n">cvt_nid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_create_spdif_in_ctls</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * input MUX helper</span>
<span class="cm"> */</span>
<span class="cp">#define HDA_MAX_NUM_INPUTS	16</span>
<span class="k">struct</span> <span class="n">hda_input_mux_item</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">label</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">hda_input_mux</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_items</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_input_mux_item</span> <span class="n">items</span><span class="p">[</span><span class="n">HDA_MAX_NUM_INPUTS</span><span class="p">];</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">snd_hda_input_mux_info</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hda_input_mux</span> <span class="o">*</span><span class="n">imux</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_input_mux_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">hda_input_mux</span> <span class="o">*</span><span class="n">imux</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cur_val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_add_imux_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_input_mux</span> <span class="o">*</span><span class="n">imux</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">type_index_ret</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Channel mode helper</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hda_channel_mode</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">channels</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">hda_verb</span> <span class="o">*</span><span class="n">sequence</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">snd_hda_ch_mode_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">hda_channel_mode</span> <span class="o">*</span><span class="n">chmode</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">num_chmodes</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_ch_mode_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">hda_channel_mode</span> <span class="o">*</span><span class="n">chmode</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">num_chmodes</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">max_channels</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_ch_mode_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">hda_channel_mode</span> <span class="o">*</span><span class="n">chmode</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">num_chmodes</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">max_channelsp</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Multi-channel / digital-out PCM helper</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="p">{</span> <span class="n">HDA_FRONT</span><span class="p">,</span> <span class="n">HDA_REAR</span><span class="p">,</span> <span class="n">HDA_CLFE</span><span class="p">,</span> <span class="n">HDA_SIDE</span> <span class="p">};</span> <span class="cm">/* index for dac_nidx */</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">HDA_DIG_NONE</span><span class="p">,</span> <span class="n">HDA_DIG_EXCLUSIVE</span><span class="p">,</span> <span class="n">HDA_DIG_ANALOG_DUP</span> <span class="p">};</span> <span class="cm">/* dig_out_used */</span>

<span class="cp">#define HDA_MAX_OUTS	5</span>

<span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_dacs</span><span class="p">;</span>		<span class="cm">/* # of DACs, must be more than 1 */</span>
	<span class="k">const</span> <span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">dac_nids</span><span class="p">;</span>	<span class="cm">/* DAC list */</span>
	<span class="n">hda_nid_t</span> <span class="n">hp_nid</span><span class="p">;</span>	<span class="cm">/* optional DAC for HP, 0 when not exists */</span>
	<span class="n">hda_nid_t</span> <span class="n">hp_out_nid</span><span class="p">[</span><span class="n">HDA_MAX_OUTS</span><span class="p">];</span>	<span class="cm">/* DACs for multiple HPs */</span>
	<span class="n">hda_nid_t</span> <span class="n">extra_out_nid</span><span class="p">[</span><span class="n">HDA_MAX_OUTS</span><span class="p">];</span>	<span class="cm">/* other (e.g. speaker) DACs */</span>
	<span class="n">hda_nid_t</span> <span class="n">dig_out_nid</span><span class="p">;</span>	<span class="cm">/* digital out audio widget */</span>
	<span class="k">const</span> <span class="n">hda_nid_t</span> <span class="o">*</span><span class="n">slave_dig_outs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_channels</span><span class="p">;</span>	<span class="cm">/* currently supported analog channels */</span>
	<span class="kt">int</span> <span class="n">dig_out_used</span><span class="p">;</span>	<span class="cm">/* current usage of digital out (HDA_DIG_XXX) */</span>
	<span class="kt">int</span> <span class="n">no_share_stream</span><span class="p">;</span>	<span class="cm">/* don&#39;t share a stream with multiple pins */</span>
	<span class="kt">int</span> <span class="n">share_spdif</span><span class="p">;</span>	<span class="cm">/* share SPDIF pin */</span>
	<span class="cm">/* PCM information for both analog and SPDIF DACs */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">analog_rates</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">analog_maxbps</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">analog_formats</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">spdif_rates</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">spdif_maxbps</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">spdif_formats</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">snd_hda_create_spdif_share_sw</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_multi_out_dig_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_multi_out_dig_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_multi_out_dig_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_tag</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">format</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_multi_out_dig_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_multi_out_analog_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_multi_out_analog_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_tag</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">format</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_multi_out_analog_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">hda_multi_out</span> <span class="o">*</span><span class="n">mout</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * generic codec parser</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SND_HDA_GENERIC</span>
<span class="kt">int</span> <span class="n">snd_hda_parse_generic_codec</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">snd_hda_parse_generic_codec</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * generic proc interface</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="kt">int</span> <span class="n">snd_hda_codec_proc_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">snd_hda_codec_proc_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#define SND_PRINT_BITS_ADVISED_BUFSIZE	16</span>
<span class="kt">void</span> <span class="n">snd_print_pcm_bits</span><span class="p">(</span><span class="kt">int</span> <span class="n">pcm</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Misc</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">snd_hda_check_board_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_configs</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">modelnames</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_pci_quirk</span> <span class="o">*</span><span class="n">pci_list</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_check_board_codec_sid_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
                               <span class="kt">int</span> <span class="n">num_configs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">models</span><span class="p">,</span>
                               <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_pci_quirk</span> <span class="o">*</span><span class="n">tbl</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_add_new_ctls</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="o">*</span><span class="n">knew</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * unsolicited event handler</span>
<span class="cm"> */</span>

<span class="cp">#define HDA_UNSOL_QUEUE_SIZE	64</span>

<span class="k">struct</span> <span class="n">hda_bus_unsolicited</span> <span class="p">{</span>
	<span class="cm">/* ring buffer */</span>
	<span class="n">u32</span> <span class="n">queue</span><span class="p">[</span><span class="n">HDA_UNSOL_QUEUE_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rp</span><span class="p">,</span> <span class="n">wp</span><span class="p">;</span>

	<span class="cm">/* workqueue */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hda_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* helper macros to retrieve pin default-config values */</span>
<span class="cp">#define get_defcfg_connect(cfg) \</span>
<span class="cp">	((cfg &amp; AC_DEFCFG_PORT_CONN) &gt;&gt; AC_DEFCFG_PORT_CONN_SHIFT)</span>
<span class="cp">#define get_defcfg_association(cfg) \</span>
<span class="cp">	((cfg &amp; AC_DEFCFG_DEF_ASSOC) &gt;&gt; AC_DEFCFG_ASSOC_SHIFT)</span>
<span class="cp">#define get_defcfg_location(cfg) \</span>
<span class="cp">	((cfg &amp; AC_DEFCFG_LOCATION) &gt;&gt; AC_DEFCFG_LOCATION_SHIFT)</span>
<span class="cp">#define get_defcfg_sequence(cfg) \</span>
<span class="cp">	(cfg &amp; AC_DEFCFG_SEQUENCE)</span>
<span class="cp">#define get_defcfg_device(cfg) \</span>
<span class="cp">	((cfg &amp; AC_DEFCFG_DEVICE) &gt;&gt; AC_DEFCFG_DEVICE_SHIFT)</span>
<span class="cp">#define get_defcfg_misc(cfg) \</span>
<span class="cp">	((cfg &amp; AC_DEFCFG_MISC) &gt;&gt; AC_DEFCFG_MISC_SHIFT)</span>

<span class="cm">/* amp values */</span>
<span class="cp">#define AMP_IN_MUTE(idx)	(0x7080 | ((idx)&lt;&lt;8))</span>
<span class="cp">#define AMP_IN_UNMUTE(idx)	(0x7000 | ((idx)&lt;&lt;8))</span>
<span class="cp">#define AMP_OUT_MUTE		0xb080</span>
<span class="cp">#define AMP_OUT_UNMUTE		0xb000</span>
<span class="cp">#define AMP_OUT_ZERO		0xb000</span>
<span class="cm">/* pinctl values */</span>
<span class="cp">#define PIN_IN			(AC_PINCTL_IN_EN)</span>
<span class="cp">#define PIN_VREFHIZ		(AC_PINCTL_IN_EN | AC_PINCTL_VREF_HIZ)</span>
<span class="cp">#define PIN_VREF50		(AC_PINCTL_IN_EN | AC_PINCTL_VREF_50)</span>
<span class="cp">#define PIN_VREFGRD		(AC_PINCTL_IN_EN | AC_PINCTL_VREF_GRD)</span>
<span class="cp">#define PIN_VREF80		(AC_PINCTL_IN_EN | AC_PINCTL_VREF_80)</span>
<span class="cp">#define PIN_VREF100		(AC_PINCTL_IN_EN | AC_PINCTL_VREF_100)</span>
<span class="cp">#define PIN_OUT			(AC_PINCTL_OUT_EN)</span>
<span class="cp">#define PIN_HP			(AC_PINCTL_OUT_EN | AC_PINCTL_HP_EN)</span>
<span class="cp">#define PIN_HP_AMP		(AC_PINCTL_HP_EN)</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">snd_hda_get_default_vref</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">pin</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">_snd_hda_set_pin_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">pin</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="n">bool</span> <span class="n">cached</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * _snd_hda_set_pin_ctl - Set a pin-control value safely</span>
<span class="cm"> * @codec: the codec instance</span>
<span class="cm"> * @pin: the pin NID to set the control</span>
<span class="cm"> * @val: the pin-control value (AC_PINCTL_* bits)</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets the pin-control value to the given pin, but</span>
<span class="cm"> * filters out the invalid pin-control bits when the pin has no such</span>
<span class="cm"> * capabilities.  For example, when PIN_HP is passed but the pin has no</span>
<span class="cm"> * HP-drive capability, the HP bit is omitted.</span>
<span class="cm"> *</span>
<span class="cm"> * The function doesn&#39;t check the input VREF capability bits, though.</span>
<span class="cm"> * Use snd_hda_get_default_vref() to guess the right value.</span>
<span class="cm"> * Also, this function is only for analog pins, not for HDMI pins.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">snd_hda_set_pin_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">pin</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_snd_hda_set_pin_ctl</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_hda_set_pin_ctl_cache - Set a pin-control value safely</span>
<span class="cm"> * @codec: the codec instance</span>
<span class="cm"> * @pin: the pin NID to set the control</span>
<span class="cm"> * @val: the pin-control value (AC_PINCTL_* bits)</span>
<span class="cm"> *</span>
<span class="cm"> * Just like snd_hda_set_pin_ctl() but write to cache as well.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">snd_hda_set_pin_ctl_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">pin</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_snd_hda_set_pin_ctl</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get widget capabilities</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">get_wcaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&lt;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">start_nid</span> <span class="o">||</span>
	    <span class="n">nid</span> <span class="o">&gt;=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">start_nid</span> <span class="o">+</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">num_nodes</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">wcaps</span><span class="p">[</span><span class="n">nid</span> <span class="o">-</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">start_nid</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* get the widget type from widget capability bits */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_wcaps_type</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wcaps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wcaps</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* invalid type */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">wcaps</span> <span class="o">&amp;</span> <span class="n">AC_WCAP_TYPE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">AC_WCAP_TYPE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_wcaps_channels</span><span class="p">(</span><span class="n">u32</span> <span class="n">wcaps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chans</span><span class="p">;</span>

	<span class="n">chans</span> <span class="o">=</span> <span class="p">(</span><span class="n">wcaps</span> <span class="o">&amp;</span> <span class="n">AC_WCAP_CHAN_CNT_EXT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">;</span>
	<span class="n">chans</span> <span class="o">=</span> <span class="p">((</span><span class="n">chans</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">chans</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u32</span> <span class="n">query_amp_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_override_amp_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">caps</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">snd_hda_query_pin_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_override_pin_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">caps</span><span class="p">);</span>

<span class="cm">/* flags for hda_nid_item */</span>
<span class="cp">#define HDA_NID_ITEM_AMP	(1&lt;&lt;0)</span>

<span class="k">struct</span> <span class="n">hda_nid_item</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kctl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">snd_hda_ctl_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kctl</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_add_nid</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kctl</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">snd_hda_ctls_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * hwdep interface</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SND_HDA_HWDEP</span>
<span class="kt">int</span> <span class="n">snd_hda_create_hwdep</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">snd_hda_create_hwdep</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_SND_HDA_POWER_SAVE) &amp;&amp; defined(CONFIG_SND_HDA_HWDEP)</span>
<span class="kt">int</span> <span class="n">snd_hda_hwdep_add_power_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">snd_hda_hwdep_add_power_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SND_HDA_RECONFIG</span>
<span class="kt">int</span> <span class="n">snd_hda_hwdep_add_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">snd_hda_hwdep_add_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SND_HDA_RECONFIG</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">snd_hda_get_hint</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hda_get_bool_hint</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">snd_hda_get_hint</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">snd_hda_get_bool_hint</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * power-management</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="n">snd_hda_schedule_power_save</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">hda_amp_list</span> <span class="p">{</span>
	<span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dir</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hda_loopback_check</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">hda_amp_list</span> <span class="o">*</span><span class="n">amplist</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">power_on</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">snd_hda_check_amp_list_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">hda_loopback_check</span> <span class="o">*</span><span class="n">check</span><span class="p">,</span>
				 <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * AMP control callbacks</span>
<span class="cm"> */</span>
<span class="cm">/* retrieve parameters from private_value */</span>
<span class="cp">#define get_amp_nid_(pv)	((pv) &amp; 0xffff)</span>
<span class="cp">#define get_amp_nid(kc)		get_amp_nid_((kc)-&gt;private_value)</span>
<span class="cp">#define get_amp_channels(kc)	(((kc)-&gt;private_value &gt;&gt; 16) &amp; 0x3)</span>
<span class="cp">#define get_amp_direction_(pv)	(((pv) &gt;&gt; 18) &amp; 0x1)</span>
<span class="cp">#define get_amp_direction(kc)	get_amp_direction_((kc)-&gt;private_value)</span>
<span class="cp">#define get_amp_index(kc)	(((kc)-&gt;private_value &gt;&gt; 19) &amp; 0xf)</span>
<span class="cp">#define get_amp_offset(kc)	(((kc)-&gt;private_value &gt;&gt; 23) &amp; 0x3f)</span>
<span class="cp">#define get_amp_min_mute(kc)	(((kc)-&gt;private_value &gt;&gt; 29) &amp; 0x1)</span>

<span class="cm">/*</span>
<span class="cm"> * CEA Short Audio Descriptor data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cea_sad</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">channels</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">format</span><span class="p">;</span>		<span class="cm">/* (format == 0) indicates invalid SAD */</span>
	<span class="kt">int</span>	<span class="n">rates</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">sample_bits</span><span class="p">;</span>	<span class="cm">/* for LPCM */</span>
	<span class="kt">int</span>	<span class="n">max_bitrate</span><span class="p">;</span>	<span class="cm">/* for AC3...ATRAC */</span>
	<span class="kt">int</span>	<span class="n">profile</span><span class="p">;</span>	<span class="cm">/* for WMAPRO */</span>
<span class="p">};</span>

<span class="cp">#define ELD_FIXED_BYTES	20</span>
<span class="cp">#define ELD_MAX_SIZE    256</span>
<span class="cp">#define ELD_MAX_MNL	16</span>
<span class="cp">#define ELD_MAX_SAD	16</span>

<span class="cm">/*</span>
<span class="cm"> * ELD: EDID Like Data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hdmi_eld</span> <span class="p">{</span>
	<span class="n">bool</span>	<span class="n">monitor_present</span><span class="p">;</span>
	<span class="n">bool</span>	<span class="n">eld_valid</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">eld_size</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">baseline_len</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">eld_ver</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">cea_edid_ver</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">monitor_name</span><span class="p">[</span><span class="n">ELD_MAX_MNL</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span>	<span class="n">manufacture_id</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">product_id</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">port_id</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">support_hdcp</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">support_ai</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">conn_type</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">aud_synch_delay</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">spk_alloc</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">sad_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cea_sad</span> <span class="n">sad</span><span class="p">[</span><span class="n">ELD_MAX_SAD</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * all fields above eld_buffer will be cleared before updating ELD</span>
<span class="cm">	 */</span>
	<span class="kt">char</span>    <span class="n">eld_buffer</span><span class="p">[</span><span class="n">ELD_MAX_SIZE</span><span class="p">];</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="k">struct</span> <span class="n">snd_info_entry</span> <span class="o">*</span><span class="n">proc_entry</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">snd_hdmi_get_eld_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">hda_nid_t</span> <span class="n">nid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_hdmi_get_eld</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdmi_eld</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="p">,</span> <span class="n">hda_nid_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">snd_hdmi_show_eld</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdmi_eld</span> <span class="o">*</span><span class="n">eld</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">snd_hdmi_eld_update_pcm_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdmi_eld</span> <span class="o">*</span><span class="n">eld</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">hda_pcm_stream</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="kt">int</span> <span class="n">snd_hda_eld_proc_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hdmi_eld</span> <span class="o">*</span><span class="n">eld</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">snd_hda_eld_proc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hdmi_eld</span> <span class="o">*</span><span class="n">eld</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">snd_hda_eld_proc_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">hdmi_eld</span> <span class="o">*</span><span class="n">eld</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">snd_hda_eld_proc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">hda_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">hdmi_eld</span> <span class="o">*</span><span class="n">eld</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#define SND_PRINT_CHANNEL_ALLOCATION_ADVISED_BUFSIZE 80</span>
<span class="kt">void</span> <span class="n">snd_print_channel_allocation</span><span class="p">(</span><span class="kt">int</span> <span class="n">spk_alloc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __SOUND_HDA_LOCAL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
