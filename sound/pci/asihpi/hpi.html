<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › pci › asihpi › hpi.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hpi.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>

<span class="cm">    AudioScience HPI driver</span>
<span class="cm">    Copyright (C) 1997-2011  AudioScience Inc. &lt;support@audioscience.com&gt;</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of version 2 of the GNU General Public License as</span>
<span class="cm">    published by the Free Software Foundation;</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>

<span class="cm">*/</span>
<span class="cm">/** \file hpi.h</span>

<span class="cm"> AudioScience Hardware Programming Interface (HPI)</span>
<span class="cm"> public API definition.</span>

<span class="cm"> The HPI is a low-level hardware abstraction layer to all</span>
<span class="cm"> AudioScience digital audio adapters</span>

<span class="cm">(C) Copyright AudioScience Inc. 1998-2010</span>
<span class="cm">*/</span>

<span class="cp">#ifndef _HPI_H_</span>
<span class="cp">#define _HPI_H_</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#define HPI_BUILD_KERNEL_MODE</span>

<span class="cm">/******************************************************************************/</span>
<span class="cm">/********       HPI API DEFINITIONS                                       *****/</span>
<span class="cm">/******************************************************************************/</span>

<span class="cm">/*******************************************/</span>
<span class="cm">/**  Audio format types</span>
<span class="cm">\ingroup stream</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_FORMATS</span> <span class="p">{</span>
<span class="cm">/** Used internally on adapter. */</span>
	<span class="n">HPI_FORMAT_MIXER_NATIVE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="cm">/** 8-bit unsigned PCM. Windows equivalent is WAVE_FORMAT_PCM. */</span>
	<span class="n">HPI_FORMAT_PCM8_UNSIGNED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="cm">/** 16-bit signed PCM. Windows equivalent is WAVE_FORMAT_PCM. */</span>
	<span class="n">HPI_FORMAT_PCM16_SIGNED</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="cm">/** MPEG-1 Layer-1. */</span>
	<span class="n">HPI_FORMAT_MPEG_L1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="cm">/** MPEG-1 Layer-2.</span>

<span class="cm">Windows equivalent is WAVE_FORMAT_MPEG.</span>

<span class="cm">The following table shows what combinations of mode and bitrate are possible:</span>

<span class="cm">&lt;table border=1 cellspacing=0 cellpadding=5&gt;</span>
<span class="cm">&lt;tr&gt;</span>
<span class="cm">&lt;td&gt;&lt;p&gt;&lt;b&gt;Bitrate (kbs)&lt;/b&gt;&lt;/p&gt;</span>
<span class="cm">&lt;td&gt;&lt;p&gt;&lt;b&gt;Mono&lt;/b&gt;&lt;/p&gt;</span>
<span class="cm">&lt;td&gt;&lt;p&gt;&lt;b&gt;Stereo,&lt;br&gt;Joint Stereo or&lt;br&gt;Dual Channel&lt;/b&gt;&lt;/p&gt;</span>

<span class="cm">&lt;tr&gt;&lt;td&gt;32&lt;td&gt;X&lt;td&gt;_</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;40&lt;td&gt;_&lt;td&gt;_</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;48&lt;td&gt;X&lt;td&gt;_</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;56&lt;td&gt;X&lt;td&gt;_</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;64&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;80&lt;td&gt;X&lt;td&gt;_</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;96&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;112&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;128&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;160&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;192&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;224&lt;td&gt;_&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;256&lt;td&gt;-&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;320&lt;td&gt;-&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;384&lt;td&gt;_&lt;td&gt;X</span>
<span class="cm">&lt;/table&gt;</span>
<span class="cm">*/</span>
	<span class="n">HPI_FORMAT_MPEG_L2</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="cm">/** MPEG-1 Layer-3.</span>
<span class="cm">Windows equivalent is WAVE_FORMAT_MPEG.</span>

<span class="cm">The following table shows what combinations of mode and bitrate are possible:</span>

<span class="cm">&lt;table border=1 cellspacing=0 cellpadding=5&gt;</span>
<span class="cm">&lt;tr&gt;</span>
<span class="cm">&lt;td&gt;&lt;p&gt;&lt;b&gt;Bitrate (kbs)&lt;/b&gt;&lt;/p&gt;</span>
<span class="cm">&lt;td&gt;&lt;p&gt;&lt;b&gt;Mono&lt;br&gt;Stereo @ 8,&lt;br&gt;11.025 and&lt;br&gt;12kHz*&lt;/b&gt;&lt;/p&gt;</span>
<span class="cm">&lt;td&gt;&lt;p&gt;&lt;b&gt;Mono&lt;br&gt;Stereo @ 16,&lt;br&gt;22.050 and&lt;br&gt;24kHz*&lt;/b&gt;&lt;/p&gt;</span>
<span class="cm">&lt;td&gt;&lt;p&gt;&lt;b&gt;Mono&lt;br&gt;Stereo @ 32,&lt;br&gt;44.1 and&lt;br&gt;48kHz&lt;/b&gt;&lt;/p&gt;</span>

<span class="cm">&lt;tr&gt;&lt;td&gt;16&lt;td&gt;X&lt;td&gt;X&lt;td&gt;_</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;24&lt;td&gt;X&lt;td&gt;X&lt;td&gt;_</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;32&lt;td&gt;X&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;40&lt;td&gt;X&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;48&lt;td&gt;X&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;56&lt;td&gt;X&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;64&lt;td&gt;X&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;80&lt;td&gt;_&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;96&lt;td&gt;_&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;112&lt;td&gt;_&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;128&lt;td&gt;_&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;144&lt;td&gt;_&lt;td&gt;X&lt;td&gt;_</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;160&lt;td&gt;_&lt;td&gt;X&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;192&lt;td&gt;_&lt;td&gt;_&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;224&lt;td&gt;_&lt;td&gt;_&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;256&lt;td&gt;-&lt;td&gt;_&lt;td&gt;X</span>
<span class="cm">&lt;tr&gt;&lt;td&gt;320&lt;td&gt;-&lt;td&gt;_&lt;td&gt;X</span>
<span class="cm">&lt;/table&gt;</span>
<span class="cm">\b * Available on the ASI6000 series only</span>
<span class="cm">*/</span>
	<span class="n">HPI_FORMAT_MPEG_L3</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="cm">/** Dolby AC-2. */</span>
	<span class="n">HPI_FORMAT_DOLBY_AC2</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<span class="cm">/** Dolbt AC-3. */</span>
	<span class="n">HPI_FORMAT_DOLBY_AC3</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
<span class="cm">/** 16-bit PCM big-endian. */</span>
	<span class="n">HPI_FORMAT_PCM16_BIGENDIAN</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
<span class="cm">/** TAGIT-1 algorithm - hits. */</span>
	<span class="n">HPI_FORMAT_AA_TAGIT1_HITS</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
<span class="cm">/** TAGIT-1 algorithm - inserts. */</span>
	<span class="n">HPI_FORMAT_AA_TAGIT1_INSERTS</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
<span class="cm">/** 32-bit signed PCM. Windows equivalent is WAVE_FORMAT_PCM.</span>
<span class="cm">Each sample is a 32bit word. The most significant 24 bits contain a 24-bit</span>
<span class="cm">sample and the least significant 8 bits are set to 0.</span>
<span class="cm">*/</span>
	<span class="n">HPI_FORMAT_PCM32_SIGNED</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
<span class="cm">/** Raw bitstream - unknown format. */</span>
	<span class="n">HPI_FORMAT_RAW_BITSTREAM</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
<span class="cm">/** TAGIT-1 algorithm hits - extended. */</span>
	<span class="n">HPI_FORMAT_AA_TAGIT1_HITS_EX1</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
<span class="cm">/** 32-bit PCM as an IEEE float. Windows equivalent is WAVE_FORMAT_IEEE_FLOAT.</span>
<span class="cm">Each sample is a 32bit word in IEEE754 floating point format.</span>
<span class="cm">The range is +1.0 to -1.0, which corresponds to digital fullscale.</span>
<span class="cm">*/</span>
	<span class="n">HPI_FORMAT_PCM32_FLOAT</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
<span class="cm">/** 24-bit PCM signed. Windows equivalent is WAVE_FORMAT_PCM. */</span>
	<span class="n">HPI_FORMAT_PCM24_SIGNED</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
<span class="cm">/** OEM format 1 - private. */</span>
	<span class="n">HPI_FORMAT_OEM1</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
<span class="cm">/** OEM format 2 - private. */</span>
	<span class="n">HPI_FORMAT_OEM2</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
<span class="cm">/** Undefined format. */</span>
	<span class="n">HPI_FORMAT_UNDEFINED</span> <span class="o">=</span> <span class="mh">0xffff</span>
<span class="p">};</span>

<span class="cm">/*******************************************/</span>
<span class="cm">/** Stream States</span>
<span class="cm">\ingroup stream</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_STREAM_STATES</span> <span class="p">{</span>
	<span class="cm">/** State stopped - stream is stopped. */</span>
	<span class="n">HPI_STATE_STOPPED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="cm">/** State playing - stream is playing audio. */</span>
	<span class="n">HPI_STATE_PLAYING</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="cm">/** State recording - stream is recording. */</span>
	<span class="n">HPI_STATE_RECORDING</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="cm">/** State drained - playing stream ran out of data to play. */</span>
	<span class="n">HPI_STATE_DRAINED</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="cm">/** State generate sine - to be implemented. */</span>
	<span class="n">HPI_STATE_SINEGEN</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="cm">/** State wait - used for inter-card sync to mean waiting for all</span>
<span class="cm">		cards to be ready. */</span>
	<span class="n">HPI_STATE_WAIT</span> <span class="o">=</span> <span class="mi">6</span>
<span class="p">};</span>
<span class="cm">/*******************************************/</span>
<span class="cm">/** Source node types</span>
<span class="cm">\ingroup mixer</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_SOURCENODES</span> <span class="p">{</span>
	<span class="cm">/** This define can be used instead of 0 to indicate</span>
<span class="cm">	that there is no valid source node. A control that</span>
<span class="cm">	exists on a destination node can be searched for using a source</span>
<span class="cm">	node value of either 0, or HPI_SOURCENODE_NONE */</span>
	<span class="n">HPI_SOURCENODE_NONE</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
	<span class="cm">/** Out Stream (Play) node. */</span>
	<span class="n">HPI_SOURCENODE_OSTREAM</span> <span class="o">=</span> <span class="mi">101</span><span class="p">,</span>
	<span class="cm">/** Line in node - could be analog, AES/EBU or network. */</span>
	<span class="n">HPI_SOURCENODE_LINEIN</span> <span class="o">=</span> <span class="mi">102</span><span class="p">,</span>
	<span class="n">HPI_SOURCENODE_AESEBU_IN</span> <span class="o">=</span> <span class="mi">103</span><span class="p">,</span>	     <span class="cm">/**&lt; AES/EBU input node. */</span>
	<span class="n">HPI_SOURCENODE_TUNER</span> <span class="o">=</span> <span class="mi">104</span><span class="p">,</span>	     <span class="cm">/**&lt; tuner node. */</span>
	<span class="n">HPI_SOURCENODE_RF</span> <span class="o">=</span> <span class="mi">105</span><span class="p">,</span>	     <span class="cm">/**&lt; RF input node. */</span>
	<span class="n">HPI_SOURCENODE_CLOCK_SOURCE</span> <span class="o">=</span> <span class="mi">106</span><span class="p">,</span>   <span class="cm">/**&lt; clock source node. */</span>
	<span class="n">HPI_SOURCENODE_RAW_BITSTREAM</span> <span class="o">=</span> <span class="mi">107</span><span class="p">,</span>  <span class="cm">/**&lt; raw bitstream node. */</span>
	<span class="n">HPI_SOURCENODE_MICROPHONE</span> <span class="o">=</span> <span class="mi">108</span><span class="p">,</span>     <span class="cm">/**&lt; microphone node. */</span>
	<span class="cm">/** Cobranet input node -</span>
<span class="cm">	    Audio samples come from the Cobranet network and into the device. */</span>
	<span class="n">HPI_SOURCENODE_COBRANET</span> <span class="o">=</span> <span class="mi">109</span><span class="p">,</span>
	<span class="n">HPI_SOURCENODE_ANALOG</span> <span class="o">=</span> <span class="mi">110</span><span class="p">,</span>	     <span class="cm">/**&lt; analog input node. */</span>
	<span class="n">HPI_SOURCENODE_ADAPTER</span> <span class="o">=</span> <span class="mi">111</span><span class="p">,</span>	     <span class="cm">/**&lt; adapter node. */</span>
	<span class="cm">/** RTP stream input node - This node is a destination for</span>
<span class="cm">	    packets of RTP audio samples from other devices. */</span>
	<span class="n">HPI_SOURCENODE_RTP_DESTINATION</span> <span class="o">=</span> <span class="mi">112</span><span class="p">,</span>
	<span class="n">HPI_SOURCENODE_INTERNAL</span> <span class="o">=</span> <span class="mi">113</span><span class="p">,</span>	     <span class="cm">/**&lt; node internal to the device. */</span>
	<span class="cm">/* !!!Update this  AND hpidebug.h if you add a new sourcenode type!!! */</span>
	<span class="n">HPI_SOURCENODE_LAST_INDEX</span> <span class="o">=</span> <span class="mi">113</span>	     <span class="cm">/**&lt; largest ID */</span>
		<span class="cm">/* AX6 max sourcenode types = 15 */</span>
<span class="p">};</span>

<span class="cm">/*******************************************/</span>
<span class="cm">/** Destination node types</span>
<span class="cm">\ingroup mixer</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_DESTNODES</span> <span class="p">{</span>
	<span class="cm">/** This define can be used instead of 0 to indicate</span>
<span class="cm">	that there is no valid destination node. A control that</span>
<span class="cm">	exists on a source node can be searched for using a destination</span>
<span class="cm">	node value of either 0, or HPI_DESTNODE_NONE */</span>
	<span class="n">HPI_DESTNODE_NONE</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
	<span class="cm">/** In Stream (Record) node. */</span>
	<span class="n">HPI_DESTNODE_ISTREAM</span> <span class="o">=</span> <span class="mi">201</span><span class="p">,</span>
	<span class="n">HPI_DESTNODE_LINEOUT</span> <span class="o">=</span> <span class="mi">202</span><span class="p">,</span>	     <span class="cm">/**&lt; line out node. */</span>
	<span class="n">HPI_DESTNODE_AESEBU_OUT</span> <span class="o">=</span> <span class="mi">203</span><span class="p">,</span>	     <span class="cm">/**&lt; AES/EBU output node. */</span>
	<span class="n">HPI_DESTNODE_RF</span> <span class="o">=</span> <span class="mi">204</span><span class="p">,</span>		     <span class="cm">/**&lt; RF output node. */</span>
	<span class="n">HPI_DESTNODE_SPEAKER</span> <span class="o">=</span> <span class="mi">205</span><span class="p">,</span>	     <span class="cm">/**&lt; speaker output node. */</span>
	<span class="cm">/** Cobranet output node -</span>
<span class="cm">	    Audio samples from the device are sent out on the Cobranet network.*/</span>
	<span class="n">HPI_DESTNODE_COBRANET</span> <span class="o">=</span> <span class="mi">206</span><span class="p">,</span>
	<span class="n">HPI_DESTNODE_ANALOG</span> <span class="o">=</span> <span class="mi">207</span><span class="p">,</span>	     <span class="cm">/**&lt; analog output node. */</span>
	<span class="cm">/** RTP stream output node - This node is a source for</span>
<span class="cm">	    packets of RTP audio samples that are sent to other devices. */</span>
	<span class="n">HPI_DESTNODE_RTP_SOURCE</span> <span class="o">=</span> <span class="mi">208</span><span class="p">,</span>
	<span class="cm">/* !!!Update this AND hpidebug.h if you add a new destnode type!!! */</span>
	<span class="n">HPI_DESTNODE_LAST_INDEX</span> <span class="o">=</span> <span class="mi">208</span>	     <span class="cm">/**&lt; largest ID */</span>
		<span class="cm">/* AX6 max destnode types = 15 */</span>
<span class="p">};</span>

<span class="cm">/*******************************************/</span>
<span class="cm">/** Mixer control types</span>
<span class="cm">\ingroup mixer</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_CONTROLS</span> <span class="p">{</span>
	<span class="n">HPI_CONTROL_GENERIC</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/**&lt; generic control. */</span>
	<span class="n">HPI_CONTROL_CONNECTION</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/**&lt; A connection between nodes. */</span>
	<span class="n">HPI_CONTROL_VOLUME</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>	      <span class="cm">/**&lt; volume control - works in dB_fs. */</span>
	<span class="n">HPI_CONTROL_METER</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/**&lt; peak meter control. */</span>
	<span class="n">HPI_CONTROL_MUTE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/*mute control - not used at present. */</span>
	<span class="n">HPI_CONTROL_MULTIPLEXER</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>	<span class="cm">/**&lt; multiplexer control. */</span>

	<span class="n">HPI_CONTROL_AESEBU_TRANSMITTER</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="cm">/**&lt; AES/EBU transmitter control */</span>
	<span class="n">HPI_CONTROL_AESEBUTX</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>	<span class="cm">/* HPI_CONTROL_AESEBU_TRANSMITTER */</span>

	<span class="n">HPI_CONTROL_AESEBU_RECEIVER</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="cm">/**&lt; AES/EBU receiver control. */</span>
	<span class="n">HPI_CONTROL_AESEBURX</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>	<span class="cm">/* HPI_CONTROL_AESEBU_RECEIVER */</span>

	<span class="n">HPI_CONTROL_LEVEL</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="cm">/**&lt; level/trim control - works in d_bu. */</span>
	<span class="n">HPI_CONTROL_TUNER</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>	<span class="cm">/**&lt; tuner control. */</span>
<span class="cm">/*      HPI_CONTROL_ONOFFSWITCH =       10 */</span>
	<span class="n">HPI_CONTROL_VOX</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>	<span class="cm">/**&lt; vox control. */</span>
<span class="cm">/*      HPI_CONTROL_AES18_TRANSMITTER = 12 */</span>
<span class="cm">/*      HPI_CONTROL_AES18_RECEIVER = 13 */</span>
<span class="cm">/*      HPI_CONTROL_AES18_BLOCKGENERATOR  = 14 */</span>
	<span class="n">HPI_CONTROL_CHANNEL_MODE</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>	<span class="cm">/**&lt; channel mode control. */</span>

	<span class="n">HPI_CONTROL_BITSTREAM</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>	<span class="cm">/**&lt; bitstream control. */</span>
	<span class="n">HPI_CONTROL_SAMPLECLOCK</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>	<span class="cm">/**&lt; sample clock control. */</span>
	<span class="n">HPI_CONTROL_MICROPHONE</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>	<span class="cm">/**&lt; microphone control. */</span>
	<span class="n">HPI_CONTROL_PARAMETRIC_EQ</span> <span class="o">=</span> <span class="mi">19</span><span class="p">,</span>	<span class="cm">/**&lt; parametric EQ control. */</span>
	<span class="n">HPI_CONTROL_EQUALIZER</span> <span class="o">=</span> <span class="mi">19</span><span class="p">,</span>	<span class="cm">/*HPI_CONTROL_PARAMETRIC_EQ */</span>

	<span class="n">HPI_CONTROL_COMPANDER</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>	<span class="cm">/**&lt; compander control. */</span>
	<span class="n">HPI_CONTROL_COBRANET</span> <span class="o">=</span> <span class="mi">21</span><span class="p">,</span>	<span class="cm">/**&lt; cobranet control. */</span>
	<span class="n">HPI_CONTROL_TONEDETECTOR</span> <span class="o">=</span> <span class="mi">22</span><span class="p">,</span>	<span class="cm">/**&lt; tone detector control. */</span>
	<span class="n">HPI_CONTROL_SILENCEDETECTOR</span> <span class="o">=</span> <span class="mi">23</span><span class="p">,</span>	<span class="cm">/**&lt; silence detector control. */</span>
	<span class="n">HPI_CONTROL_PAD</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>	<span class="cm">/**&lt; tuner PAD control. */</span>
	<span class="n">HPI_CONTROL_SRC</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>	<span class="cm">/**&lt; samplerate converter control. */</span>
	<span class="n">HPI_CONTROL_UNIVERSAL</span> <span class="o">=</span> <span class="mi">26</span><span class="p">,</span>	<span class="cm">/**&lt; universal control. */</span>

<span class="cm">/*  !!! Update this AND hpidebug.h if you add a new control type!!!*/</span>
	<span class="n">HPI_CONTROL_LAST_INDEX</span> <span class="o">=</span> <span class="mi">26</span> <span class="cm">/**&lt;highest control type ID */</span>
<span class="cm">/* WARNING types 256 or greater impact bit packing in all AX6 DSP code */</span>
<span class="p">};</span>

<span class="cm">/*******************************************/</span>
<span class="cm">/** Adapter properties</span>
<span class="cm">These are used in HPI_AdapterSetProperty() and HPI_AdapterGetProperty()</span>
<span class="cm">\ingroup adapter</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_ADAPTER_PROPERTIES</span> <span class="p">{</span>
<span class="cm">/** \internal Used in dwProperty field of HPI_AdapterSetProperty() and</span>
<span class="cm">HPI_AdapterGetProperty(). This errata applies to all ASI6000 cards with both</span>
<span class="cm">analog and digital outputs. The CS4224 A/D+D/A has a one sample delay between</span>
<span class="cm">left and right channels on both its input (ADC) and output (DAC).</span>
<span class="cm">More details are available in Cirrus Logic errata ER284B2.</span>
<span class="cm">PDF available from www.cirrus.com, released by Cirrus in 2001.</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_ERRATA_1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

<span class="cm">/** Adapter grouping property</span>
<span class="cm">Indicates whether the adapter supports the grouping API (for ASIO and SSX2)</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_GROUPING</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>

<span class="cm">/** Driver SSX2 property</span>
<span class="cm">Tells the kernel driver to turn on SSX2 stream mapping.</span>
<span class="cm">This feature is not used by the DSP. In fact the call is completely processed</span>
<span class="cm">by the driver and is not passed on to the DSP at all.</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_ENABLE_SSX2</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>

<span class="cm">/** Adapter SSX2 property</span>
<span class="cm">Indicates the state of the adapter&#39;s SSX2 setting. This setting is stored in</span>
<span class="cm">non-volatile memory on the adapter. A typical call sequence would be to use</span>
<span class="cm">HPI_ADAPTER_PROPERTY_SSX2_SETTING to set SSX2 on the adapter and then to reload</span>
<span class="cm">the driver. The driver would query HPI_ADAPTER_PROPERTY_SSX2_SETTING during</span>
<span class="cm">startup and if SSX2 is set, it would then call HPI_ADAPTER_PROPERTY_ENABLE_SSX2</span>
<span class="cm">to enable SSX2 stream mapping within the kernel level of the driver.</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_SSX2_SETTING</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>

<span class="cm">/** Enables/disables PCI(e) IRQ.</span>
<span class="cm">A setting of 0 indicates that no interrupts are being generated. A DSP boot</span>
<span class="cm">this property is set to 0. Setting to a non-zero value specifies the number</span>
<span class="cm">of frames of audio that should be processed between interrupts. This property</span>
<span class="cm">should be set to multiple of the mixer interval as read back from the</span>
<span class="cm">HPI_ADAPTER_PROPERTY_INTERVAL property.</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_IRQ_RATE</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>

<span class="cm">/** Base number for readonly properties */</span>
	<span class="n">HPI_ADAPTER_PROPERTY_READONLYBASE</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>

<span class="cm">/** Readonly adapter latency property.</span>
<span class="cm">This property returns in the input and output latency in samples.</span>
<span class="cm">Property 1 is the estimated input latency</span>
<span class="cm">in samples, while Property 2 is that output latency in  samples.</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_LATENCY</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>

<span class="cm">/** Readonly adapter granularity property.</span>
<span class="cm">The granulariy is the smallest size chunk of stereo samples that is processed by</span>
<span class="cm">the adapter.</span>
<span class="cm">This property returns the record granularity in samples in Property 1.</span>
<span class="cm">Property 2 returns the play granularity.</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_GRANULARITY</span> <span class="o">=</span> <span class="mi">257</span><span class="p">,</span>

<span class="cm">/** Readonly adapter number of current channels property.</span>
<span class="cm">Property 1 is the number of record channels per record device.</span>
<span class="cm">Property 2 is the number of play channels per playback device.*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_CURCHANNELS</span> <span class="o">=</span> <span class="mi">258</span><span class="p">,</span>

<span class="cm">/** Readonly adapter software version.</span>
<span class="cm">The SOFTWARE_VERSION property returns the version of the software running</span>
<span class="cm">on the adapter as Major.Minor.Release.</span>
<span class="cm">Property 1 contains Major in bits 15..8 and Minor in bits 7..0.</span>
<span class="cm">Property 2 contains Release in bits 7..0. */</span>
	<span class="n">HPI_ADAPTER_PROPERTY_SOFTWARE_VERSION</span> <span class="o">=</span> <span class="mi">259</span><span class="p">,</span>

<span class="cm">/** Readonly adapter MAC address MSBs.</span>
<span class="cm">The MAC_ADDRESS_MSB property returns</span>
<span class="cm">the most significant 32 bits of the MAC address.</span>
<span class="cm">Property 1 contains bits 47..32 of the MAC address.</span>
<span class="cm">Property 2 contains bits 31..16 of the MAC address. */</span>
	<span class="n">HPI_ADAPTER_PROPERTY_MAC_ADDRESS_MSB</span> <span class="o">=</span> <span class="mi">260</span><span class="p">,</span>

<span class="cm">/** Readonly adapter MAC address LSBs</span>
<span class="cm">The MAC_ADDRESS_LSB property returns</span>
<span class="cm">the least significant 16 bits of the MAC address.</span>
<span class="cm">Property 1 contains bits 15..0 of the MAC address. */</span>
	<span class="n">HPI_ADAPTER_PROPERTY_MAC_ADDRESS_LSB</span> <span class="o">=</span> <span class="mi">261</span><span class="p">,</span>

<span class="cm">/** Readonly extended adapter type number</span>
<span class="cm">The EXTENDED_ADAPTER_TYPE property returns the 4 digits of an extended</span>
<span class="cm">adapter type, i.e ASI8920-0022, 0022 is the extended type.</span>
<span class="cm">The digits are returned as ASCII characters rather than the hex digits that</span>
<span class="cm">are returned for the main type</span>
<span class="cm">Property 1 returns the 1st two (left most) digits, i.e &quot;00&quot;</span>
<span class="cm">in the example above, the upper byte being the left most digit.</span>
<span class="cm">Property 2 returns the 2nd two digits, i.e &quot;22&quot; in the example above*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_EXTENDED_ADAPTER_TYPE</span> <span class="o">=</span> <span class="mi">262</span><span class="p">,</span>

<span class="cm">/** Readonly debug log buffer information */</span>
	<span class="n">HPI_ADAPTER_PROPERTY_LOGTABLEN</span> <span class="o">=</span> <span class="mi">263</span><span class="p">,</span>
	<span class="n">HPI_ADAPTER_PROPERTY_LOGTABBEG</span> <span class="o">=</span> <span class="mi">264</span><span class="p">,</span>

<span class="cm">/** Readonly adapter IP address</span>
<span class="cm">For 192.168.1.101</span>
<span class="cm">Property 1 returns the 1st two (left most) digits, i.e 192*256 + 168</span>
<span class="cm">in the example above, the upper byte being the left most digit.</span>
<span class="cm">Property 2 returns the 2nd two digits, i.e 1*256 + 101 in the example above, */</span>
	<span class="n">HPI_ADAPTER_PROPERTY_IP_ADDRESS</span> <span class="o">=</span> <span class="mi">265</span><span class="p">,</span>

<span class="cm">/** Readonly adapter buffer processed count. Returns a buffer processed count</span>
<span class="cm">that is incremented every time all buffers for all streams are updated. This</span>
<span class="cm">is useful for checking completion of all stream operations across the adapter</span>
<span class="cm">when using grouped streams.</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_BUFFER_UPDATE_COUNT</span> <span class="o">=</span> <span class="mi">266</span><span class="p">,</span>

<span class="cm">/** Readonly mixer and stream intervals</span>

<span class="cm">These intervals are  measured in mixer frames.</span>
<span class="cm">To convert to time, divide  by the adapter samplerate.</span>

<span class="cm">The mixer interval is the number of frames processed in one mixer iteration.</span>
<span class="cm">The stream update interval is the interval at which streams check for and</span>
<span class="cm">process data, and BBM host buffer counters are updated.</span>

<span class="cm">Property 1 is the mixer interval in mixer frames.</span>
<span class="cm">Property 2 is the stream update interval in mixer frames.</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_INTERVAL</span> <span class="o">=</span> <span class="mi">267</span><span class="p">,</span>
<span class="cm">/** Adapter capabilities 1</span>
<span class="cm">Property 1 - adapter can do multichannel (SSX1)</span>
<span class="cm">Property 2 - adapter can do stream grouping (supports SSX2)</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_CAPS1</span> <span class="o">=</span> <span class="mi">268</span><span class="p">,</span>
<span class="cm">/** Adapter capabilities 2</span>
<span class="cm">Property 1 - adapter can do samplerate conversion (MRX)</span>
<span class="cm">Property 2 - adapter can do timestretch (TSX)</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_CAPS2</span> <span class="o">=</span> <span class="mi">269</span><span class="p">,</span>

<span class="cm">/** Readonly adapter sync header connection count.</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_SYNC_HEADER_CONNECTIONS</span> <span class="o">=</span> <span class="mi">270</span><span class="p">,</span>
<span class="cm">/** Readonly supports SSX2 property.</span>
<span class="cm">Indicates the adapter supports SSX2 in some mode setting. The</span>
<span class="cm">return value is true (1) or false (0). If the current adapter</span>
<span class="cm">mode is MONO SSX2 is disabled, even though this property will</span>
<span class="cm">return true.</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_SUPPORTS_SSX2</span> <span class="o">=</span> <span class="mi">271</span><span class="p">,</span>
<span class="cm">/** Readonly supports PCI(e) IRQ.</span>
<span class="cm">Indicates that the adapter in it&#39;s current mode supports interrupts</span>
<span class="cm">across the host bus. Note, this does not imply that interrupts are</span>
<span class="cm">enabled. Instead it indicates that they can be enabled.</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_SUPPORTS_IRQ</span> <span class="o">=</span> <span class="mi">272</span><span class="p">,</span>
<span class="cm">/** Readonly supports firmware updating.</span>
<span class="cm">Indicates that the adapter implements an interface to update firmware</span>
<span class="cm">on the adapter.</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_SUPPORTS_FW_UPDATE</span> <span class="o">=</span> <span class="mi">273</span><span class="p">,</span>
<span class="cm">/** Readonly Firmware IDs</span>
<span class="cm">Identifiy firmware independent of individual adapter type.</span>
<span class="cm">May be used as a filter for firmware update images.</span>
<span class="cm">Property 1 = Bootloader ID</span>
<span class="cm">Property 2 = Main program ID</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_PROPERTY_FIRMWARE_ID</span> <span class="o">=</span> <span class="mi">274</span>
<span class="p">};</span>

<span class="cm">/** Adapter mode commands</span>

<span class="cm">Used in wQueryOrSet parameter of HPI_AdapterSetModeEx().</span>
<span class="cm">\ingroup adapter</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_ADAPTER_MODE_CMDS</span> <span class="p">{</span>
	<span class="cm">/** Set the mode to the given parameter */</span>
	<span class="n">HPI_ADAPTER_MODE_SET</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="cm">/** Return 0 or error depending whether mode is valid,</span>
<span class="cm">	but don&#39;t set the mode */</span>
	<span class="n">HPI_ADAPTER_MODE_QUERY</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="cm">/** Adapter Modes</span>
<span class="cm"> These are used by HPI_AdapterSetModeEx()</span>

<span class="cm">\warning - more than 16 possible modes breaks</span>
<span class="cm">a bitmask in the Windows WAVE DLL</span>
<span class="cm">\ingroup adapter</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_ADAPTER_MODES</span> <span class="p">{</span>
<span class="cm">/** 4 outstream mode.</span>
<span class="cm">- ASI6114: 1 instream</span>
<span class="cm">- ASI6044: 4 instreams</span>
<span class="cm">- ASI6012: 1 instream</span>
<span class="cm">- ASI6102: no instreams</span>
<span class="cm">- ASI6022, ASI6122: 2 instreams</span>
<span class="cm">- ASI5111, ASI5101: 2 instreams</span>
<span class="cm">- ASI652x, ASI662x: 2 instreams</span>
<span class="cm">- ASI654x, ASI664x: 4 instreams</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_MODE_4OSTREAM</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

<span class="cm">/** 6 outstream mode.</span>
<span class="cm">- ASI6012: 1 instream,</span>
<span class="cm">- ASI6022, ASI6122: 2 instreams</span>
<span class="cm">- ASI652x, ASI662x: 4 instreams</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_MODE_6OSTREAM</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>

<span class="cm">/** 8 outstream mode.</span>
<span class="cm">- ASI6114: 8 instreams</span>
<span class="cm">- ASI6118: 8 instreams</span>
<span class="cm">- ASI6585: 8 instreams</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_MODE_8OSTREAM</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>

<span class="cm">/** 16 outstream mode.</span>
<span class="cm">- ASI6416 16 instreams</span>
<span class="cm">- ASI6518, ASI6618 16 instreams</span>
<span class="cm">- ASI6118 16 mono out and in streams</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_MODE_16OSTREAM</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>

<span class="cm">/** one outstream mode.</span>
<span class="cm">- ASI5111 1 outstream, 1 instream</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_MODE_1OSTREAM</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>

<span class="cm">/** ASI504X mode 1. 12 outstream, 4 instream 0 to 48kHz sample rates</span>
<span class="cm">	(see ASI504X datasheet for more info).</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_MODE_1</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>

<span class="cm">/** ASI504X mode 2. 4 outstreams, 4 instreams at 0 to 192kHz sample rates</span>
<span class="cm">	(see ASI504X datasheet for more info).</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_MODE_2</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>

<span class="cm">/** ASI504X mode 3. 4 outstreams, 4 instreams at 0 to 192kHz sample rates</span>
<span class="cm">	(see ASI504X datasheet for more info).</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_MODE_3</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>

<span class="cm">/** ASI504X multichannel mode.</span>
<span class="cm">	2 outstreams -&gt; 4 line outs = 1 to 8 channel streams),</span>
<span class="cm">	4 lineins -&gt; 1 instream (1 to 8 channel streams) at 0-48kHz.</span>
<span class="cm">	For more info see the SSX Specification.</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_MODE_MULTICHANNEL</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>

<span class="cm">/** 12 outstream mode.</span>
<span class="cm">- ASI6514, ASI6614: 2 instreams</span>
<span class="cm">- ASI6540,ASI6544: 8 instreams</span>
<span class="cm">- ASI6640,ASI6644: 8 instreams</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_MODE_12OSTREAM</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>

<span class="cm">/** 9 outstream mode.</span>
<span class="cm">- ASI6044: 8 instreams</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_MODE_9OSTREAM</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>

<span class="cm">/** mono mode.</span>
<span class="cm">- ASI6416: 16 outstreams/instreams</span>
<span class="cm">- ASI5402: 2 outstreams/instreams</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_MODE_MONO</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>

<span class="cm">/** Low latency mode.</span>
<span class="cm">- ASI6416/ASI6316: 1 16 channel outstream and instream</span>
<span class="cm">*/</span>
	<span class="n">HPI_ADAPTER_MODE_LOW_LATENCY</span> <span class="o">=</span> <span class="mi">13</span>
<span class="p">};</span>

<span class="cm">/* Note, adapters can have more than one capability -</span>
<span class="cm">encoding as bitfield is recommended. */</span>
<span class="cp">#define HPI_CAPABILITY_NONE             (0)</span>
<span class="cp">#define HPI_CAPABILITY_MPEG_LAYER3      (1)</span>

<span class="cm">/* Set this equal to maximum capability index,</span>
<span class="cm">Must not be greater than 32 - see axnvdef.h */</span>
<span class="cp">#define HPI_CAPABILITY_MAX                      1</span>
<span class="cm">/* #define HPI_CAPABILITY_AAC              2 */</span>

<span class="cm">/******************************************* STREAM ATTRIBUTES ****/</span>

<span class="cm">/** MPEG Ancillary Data modes</span>

<span class="cm">The mode for the ancillary data insertion or extraction to operate in.</span>
<span class="cm">\ingroup stream</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_MPEG_ANC_MODES</span> <span class="p">{</span>
	<span class="cm">/** the MPEG frames have energy information stored in them (5 bytes per stereo frame, 3 per mono) */</span>
	<span class="n">HPI_MPEG_ANC_HASENERGY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="cm">/** the entire ancillary data field is taken up by data from the Anc data buffer</span>
<span class="cm">	On encode, the encoder will insert the energy bytes before filling the remainder</span>
<span class="cm">	of the ancillary data space with data from the ancillary data buffer.</span>
<span class="cm">	*/</span>
	<span class="n">HPI_MPEG_ANC_RAW</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="cm">/** Ancillary Data Alignment</span>
<span class="cm">\ingroup instream</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_ISTREAM_MPEG_ANC_ALIGNS</span> <span class="p">{</span>
	<span class="cm">/** data is packed against the end of data, then padded to the end of frame */</span>
	<span class="n">HPI_MPEG_ANC_ALIGN_LEFT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="cm">/** data is packed against the end of the frame */</span>
	<span class="n">HPI_MPEG_ANC_ALIGN_RIGHT</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="cm">/** MPEG modes</span>
<span class="cm">MPEG modes - can be used optionally for HPI_FormatCreate()</span>
<span class="cm">parameter dwAttributes.</span>

<span class="cm">Using any mode setting other than HPI_MPEG_MODE_DEFAULT</span>
<span class="cm">with single channel format will return an error.</span>
<span class="cm">\ingroup stream</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_MPEG_MODES</span> <span class="p">{</span>
<span class="cm">/** Causes the MPEG-1 Layer II bitstream to be recorded</span>
<span class="cm">in single_channel mode when the number of channels is 1 and in stereo when the</span>
<span class="cm">number of channels is 2. */</span>
	<span class="n">HPI_MPEG_MODE_DEFAULT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="cm">/** Standard stereo without joint-stereo compression */</span>
	<span class="n">HPI_MPEG_MODE_STEREO</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="cm">/** Joint stereo  */</span>
	<span class="n">HPI_MPEG_MODE_JOINTSTEREO</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="cm">/** Left and Right channels are completely independent */</span>
	<span class="n">HPI_MPEG_MODE_DUALCHANNEL</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">};</span>
<span class="cm">/******************************************* MIXER ATTRIBUTES ****/</span>

<span class="cm">/* \defgroup mixer_flags Mixer flags for HPI_MIXER_GET_CONTROL_MULTIPLE_VALUES</span>
<span class="cm">{</span>
<span class="cm">*/</span>
<span class="cp">#define HPI_MIXER_GET_CONTROL_MULTIPLE_CHANGED  (0)</span>
<span class="cp">#define HPI_MIXER_GET_CONTROL_MULTIPLE_RESET    (1)</span>
<span class="cm">/*}*/</span>

<span class="cm">/** Commands used by HPI_MixerStore()</span>
<span class="cm">\ingroup mixer</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_MIXER_STORE_COMMAND</span> <span class="p">{</span>
<span class="cm">/** Save all mixer control settings. */</span>
	<span class="n">HPI_MIXER_STORE_SAVE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="cm">/** Restore all controls from saved. */</span>
	<span class="n">HPI_MIXER_STORE_RESTORE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="cm">/** Delete saved control settings. */</span>
	<span class="n">HPI_MIXER_STORE_DELETE</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="cm">/** Enable auto storage of some control settings. */</span>
	<span class="n">HPI_MIXER_STORE_ENABLE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="cm">/** Disable auto storage of some control settings. */</span>
	<span class="n">HPI_MIXER_STORE_DISABLE</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="cm">/** Unimplemented - save the attributes of a single control. */</span>
	<span class="n">HPI_MIXER_STORE_SAVE_SINGLE</span> <span class="o">=</span> <span class="mi">6</span>
<span class="p">};</span>

<span class="cm">/****************************/</span>
<span class="cm">/* CONTROL ATTRIBUTE VALUES */</span>
<span class="cm">/****************************/</span>

<span class="cm">/** Used by mixer plugin enable functions</span>

<span class="cm">E.g. HPI_ParametricEq_SetState()</span>
<span class="cm">\ingroup mixer</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_SWITCH_STATES</span> <span class="p">{</span>
	<span class="n">HPI_SWITCH_OFF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/**&lt; turn the mixer plugin on. */</span>
	<span class="n">HPI_SWITCH_ON</span> <span class="o">=</span> <span class="mi">1</span>	<span class="cm">/**&lt; turn the mixer plugin off. */</span>
<span class="p">};</span>

<span class="cm">/* Volume control special gain values */</span>

<span class="cm">/** volumes units are 100ths of a dB</span>
<span class="cm">\ingroup volume</span>
<span class="cm">*/</span>
<span class="cp">#define HPI_UNITS_PER_dB                100</span>
<span class="cm">/** turns volume control OFF or MUTE</span>
<span class="cm">\ingroup volume</span>
<span class="cm">*/</span>
<span class="cp">#define HPI_GAIN_OFF                    (-100 * HPI_UNITS_PER_dB)</span>

<span class="cm">/** channel mask specifying all channels</span>
<span class="cm">\ingroup volume</span>
<span class="cm">*/</span>
<span class="cp">#define HPI_BITMASK_ALL_CHANNELS        (0xFFFFFFFF)</span>

<span class="cm">/** value returned for no signal</span>
<span class="cm">\ingroup meter</span>
<span class="cm">*/</span>
<span class="cp">#define HPI_METER_MINIMUM               (-150 * HPI_UNITS_PER_dB)</span>

<span class="cm">/** autofade profiles</span>
<span class="cm">\ingroup volume</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_VOLUME_AUTOFADES</span> <span class="p">{</span>
<span class="cm">/** log fade - dB attenuation changes linearly over time */</span>
	<span class="n">HPI_VOLUME_AUTOFADE_LOG</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="cm">/** linear fade - amplitude changes linearly */</span>
	<span class="n">HPI_VOLUME_AUTOFADE_LINEAR</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">};</span>

<span class="cm">/** The physical encoding format of the AESEBU I/O.</span>

<span class="cm">Used in HPI_Aesebu_Transmitter_SetFormat(), HPI_Aesebu_Receiver_SetFormat()</span>
<span class="cm">along with related Get and Query functions</span>
<span class="cm">\ingroup aestx</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_AESEBU_FORMATS</span> <span class="p">{</span>
<span class="cm">/** AES/EBU physical format - AES/EBU balanced &quot;professional&quot;  */</span>
	<span class="n">HPI_AESEBU_FORMAT_AESEBU</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="cm">/** AES/EBU physical format - S/PDIF unbalanced &quot;consumer&quot;      */</span>
	<span class="n">HPI_AESEBU_FORMAT_SPDIF</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="cm">/** AES/EBU error status bits</span>

<span class="cm">Returned by HPI_Aesebu_Receiver_GetErrorStatus()</span>
<span class="cm">\ingroup aesrx</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_AESEBU_ERRORS</span> <span class="p">{</span>
<span class="cm">/**  bit0: 1 when PLL is not locked */</span>
	<span class="n">HPI_AESEBU_ERROR_NOT_LOCKED</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
<span class="cm">/**  bit1: 1 when signal quality is poor */</span>
	<span class="n">HPI_AESEBU_ERROR_POOR_QUALITY</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
<span class="cm">/** bit2: 1 when there is a parity error */</span>
	<span class="n">HPI_AESEBU_ERROR_PARITY_ERROR</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
<span class="cm">/**  bit3: 1 when there is a bi-phase coding violation */</span>
	<span class="n">HPI_AESEBU_ERROR_BIPHASE_VIOLATION</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
<span class="cm">/**  bit4: 1 when the validity bit is high */</span>
	<span class="n">HPI_AESEBU_ERROR_VALIDITY</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
<span class="cm">/**  bit5: 1 when the CRC error bit is high */</span>
	<span class="n">HPI_AESEBU_ERROR_CRC</span> <span class="o">=</span> <span class="mh">0x20</span>
<span class="p">};</span>

<span class="cm">/** \addtogroup pad</span>
<span class="cm">\{</span>
<span class="cm">*/</span>
<span class="cm">/** The text string containing the station/channel combination. */</span>
<span class="cp">#define HPI_PAD_CHANNEL_NAME_LEN        16</span>
<span class="cm">/** The text string containing the artist. */</span>
<span class="cp">#define HPI_PAD_ARTIST_LEN              64</span>
<span class="cm">/** The text string containing the title. */</span>
<span class="cp">#define HPI_PAD_TITLE_LEN               64</span>
<span class="cm">/** The text string containing the comment. */</span>
<span class="cp">#define HPI_PAD_COMMENT_LEN             256</span>
<span class="cm">/** The PTY when the tuner has not received any PTY. */</span>
<span class="cp">#define HPI_PAD_PROGRAM_TYPE_INVALID    0xffff</span>
<span class="cm">/** \} */</span>

<span class="cm">/** Data types for PTY string translation.</span>
<span class="cm">\ingroup rds</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">eHPI_RDS_type</span> <span class="p">{</span>
	<span class="n">HPI_RDS_DATATYPE_RDS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/**&lt; RDS bitstream.*/</span>
	<span class="n">HPI_RDS_DATATYPE_RBDS</span> <span class="o">=</span> <span class="mi">1</span>	<span class="cm">/**&lt; RBDS bitstream.*/</span>
<span class="p">};</span>

<span class="cm">/** Tuner bands</span>

<span class="cm">Used for HPI_Tuner_SetBand(),HPI_Tuner_GetBand()</span>
<span class="cm">\ingroup tuner</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_TUNER_BAND</span> <span class="p">{</span>
	<span class="n">HPI_TUNER_BAND_AM</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	 <span class="cm">/**&lt; AM band */</span>
	<span class="n">HPI_TUNER_BAND_FM</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>	 <span class="cm">/**&lt; FM band (mono) */</span>
	<span class="n">HPI_TUNER_BAND_TV_NTSC_M</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>	 <span class="cm">/**&lt; NTSC-M TV band*/</span>
	<span class="n">HPI_TUNER_BAND_TV</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* use TV_NTSC_M */</span>
	<span class="n">HPI_TUNER_BAND_FM_STEREO</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>	 <span class="cm">/**&lt; FM band (stereo) */</span>
	<span class="n">HPI_TUNER_BAND_AUX</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>	 <span class="cm">/**&lt; auxiliary input */</span>
	<span class="n">HPI_TUNER_BAND_TV_PAL_BG</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>	 <span class="cm">/**&lt; PAL-B/G TV band*/</span>
	<span class="n">HPI_TUNER_BAND_TV_PAL_I</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>	 <span class="cm">/**&lt; PAL-I TV band*/</span>
	<span class="n">HPI_TUNER_BAND_TV_PAL_DK</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>	 <span class="cm">/**&lt; PAL-D/K TV band*/</span>
	<span class="n">HPI_TUNER_BAND_TV_SECAM_L</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>	 <span class="cm">/**&lt; SECAM-L TV band*/</span>
	<span class="n">HPI_TUNER_BAND_LAST</span> <span class="o">=</span> <span class="mi">9</span>	<span class="cm">/**&lt; the index of the last tuner band. */</span>
<span class="p">};</span>

<span class="cm">/** Tuner mode attributes</span>

<span class="cm">Used by HPI_Tuner_SetMode(), HPI_Tuner_GetMode()</span>
<span class="cm">\ingroup tuner</span>

<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_TUNER_MODES</span> <span class="p">{</span>
	<span class="n">HPI_TUNER_MODE_RSS</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/**&lt; control  RSS */</span>
	<span class="n">HPI_TUNER_MODE_RDS</span> <span class="o">=</span> <span class="mi">2</span>	<span class="cm">/**&lt; control  RBDS/RDS */</span>
<span class="p">};</span>

<span class="cm">/** Tuner mode attribute values</span>

<span class="cm">Used by HPI_Tuner_SetMode(), HPI_Tuner_GetMode()</span>
<span class="cm">\ingroup tuner</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_TUNER_MODE_VALUES</span> <span class="p">{</span>
<span class="cm">/* RSS attribute values */</span>
	<span class="n">HPI_TUNER_MODE_RSS_DISABLE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/**&lt; RSS disable */</span>
	<span class="n">HPI_TUNER_MODE_RSS_ENABLE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/**&lt; RSS enable */</span>

<span class="cm">/* RDS mode attributes */</span>
	<span class="n">HPI_TUNER_MODE_RDS_DISABLE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/**&lt; RDS - disabled */</span>
	<span class="n">HPI_TUNER_MODE_RDS_RDS</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="cm">/**&lt; RDS - RDS mode */</span>
	<span class="n">HPI_TUNER_MODE_RDS_RBDS</span> <span class="o">=</span> <span class="mi">2</span> <span class="cm">/**&lt;  RDS - RBDS mode */</span>
<span class="p">};</span>

<span class="cm">/** Tuner Status Bits</span>

<span class="cm">These bitfield values are returned by a call to HPI_Tuner_GetStatus().</span>
<span class="cm">Multiple fields are returned from a single call.</span>
<span class="cm">\ingroup tuner</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_TUNER_STATUS_BITS</span> <span class="p">{</span>
	<span class="n">HPI_TUNER_VIDEO_COLOR_PRESENT</span> <span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span>	<span class="cm">/**&lt; video color is present. */</span>
	<span class="n">HPI_TUNER_VIDEO_IS_60HZ</span> <span class="o">=</span> <span class="mh">0x0020</span><span class="p">,</span> <span class="cm">/**&lt; 60 hz video detected. */</span>
	<span class="n">HPI_TUNER_VIDEO_HORZ_SYNC_MISSING</span> <span class="o">=</span> <span class="mh">0x0040</span><span class="p">,</span> <span class="cm">/**&lt; video HSYNC is missing. */</span>
	<span class="n">HPI_TUNER_VIDEO_STATUS_VALID</span> <span class="o">=</span> <span class="mh">0x0100</span><span class="p">,</span> <span class="cm">/**&lt; video status is valid. */</span>
	<span class="n">HPI_TUNER_DIGITAL</span> <span class="o">=</span> <span class="mh">0x0200</span><span class="p">,</span> <span class="cm">/**&lt; tuner reports digital programming. */</span>
	<span class="n">HPI_TUNER_MULTIPROGRAM</span> <span class="o">=</span> <span class="mh">0x0400</span><span class="p">,</span> <span class="cm">/**&lt; tuner reports multiple programs. */</span>
	<span class="n">HPI_TUNER_PLL_LOCKED</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="cm">/**&lt; the tuner&#39;s PLL is locked. */</span>
	<span class="n">HPI_TUNER_FM_STEREO</span> <span class="o">=</span> <span class="mh">0x2000</span> <span class="cm">/**&lt; tuner reports back FM stereo. */</span>
<span class="p">};</span>

<span class="cm">/** Channel Modes</span>
<span class="cm">Used for HPI_ChannelModeSet/Get()</span>
<span class="cm">\ingroup channelmode</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_CHANNEL_MODES</span> <span class="p">{</span>
<span class="cm">/** Left channel out = left channel in, Right channel out = right channel in. */</span>
	<span class="n">HPI_CHANNEL_MODE_NORMAL</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="cm">/** Left channel out = right channel in, Right channel out = left channel in. */</span>
	<span class="n">HPI_CHANNEL_MODE_SWAP</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="cm">/** Left channel out = left channel in, Right channel out = left channel in. */</span>
	<span class="n">HPI_CHANNEL_MODE_LEFT_TO_STEREO</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="cm">/** Left channel out = right channel in, Right channel out = right channel in.*/</span>
	<span class="n">HPI_CHANNEL_MODE_RIGHT_TO_STEREO</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="cm">/** Left channel out = (left channel in + right channel in)/2,</span>
<span class="cm">    Right channel out = mute. */</span>
	<span class="n">HPI_CHANNEL_MODE_STEREO_TO_LEFT</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="cm">/** Left channel out = mute,</span>
<span class="cm">    Right channel out = (right channel in + left channel in)/2. */</span>
	<span class="n">HPI_CHANNEL_MODE_STEREO_TO_RIGHT</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">HPI_CHANNEL_MODE_LAST</span> <span class="o">=</span> <span class="mi">6</span>
<span class="p">};</span>

<span class="cm">/** SampleClock source values</span>
<span class="cm">\ingroup sampleclock</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_SAMPLECLOCK_SOURCES</span> <span class="p">{</span>
<span class="cm">/** The sampleclock output is derived from its local samplerate generator.</span>
<span class="cm">    The local samplerate may be set using HPI_SampleClock_SetLocalRate(). */</span>
	<span class="n">HPI_SAMPLECLOCK_SOURCE_LOCAL</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="cm">/** The adapter is clocked from a dedicated AES/EBU SampleClock input.*/</span>
	<span class="n">HPI_SAMPLECLOCK_SOURCE_AESEBU_SYNC</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="cm">/** From external wordclock connector */</span>
	<span class="n">HPI_SAMPLECLOCK_SOURCE_WORD</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="cm">/** Board-to-board header */</span>
	<span class="n">HPI_SAMPLECLOCK_SOURCE_WORD_HEADER</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="cm">/** FUTURE - SMPTE clock. */</span>
	<span class="n">HPI_SAMPLECLOCK_SOURCE_SMPTE</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="cm">/** One of the aesebu inputs */</span>
	<span class="n">HPI_SAMPLECLOCK_SOURCE_AESEBU_INPUT</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<span class="cm">/** From a network interface e.g. Cobranet or Livewire at either 48 or 96kHz */</span>
	<span class="n">HPI_SAMPLECLOCK_SOURCE_NETWORK</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
<span class="cm">/** From previous adjacent module (ASI2416 only)*/</span>
	<span class="n">HPI_SAMPLECLOCK_SOURCE_PREV_MODULE</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
<span class="cm">/*! Update this if you add a new clock source.*/</span>
	<span class="n">HPI_SAMPLECLOCK_SOURCE_LAST</span> <span class="o">=</span> <span class="mi">10</span>
<span class="p">};</span>

<span class="cm">/** Equalizer filter types. Used by HPI_ParametricEq_SetBand()</span>
<span class="cm">\ingroup parmeq</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_FILTER_TYPE</span> <span class="p">{</span>
	<span class="n">HPI_FILTER_TYPE_BYPASS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/**&lt; filter is turned off */</span>

	<span class="n">HPI_FILTER_TYPE_LOWSHELF</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/**&lt; EQ low shelf */</span>
	<span class="n">HPI_FILTER_TYPE_HIGHSHELF</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/**&lt; EQ high shelf */</span>
	<span class="n">HPI_FILTER_TYPE_EQ_BAND</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/**&lt; EQ gain */</span>

	<span class="n">HPI_FILTER_TYPE_LOWPASS</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/**&lt; standard low pass */</span>
	<span class="n">HPI_FILTER_TYPE_HIGHPASS</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>	<span class="cm">/**&lt; standard high pass */</span>
	<span class="n">HPI_FILTER_TYPE_BANDPASS</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>	<span class="cm">/**&lt; standard band pass */</span>
	<span class="n">HPI_FILTER_TYPE_BANDSTOP</span> <span class="o">=</span> <span class="mi">7</span>	<span class="cm">/**&lt; standard band stop/notch */</span>
<span class="p">};</span>

<span class="cm">/** Async Event sources</span>
<span class="cm">\ingroup async</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">ASYNC_EVENT_SOURCES</span> <span class="p">{</span>
	<span class="n">HPI_ASYNC_EVENT_GPIO</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/**&lt; GPIO event. */</span>
	<span class="n">HPI_ASYNC_EVENT_SILENCE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/**&lt; silence event detected. */</span>
	<span class="n">HPI_ASYNC_EVENT_TONE</span> <span class="o">=</span> <span class="mi">3</span>	<span class="cm">/**&lt; tone event detected. */</span>
<span class="p">};</span>
<span class="cm">/*******************************************/</span>
<span class="cm">/** HPI Error codes</span>

<span class="cm">Almost all HPI functions return an error code</span>
<span class="cm">A return value of zero means there was no error.</span>
<span class="cm">Otherwise one of these error codes is returned.</span>
<span class="cm">Error codes can be converted to a descriptive string using HPI_GetErrorText()</span>

<span class="cm">\note When a new error code is added HPI_GetErrorText() MUST be updated.</span>
<span class="cm">\note Codes 1-100 are reserved for driver use</span>
<span class="cm">\ingroup utility</span>
<span class="cm">*/</span>
<span class="k">enum</span> <span class="n">HPI_ERROR_CODES</span> <span class="p">{</span>
	<span class="cm">/** Message type does not exist. */</span>
	<span class="n">HPI_ERROR_INVALID_TYPE</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
	<span class="cm">/** Object type does not exist. */</span>
	<span class="n">HPI_ERROR_INVALID_OBJ</span> <span class="o">=</span> <span class="mi">101</span><span class="p">,</span>
	<span class="cm">/** Function does not exist. */</span>
	<span class="n">HPI_ERROR_INVALID_FUNC</span> <span class="o">=</span> <span class="mi">102</span><span class="p">,</span>
	<span class="cm">/** The specified object does not exist. */</span>
	<span class="n">HPI_ERROR_INVALID_OBJ_INDEX</span> <span class="o">=</span> <span class="mi">103</span><span class="p">,</span>
	<span class="cm">/** Trying to access an object that has not been opened yet. */</span>
	<span class="n">HPI_ERROR_OBJ_NOT_OPEN</span> <span class="o">=</span> <span class="mi">104</span><span class="p">,</span>
	<span class="cm">/** Trying to open an already open object. */</span>
	<span class="n">HPI_ERROR_OBJ_ALREADY_OPEN</span> <span class="o">=</span> <span class="mi">105</span><span class="p">,</span>
	<span class="cm">/** PCI, ISA resource not valid. */</span>
	<span class="n">HPI_ERROR_INVALID_RESOURCE</span> <span class="o">=</span> <span class="mi">106</span><span class="p">,</span>
	<span class="cm">/* HPI_ERROR_SUBSYSFINDADAPTERS_GETINFO= 107 */</span>
	<span class="cm">/** Default response was never updated with actual error code. */</span>
	<span class="n">HPI_ERROR_INVALID_RESPONSE</span> <span class="o">=</span> <span class="mi">108</span><span class="p">,</span>
	<span class="cm">/** wSize field of response was not updated,</span>
<span class="cm">	indicating that the message was not processed. */</span>
	<span class="n">HPI_ERROR_PROCESSING_MESSAGE</span> <span class="o">=</span> <span class="mi">109</span><span class="p">,</span>
	<span class="cm">/** The network did not respond in a timely manner. */</span>
	<span class="n">HPI_ERROR_NETWORK_TIMEOUT</span> <span class="o">=</span> <span class="mi">110</span><span class="p">,</span>
	<span class="cm">/* An HPI handle is invalid (uninitialised?). */</span>
	<span class="n">HPI_ERROR_INVALID_HANDLE</span> <span class="o">=</span> <span class="mi">111</span><span class="p">,</span>
	<span class="cm">/** A function or attribute has not been implemented yet. */</span>
	<span class="n">HPI_ERROR_UNIMPLEMENTED</span> <span class="o">=</span> <span class="mi">112</span><span class="p">,</span>
	<span class="cm">/** There are too many clients attempting</span>
<span class="cm">	    to access a network resource. */</span>
	<span class="n">HPI_ERROR_NETWORK_TOO_MANY_CLIENTS</span> <span class="o">=</span> <span class="mi">113</span><span class="p">,</span>
	<span class="cm">/** Response buffer passed to HPI_Message</span>
<span class="cm">	    was smaller than returned response.</span>
<span class="cm">	    wSpecificError field of hpi response contains the required size.</span>
<span class="cm">	*/</span>
	<span class="n">HPI_ERROR_RESPONSE_BUFFER_TOO_SMALL</span> <span class="o">=</span> <span class="mi">114</span><span class="p">,</span>
	<span class="cm">/** The returned response did not match the sent message */</span>
	<span class="n">HPI_ERROR_RESPONSE_MISMATCH</span> <span class="o">=</span> <span class="mi">115</span><span class="p">,</span>
	<span class="cm">/** A control setting that should have been cached was not. */</span>
	<span class="n">HPI_ERROR_CONTROL_CACHING</span> <span class="o">=</span> <span class="mi">116</span><span class="p">,</span>
	<span class="cm">/** A message buffer in the path to the adapter was smaller</span>
<span class="cm">	    than the message size.</span>
<span class="cm">	    wSpecificError field of hpi response contains the actual size.</span>
<span class="cm">	*/</span>
	<span class="n">HPI_ERROR_MESSAGE_BUFFER_TOO_SMALL</span> <span class="o">=</span> <span class="mi">117</span><span class="p">,</span>

	<span class="cm">/* HPI_ERROR_TOO_MANY_ADAPTERS= 200 */</span>
	<span class="cm">/** Bad adpater. */</span>
	<span class="n">HPI_ERROR_BAD_ADAPTER</span> <span class="o">=</span> <span class="mi">201</span><span class="p">,</span>
	<span class="cm">/** Adapter number out of range or not set properly. */</span>
	<span class="n">HPI_ERROR_BAD_ADAPTER_NUMBER</span> <span class="o">=</span> <span class="mi">202</span><span class="p">,</span>
	<span class="cm">/** 2 adapters with the same adapter number. */</span>
	<span class="n">HPI_ERROR_DUPLICATE_ADAPTER_NUMBER</span> <span class="o">=</span> <span class="mi">203</span><span class="p">,</span>
	<span class="cm">/** DSP code failed to bootload. Usually a DSP memory test failure. */</span>
	<span class="n">HPI_ERROR_DSP_BOOTLOAD</span> <span class="o">=</span> <span class="mi">204</span><span class="p">,</span>
	<span class="cm">/** Couldn&#39;t find or open the DSP code file. */</span>
	<span class="n">HPI_ERROR_DSP_FILE_NOT_FOUND</span> <span class="o">=</span> <span class="mi">206</span><span class="p">,</span>
	<span class="cm">/** Internal DSP hardware error. */</span>
	<span class="n">HPI_ERROR_DSP_HARDWARE</span> <span class="o">=</span> <span class="mi">207</span><span class="p">,</span>
	<span class="cm">/** Could not allocate memory */</span>
	<span class="n">HPI_ERROR_MEMORY_ALLOC</span> <span class="o">=</span> <span class="mi">208</span><span class="p">,</span>
	<span class="cm">/** Failed to correctly load/config PLD. (unused) */</span>
	<span class="n">HPI_ERROR_PLD_LOAD</span> <span class="o">=</span> <span class="mi">209</span><span class="p">,</span>
	<span class="cm">/** Unexpected end of file, block length too big etc. */</span>
	<span class="n">HPI_ERROR_DSP_FILE_FORMAT</span> <span class="o">=</span> <span class="mi">210</span><span class="p">,</span>

	<span class="cm">/** Found but could not open DSP code file. */</span>
	<span class="n">HPI_ERROR_DSP_FILE_ACCESS_DENIED</span> <span class="o">=</span> <span class="mi">211</span><span class="p">,</span>
	<span class="cm">/** First DSP code section header not found in DSP file. */</span>
	<span class="n">HPI_ERROR_DSP_FILE_NO_HEADER</span> <span class="o">=</span> <span class="mi">212</span><span class="p">,</span>
	<span class="cm">/* HPI_ERROR_DSP_FILE_READ_ERROR= 213, */</span>
	<span class="cm">/** DSP code for adapter family not found. */</span>
	<span class="n">HPI_ERROR_DSP_SECTION_NOT_FOUND</span> <span class="o">=</span> <span class="mi">214</span><span class="p">,</span>
	<span class="cm">/** Other OS specific error opening DSP file. */</span>
	<span class="n">HPI_ERROR_DSP_FILE_OTHER_ERROR</span> <span class="o">=</span> <span class="mi">215</span><span class="p">,</span>
	<span class="cm">/** Sharing violation opening DSP code file. */</span>
	<span class="n">HPI_ERROR_DSP_FILE_SHARING_VIOLATION</span> <span class="o">=</span> <span class="mi">216</span><span class="p">,</span>
	<span class="cm">/** DSP code section header had size == 0. */</span>
	<span class="n">HPI_ERROR_DSP_FILE_NULL_HEADER</span> <span class="o">=</span> <span class="mi">217</span><span class="p">,</span>

	<span class="cm">/* HPI_ERROR_FLASH = 220, */</span>

	<span class="cm">/** Flash has bad checksum */</span>
	<span class="n">HPI_ERROR_BAD_CHECKSUM</span> <span class="o">=</span> <span class="mi">221</span><span class="p">,</span>
	<span class="n">HPI_ERROR_BAD_SEQUENCE</span> <span class="o">=</span> <span class="mi">222</span><span class="p">,</span>
	<span class="n">HPI_ERROR_FLASH_ERASE</span> <span class="o">=</span> <span class="mi">223</span><span class="p">,</span>
	<span class="n">HPI_ERROR_FLASH_PROGRAM</span> <span class="o">=</span> <span class="mi">224</span><span class="p">,</span>
	<span class="n">HPI_ERROR_FLASH_VERIFY</span> <span class="o">=</span> <span class="mi">225</span><span class="p">,</span>
	<span class="n">HPI_ERROR_FLASH_TYPE</span> <span class="o">=</span> <span class="mi">226</span><span class="p">,</span>
	<span class="n">HPI_ERROR_FLASH_START</span> <span class="o">=</span> <span class="mi">227</span><span class="p">,</span>
	<span class="n">HPI_ERROR_FLASH_READ</span> <span class="o">=</span> <span class="mi">228</span><span class="p">,</span>
	<span class="n">HPI_ERROR_FLASH_READ_NO_FILE</span> <span class="o">=</span> <span class="mi">229</span><span class="p">,</span>
	<span class="n">HPI_ERROR_FLASH_SIZE</span> <span class="o">=</span> <span class="mi">230</span><span class="p">,</span>

	<span class="cm">/** Reserved for OEMs. */</span>
	<span class="n">HPI_ERROR_RESERVED_1</span> <span class="o">=</span> <span class="mi">290</span><span class="p">,</span>

	<span class="cm">/* HPI_ERROR_INVALID_STREAM = 300 use HPI_ERROR_INVALID_OBJ_INDEX */</span>
	<span class="cm">/** Invalid compression format. */</span>
	<span class="n">HPI_ERROR_INVALID_FORMAT</span> <span class="o">=</span> <span class="mi">301</span><span class="p">,</span>
	<span class="cm">/** Invalid format samplerate */</span>
	<span class="n">HPI_ERROR_INVALID_SAMPLERATE</span> <span class="o">=</span> <span class="mi">302</span><span class="p">,</span>
	<span class="cm">/** Invalid format number of channels. */</span>
	<span class="n">HPI_ERROR_INVALID_CHANNELS</span> <span class="o">=</span> <span class="mi">303</span><span class="p">,</span>
	<span class="cm">/** Invalid format bitrate. */</span>
	<span class="n">HPI_ERROR_INVALID_BITRATE</span> <span class="o">=</span> <span class="mi">304</span><span class="p">,</span>
	<span class="cm">/** Invalid datasize used for stream read/write. */</span>
	<span class="n">HPI_ERROR_INVALID_DATASIZE</span> <span class="o">=</span> <span class="mi">305</span><span class="p">,</span>
	<span class="cm">/* HPI_ERROR_BUFFER_FULL = 306 use HPI_ERROR_INVALID_DATASIZE */</span>
	<span class="cm">/* HPI_ERROR_BUFFER_EMPTY = 307 use HPI_ERROR_INVALID_DATASIZE */</span>
	<span class="cm">/** Null data pointer used for stream read/write. */</span>
	<span class="n">HPI_ERROR_INVALID_DATA_POINTER</span> <span class="o">=</span> <span class="mi">308</span><span class="p">,</span>
	<span class="cm">/** Packet ordering error for stream read/write. */</span>
	<span class="n">HPI_ERROR_INVALID_PACKET_ORDER</span> <span class="o">=</span> <span class="mi">309</span><span class="p">,</span>

	<span class="cm">/** Object can&#39;t do requested operation in its current</span>
<span class="cm">	    state, eg set format, change rec mux state while recording.*/</span>
	<span class="n">HPI_ERROR_INVALID_OPERATION</span> <span class="o">=</span> <span class="mi">310</span><span class="p">,</span>

	<span class="cm">/** Where a SRG is shared amongst streams, an incompatible samplerate</span>
<span class="cm">	    is one that is different to any currently active stream. */</span>
	<span class="n">HPI_ERROR_INCOMPATIBLE_SAMPLERATE</span> <span class="o">=</span> <span class="mi">311</span><span class="p">,</span>
	<span class="cm">/** Adapter mode is illegal.*/</span>
	<span class="n">HPI_ERROR_BAD_ADAPTER_MODE</span> <span class="o">=</span> <span class="mi">312</span><span class="p">,</span>

	<span class="cm">/** There have been too many attempts to set the adapter&#39;s</span>
<span class="cm">	capabilities (using bad keys), the card should be returned</span>
<span class="cm">	to ASI if further capabilities updates are required */</span>
	<span class="n">HPI_ERROR_TOO_MANY_CAPABILITY_CHANGE_ATTEMPTS</span> <span class="o">=</span> <span class="mi">313</span><span class="p">,</span>
	<span class="cm">/** Streams on different adapters cannot be grouped. */</span>
	<span class="n">HPI_ERROR_NO_INTERADAPTER_GROUPS</span> <span class="o">=</span> <span class="mi">314</span><span class="p">,</span>
	<span class="cm">/** Streams on different DSPs cannot be grouped. */</span>
	<span class="n">HPI_ERROR_NO_INTERDSP_GROUPS</span> <span class="o">=</span> <span class="mi">315</span><span class="p">,</span>
	<span class="cm">/** Stream wait cancelled before threshold reached. */</span>
	<span class="n">HPI_ERROR_WAIT_CANCELLED</span> <span class="o">=</span> <span class="mi">316</span><span class="p">,</span>
	<span class="cm">/** A character string is invalid. */</span>
	<span class="n">HPI_ERROR_INVALID_STRING</span> <span class="o">=</span> <span class="mi">317</span><span class="p">,</span>

	<span class="cm">/** Invalid mixer node for this adapter. */</span>
	<span class="n">HPI_ERROR_INVALID_NODE</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span>
	<span class="cm">/** Invalid control. */</span>
	<span class="n">HPI_ERROR_INVALID_CONTROL</span> <span class="o">=</span> <span class="mi">401</span><span class="p">,</span>
	<span class="cm">/** Invalid control value was passed. */</span>
	<span class="n">HPI_ERROR_INVALID_CONTROL_VALUE</span> <span class="o">=</span> <span class="mi">402</span><span class="p">,</span>
	<span class="cm">/** Control attribute not supported by this control. */</span>
	<span class="n">HPI_ERROR_INVALID_CONTROL_ATTRIBUTE</span> <span class="o">=</span> <span class="mi">403</span><span class="p">,</span>
	<span class="cm">/** Control is disabled. */</span>
	<span class="n">HPI_ERROR_CONTROL_DISABLED</span> <span class="o">=</span> <span class="mi">404</span><span class="p">,</span>
	<span class="cm">/** I2C transaction failed due to a missing ACK. */</span>
	<span class="n">HPI_ERROR_CONTROL_I2C_MISSING_ACK</span> <span class="o">=</span> <span class="mi">405</span><span class="p">,</span>
	<span class="n">HPI_ERROR_I2C_MISSING_ACK</span> <span class="o">=</span> <span class="mi">405</span><span class="p">,</span>
	<span class="cm">/** Control is busy, or coming out of</span>
<span class="cm">	reset and cannot be accessed at this time. */</span>
	<span class="n">HPI_ERROR_CONTROL_NOT_READY</span> <span class="o">=</span> <span class="mi">407</span><span class="p">,</span>

	<span class="cm">/** Non volatile memory */</span>
	<span class="n">HPI_ERROR_NVMEM_BUSY</span> <span class="o">=</span> <span class="mi">450</span><span class="p">,</span>
	<span class="n">HPI_ERROR_NVMEM_FULL</span> <span class="o">=</span> <span class="mi">451</span><span class="p">,</span>
	<span class="n">HPI_ERROR_NVMEM_FAIL</span> <span class="o">=</span> <span class="mi">452</span><span class="p">,</span>

	<span class="cm">/** I2C */</span>
	<span class="n">HPI_ERROR_I2C_BAD_ADR</span> <span class="o">=</span> <span class="mi">460</span><span class="p">,</span>

	<span class="cm">/** Entity type did not match requested type */</span>
	<span class="n">HPI_ERROR_ENTITY_TYPE_MISMATCH</span> <span class="o">=</span> <span class="mi">470</span><span class="p">,</span>
	<span class="cm">/** Entity item count did not match requested count */</span>
	<span class="n">HPI_ERROR_ENTITY_ITEM_COUNT</span> <span class="o">=</span> <span class="mi">471</span><span class="p">,</span>
	<span class="cm">/** Entity type is not one of the valid types */</span>
	<span class="n">HPI_ERROR_ENTITY_TYPE_INVALID</span> <span class="o">=</span> <span class="mi">472</span><span class="p">,</span>
	<span class="cm">/** Entity role is not one of the valid roles */</span>
	<span class="n">HPI_ERROR_ENTITY_ROLE_INVALID</span> <span class="o">=</span> <span class="mi">473</span><span class="p">,</span>
	<span class="cm">/** Entity size doesn&#39;t match target size */</span>
	<span class="n">HPI_ERROR_ENTITY_SIZE_MISMATCH</span> <span class="o">=</span> <span class="mi">474</span><span class="p">,</span>

	<span class="cm">/* AES18 specific errors were 500..507 */</span>

	<span class="cm">/** custom error to use for debugging */</span>
	<span class="n">HPI_ERROR_CUSTOM</span> <span class="o">=</span> <span class="mi">600</span><span class="p">,</span>

	<span class="cm">/** hpioct32.c can&#39;t obtain mutex */</span>
	<span class="n">HPI_ERROR_MUTEX_TIMEOUT</span> <span class="o">=</span> <span class="mi">700</span><span class="p">,</span>

	<span class="cm">/** Backend errors used to be greater than this.</span>
<span class="cm">	    \deprecated Now, all backends return only errors defined here in hpi.h</span>
<span class="cm">	*/</span>
	<span class="n">HPI_ERROR_BACKEND_BASE</span> <span class="o">=</span> <span class="mi">900</span><span class="p">,</span>

	<span class="cm">/** Communication with DSP failed */</span>
	<span class="n">HPI_ERROR_DSP_COMMUNICATION</span> <span class="o">=</span> <span class="mi">900</span>
		<span class="cm">/* Note that the dsp communication error is set to this value so that</span>
<span class="cm">		   it remains compatible with any software that expects such errors</span>
<span class="cm">		   to be backend errors i.e. &gt;= 900.</span>
<span class="cm">		   Do not define any new error codes with values &gt; 900.</span>
<span class="cm">		 */</span>
<span class="p">};</span>

<span class="cm">/** \defgroup maximums HPI maximum values</span>
<span class="cm">\{</span>
<span class="cm">*/</span>
<span class="cm">/** Maximum number of PCI HPI adapters */</span>
<span class="cp">#define HPI_MAX_ADAPTERS                20</span>
<span class="cm">/** Maximum number of in or out streams per adapter */</span>
<span class="cp">#define HPI_MAX_STREAMS                 16</span>
<span class="cp">#define HPI_MAX_CHANNELS                2	</span><span class="cm">/* per stream */</span><span class="cp"></span>
<span class="cp">#define HPI_MAX_NODES                   8	</span><span class="cm">/* per mixer ? */</span><span class="cp"></span>
<span class="cp">#define HPI_MAX_CONTROLS                4	</span><span class="cm">/* per node ? */</span><span class="cp"></span>
<span class="cm">/** maximum number of ancillary bytes per MPEG frame */</span>
<span class="cp">#define HPI_MAX_ANC_BYTES_PER_FRAME     (64)</span>
<span class="cp">#define HPI_STRING_LEN                  16</span>

<span class="cm">/** Networked adapters have index &gt;= 100 */</span>
<span class="cp">#define HPI_MIN_NETWORK_ADAPTER_IDX 100</span>

<span class="cm">/** Velocity units */</span>
<span class="cp">#define HPI_OSTREAM_VELOCITY_UNITS      4096</span>
<span class="cm">/** OutStream timescale units */</span>
<span class="cp">#define HPI_OSTREAM_TIMESCALE_UNITS     10000</span>
<span class="cm">/** OutStream timescale passthrough - turns timescaling on in passthough mode */</span>
<span class="cp">#define HPI_OSTREAM_TIMESCALE_PASSTHROUGH       99999</span>

<span class="cm">/**\}*/</span>

<span class="cm">/**************/</span>
<span class="cm">/* STRUCTURES */</span>
<span class="cp">#ifndef DISABLE_PRAGMA_PACK1</span>
<span class="cp">#pragma pack(push, 1)</span>
<span class="cp">#endif</span>

<span class="cm">/** Structure containing sample format information.</span>
<span class="cm">    See also HPI_FormatCreate().</span>
<span class="cm">  */</span>
<span class="k">struct</span> <span class="n">hpi_format</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">sample_rate</span><span class="p">;</span>
				<span class="cm">/**&lt; 11025, 32000, 44100 ... */</span>
	<span class="n">u32</span> <span class="n">bit_rate</span><span class="p">;</span>		  <span class="cm">/**&lt; for MPEG */</span>
	<span class="n">u32</span> <span class="n">attributes</span><span class="p">;</span>
				<span class="cm">/**&lt; Stereo/JointStereo/Mono */</span>
	<span class="n">u16</span> <span class="n">mode_legacy</span><span class="p">;</span>
				<span class="cm">/**&lt; Legacy ancillary mode or idle bit  */</span>
	<span class="n">u16</span> <span class="n">unused</span><span class="p">;</span>		  <span class="cm">/**&lt; Unused */</span>
	<span class="n">u16</span> <span class="n">channels</span><span class="p">;</span>	  <span class="cm">/**&lt; 1,2..., (or ancillary mode or idle bit */</span>
	<span class="n">u16</span> <span class="n">format</span><span class="p">;</span>	  <span class="cm">/**&lt; HPI_FORMAT_PCM16, _MPEG etc. see #HPI_FORMATS. */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hpi_anc_frame</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">valid_bits_in_this_frame</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">b_data</span><span class="p">[</span><span class="n">HPI_MAX_ANC_BYTES_PER_FRAME</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/** An object for containing a single async event.</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">hpi_async_event</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">event_type</span><span class="p">;</span>	<span class="cm">/**&lt; type of event. \sa async_event  */</span>
	<span class="n">u16</span> <span class="n">sequence</span><span class="p">;</span> <span class="cm">/**&lt; Sequence number, allows lost event detection */</span>
	<span class="n">u32</span> <span class="n">state</span><span class="p">;</span> <span class="cm">/**&lt; New state */</span>
	<span class="n">u32</span> <span class="n">h_object</span><span class="p">;</span> <span class="cm">/**&lt; handle to the object returning the event. */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="n">index</span><span class="p">;</span> <span class="cm">/**&lt; GPIO bit index. */</span>
		<span class="p">}</span> <span class="n">gpio</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="n">node_index</span><span class="p">;</span>	<span class="cm">/**&lt; what node is the control on ? */</span>
			<span class="n">u16</span> <span class="n">node_type</span><span class="p">;</span> <span class="cm">/**&lt; what type of node is the control on ? */</span>
		<span class="p">}</span> <span class="n">control</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifndef DISABLE_PRAGMA_PACK1</span>
<span class="cp">#pragma pack(pop)</span>
<span class="cp">#endif</span>

<span class="cm">/*****************/</span>
<span class="cm">/* HPI FUNCTIONS */</span>
<span class="cm">/*****************/</span>

<span class="cm">/* Stream */</span>
<span class="n">u16</span> <span class="n">hpi_stream_estimate_buffer_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">hpi_format</span> <span class="o">*</span><span class="n">pF</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">host_polling_rate_in_milli_seconds</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">recommended_buffer_size</span><span class="p">);</span>

<span class="cm">/*************/</span>
<span class="cm">/* SubSystem */</span>
<span class="cm">/*************/</span>

<span class="n">u16</span> <span class="n">hpi_subsys_get_version_ex</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">pversion_ex</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_subsys_get_num_adapters</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">pn_num_adapters</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_subsys_get_adapter</span><span class="p">(</span><span class="kt">int</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">padapter_index</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_adapter_type</span><span class="p">);</span>

<span class="cm">/***********/</span>
<span class="cm">/* Adapter */</span>
<span class="cm">/***********/</span>

<span class="n">u16</span> <span class="n">hpi_adapter_open</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_adapter_close</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_adapter_get_info</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_num_outstreams</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_num_instreams</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_version</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pserial_number</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_adapter_type</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_adapter_get_module_by_index</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">module_index</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_num_outputs</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_num_inputs</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_version</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pserial_number</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_module_type</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ph_module</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_adapter_set_mode</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u32</span> <span class="n">adapter_mode</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_adapter_set_mode_ex</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u32</span> <span class="n">adapter_mode</span><span class="p">,</span>
	<span class="n">u16</span> <span class="n">query_or_set</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_adapter_get_mode</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">padapter_mode</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_adapter_get_assert2</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">p_assert_count</span><span class="p">,</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">psz_assert</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">p_param1</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">p_param2</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p_dsp_string_addr</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">p_processor_id</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_adapter_test_assert</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">assert_id</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_adapter_enable_capability</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">capability</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_adapter_self_test</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_adapter_debug_read</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsp_address</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p_bytes</span><span class="p">,</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">count_bytes</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_adapter_set_property</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">property</span><span class="p">,</span> <span class="n">u16</span> <span class="n">paramter1</span><span class="p">,</span>
	<span class="n">u16</span> <span class="n">paramter2</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_adapter_get_property</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">property</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_paramter1</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_paramter2</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_adapter_enumerate_property</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u16</span> <span class="n">what_to_enumerate</span><span class="p">,</span> <span class="n">u16</span> <span class="n">property_index</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">psetting</span><span class="p">);</span>
<span class="cm">/*************/</span>
<span class="cm">/* OutStream */</span>
<span class="cm">/*************/</span>
<span class="n">u16</span> <span class="n">hpi_outstream_open</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">outstream_index</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">ph_outstream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_close</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_get_info_ex</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_state</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pbuffer_size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pdata_to_play</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">psamples_played</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pauxiliary_data_to_play</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_write_buf</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">pb_write_buf</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">bytes_to_write</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">hpi_format</span> <span class="o">*</span><span class="n">p_format</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_start</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_wait_start</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_stop</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_sinegen</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_reset</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_query_format</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hpi_format</span> <span class="o">*</span><span class="n">p_format</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_set_format</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hpi_format</span> <span class="o">*</span><span class="n">p_format</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_set_punch_in_out</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">,</span> <span class="n">u32</span> <span class="n">punch_in_sample</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">punch_out_sample</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_set_velocity</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">,</span> <span class="kt">short</span> <span class="n">velocity</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_ancillary_reset</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mode</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_ancillary_get_info</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pframes_available</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_ancillary_read</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">hpi_anc_frame</span> <span class="o">*</span><span class="n">p_anc_frame_buffer</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">anc_frame_buffer_size_in_bytes</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">number_of_ancillary_frames_to_read</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_set_time_scale</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">,</span> <span class="n">u32</span> <span class="n">time_scaleX10000</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_host_buffer_allocate</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size_in_bytes</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_host_buffer_free</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_group_add</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">,</span> <span class="n">u32</span> <span class="n">h_stream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_group_get_map</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">poutstream_map</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pinstream_map</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_outstream_group_reset</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_outstream</span><span class="p">);</span>

<span class="cm">/************/</span>
<span class="cm">/* InStream */</span>
<span class="cm">/************/</span>
<span class="n">u16</span> <span class="n">hpi_instream_open</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">instream_index</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">ph_instream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_close</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_query_format</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">hpi_format</span> <span class="o">*</span><span class="n">p_format</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_set_format</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">hpi_format</span> <span class="o">*</span><span class="n">p_format</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_read_buf</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">pb_read_buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bytes_to_read</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_start</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_wait_start</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_stop</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_reset</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_get_info_ex</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_state</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pbuffer_size</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pdata_recorded</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">psamples_recorded</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pauxiliary_data_recorded</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_ancillary_reset</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">,</span> <span class="n">u16</span> <span class="n">bytes_per_frame</span><span class="p">,</span>
	<span class="n">u16</span> <span class="n">mode</span><span class="p">,</span> <span class="n">u16</span> <span class="n">alignment</span><span class="p">,</span> <span class="n">u16</span> <span class="n">idle_bit</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_ancillary_get_info</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pframe_space</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_ancillary_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">hpi_anc_frame</span> <span class="o">*</span><span class="n">p_anc_frame_buffer</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">anc_frame_buffer_size_in_bytes</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">number_of_ancillary_frames_to_write</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_host_buffer_allocate</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size_in_bytes</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_host_buffer_free</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_group_add</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">,</span> <span class="n">u32</span> <span class="n">h_stream</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_group_get_map</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">poutstream_map</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pinstream_map</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_instream_group_reset</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_instream</span><span class="p">);</span>

<span class="cm">/*********/</span>
<span class="cm">/* Mixer */</span>
<span class="cm">/*********/</span>
<span class="n">u16</span> <span class="n">hpi_mixer_open</span><span class="p">(</span><span class="n">u16</span> <span class="n">adapter_index</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ph_mixer</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_mixer_close</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_mixer</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_mixer_get_control</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_mixer</span><span class="p">,</span> <span class="n">u16</span> <span class="n">src_node_type</span><span class="p">,</span>
	<span class="n">u16</span> <span class="n">src_node_type_index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">dst_node_type</span><span class="p">,</span> <span class="n">u16</span> <span class="n">dst_node_type_index</span><span class="p">,</span>
	<span class="n">u16</span> <span class="n">control_type</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ph_control</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_mixer_get_control_by_index</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_mixer</span><span class="p">,</span> <span class="n">u16</span> <span class="n">control_index</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_src_node_type</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_src_node_index</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_dst_node_type</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_dst_node_index</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_control_type</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ph_control</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_mixer_store</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_mixer</span><span class="p">,</span> <span class="k">enum</span> <span class="n">HPI_MIXER_STORE_COMMAND</span> <span class="n">command</span><span class="p">,</span>
	<span class="n">u16</span> <span class="n">index</span><span class="p">);</span>
<span class="cm">/************/</span>
<span class="cm">/* Controls */</span>
<span class="cm">/************/</span>
<span class="cm">/******************/</span>
<span class="cm">/* Volume control */</span>
<span class="cm">/******************/</span>
<span class="n">u16</span> <span class="n">hpi_volume_set_gain</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">short</span> <span class="n">an_gain0_01dB</span><span class="p">[</span><span class="n">HPI_MAX_CHANNELS</span><span class="p">]</span>
	<span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_volume_get_gain</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span>
	<span class="kt">short</span> <span class="n">an_gain0_01dB_out</span><span class="p">[</span><span class="n">HPI_MAX_CHANNELS</span><span class="p">]</span>
	<span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_volume_set_mute</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mute</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_volume_get_mute</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">mute</span><span class="p">);</span>

<span class="cp">#define hpi_volume_get_range hpi_volume_query_range</span>
<span class="n">u16</span> <span class="n">hpi_volume_query_range</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">min_gain_01dB</span><span class="p">,</span>
	<span class="kt">short</span> <span class="o">*</span><span class="n">max_gain_01dB</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">step_gain_01dB</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_volume_query_channels</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">p_channels</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_volume_auto_fade</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span>
	<span class="kt">short</span> <span class="n">an_stop_gain0_01dB</span><span class="p">[</span><span class="n">HPI_MAX_CHANNELS</span><span class="p">],</span> <span class="n">u32</span> <span class="n">duration_ms</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_volume_auto_fade_profile</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span>
	<span class="kt">short</span> <span class="n">an_stop_gain0_01dB</span><span class="p">[</span><span class="n">HPI_MAX_CHANNELS</span><span class="p">],</span> <span class="n">u32</span> <span class="n">duration_ms</span><span class="p">,</span>
	<span class="n">u16</span> <span class="n">profile</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_volume_query_auto_fade_profile</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">i</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">profile</span><span class="p">);</span>

<span class="cm">/*****************/</span>
<span class="cm">/* Level control */</span>
<span class="cm">/*****************/</span>
<span class="n">u16</span> <span class="n">hpi_level_query_range</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">min_gain_01dB</span><span class="p">,</span>
	<span class="kt">short</span> <span class="o">*</span><span class="n">max_gain_01dB</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">step_gain_01dB</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_level_set_gain</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">short</span> <span class="n">an_gain0_01dB</span><span class="p">[</span><span class="n">HPI_MAX_CHANNELS</span><span class="p">]</span>
	<span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_level_get_gain</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span>
	<span class="kt">short</span> <span class="n">an_gain0_01dB_out</span><span class="p">[</span><span class="n">HPI_MAX_CHANNELS</span><span class="p">]</span>
	<span class="p">);</span>

<span class="cm">/*****************/</span>
<span class="cm">/* Meter control */</span>
<span class="cm">/*****************/</span>
<span class="n">u16</span> <span class="n">hpi_meter_query_channels</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">h_meter</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">p_channels</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_meter_get_peak</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span>
	<span class="kt">short</span> <span class="n">an_peak0_01dB_out</span><span class="p">[</span><span class="n">HPI_MAX_CHANNELS</span><span class="p">]</span>
	<span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_meter_get_rms</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">short</span> <span class="n">an_peak0_01dB_out</span><span class="p">[</span><span class="n">HPI_MAX_CHANNELS</span><span class="p">]</span>
	<span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_meter_set_peak_ballistics</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">attack</span><span class="p">,</span> <span class="n">u16</span> <span class="n">decay</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_meter_set_rms_ballistics</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">attack</span><span class="p">,</span> <span class="n">u16</span> <span class="n">decay</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_meter_get_peak_ballistics</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">attack</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">decay</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_meter_get_rms_ballistics</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">attack</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">decay</span><span class="p">);</span>

<span class="cm">/************************/</span>
<span class="cm">/* ChannelMode control */</span>
<span class="cm">/************************/</span>
<span class="n">u16</span> <span class="n">hpi_channel_mode_query_mode</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">h_mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_mode</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_channel_mode_set</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mode</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_channel_mode_get</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>

<span class="cm">/*****************/</span>
<span class="cm">/* Tuner control */</span>
<span class="cm">/*****************/</span>
<span class="n">u16</span> <span class="n">hpi_tuner_query_band</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">h_tuner</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_band</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_set_band</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">band</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_get_band</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_band</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_query_frequency</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">h_tuner</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">u16</span> <span class="n">band</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pfreq</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_set_frequency</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">freq_ink_hz</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_get_frequency</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pw_freq_ink_hz</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_get_rf_level</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">pw_level</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_get_raw_rf_level</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">pw_level</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_query_gain</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">h_tuner</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_gain</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_set_gain</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">short</span> <span class="n">gain</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_get_gain</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">pn_gain</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_get_status</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_status_mask</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_status</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_set_mode</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mode</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_get_mode</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mode</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pn_value</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_get_rds</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p_rds_data</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_query_deemphasis</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">h_tuner</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">u16</span> <span class="n">band</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pdeemphasis</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_set_deemphasis</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">deemphasis</span><span class="p">);</span>
<span class="n">u16</span> <span class="n">hpi_tuner_get_deemphasis</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pdeemphasis</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_query_program</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">h_tuner</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pbitmap_program</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_set_program</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">program</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_get_program</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pprogram</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_get_hd_radio_dsp_version</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">psz_dsp_version</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">string_size</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_get_hd_radio_sdk_version</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">psz_sdk_version</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">string_size</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_get_hd_radio_signal_quality</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pquality</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_get_hd_radio_signal_blend</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pblend</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tuner_set_hd_radio_signal_blend</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">blend</span><span class="p">);</span>

<span class="cm">/***************/</span>
<span class="cm">/* PAD control */</span>
<span class="cm">/***************/</span>

<span class="n">u16</span> <span class="n">hpi_pad_get_channel_name</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">psz_string</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">string_length</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_pad_get_artist</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">psz_string</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">string_length</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_pad_get_title</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">psz_string</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">string_length</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_pad_get_comment</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">psz_string</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">string_length</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_pad_get_program_type</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ppTY</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_pad_get_rdsPI</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ppI</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_pad_get_program_type_string</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">data_type</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">pTY</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">psz_string</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">string_length</span><span class="p">);</span>

<span class="cm">/****************************/</span>
<span class="cm">/* AES/EBU Receiver control */</span>
<span class="cm">/****************************/</span>
<span class="n">u16</span> <span class="n">hpi_aesebu_receiver_query_format</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">h_aes_rx</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_format</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_aesebu_receiver_set_format</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">source</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_aesebu_receiver_get_format</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_source</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_aesebu_receiver_get_sample_rate</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">psample_rate</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_aesebu_receiver_get_user_data</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_data</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_aesebu_receiver_get_channel_status</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_data</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_aesebu_receiver_get_error_status</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_error_data</span><span class="p">);</span>

<span class="cm">/*******************************/</span>
<span class="cm">/* AES/EBU Transmitter control */</span>
<span class="cm">/*******************************/</span>
<span class="n">u16</span> <span class="n">hpi_aesebu_transmitter_set_sample_rate</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sample_rate</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_aesebu_transmitter_set_user_data</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_aesebu_transmitter_set_channel_status</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_aesebu_transmitter_get_channel_status</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_data</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_aesebu_transmitter_query_format</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">h_aes_tx</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_format</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_aesebu_transmitter_set_format</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">output_format</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_aesebu_transmitter_get_format</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_output_format</span><span class="p">);</span>

<span class="cm">/***********************/</span>
<span class="cm">/* Multiplexer control */</span>
<span class="cm">/***********************/</span>
<span class="n">u16</span> <span class="n">hpi_multiplexer_set_source</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">source_node_type</span><span class="p">,</span>
	<span class="n">u16</span> <span class="n">source_node_index</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_multiplexer_get_source</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">source_node_type</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">source_node_index</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_multiplexer_query_source</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">source_node_type</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">source_node_index</span><span class="p">);</span>

<span class="cm">/***************/</span>
<span class="cm">/* Vox control */</span>
<span class="cm">/***************/</span>
<span class="n">u16</span> <span class="n">hpi_vox_set_threshold</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">short</span> <span class="n">an_gain0_01dB</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_vox_get_threshold</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">an_gain0_01dB</span><span class="p">);</span>

<span class="cm">/*********************/</span>
<span class="cm">/* Bitstream control */</span>
<span class="cm">/*********************/</span>
<span class="n">u16</span> <span class="n">hpi_bitstream_set_clock_edge</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">edge_type</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_bitstream_set_data_polarity</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">polarity</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_bitstream_get_activity</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_clk_activity</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_data_activity</span><span class="p">);</span>

<span class="cm">/***********************/</span>
<span class="cm">/* SampleClock control */</span>
<span class="cm">/***********************/</span>

<span class="n">u16</span> <span class="n">hpi_sample_clock_query_source</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">h_clock</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_source</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_sample_clock_set_source</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">source</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_sample_clock_get_source</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_source</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_sample_clock_query_source_index</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">h_clock</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">source</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_source_index</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_sample_clock_set_source_index</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">source_index</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_sample_clock_get_source_index</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_source_index</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_sample_clock_get_sample_rate</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">psample_rate</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_sample_clock_query_local_rate</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">h_clock</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">psource</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_sample_clock_set_local_rate</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sample_rate</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_sample_clock_get_local_rate</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">psample_rate</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_sample_clock_set_auto</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">enable</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_sample_clock_get_auto</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">penable</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_sample_clock_set_local_rate_lock</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lock</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_sample_clock_get_local_rate_lock</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">plock</span><span class="p">);</span>

<span class="cm">/***********************/</span>
<span class="cm">/* Microphone control */</span>
<span class="cm">/***********************/</span>
<span class="n">u16</span> <span class="n">hpi_microphone_set_phantom_power</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">on_off</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_microphone_get_phantom_power</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_on_off</span><span class="p">);</span>

<span class="cm">/********************************/</span>
<span class="cm">/* Parametric Equalizer control */</span>
<span class="cm">/********************************/</span>
<span class="n">u16</span> <span class="n">hpi_parametric_eq_get_info</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pw_number_of_bands</span><span class="p">,</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pw_enabled</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_parametric_eq_set_state</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">on_off</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_parametric_eq_set_band</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="n">type</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">frequency_hz</span><span class="p">,</span> <span class="kt">short</span> <span class="n">q100</span><span class="p">,</span> <span class="kt">short</span> <span class="n">gain0_01dB</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_parametric_eq_get_band</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">pn_type</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pfrequency_hz</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">pnQ100</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">pn_gain0_01dB</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_parametric_eq_get_coeffs</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span> <span class="kt">short</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
	<span class="p">);</span>

<span class="cm">/*******************************/</span>
<span class="cm">/* Compressor Expander control */</span>
<span class="cm">/*******************************/</span>

<span class="n">u16</span> <span class="n">hpi_compander_set_enable</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">on</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_compander_get_enable</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pon</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_compander_set_makeup_gain</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">short</span> <span class="n">makeup_gain0_01dB</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_compander_get_makeup_gain</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">pn_makeup_gain0_01dB</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_compander_set_attack_time_constant</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">attack</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_compander_get_attack_time_constant</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pw_attack</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_compander_set_decay_time_constant</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">decay</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_compander_get_decay_time_constant</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pw_decay</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_compander_set_threshold</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="kt">short</span> <span class="n">threshold0_01dB</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_compander_get_threshold</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="kt">short</span> <span class="o">*</span><span class="n">pn_threshold0_01dB</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_compander_set_ratio</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ratio100</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_compander_get_ratio</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pw_ratio100</span><span class="p">);</span>

<span class="cm">/********************/</span>
<span class="cm">/* Cobranet control */</span>
<span class="cm">/********************/</span>
<span class="n">u16</span> <span class="n">hpi_cobranet_hmi_write</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hmi_address</span><span class="p">,</span> <span class="n">u32</span> <span class="n">byte_count</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">pb_data</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_cobranet_hmi_read</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hmi_address</span><span class="p">,</span> <span class="n">u32</span> <span class="n">max_byte_count</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pbyte_count</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">pb_data</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_cobranet_hmi_get_status</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pstatus</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">preadable_size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pwriteable_size</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_cobranet_get_ip_address</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pdw_ip_address</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_cobranet_set_ip_address</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dw_ip_address</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_cobranet_get_static_ip_address</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pdw_ip_address</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_cobranet_set_static_ip_address</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dw_ip_address</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_cobranet_get_macaddress</span><span class="p">(</span><span class="n">u32</span> <span class="n">h_control</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">p_mac_msbs</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">p_mac_lsbs</span><span class="p">);</span>

<span class="cm">/*************************/</span>
<span class="cm">/* Tone Detector control */</span>
<span class="cm">/*************************/</span>
<span class="n">u16</span> <span class="n">hpi_tone_detector_get_state</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tone_detector_set_enable</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="n">u32</span> <span class="n">enable</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tone_detector_get_enable</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">enable</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tone_detector_set_event_enable</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event_enable</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tone_detector_get_event_enable</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">event_enable</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tone_detector_set_threshold</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="kt">int</span> <span class="n">threshold</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tone_detector_get_threshold</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">threshold</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_tone_detector_get_frequency</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">frequency</span><span class="p">);</span>

<span class="cm">/****************************/</span>
<span class="cm">/* Silence Detector control */</span>
<span class="cm">/****************************/</span>
<span class="n">u16</span> <span class="n">hpi_silence_detector_get_state</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_silence_detector_set_enable</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="n">u32</span> <span class="n">enable</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_silence_detector_get_enable</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">enable</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_silence_detector_set_event_enable</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event_enable</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_silence_detector_get_event_enable</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">event_enable</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_silence_detector_set_delay</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="n">u32</span> <span class="n">delay</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_silence_detector_get_delay</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">delay</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_silence_detector_set_threshold</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="kt">int</span> <span class="n">threshold</span><span class="p">);</span>

<span class="n">u16</span> <span class="n">hpi_silence_detector_get_threshold</span><span class="p">(</span><span class="n">u32</span> <span class="n">hC</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">threshold</span><span class="p">);</span>
<span class="cm">/*********************/</span>
<span class="cm">/* Utility functions */</span>
<span class="cm">/*********************/</span>

<span class="n">u16</span> <span class="n">hpi_format_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">hpi_format</span> <span class="o">*</span><span class="n">p_format</span><span class="p">,</span> <span class="n">u16</span> <span class="n">channels</span><span class="p">,</span> <span class="n">u16</span> <span class="n">format</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bit_rate</span><span class="p">,</span> <span class="n">u32</span> <span class="n">attributes</span><span class="p">);</span>

<span class="cp">#endif	 </span><span class="cm">/*_HPI_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
