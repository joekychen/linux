<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › pci › nm256 › nm256.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>nm256.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* </span>
<span class="cm"> * Driver for NeoMagic 256AV and 256ZX chipsets.</span>
<span class="cm"> * Copyright (c) 2000 by Takashi Iwai &lt;tiwai@suse.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Based on nm256_audio.c OSS driver in linux kernel.</span>
<span class="cm"> * The original author of OSS nm256 driver wishes to remain anonymous,</span>
<span class="cm"> * so I just put my acknoledgment to him/her here.</span>
<span class="cm"> * The original author&#39;s web page is found at</span>
<span class="cm"> *	http://www.uglx.org/sony.html</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *   GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>
  
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#include &lt;sound/core.h&gt;</span>
<span class="cp">#include &lt;sound/info.h&gt;</span>
<span class="cp">#include &lt;sound/control.h&gt;</span>
<span class="cp">#include &lt;sound/pcm.h&gt;</span>
<span class="cp">#include &lt;sound/ac97_codec.h&gt;</span>
<span class="cp">#include &lt;sound/initval.h&gt;</span>

<span class="cp">#define CARD_NAME &quot;NeoMagic 256AV/ZX&quot;</span>
<span class="cp">#define DRIVER_NAME &quot;NM256&quot;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Takashi Iwai &lt;tiwai@suse.de&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;NeoMagic NM256AV/ZX&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_SUPPORTED_DEVICE</span><span class="p">(</span><span class="s">&quot;{{NeoMagic,NM256AV},&quot;</span>
		<span class="s">&quot;{NeoMagic,NM256ZX}}&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * some compile conditions.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">SNDRV_DEFAULT_IDX1</span><span class="p">;</span>	<span class="cm">/* Index */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="n">SNDRV_DEFAULT_STR1</span><span class="p">;</span>	<span class="cm">/* ID for this card */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">playback_bufsize</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">capture_bufsize</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">force_ac97</span><span class="p">;</span>			<span class="cm">/* disabled as default */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">buffer_top</span><span class="p">;</span>			<span class="cm">/* not specified */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">use_cache</span><span class="p">;</span>			<span class="cm">/* disabled */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">vaio_hack</span><span class="p">;</span>			<span class="cm">/* disabled */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">reset_workaround</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">reset_workaround_2</span><span class="p">;</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s">&quot;Index value for &quot;</span> <span class="n">CARD_NAME</span> <span class="s">&quot; soundcard.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="s">&quot;ID string for &quot;</span> <span class="n">CARD_NAME</span> <span class="s">&quot; soundcard.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">playback_bufsize</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">playback_bufsize</span><span class="p">,</span> <span class="s">&quot;DAC frame size in kB for &quot;</span> <span class="n">CARD_NAME</span> <span class="s">&quot; soundcard.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">capture_bufsize</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">capture_bufsize</span><span class="p">,</span> <span class="s">&quot;ADC frame size in kB for &quot;</span> <span class="n">CARD_NAME</span> <span class="s">&quot; soundcard.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">force_ac97</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">force_ac97</span><span class="p">,</span> <span class="s">&quot;Force to use AC97 codec for &quot;</span> <span class="n">CARD_NAME</span> <span class="s">&quot; soundcard.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">buffer_top</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">buffer_top</span><span class="p">,</span> <span class="s">&quot;Set the top address of audio buffer for &quot;</span> <span class="n">CARD_NAME</span> <span class="s">&quot; soundcard.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">use_cache</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">use_cache</span><span class="p">,</span> <span class="s">&quot;Enable the cache for coefficient table access.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">vaio_hack</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">vaio_hack</span><span class="p">,</span> <span class="s">&quot;Enable workaround for Sony VAIO notebooks.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">reset_workaround</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">reset_workaround</span><span class="p">,</span> <span class="s">&quot;Enable AC97 RESET workaround for some laptops.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">reset_workaround_2</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">reset_workaround_2</span><span class="p">,</span> <span class="s">&quot;Enable extended AC97 RESET workaround for some other laptops.&quot;</span><span class="p">);</span>

<span class="cm">/* just for backward compatibility */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">enable</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>



<span class="cm">/*</span>
<span class="cm"> * hw definitions</span>
<span class="cm"> */</span>

<span class="cm">/* The BIOS signature. */</span>
<span class="cp">#define NM_SIGNATURE 0x4e4d0000</span>
<span class="cm">/* Signature mask. */</span>
<span class="cp">#define NM_SIG_MASK 0xffff0000</span>

<span class="cm">/* Size of the second memory area. */</span>
<span class="cp">#define NM_PORT2_SIZE 4096</span>

<span class="cm">/* The base offset of the mixer in the second memory area. */</span>
<span class="cp">#define NM_MIXER_OFFSET 0x600</span>

<span class="cm">/* The maximum size of a coefficient entry. */</span>
<span class="cp">#define NM_MAX_PLAYBACK_COEF_SIZE	0x5000</span>
<span class="cp">#define NM_MAX_RECORD_COEF_SIZE		0x1260</span>

<span class="cm">/* The interrupt register. */</span>
<span class="cp">#define NM_INT_REG 0xa04</span>
<span class="cm">/* And its bits. */</span>
<span class="cp">#define NM_PLAYBACK_INT 0x40</span>
<span class="cp">#define NM_RECORD_INT 0x100</span>
<span class="cp">#define NM_MISC_INT_1 0x4000</span>
<span class="cp">#define NM_MISC_INT_2 0x1</span>
<span class="cp">#define NM_ACK_INT(chip, X) snd_nm256_writew(chip, NM_INT_REG, (X) &lt;&lt; 1)</span>

<span class="cm">/* The AV&#39;s &quot;mixer ready&quot; status bit and location. */</span>
<span class="cp">#define NM_MIXER_STATUS_OFFSET 0xa04</span>
<span class="cp">#define NM_MIXER_READY_MASK 0x0800</span>
<span class="cp">#define NM_MIXER_PRESENCE 0xa06</span>
<span class="cp">#define NM_PRESENCE_MASK 0x0050</span>
<span class="cp">#define NM_PRESENCE_VALUE 0x0040</span>

<span class="cm">/*</span>
<span class="cm"> * For the ZX.  It uses the same interrupt register, but it holds 32</span>
<span class="cm"> * bits instead of 16.</span>
<span class="cm"> */</span>
<span class="cp">#define NM2_PLAYBACK_INT 0x10000</span>
<span class="cp">#define NM2_RECORD_INT 0x80000</span>
<span class="cp">#define NM2_MISC_INT_1 0x8</span>
<span class="cp">#define NM2_MISC_INT_2 0x2</span>
<span class="cp">#define NM2_ACK_INT(chip, X) snd_nm256_writel(chip, NM_INT_REG, (X))</span>

<span class="cm">/* The ZX&#39;s &quot;mixer ready&quot; status bit and location. */</span>
<span class="cp">#define NM2_MIXER_STATUS_OFFSET 0xa06</span>
<span class="cp">#define NM2_MIXER_READY_MASK 0x0800</span>

<span class="cm">/* The playback registers start from here. */</span>
<span class="cp">#define NM_PLAYBACK_REG_OFFSET 0x0</span>
<span class="cm">/* The record registers start from here. */</span>
<span class="cp">#define NM_RECORD_REG_OFFSET 0x200</span>

<span class="cm">/* The rate register is located 2 bytes from the start of the register area. */</span>
<span class="cp">#define NM_RATE_REG_OFFSET 2</span>

<span class="cm">/* Mono/stereo flag, number of bits on playback, and rate mask. */</span>
<span class="cp">#define NM_RATE_STEREO 1</span>
<span class="cp">#define NM_RATE_BITS_16 2</span>
<span class="cp">#define NM_RATE_MASK 0xf0</span>

<span class="cm">/* Playback enable register. */</span>
<span class="cp">#define NM_PLAYBACK_ENABLE_REG (NM_PLAYBACK_REG_OFFSET + 0x1)</span>
<span class="cp">#define NM_PLAYBACK_ENABLE_FLAG 1</span>
<span class="cp">#define NM_PLAYBACK_ONESHOT 2</span>
<span class="cp">#define NM_PLAYBACK_FREERUN 4</span>

<span class="cm">/* Mutes the audio output. */</span>
<span class="cp">#define NM_AUDIO_MUTE_REG (NM_PLAYBACK_REG_OFFSET + 0x18)</span>
<span class="cp">#define NM_AUDIO_MUTE_LEFT 0x8000</span>
<span class="cp">#define NM_AUDIO_MUTE_RIGHT 0x0080</span>

<span class="cm">/* Recording enable register. */</span>
<span class="cp">#define NM_RECORD_ENABLE_REG (NM_RECORD_REG_OFFSET + 0)</span>
<span class="cp">#define NM_RECORD_ENABLE_FLAG 1</span>
<span class="cp">#define NM_RECORD_FREERUN 2</span>

<span class="cm">/* coefficient buffer pointer */</span>
<span class="cp">#define NM_COEFF_START_OFFSET	0x1c</span>
<span class="cp">#define NM_COEFF_END_OFFSET	0x20</span>

<span class="cm">/* DMA buffer offsets */</span>
<span class="cp">#define NM_RBUFFER_START (NM_RECORD_REG_OFFSET + 0x4)</span>
<span class="cp">#define NM_RBUFFER_END   (NM_RECORD_REG_OFFSET + 0x10)</span>
<span class="cp">#define NM_RBUFFER_WMARK (NM_RECORD_REG_OFFSET + 0xc)</span>
<span class="cp">#define NM_RBUFFER_CURRP (NM_RECORD_REG_OFFSET + 0x8)</span>

<span class="cp">#define NM_PBUFFER_START (NM_PLAYBACK_REG_OFFSET + 0x4)</span>
<span class="cp">#define NM_PBUFFER_END   (NM_PLAYBACK_REG_OFFSET + 0x14)</span>
<span class="cp">#define NM_PBUFFER_WMARK (NM_PLAYBACK_REG_OFFSET + 0xc)</span>
<span class="cp">#define NM_PBUFFER_CURRP (NM_PLAYBACK_REG_OFFSET + 0x8)</span>

<span class="k">struct</span> <span class="n">nm256_stream</span> <span class="p">{</span>

	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">running</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">suspended</span><span class="p">;</span>
	
	<span class="n">u32</span> <span class="n">buf</span><span class="p">;</span>	<span class="cm">/* offset from chip-&gt;buffer */</span>
	<span class="kt">int</span> <span class="n">bufsize</span><span class="p">;</span>	<span class="cm">/* buffer size in bytes */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">bufptr</span><span class="p">;</span>		<span class="cm">/* mapped pointer */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bufptr_addr</span><span class="p">;</span>	<span class="cm">/* physical address of the mapped pointer */</span>

	<span class="kt">int</span> <span class="n">dma_size</span><span class="p">;</span>		<span class="cm">/* buffer size of the substream in bytes */</span>
	<span class="kt">int</span> <span class="n">period_size</span><span class="p">;</span>	<span class="cm">/* period size in bytes */</span>
	<span class="kt">int</span> <span class="n">periods</span><span class="p">;</span>		<span class="cm">/* # of periods */</span>
	<span class="kt">int</span> <span class="n">shift</span><span class="p">;</span>		<span class="cm">/* bit shifts */</span>
	<span class="kt">int</span> <span class="n">cur_period</span><span class="p">;</span>		<span class="cm">/* current period # */</span>

<span class="p">};</span>

<span class="k">struct</span> <span class="n">nm256</span> <span class="p">{</span>
	
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>

	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">cport</span><span class="p">;</span>		<span class="cm">/* control port */</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res_cport</span><span class="p">;</span>	<span class="cm">/* its resource */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cport_addr</span><span class="p">;</span>	<span class="cm">/* physical address */</span>

	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>		<span class="cm">/* buffer */</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res_buffer</span><span class="p">;</span>	<span class="cm">/* its resource */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer_addr</span><span class="p">;</span>	<span class="cm">/* buffer phyiscal address */</span>

	<span class="n">u32</span> <span class="n">buffer_start</span><span class="p">;</span>		<span class="cm">/* start offset from pci resource 0 */</span>
	<span class="n">u32</span> <span class="n">buffer_end</span><span class="p">;</span>			<span class="cm">/* end offset */</span>
	<span class="n">u32</span> <span class="n">buffer_size</span><span class="p">;</span>		<span class="cm">/* total buffer size */</span>

	<span class="n">u32</span> <span class="n">all_coeff_buf</span><span class="p">;</span>		<span class="cm">/* coefficient buffer */</span>
	<span class="n">u32</span> <span class="n">coeff_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>		<span class="cm">/* coefficient buffer for each stream */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">coeffs_current</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* coeff. table is loaded? */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">use_cache</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* use one big coef. table */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reset_workaround</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Workaround for some laptops to avoid freeze */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reset_workaround_2</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Extended workaround for some other laptops to avoid freeze */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">in_resume</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">mixer_base</span><span class="p">;</span>			<span class="cm">/* register offset of ac97 mixer */</span>
	<span class="kt">int</span> <span class="n">mixer_status_offset</span><span class="p">;</span>	<span class="cm">/* offset of mixer status reg. */</span>
	<span class="kt">int</span> <span class="n">mixer_status_mask</span><span class="p">;</span>		<span class="cm">/* bit mask to test the mixer status */</span>

	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq_acks</span><span class="p">;</span>
	<span class="n">irq_handler_t</span> <span class="n">interrupt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">badintrcount</span><span class="p">;</span>		<span class="cm">/* counter to check bogus interrupts */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">irq_mutex</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">nm256_stream</span> <span class="n">streams</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">snd_ac97</span> <span class="o">*</span><span class="n">ac97</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">ac97_regs</span><span class="p">;</span> <span class="cm">/* register caches, only for valid regs */</span>

	<span class="k">struct</span> <span class="n">snd_pcm</span> <span class="o">*</span><span class="n">pcm</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">reg_lock</span><span class="p">;</span>

<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * include coefficient table</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;nm256_coef.c&quot;</span>


<span class="cm">/*</span>
<span class="cm"> * PCI ids</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">snd_nm256_ids</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">NEOMAGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO</span><span class="p">),</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">NEOMAGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO</span><span class="p">),</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">NEOMAGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO</span><span class="p">),</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,},</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">snd_nm256_ids</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * lowlvel stuffs</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span>
<span class="nf">snd_nm256_readb</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readb</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span>
<span class="nf">snd_nm256_readw</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readw</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span>
<span class="nf">snd_nm256_readl</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_nm256_writeb</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_nm256_writew</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_nm256_writel</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_nm256_write_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">offset</span> <span class="o">-=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SND_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;write_buffer invalid offset = %d size = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * coefficient handlers -- what a magic!</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u16</span>
<span class="nf">snd_nm256_get_start_offset</span><span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">which</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">coefficient_sizes</span><span class="p">[</span><span class="n">which</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_nm256_load_one_coefficient</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stream</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">which</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">coeff_buf</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">coeff_buf</span><span class="p">[</span><span class="n">stream</span><span class="p">];</span>
	<span class="n">u16</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">snd_nm256_get_start_offset</span><span class="p">(</span><span class="n">which</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">size</span> <span class="o">=</span> <span class="n">coefficient_sizes</span><span class="p">[</span><span class="n">which</span><span class="p">];</span>

	<span class="n">snd_nm256_write_buffer</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">coefficients</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">coeff_buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">snd_nm256_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">coeff_buf</span><span class="p">);</span>
	<span class="cm">/* ???  Record seems to behave differently than playback.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">)</span>
		<span class="n">size</span><span class="o">--</span><span class="p">;</span>
	<span class="n">snd_nm256_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">port</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">coeff_buf</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_nm256_load_coefficient</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">number</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The enable register for the specified engine.  */</span>
	<span class="n">u32</span> <span class="n">poffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">stream</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_CAPTURE</span> <span class="o">?</span>
		       <span class="n">NM_RECORD_ENABLE_REG</span> <span class="o">:</span> <span class="n">NM_PLAYBACK_ENABLE_REG</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">NM_COEFF_START_OFFSET</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">stream</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_CAPTURE</span> <span class="o">?</span>
		 <span class="n">NM_RECORD_REG_OFFSET</span> <span class="o">:</span> <span class="n">NM_PLAYBACK_REG_OFFSET</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_nm256_readb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">poffset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="s">&quot;NM256: Engine was enabled while loading coefficients!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The recording engine uses coefficient values 8-15.  */</span>
	<span class="n">number</span> <span class="o">&amp;=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">)</span>
		<span class="n">number</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">use_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_nm256_load_one_coefficient</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">coeffs_current</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_nm256_write_buffer</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">all_coeff_buf</span><span class="p">,</span>
				       <span class="n">NM_TOTAL_COEFF_COUNT</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">coeffs_current</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">base</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">all_coeff_buf</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">snd_nm256_get_start_offset</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>
		<span class="n">u32</span> <span class="n">end_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">coefficient_sizes</span><span class="p">[</span><span class="n">number</span><span class="p">];</span>
		<span class="n">snd_nm256_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">)</span>
			<span class="n">end_offset</span><span class="o">--</span><span class="p">;</span>
		<span class="n">snd_nm256_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">end_offset</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* The actual rates supported by the card. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">samplerates</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">8000</span><span class="p">,</span> <span class="mi">11025</span><span class="p">,</span> <span class="mi">16000</span><span class="p">,</span> <span class="mi">22050</span><span class="p">,</span> <span class="mi">24000</span><span class="p">,</span> <span class="mi">32000</span><span class="p">,</span> <span class="mi">44100</span><span class="p">,</span> <span class="mi">48000</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_hw_constraint_list</span> <span class="n">constraints_rates</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">samplerates</span><span class="p">),</span> 
	<span class="p">.</span><span class="n">list</span> <span class="o">=</span> <span class="n">samplerates</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * return the index of the target rate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_nm256_fixed_rate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">samplerates</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rate</span> <span class="o">==</span> <span class="n">samplerates</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">snd_BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * set sample rate and format</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_nm256_set_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rate_index</span> <span class="o">=</span> <span class="n">snd_nm256_fixed_rate</span><span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ratebits</span> <span class="o">=</span> <span class="p">(</span><span class="n">rate_index</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NM_RATE_MASK</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_pcm_format_width</span><span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">)</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ratebits</span> <span class="o">|=</span> <span class="n">NM_RATE_BITS_16</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">shift</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ratebits</span> <span class="o">|=</span> <span class="n">NM_RATE_STEREO</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">shift</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="n">samplerates</span><span class="p">[</span><span class="n">rate_index</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span>:
		<span class="n">snd_nm256_load_coefficient</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rate_index</span><span class="p">);</span> <span class="cm">/* 0 = playback */</span>
		<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span>
				 <span class="n">NM_PLAYBACK_REG_OFFSET</span> <span class="o">+</span> <span class="n">NM_RATE_REG_OFFSET</span><span class="p">,</span>
				 <span class="n">ratebits</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_STREAM_CAPTURE</span>:
		<span class="n">snd_nm256_load_coefficient</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rate_index</span><span class="p">);</span> <span class="cm">/* 1 = record */</span>
		<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span>
				 <span class="n">NM_RECORD_REG_OFFSET</span> <span class="o">+</span> <span class="n">NM_RATE_REG_OFFSET</span><span class="p">,</span>
				 <span class="n">ratebits</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* acquire interrupt */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_nm256_acquire_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
				<span class="n">KBUILD_MODNAME</span><span class="p">,</span> <span class="n">chip</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;unable to grab IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_mutex</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_acks</span><span class="o">++</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* release interrupt */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snd_nm256_release_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_acks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_acks</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_acks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * start / stop</span>
<span class="cm"> */</span>

<span class="cm">/* update the watermark (current period) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snd_nm256_pcm_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">cur_period</span><span class="o">++</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">cur_period</span> <span class="o">%=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">periods</span><span class="p">;</span>
	<span class="n">snd_nm256_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cur_period</span> <span class="o">*</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">period_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define snd_nm256_playback_mark(chip, s) snd_nm256_pcm_mark(chip, s, NM_PBUFFER_WMARK)</span>
<span class="cp">#define snd_nm256_capture_mark(chip, s)  snd_nm256_pcm_mark(chip, s, NM_RBUFFER_WMARK)</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_nm256_playback_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* program buffer pointers */</span>
	<span class="n">snd_nm256_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_PBUFFER_START</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">snd_nm256_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_PBUFFER_END</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dma_size</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">));</span>
	<span class="n">snd_nm256_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_PBUFFER_CURRP</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">snd_nm256_playback_mark</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

	<span class="cm">/* Enable playback engine and interrupts. */</span>
	<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_PLAYBACK_ENABLE_REG</span><span class="p">,</span>
			 <span class="n">NM_PLAYBACK_ENABLE_FLAG</span> <span class="o">|</span> <span class="n">NM_PLAYBACK_FREERUN</span><span class="p">);</span>
	<span class="cm">/* Enable both channels. */</span>
	<span class="n">snd_nm256_writew</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_AUDIO_MUTE_REG</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_nm256_capture_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* program buffer pointers */</span>
	<span class="n">snd_nm256_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_RBUFFER_START</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">snd_nm256_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_RBUFFER_END</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dma_size</span><span class="p">);</span>
	<span class="n">snd_nm256_writel</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_RBUFFER_CURRP</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">snd_nm256_capture_mark</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

	<span class="cm">/* Enable playback engine and interrupts. */</span>
	<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_RECORD_ENABLE_REG</span><span class="p">,</span>
			 <span class="n">NM_RECORD_ENABLE_FLAG</span> <span class="o">|</span> <span class="n">NM_RECORD_FREERUN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Stop the play engine. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_nm256_playback_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Shut off sound from both channels. */</span>
	<span class="n">snd_nm256_writew</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_AUDIO_MUTE_REG</span><span class="p">,</span>
			 <span class="n">NM_AUDIO_MUTE_LEFT</span> <span class="o">|</span> <span class="n">NM_AUDIO_MUTE_RIGHT</span><span class="p">);</span>
	<span class="cm">/* Disable play engine. */</span>
	<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_PLAYBACK_ENABLE_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_nm256_capture_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable recording engine. */</span>
	<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_RECORD_ENABLE_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_nm256_playback_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_RESUME</span>:
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* fallthru */</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_START</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_nm256_playback_start</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">substream</span><span class="p">);</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_SUSPEND</span>:
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">suspended</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* fallthru */</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_STOP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_nm256_playback_stop</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_nm256_capture_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_START</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_RESUME</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_nm256_capture_start</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">substream</span><span class="p">);</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_STOP</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_SUSPEND</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_nm256_capture_stop</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * prepare playback/capture channel</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_nm256_pcm_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">dma_size</span> <span class="o">=</span> <span class="n">frames_to_bytes</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">period_size</span> <span class="o">=</span> <span class="n">frames_to_bytes</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">period_size</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">periods</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">periods</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">cur_period</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">snd_nm256_set_format</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">substream</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * get the current pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">snd_pcm_uframes_t</span>
<span class="nf">snd_nm256_playback_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">curp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">curp</span> <span class="o">=</span> <span class="n">snd_nm256_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_PBUFFER_CURRP</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">curp</span> <span class="o">%=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dma_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bytes_to_frames</span><span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">,</span> <span class="n">curp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">snd_pcm_uframes_t</span>
<span class="nf">snd_nm256_capture_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">curp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">curp</span> <span class="o">=</span> <span class="n">snd_nm256_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_RBUFFER_CURRP</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">curp</span> <span class="o">%=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dma_size</span><span class="p">;</span>	
	<span class="k">return</span> <span class="n">bytes_to_frames</span><span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">,</span> <span class="n">curp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Remapped I/O space can be accessible as pointer on i386 */</span>
<span class="cm">/* This might be changed in the future */</span>
<span class="cp">#ifndef __i386__</span>
<span class="cm">/*</span>
<span class="cm"> * silence / copy for playback</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_nm256_playback_silence</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="cm">/* not used (interleaved data) */</span>
			   <span class="n">snd_pcm_uframes_t</span> <span class="n">pos</span><span class="p">,</span>
			   <span class="n">snd_pcm_uframes_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">frames_to_bytes</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">frames_to_bytes</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">memset_io</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bufptr</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_nm256_playback_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="cm">/* not used (interleaved data) */</span>
			<span class="n">snd_pcm_uframes_t</span> <span class="n">pos</span><span class="p">,</span>
			<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
			<span class="n">snd_pcm_uframes_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">frames_to_bytes</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">frames_to_bytes</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user_toio</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bufptr</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * copy to user</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_nm256_capture_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="cm">/* not used (interleaved data) */</span>
		       <span class="n">snd_pcm_uframes_t</span> <span class="n">pos</span><span class="p">,</span>
		       <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
		       <span class="n">snd_pcm_uframes_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">frames_to_bytes</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">frames_to_bytes</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user_fromio</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bufptr</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !__i386__ */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * update playback/capture watermarks</span>
<span class="cm"> */</span>

<span class="cm">/* spinlock held! */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_nm256_playback_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="n">snd_pcm_period_elapsed</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="n">snd_nm256_playback_mark</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* spinlock held! */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_nm256_capture_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="n">snd_pcm_period_elapsed</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="n">snd_nm256_capture_mark</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * hardware info</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_hardware</span> <span class="n">snd_nm256_playback</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span>			<span class="n">SNDRV_PCM_INFO_MMAP_IOMEM</span> <span class="o">|</span><span class="n">SNDRV_PCM_INFO_MMAP_VALID</span> <span class="o">|</span>
				<span class="n">SNDRV_PCM_INFO_INTERLEAVED</span> <span class="o">|</span>
				<span class="cm">/*SNDRV_PCM_INFO_PAUSE |*/</span>
				<span class="n">SNDRV_PCM_INFO_RESUME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">formats</span> <span class="o">=</span>		<span class="n">SNDRV_PCM_FMTBIT_U8</span> <span class="o">|</span> <span class="n">SNDRV_PCM_FMTBIT_S16_LE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rates</span> <span class="o">=</span>		<span class="n">SNDRV_PCM_RATE_KNOT</span><span class="cm">/*24k*/</span> <span class="o">|</span> <span class="n">SNDRV_PCM_RATE_8000_48000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rate_min</span> <span class="o">=</span>		<span class="mi">8000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rate_max</span> <span class="o">=</span>		<span class="mi">48000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">channels_min</span> <span class="o">=</span>		<span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">channels_max</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">periods_min</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">periods_max</span> <span class="o">=</span>		<span class="mi">1024</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buffer_bytes_max</span> <span class="o">=</span>	<span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
	<span class="p">.</span><span class="n">period_bytes_min</span> <span class="o">=</span>	<span class="mi">256</span><span class="p">,</span>
	<span class="p">.</span><span class="n">period_bytes_max</span> <span class="o">=</span>	<span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_hardware</span> <span class="n">snd_nm256_capture</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span>			<span class="n">SNDRV_PCM_INFO_MMAP_IOMEM</span> <span class="o">|</span> <span class="n">SNDRV_PCM_INFO_MMAP_VALID</span> <span class="o">|</span>
				<span class="n">SNDRV_PCM_INFO_INTERLEAVED</span> <span class="o">|</span>
				<span class="cm">/*SNDRV_PCM_INFO_PAUSE |*/</span>
				<span class="n">SNDRV_PCM_INFO_RESUME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">formats</span> <span class="o">=</span>		<span class="n">SNDRV_PCM_FMTBIT_U8</span> <span class="o">|</span> <span class="n">SNDRV_PCM_FMTBIT_S16_LE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rates</span> <span class="o">=</span>		<span class="n">SNDRV_PCM_RATE_KNOT</span><span class="cm">/*24k*/</span> <span class="o">|</span> <span class="n">SNDRV_PCM_RATE_8000_48000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rate_min</span> <span class="o">=</span>		<span class="mi">8000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rate_max</span> <span class="o">=</span>		<span class="mi">48000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">channels_min</span> <span class="o">=</span>		<span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">channels_max</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">periods_min</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">periods_max</span> <span class="o">=</span>		<span class="mi">1024</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buffer_bytes_max</span> <span class="o">=</span>	<span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
	<span class="p">.</span><span class="n">period_bytes_min</span> <span class="o">=</span>	<span class="mi">256</span><span class="p">,</span>
	<span class="p">.</span><span class="n">period_bytes_max</span> <span class="o">=</span>	<span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* set dma transfer size */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_nm256_pcm_hw_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">hw_params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* area and addr are already set and unchanged */</span>
	<span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_bytes</span> <span class="o">=</span> <span class="n">params_buffer_bytes</span><span class="p">(</span><span class="n">hw_params</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * open</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snd_nm256_setup_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">snd_pcm_hardware</span> <span class="o">*</span><span class="n">hw_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span> <span class="o">=</span> <span class="o">*</span><span class="n">hw_ptr</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">buffer_bytes_max</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bufsize</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_bytes_max</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bufsize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bufptr</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bufptr_addr</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_bytes</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bufsize</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">substream</span> <span class="o">=</span> <span class="n">substream</span><span class="p">;</span>

	<span class="n">snd_pcm_hw_constraint_list</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_RATE</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">constraints_rates</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_nm256_playback_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_nm256_acquire_irq</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="n">snd_nm256_setup_stream</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">],</span>
			       <span class="n">substream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snd_nm256_playback</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_nm256_capture_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_nm256_acquire_irq</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="n">snd_nm256_setup_stream</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">],</span>
			       <span class="n">substream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snd_nm256_capture</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * close - we don&#39;t have to do special..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_nm256_playback_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>

	<span class="n">snd_nm256_release_irq</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_nm256_capture_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>

	<span class="n">snd_nm256_release_irq</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * create a pcm instance</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_ops</span> <span class="n">snd_nm256_playback_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">snd_nm256_playback_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span>	<span class="n">snd_nm256_playback_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">snd_pcm_lib_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_params</span> <span class="o">=</span>	<span class="n">snd_nm256_pcm_hw_params</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare</span> <span class="o">=</span>	<span class="n">snd_nm256_pcm_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span>	<span class="n">snd_nm256_playback_trigger</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pointer</span> <span class="o">=</span>	<span class="n">snd_nm256_playback_pointer</span><span class="p">,</span>
<span class="cp">#ifndef __i386__</span>
	<span class="p">.</span><span class="n">copy</span> <span class="o">=</span>		<span class="n">snd_nm256_playback_copy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">silence</span> <span class="o">=</span>	<span class="n">snd_nm256_playback_silence</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">snd_pcm_lib_mmap_iomem</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_ops</span> <span class="n">snd_nm256_capture_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">snd_nm256_capture_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span>	<span class="n">snd_nm256_capture_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">snd_pcm_lib_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_params</span> <span class="o">=</span>	<span class="n">snd_nm256_pcm_hw_params</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare</span> <span class="o">=</span>	<span class="n">snd_nm256_pcm_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span>	<span class="n">snd_nm256_capture_trigger</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pointer</span> <span class="o">=</span>	<span class="n">snd_nm256_capture_pointer</span><span class="p">,</span>
<span class="cp">#ifndef __i386__</span>
	<span class="p">.</span><span class="n">copy</span> <span class="o">=</span>		<span class="n">snd_nm256_capture_copy</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">snd_pcm_lib_mmap_iomem</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">snd_nm256_pcm</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm</span> <span class="o">*</span><span class="n">pcm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">bufptr</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">bufptr_addr</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_pcm_new</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span>
			  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">snd_pcm_set_ops</span><span class="p">(</span><span class="n">pcm</span><span class="p">,</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snd_nm256_playback_ops</span><span class="p">);</span>
	<span class="n">snd_pcm_set_ops</span><span class="p">(</span><span class="n">pcm</span><span class="p">,</span> <span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snd_nm256_capture_ops</span><span class="p">);</span>

	<span class="n">pcm</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">pcm</span><span class="o">-&gt;</span><span class="n">info_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm</span> <span class="o">=</span> <span class="n">pcm</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* </span>
<span class="cm"> * Initialize the hardware. </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_nm256_init_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Reset everything. */</span>
	<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">);</span>
	<span class="n">snd_nm256_writew</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0x214</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* stop sounds.. */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>snd<em>nm256</em>playback<em>stop(chip);
snd</em>nm256<em>capture</em>stop(chip);</p></td><td class="code"><div class="highlight"><pre><span class="p">}</span>


<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">snd_nm256_intr_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">badintrcount</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * I&#39;m not sure if the best thing is to stop the card from</span>
<span class="cm">		 * playing or just release the interrupt (after all, we&#39;re in</span>
<span class="cm">		 * a bad situation, so doing fancy stuff may not be such a good</span>
<span class="cm">		 * idea).</span>
<span class="cm">		 *</span>
<span class="cm">		 * I worry about the card engine continuing to play noise</span>
<span class="cm">		 * over and over, however--that could become a very</span>
<span class="cm">		 * obnoxious problem.  And we know that when this usually</span>
<span class="cm">		 * happens things are fairly safe, it just means the user&#39;s</span>
<span class="cm">		 * inserted a PCMCIA card and someone&#39;s spamming us with IRQ 9s.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">].</span><span class="n">running</span><span class="p">)</span>
			<span class="n">snd_nm256_playback_stop</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">].</span><span class="n">running</span><span class="p">)</span>
			<span class="n">snd_nm256_capture_stop</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">badintrcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> * Handle a potential interrupt for the device referred to by DEV_ID. </span>
<span class="cm"> *</span>
<span class="cm"> * I don&#39;t like the cut-n-paste job here either between the two routines,</span>
<span class="cm"> * but there are sufficient differences between the two interrupt handlers</span>
<span class="cm"> * that parameterizing it isn&#39;t all that great either.  (Could use a macro,</span>
<span class="cm"> * I suppose...yucky bleah.)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">snd_nm256_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cbyte</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">snd_nm256_readw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_INT_REG</span><span class="p">);</span>

	<span class="cm">/* Not ours. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">snd_nm256_intr_check</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">badintrcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Rather boring; check for individual interrupts and process them. */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">NM_PLAYBACK_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NM_PLAYBACK_INT</span><span class="p">;</span>
		<span class="n">NM_ACK_INT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_PLAYBACK_INT</span><span class="p">);</span>
		<span class="n">snd_nm256_playback_update</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">NM_RECORD_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NM_RECORD_INT</span><span class="p">;</span>
		<span class="n">NM_ACK_INT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_RECORD_INT</span><span class="p">);</span>
		<span class="n">snd_nm256_capture_update</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">NM_MISC_INT_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NM_MISC_INT_1</span><span class="p">;</span>
		<span class="n">NM_ACK_INT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_MISC_INT_1</span><span class="p">);</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="s">&quot;NM256: Got misc interrupt #1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">snd_nm256_writew</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_INT_REG</span><span class="p">,</span> <span class="mh">0x8000</span><span class="p">);</span>
		<span class="n">cbyte</span> <span class="o">=</span> <span class="n">snd_nm256_readb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0x400</span><span class="p">);</span>
		<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0x400</span><span class="p">,</span> <span class="n">cbyte</span> <span class="o">|</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">NM_MISC_INT_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NM_MISC_INT_2</span><span class="p">;</span>
		<span class="n">NM_ACK_INT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_MISC_INT_2</span><span class="p">);</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="s">&quot;NM256: Got misc interrupt #2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cbyte</span> <span class="o">=</span> <span class="n">snd_nm256_readb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0x400</span><span class="p">);</span>
		<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0x400</span><span class="p">,</span> <span class="n">cbyte</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Unknown interrupt. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="s">&quot;NM256: Fire in the hole! Unknown status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">status</span><span class="p">);</span>
		<span class="cm">/* Pray. */</span>
		<span class="n">NM_ACK_INT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle a potential interrupt for the device referred to by DEV_ID.</span>
<span class="cm"> * This handler is for the 256ZX, and is very similar to the non-ZX</span>
<span class="cm"> * routine.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">snd_nm256_interrupt_zx</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cbyte</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">snd_nm256_readl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_INT_REG</span><span class="p">);</span>

	<span class="cm">/* Not ours. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">snd_nm256_intr_check</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">badintrcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Rather boring; check for individual interrupts and process them. */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">NM2_PLAYBACK_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NM2_PLAYBACK_INT</span><span class="p">;</span>
		<span class="n">NM2_ACK_INT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM2_PLAYBACK_INT</span><span class="p">);</span>
		<span class="n">snd_nm256_playback_update</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">NM2_RECORD_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NM2_RECORD_INT</span><span class="p">;</span>
		<span class="n">NM2_ACK_INT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM2_RECORD_INT</span><span class="p">);</span>
		<span class="n">snd_nm256_capture_update</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">NM2_MISC_INT_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NM2_MISC_INT_1</span><span class="p">;</span>
		<span class="n">NM2_ACK_INT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM2_MISC_INT_1</span><span class="p">);</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="s">&quot;NM256: Got misc interrupt #1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cbyte</span> <span class="o">=</span> <span class="n">snd_nm256_readb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0x400</span><span class="p">);</span>
		<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0x400</span><span class="p">,</span> <span class="n">cbyte</span> <span class="o">|</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">NM2_MISC_INT_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NM2_MISC_INT_2</span><span class="p">;</span>
		<span class="n">NM2_ACK_INT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM2_MISC_INT_2</span><span class="p">);</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="s">&quot;NM256: Got misc interrupt #2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cbyte</span> <span class="o">=</span> <span class="n">snd_nm256_readb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0x400</span><span class="p">);</span>
		<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0x400</span><span class="p">,</span> <span class="n">cbyte</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Unknown interrupt. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="s">&quot;NM256: Fire in the hole! Unknown status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">status</span><span class="p">);</span>
		<span class="cm">/* Pray. */</span>
		<span class="n">NM2_ACK_INT</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * AC97 interface</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Waits for the mixer to become ready to be written; returns a zero value</span>
<span class="cm"> * if it timed out.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_nm256_ac97_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">testaddr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">testb</span><span class="p">;</span>

	<span class="n">testaddr</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_status_offset</span><span class="p">;</span>
	<span class="n">testb</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_status_mask</span><span class="p">;</span>

	<span class="cm">/* </span>
<span class="cm">	 * Loop around waiting for the mixer to become ready. </span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">timeout</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">snd_nm256_readw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">testaddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">testb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> * Initial register values to be written to the AC97 mixer.</span>
<span class="cm"> * While most of these are identical to the reset values, we do this</span>
<span class="cm"> * so that we have most of the register contents cached--this avoids</span>
<span class="cm"> * reading from the mixer directly (which seems to be problematic,</span>
<span class="cm"> * probably due to ignorance).</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">initialValues</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">initialValues</span> <span class="n">nm256_ac97_init_val</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">{</span> <span class="n">AC97_MASTER</span><span class="p">,</span> 		<span class="mh">0x8000</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_HEADPHONE</span><span class="p">,</span>	<span class="mh">0x8000</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_MASTER_MONO</span><span class="p">,</span>	<span class="mh">0x8000</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_PC_BEEP</span><span class="p">,</span>		<span class="mh">0x8000</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_PHONE</span><span class="p">,</span>		<span class="mh">0x8008</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_MIC</span><span class="p">,</span>		<span class="mh">0x8000</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_LINE</span><span class="p">,</span>		<span class="mh">0x8808</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_CD</span><span class="p">,</span>		<span class="mh">0x8808</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_VIDEO</span><span class="p">,</span>		<span class="mh">0x8808</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_AUX</span><span class="p">,</span>		<span class="mh">0x8808</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_PCM</span><span class="p">,</span>		<span class="mh">0x8808</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_REC_SEL</span><span class="p">,</span>		<span class="mh">0x0000</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_REC_GAIN</span><span class="p">,</span>	<span class="mh">0x0B0B</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_GENERAL_PURPOSE</span><span class="p">,</span>	<span class="mh">0x0000</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_3D_CONTROL</span><span class="p">,</span>	<span class="mh">0x8000</span> <span class="p">},</span> 
	<span class="p">{</span> <span class="n">AC97_VENDOR_ID1</span><span class="p">,</span> 	<span class="mh">0x8384</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_VENDOR_ID2</span><span class="p">,</span>	<span class="mh">0x7609</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nm256_ac97_idx</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">nm256_ac97_init_val</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nm256_ac97_init_val</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reg</span> <span class="o">==</span> <span class="n">reg</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * some nm256 easily crash when reading from mixer registers</span>
<span class="cm"> * thus we&#39;re treating it as a write-only mixer and cache the</span>
<span class="cm"> * written values</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span>
<span class="nf">snd_nm256_ac97_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_ac97</span> <span class="o">*</span><span class="n">ac97</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">ac97</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">nm256_ac97_idx</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ac97_regs</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_nm256_ac97_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_ac97</span> <span class="o">*</span><span class="n">ac97</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">ac97</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tries</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">nm256_ac97_idx</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_base</span><span class="p">;</span>

	<span class="n">snd_nm256_ac97_ready</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* Wait for the write to take, too. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tries</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_nm256_writew</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="cm">/* a little delay here seems better.. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">snd_nm256_ac97_ready</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* successful write: set cache */</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ac97_regs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">snd_printd</span><span class="p">(</span><span class="s">&quot;nm256: ac97 codec not ready..</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* static resolution table */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_ac97_res_table</span> <span class="n">nm256_res_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">AC97_MASTER</span><span class="p">,</span> <span class="mh">0x1f1f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_HEADPHONE</span><span class="p">,</span> <span class="mh">0x1f1f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_MASTER_MONO</span><span class="p">,</span> <span class="mh">0x001f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_PC_BEEP</span><span class="p">,</span> <span class="mh">0x001f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_PHONE</span><span class="p">,</span> <span class="mh">0x001f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_MIC</span><span class="p">,</span> <span class="mh">0x001f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_LINE</span><span class="p">,</span> <span class="mh">0x1f1f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_CD</span><span class="p">,</span> <span class="mh">0x1f1f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_VIDEO</span><span class="p">,</span> <span class="mh">0x1f1f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_AUX</span><span class="p">,</span> <span class="mh">0x1f1f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_PCM</span><span class="p">,</span> <span class="mh">0x1f1f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">AC97_REC_GAIN</span><span class="p">,</span> <span class="mh">0x0f0f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span> <span class="cm">/* terminator */</span>
<span class="p">};</span>

<span class="cm">/* initialize the ac97 into a known state */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_nm256_ac97_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_ac97</span> <span class="o">*</span><span class="n">ac97</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">ac97</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="cm">/* Reset the mixer.  &#39;Tis magic!  */</span>
	<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0x6c0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">reset_workaround</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Dell latitude LS will lock up by this */</span>
		<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0x6cc</span><span class="p">,</span> <span class="mh">0x87</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">reset_workaround_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Dell latitude CSx will lock up by this */</span>
		<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0x6cc</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
		<span class="n">snd_nm256_writeb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0x6cc</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">in_resume</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">nm256_ac97_init_val</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* preload the cache, so as to avoid even a single</span>
<span class="cm">			 * read of the mixer regs</span>
<span class="cm">			 */</span>
			<span class="n">snd_nm256_ac97_write</span><span class="p">(</span><span class="n">ac97</span><span class="p">,</span> <span class="n">nm256_ac97_init_val</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reg</span><span class="p">,</span>
					     <span class="n">nm256_ac97_init_val</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* create an ac97 mixer interface */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">snd_nm256_mixer</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_ac97_bus</span> <span class="o">*</span><span class="n">pbus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_ac97_template</span> <span class="n">ac97</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_ac97_bus_ops</span> <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">reset</span> <span class="o">=</span> <span class="n">snd_nm256_ac97_reset</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">snd_nm256_ac97_write</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">snd_nm256_ac97_read</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ac97_regs</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">nm256_ac97_init_val</span><span class="p">),</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ac97_regs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_ac97_bus</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pbus</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ac97</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ac97</span><span class="p">));</span>
	<span class="n">ac97</span><span class="p">.</span><span class="n">scaps</span> <span class="o">=</span> <span class="n">AC97_SCAP_AUDIO</span><span class="p">;</span> <span class="cm">/* we support audio! */</span>
	<span class="n">ac97</span><span class="p">.</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">ac97</span><span class="p">.</span><span class="n">res_table</span> <span class="o">=</span> <span class="n">nm256_res_table</span><span class="p">;</span>
	<span class="n">pbus</span><span class="o">-&gt;</span><span class="n">no_vra</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_ac97_mixer</span><span class="p">(</span><span class="n">pbus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ac97</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ac97</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ac97</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0xf0000000</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* looks like an invalid id */</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">mixername</span><span class="p">,</span> <span class="s">&quot;%s AC97&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> * See if the signature left by the NM256 BIOS is intact; if so, we use</span>
<span class="cm"> * the associated address as the end of our audio buffer in the video</span>
<span class="cm"> * RAM.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">snd_nm256_peek_for_sig</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The signature is located 1K below the end of video RAM.  */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="cm">/* Default buffer end is 5120 bytes below the top of RAM.  */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pointer_found</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_end</span> <span class="o">-</span> <span class="mh">0x1400</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sig</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_addr</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_end</span> <span class="o">-</span> <span class="mh">0x400</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to scan for card signature in video RAM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sig</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sig</span> <span class="o">&amp;</span> <span class="n">NM_SIG_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">NM_SIGNATURE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">pointer</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">temp</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If it&#39;s obviously invalid, don&#39;t use it</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pointer</span> <span class="o">==</span> <span class="mh">0xffffffff</span> <span class="o">||</span>
		    <span class="n">pointer</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">||</span>
		    <span class="n">pointer</span> <span class="o">&gt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;invalid signature found: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pointer</span><span class="p">);</span>
			<span class="n">iounmap</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pointer_found</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;nm256: found card signature in video RAM: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">pointer</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_end</span> <span class="o">=</span> <span class="n">pointer_found</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/*</span>
<span class="cm"> * APM event handler, so the card is properly reinitialized after a power</span>
<span class="cm"> * event.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nm256_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">snd_power_change_state</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">SNDRV_CTL_POWER_D3hot</span><span class="p">);</span>
	<span class="n">snd_pcm_suspend_all</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="p">);</span>
	<span class="n">snd_ac97_suspend</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ac97</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">coeffs_current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nm256_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Perform a full reset on the hardware */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">in_resume</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pci</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;nm256: pci_enable_device failed, &quot;</span>
		       <span class="s">&quot;disabling device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">snd_card_disconnect</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>

	<span class="n">snd_nm256_init_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* restore ac97 */</span>
	<span class="n">snd_ac97_resume</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ac97</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nm256_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">substream</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">suspended</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
			<span class="n">snd_nm256_set_format</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">snd_power_change_state</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">SNDRV_CTL_POWER_D0</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">in_resume</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_nm256_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">].</span><span class="n">running</span><span class="p">)</span>
		<span class="n">snd_nm256_playback_stop</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">].</span><span class="n">running</span><span class="p">)</span>
		<span class="n">snd_nm256_capture_stop</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
	<span class="n">release_and_free_resource</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">res_cport</span><span class="p">);</span>
	<span class="n">release_and_free_resource</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">res_buffer</span><span class="p">);</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ac97_regs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_nm256_dev_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">device_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snd_nm256_free</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">snd_nm256_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">nm256</span> <span class="o">**</span><span class="n">chip_ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">pval</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_device_ops</span> <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">dev_free</span> <span class="o">=</span>	<span class="n">snd_nm256_dev_free</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>

	<span class="o">*</span><span class="n">chip_ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pci</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">chip</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chip</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span> <span class="o">=</span> <span class="n">card</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span> <span class="o">=</span> <span class="n">pci</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">use_cache</span> <span class="o">=</span> <span class="n">use_cache</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_mutex</span><span class="p">);</span>

	<span class="cm">/* store buffer sizes in bytes */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">].</span><span class="n">bufsize</span> <span class="o">=</span> <span class="n">playback_bufsize</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">].</span><span class="n">bufsize</span> <span class="o">=</span> <span class="n">capture_bufsize</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>

	<span class="cm">/* </span>
<span class="cm">	 * The NM256 has two memory ports.  The first port is nothing</span>
<span class="cm">	 * more than a chunk of video RAM, which is used as the I/O ring</span>
<span class="cm">	 * buffer.  The second port has the actual juicy stuff (like the</span>
<span class="cm">	 * mixer and the playback engine control registers).</span>
<span class="cm">	 */</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_addr</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport_addr</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Init the memory port info.  */</span>
	<span class="cm">/* remap control port (#2) */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">res_cport</span> <span class="o">=</span> <span class="n">request_mem_region</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport_addr</span><span class="p">,</span> <span class="n">NM_PORT2_SIZE</span><span class="p">,</span>
					     <span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">res_cport</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;memory region 0x%lx (size 0x%x) busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport_addr</span><span class="p">,</span> <span class="n">NM_PORT2_SIZE</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">__error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport_addr</span><span class="p">,</span> <span class="n">NM_PORT2_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;unable to map control port %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport_addr</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">__error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="s">&quot;NM256AV&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Ok, try to see if this is a non-AC97 version of the hardware. */</span>
		<span class="n">pval</span> <span class="o">=</span> <span class="n">snd_nm256_readw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">NM_MIXER_PRESENCE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pval</span> <span class="o">&amp;</span> <span class="n">NM_PRESENCE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NM_PRESENCE_VALUE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">force_ac97</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;nm256: no ac97 is found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;  force the driver to load by &quot;</span>
				       <span class="s">&quot;passing in the module parameter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;    force_ac97=1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;  or try sb16, opl3sa2, or &quot;</span>
				       <span class="s">&quot;cs423x drivers instead.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">__error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_end</span> <span class="o">=</span> <span class="mi">2560</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">interrupt</span> <span class="o">=</span> <span class="n">snd_nm256_interrupt</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_status_offset</span> <span class="o">=</span> <span class="n">NM_MIXER_STATUS_OFFSET</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_status_mask</span> <span class="o">=</span> <span class="n">NM_MIXER_READY_MASK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Not sure if there is any relevant detect for the ZX or not.  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">snd_nm256_readb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mh">0xa0b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_end</span> <span class="o">=</span> <span class="mi">6144</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_end</span> <span class="o">=</span> <span class="mi">4096</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>

		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">interrupt</span> <span class="o">=</span> <span class="n">snd_nm256_interrupt_zx</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_status_offset</span> <span class="o">=</span> <span class="n">NM2_MIXER_STATUS_OFFSET</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_status_mask</span> <span class="o">=</span> <span class="n">NM2_MIXER_READY_MASK</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">].</span><span class="n">bufsize</span> <span class="o">+</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">].</span><span class="n">bufsize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">use_cache</span><span class="p">)</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">+=</span> <span class="n">NM_TOTAL_COEFF_COUNT</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">+=</span> <span class="n">NM_MAX_PLAYBACK_COEF_SIZE</span> <span class="o">+</span> <span class="n">NM_MAX_RECORD_COEF_SIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_top</span> <span class="o">&gt;=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_top</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_end</span><span class="p">)</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_end</span> <span class="o">=</span> <span class="n">buffer_top</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* get buffer end pointer from signature */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_nm256_peek_for_sig</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">__error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_start</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_end</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_addr</span> <span class="o">+=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;nm256: Mapping port 1 from 0x%x - 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_end</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">res_buffer</span> <span class="o">=</span> <span class="n">request_mem_region</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_addr</span><span class="p">,</span>
					      <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">,</span>
					      <span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">res_buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;nm256: buffer 0x%lx (size 0x%x) busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_addr</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">__error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_addr</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;unable to map ring buffer at %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_addr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">__error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set offsets */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">].</span><span class="n">buf</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">].</span><span class="n">bufsize</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">].</span><span class="n">buf</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">].</span><span class="n">bufsize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">use_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">all_coeff_buf</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">coeff_buf</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">NM_MAX_PLAYBACK_COEF_SIZE</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">coeff_buf</span><span class="p">[</span><span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fixed setting. */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_base</span> <span class="o">=</span> <span class="n">NM_MIXER_OFFSET</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">coeffs_current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">snd_nm256_init_chip</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>pci<em>set</em>master(pci); /* needed? */</p></td><td class="code"><div class="highlight"><pre>	
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_device_new</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">SNDRV_DEV_LOWLEVEL</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">__error</span><span class="p">;</span>

	<span class="n">snd_card_set_dev</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="o">*</span><span class="n">chip_ret</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">__error:</span>
	<span class="n">snd_nm256_free</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">enum</span> <span class="p">{</span> <span class="n">NM_BLACKLISTED</span><span class="p">,</span> <span class="n">NM_RESET_WORKAROUND</span><span class="p">,</span> <span class="n">NM_RESET_WORKAROUND_2</span> <span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pci_quirk</span> <span class="n">nm256_quirks</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* HP omnibook 4150 has cs4232 codec internally */</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x103c</span><span class="p">,</span> <span class="mh">0x0007</span><span class="p">,</span> <span class="s">&quot;HP omnibook 4150&quot;</span><span class="p">,</span> <span class="n">NM_BLACKLISTED</span><span class="p">),</span>
	<span class="cm">/* Reset workarounds to avoid lock-ups */</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x104d</span><span class="p">,</span> <span class="mh">0x8041</span><span class="p">,</span> <span class="s">&quot;Sony PCG-F305&quot;</span><span class="p">,</span> <span class="n">NM_RESET_WORKAROUND</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1028</span><span class="p">,</span> <span class="mh">0x0080</span><span class="p">,</span> <span class="s">&quot;Dell Latitude LS&quot;</span><span class="p">,</span> <span class="n">NM_RESET_WORKAROUND</span><span class="p">),</span>
	<span class="n">SND_PCI_QUIRK</span><span class="p">(</span><span class="mh">0x1028</span><span class="p">,</span> <span class="mh">0x0091</span><span class="p">,</span> <span class="s">&quot;Dell Latitude CSx&quot;</span><span class="p">,</span> <span class="n">NM_RESET_WORKAROUND_2</span><span class="p">),</span>
	<span class="p">{</span> <span class="p">}</span> <span class="cm">/* terminator */</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">snd_nm256_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">pci_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nm256</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_pci_quirk</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="n">q</span> <span class="o">=</span> <span class="n">snd_pci_quirk_lookup</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">nm256_quirks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;nm256: Enabled quirk for %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">NM_BLACKLISTED</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;nm256: The device is blacklisted. &quot;</span>
			       <span class="s">&quot;Loading stopped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">NM_RESET_WORKAROUND_2</span>:
			<span class="n">reset_workaround_2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* Fall-through */</span>
		<span class="k">case</span> <span class="n">NM_RESET_WORKAROUND</span>:
			<span class="n">reset_workaround</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_card_create</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">THIS_MODULE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">card</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO</span>:
		<span class="n">strcpy</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="s">&quot;NM256AV&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO</span>:
		<span class="n">strcpy</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="s">&quot;NM256ZX&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO</span>:
		<span class="n">strcpy</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="s">&quot;NM256XL+&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;invalid device id 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
		<span class="n">snd_card_free</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vaio_hack</span><span class="p">)</span>
		<span class="n">buffer_top</span> <span class="o">=</span> <span class="mh">0x25a800</span><span class="p">;</span>	<span class="cm">/* this avoids conflicts with XFree86 server */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">playback_bufsize</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">playback_bufsize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">playback_bufsize</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">)</span>
		<span class="n">playback_bufsize</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">capture_bufsize</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">capture_bufsize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">capture_bufsize</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">)</span>
		<span class="n">capture_bufsize</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_nm256_create</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">pci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_card_free</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reset_workaround</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;nm256: reset_workaround activated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">reset_workaround</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reset_workaround_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;nm256: reset_workaround_2 activated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">reset_workaround_2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_nm256_pcm</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_nm256_mixer</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_card_free</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">shortname</span><span class="p">,</span> <span class="s">&quot;NeoMagic %s&quot;</span><span class="p">,</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">longname</span><span class="p">,</span> <span class="s">&quot;%s at 0x%lx &amp; 0x%lx, irq %d&quot;</span><span class="p">,</span>
		<span class="n">card</span><span class="o">-&gt;</span><span class="n">shortname</span><span class="p">,</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffer_addr</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">cport_addr</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_card_register</span><span class="p">(</span><span class="n">card</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_card_free</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">card</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">snd_nm256_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_card_free</span><span class="p">(</span><span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">));</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">nm256_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">KBUILD_MODNAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">snd_nm256_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">snd_nm256_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">snd_nm256_remove</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">nm256_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">nm256_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="n">module_pci_driver</span><span class="p">(</span><span class="n">nm256_driver</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
