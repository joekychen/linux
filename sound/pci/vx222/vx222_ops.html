<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › pci › vx222 › vx222_ops.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>vx222_ops.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Driver for Digigram VX222 V2/Mic soundcards</span>
<span class="cm"> *</span>
<span class="cm"> * VX222-specific low-level routines</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2002 by Takashi Iwai &lt;tiwai@suse.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *   GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#include &lt;sound/core.h&gt;</span>
<span class="cp">#include &lt;sound/control.h&gt;</span>
<span class="cp">#include &lt;sound/tlv.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &quot;vx222.h&quot;</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">vx2_reg_offset</span><span class="p">[</span><span class="n">VX_REG_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">VX_ICR</span><span class="p">]</span>    <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_CVR</span><span class="p">]</span>    <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_ISR</span><span class="p">]</span>    <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_IVR</span><span class="p">]</span>    <span class="o">=</span> <span class="mh">0x0c</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_RXH</span><span class="p">]</span>    <span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_RXM</span><span class="p">]</span>    <span class="o">=</span> <span class="mh">0x18</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_RXL</span><span class="p">]</span>    <span class="o">=</span> <span class="mh">0x1c</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_DMA</span><span class="p">]</span>    <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_CDSP</span><span class="p">]</span>   <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_CFG</span><span class="p">]</span>    <span class="o">=</span> <span class="mh">0x24</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_RUER</span><span class="p">]</span>   <span class="o">=</span> <span class="mh">0x28</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_DATA</span><span class="p">]</span>   <span class="o">=</span> <span class="mh">0x2c</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_STATUS</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_LOFREQ</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x34</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_HIFREQ</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x38</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_CSUER</span><span class="p">]</span>  <span class="o">=</span> <span class="mh">0x3c</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_SELMIC</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_COMPOT</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x44</span><span class="p">,</span> <span class="c1">// Write: POTENTIOMETER ; Read: COMPRESSION LEVEL activate</span>
	<span class="p">[</span><span class="n">VX_SCOMPR</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x48</span><span class="p">,</span> <span class="c1">// Read: COMPRESSION THRESHOLD activate</span>
	<span class="p">[</span><span class="n">VX_GLIMIT</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x4c</span><span class="p">,</span> <span class="c1">// Read: LEVEL LIMITATION activate</span>
	<span class="p">[</span><span class="n">VX_INTCSR</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x4c</span><span class="p">,</span> <span class="c1">// VX_INTCSR_REGISTER_OFFSET</span>
	<span class="p">[</span><span class="n">VX_CNTRL</span><span class="p">]</span>  <span class="o">=</span> <span class="mh">0x50</span><span class="p">,</span>		<span class="c1">// VX_CNTRL_REGISTER_OFFSET</span>
	<span class="p">[</span><span class="n">VX_GPIOC</span><span class="p">]</span>  <span class="o">=</span> <span class="mh">0x54</span><span class="p">,</span>		<span class="c1">// VX_GPIOC (new with PLX9030)</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">vx2_reg_index</span><span class="p">[</span><span class="n">VX_REG_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">VX_ICR</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_CVR</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_ISR</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_IVR</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_RXH</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_RXM</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_RXL</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_DMA</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_CDSP</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_CFG</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_RUER</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_DATA</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_STATUS</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_LOFREQ</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_HIFREQ</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_CSUER</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_SELMIC</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_COMPOT</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_SCOMPR</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_GLIMIT</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">[</span><span class="n">VX_INTCSR</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* on the PLX */</span>
	<span class="p">[</span><span class="n">VX_CNTRL</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* on the PLX */</span>
	<span class="p">[</span><span class="n">VX_GPIOC</span><span class="p">]</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* on the PLX */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">vx2_reg_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">_chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="p">)</span><span class="n">_chip</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">[</span><span class="n">vx2_reg_index</span><span class="p">[</span><span class="n">reg</span><span class="p">]]</span> <span class="o">+</span> <span class="n">vx2_reg_offset</span><span class="p">[</span><span class="n">reg</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_vx_inb - read a byte from the register</span>
<span class="cm"> * @offset: register enum</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">vx2_inb</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inb</span><span class="p">(</span><span class="n">vx2_reg_addr</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_vx_outb - write a byte on the register</span>
<span class="cm"> * @offset: the register offset</span>
<span class="cm"> * @val: the value to write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_outb</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">vx2_reg_addr</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	printk(KERN_DEBUG &quot;outb: %x -&gt; %x\n&quot;, val, vx2_reg_addr(chip, offset));</span>
<span class="cm">	*/</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_vx_inl - read a 32bit word from the register</span>
<span class="cm"> * @offset: register enum</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">vx2_inl</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inl</span><span class="p">(</span><span class="n">vx2_reg_addr</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snd_vx_outl - write a 32bit word on the register</span>
<span class="cm"> * @offset: the register enum</span>
<span class="cm"> * @val: the value to write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_outl</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	printk(KERN_DEBUG &quot;outl: %x -&gt; %x\n&quot;, val, vx2_reg_addr(chip, offset));</span>
<span class="cm">	*/</span>
	<span class="n">outl</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">vx2_reg_addr</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * redefine macros to call directly</span>
<span class="cm"> */</span>
<span class="cp">#undef vx_inb</span>
<span class="cp">#define vx_inb(chip,reg)	vx2_inb((struct vx_core*)(chip), VX_##reg)</span>
<span class="cp">#undef vx_outb</span>
<span class="cp">#define vx_outb(chip,reg,val)	vx2_outb((struct vx_core*)(chip), VX_##reg, val)</span>
<span class="cp">#undef vx_inl</span>
<span class="cp">#define vx_inl(chip,reg)	vx2_inl((struct vx_core*)(chip), VX_##reg)</span>
<span class="cp">#undef vx_outl</span>
<span class="cp">#define vx_outl(chip,reg,val)	vx2_outl((struct vx_core*)(chip), VX_##reg, val)</span>


<span class="cm">/*</span>
<span class="cm"> * vx_reset_dsp - reset the DSP</span>
<span class="cm"> */</span>

<span class="cp">#define XX_DSP_RESET_WAIT_TIME		2	</span><span class="cm">/* ms */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_reset_dsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">_chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="p">)</span><span class="n">_chip</span><span class="p">;</span>

	<span class="cm">/* set the reset dsp bit to 0 */</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CDSP</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCDSP</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VX_CDSP_DSP_RESET_MASK</span><span class="p">);</span>

	<span class="n">mdelay</span><span class="p">(</span><span class="n">XX_DSP_RESET_WAIT_TIME</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCDSP</span> <span class="o">|=</span> <span class="n">VX_CDSP_DSP_RESET_MASK</span><span class="p">;</span>
	<span class="cm">/* set the reset dsp bit to 1 */</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CDSP</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCDSP</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx2_test_xilinx</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">_chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="p">)</span><span class="n">_chip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;testing xilinx...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* This test uses several write/read sequences on TEST0 and TEST1 bits</span>
<span class="cm">	 * to figure out whever or not the xilinx was correctly loaded</span>
<span class="cm">	 */</span>

	<span class="cm">/* We write 1 on CDSP.TEST0. We should get 0 on STATUS.TEST0. */</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CDSP</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCDSP</span> <span class="o">|</span> <span class="n">VX_CDSP_TEST0_MASK</span><span class="p">);</span>
	<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STATUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">VX_STATUS_VAL_TEST0_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">VX_STATUS_VAL_TEST0_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;bad!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We write 0 on CDSP.TEST0. We should get 1 on STATUS.TEST0. */</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CDSP</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCDSP</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VX_CDSP_TEST0_MASK</span><span class="p">);</span>
	<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STATUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">VX_STATUS_VAL_TEST0_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;bad! #2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_chip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">VX_TYPE_BOARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* not implemented on VX_2_BOARDS */</span>
		<span class="cm">/* We write 1 on CDSP.TEST1. We should get 0 on STATUS.TEST1. */</span>
		<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CDSP</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCDSP</span> <span class="o">|</span> <span class="n">VX_CDSP_TEST1_MASK</span><span class="p">);</span>
		<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STATUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">VX_STATUS_VAL_TEST1_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">VX_STATUS_VAL_TEST1_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;bad! #3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* We write 0 on CDSP.TEST1. We should get 1 on STATUS.TEST1. */</span>
		<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CDSP</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCDSP</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VX_CDSP_TEST1_MASK</span><span class="p">);</span>
		<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STATUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">VX_STATUS_VAL_TEST1_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;bad! #4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;ok, xilinx fine.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * vx_setup_pseudo_dma - set up the pseudo dma read/write mode.</span>
<span class="cm"> * @do_write: 0 = read, 1 = set up for DMA write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_setup_pseudo_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">do_write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Interrupt mode and HREQ pin enabled for host transmit data transfers</span>
<span class="cm">	 * (in case of the use of the pseudo-dma facility).</span>
<span class="cm">	 */</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ICR</span><span class="p">,</span> <span class="n">do_write</span> <span class="o">?</span> <span class="n">ICR_TREQ</span> <span class="o">:</span> <span class="n">ICR_RREQ</span><span class="p">);</span>

	<span class="cm">/* Reset the pseudo-dma register (in case of the use of the</span>
<span class="cm">	 * pseudo-dma facility).</span>
<span class="cm">	 */</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RESET_DMA</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_release_pseudo_dma - disable the pseudo-DMA mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vx2_release_pseudo_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* HREQ pin disabled. */</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ICR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/* pseudo-dma write */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_dma_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">port</span> <span class="o">=</span> <span class="n">vx2_reg_addr</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">VX_DMA</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">hw_ptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">%</span> <span class="mi">4</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vx2_setup_pseudo_dma</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Transfer using pseudo-dma.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">buffer_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">buffer_bytes</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">length</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* in 32bit words */</span>
		<span class="cm">/* Transfer using pseudo-dma. */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">length</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">outl</span><span class="p">(</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">),</span> <span class="n">port</span><span class="p">);</span>
			<span class="n">addr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span><span class="p">;</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">hw_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">hw_ptr</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* in 32bit words */</span>
	<span class="cm">/* Transfer using pseudo-dma. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outl</span><span class="p">(</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">),</span> <span class="n">port</span><span class="p">);</span>
		<span class="n">addr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vx2_release_pseudo_dma</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* pseudo dma read */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_dma_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">hw_ptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">port</span> <span class="o">=</span> <span class="n">vx2_reg_addr</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">VX_DMA</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">%</span> <span class="mi">4</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vx2_setup_pseudo_dma</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* Transfer using pseudo-dma.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">buffer_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">buffer_bytes</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">length</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* in 32bit words */</span>
		<span class="cm">/* Transfer using pseudo-dma. */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">length</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">*</span><span class="n">addr</span><span class="o">++</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">inl</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span><span class="p">;</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">hw_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">hw_ptr</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* in 32bit words */</span>
	<span class="cm">/* Transfer using pseudo-dma. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">addr</span><span class="o">++</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">inl</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>

	<span class="n">vx2_release_pseudo_dma</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define VX_XILINX_RESET_MASK        0x40000000</span>
<span class="cp">#define VX_USERBIT0_MASK            0x00000004</span>
<span class="cp">#define VX_USERBIT1_MASK            0x00000020</span>
<span class="cp">#define VX_CNTRL_REGISTER_VALUE     0x00172012</span>

<span class="cm">/*</span>
<span class="cm"> * transfer counts bits to PLX</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">put_xilinx_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">counts</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">counts</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

		<span class="cm">/* set the clock bit to 0. */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">VX_CNTRL_REGISTER_VALUE</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VX_USERBIT0_MASK</span><span class="p">;</span>
		<span class="n">vx2_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">vx2_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">VX_USERBIT1_MASK</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VX_USERBIT1_MASK</span><span class="p">;</span>
		<span class="n">vx2_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">vx2_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

		<span class="cm">/* set the clock bit to 1. */</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">VX_USERBIT0_MASK</span><span class="p">;</span>
		<span class="n">vx2_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">vx2_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * load the xilinx image</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx2_load_xilinx_binary</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">xilinx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">image</span><span class="p">;</span>

	<span class="cm">/* XILINX reset (wait at least 1 millisecond between reset on and off). */</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CNTRL</span><span class="p">,</span> <span class="n">VX_CNTRL_REGISTER_VALUE</span> <span class="o">|</span> <span class="n">VX_XILINX_RESET_MASK</span><span class="p">);</span>
	<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CNTRL</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CNTRL</span><span class="p">,</span> <span class="n">VX_CNTRL_REGISTER_VALUE</span><span class="p">);</span>
	<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CNTRL</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">VX_TYPE_BOARD</span><span class="p">)</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">VX_CNTRL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">VX_GPIOC</span><span class="p">;</span> <span class="cm">/* VX222 V2 and VX222_MIC_BOARD with new PLX9030 use this register */</span>

	<span class="n">image</span> <span class="o">=</span> <span class="n">xilinx</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">xilinx</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">image</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_xilinx_data</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">*</span><span class="n">image</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/* don&#39;t take too much time in this loop... */</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">put_xilinx_data</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span> <span class="cm">/* end signature */</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

	<span class="cm">/* test after loading (is buggy with VX222) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">VX_TYPE_BOARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Test if load successful: test bit 8 of register GPIOC (VX222: use CNTRL) ! */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">GPIOC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x0100</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vx222: xilinx test failed after load, GPIOC=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

	
<span class="cm">/*</span>
<span class="cm"> * load the boot/dsp images</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx2_load_dsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">vx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">dsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="cm">/* xilinx image */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx2_load_xilinx_binary</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span> <span class="n">dsp</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx2_test_xilinx</span><span class="p">(</span><span class="n">vx</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="cm">/* DSP boot */</span>
		<span class="k">return</span> <span class="n">snd_vx_dsp_boot</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span> <span class="n">dsp</span><span class="p">);</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="cm">/* DSP image */</span>
		<span class="k">return</span> <span class="n">snd_vx_dsp_load</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span> <span class="n">dsp</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="n">snd_BUG</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_test_and_ack - test and acknowledge interrupt</span>
<span class="cm"> *</span>
<span class="cm"> * called from irq hander, too</span>
<span class="cm"> *</span>
<span class="cm"> * spinlock held!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx2_test_and_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* not booted yet? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_XILINX_LOADED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">VX_STATUS_MEMIRQ_MASK</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	
	<span class="cm">/* ok, interrupts generated, now ack it */</span>
	<span class="cm">/* set ACQUIT bit up and down */</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STATUS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* useless read just to spend some time and maintain</span>
<span class="cm">	 * the ACQUIT signal up for a while ( a bus cycle )</span>
<span class="cm">	 */</span>
	<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STATUS</span><span class="p">);</span>
	<span class="cm">/* ack */</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STATUS</span><span class="p">,</span> <span class="n">VX_STATUS_MEMIRQ_MASK</span><span class="p">);</span>
	<span class="cm">/* useless read just to spend some time and maintain</span>
<span class="cm">	 * the ACQUIT signal up for a while ( a bus cycle ) */</span>
	<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STATUS</span><span class="p">);</span>
	<span class="cm">/* clear */</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">STATUS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_validate_irq - enable/disable IRQ</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_validate_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">_chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="p">)</span><span class="n">_chip</span><span class="p">;</span>

	<span class="cm">/* Set the interrupt enable bit to 1 in CDSP register */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set the PCI interrupt enable bit to 1.*/</span>
		<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">INTCSR</span><span class="p">,</span> <span class="n">VX_INTCSR_VALUE</span><span class="o">|</span><span class="n">VX_PCI_INTERRUPT_MASK</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCDSP</span> <span class="o">|=</span> <span class="n">VX_CDSP_VALID_IRQ_MASK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Set the PCI interrupt enable bit to 0. */</span>
		<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">INTCSR</span><span class="p">,</span> <span class="n">VX_INTCSR_VALUE</span><span class="o">&amp;~</span><span class="n">VX_PCI_INTERRUPT_MASK</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCDSP</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VX_CDSP_VALID_IRQ_MASK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CDSP</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCDSP</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * write an AKM codec data (24bit)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_write_codec_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">HIFREQ</span><span class="p">);</span>

	<span class="cm">/* We have to send 24 bits (3 x 8 bits). Start with most signif. Bit */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">data</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DATA</span><span class="p">,</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0x800000</span><span class="p">)</span> <span class="o">?</span> <span class="n">VX_DATA_CODEC_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
	<span class="cm">/* Terminate access to codec registers */</span>
	<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RUER</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#define AKM_CODEC_POWER_CONTROL_CMD 0xA007</span>
<span class="cp">#define AKM_CODEC_RESET_ON_CMD      0xA100</span>
<span class="cp">#define AKM_CODEC_RESET_OFF_CMD     0xA103</span>
<span class="cp">#define AKM_CODEC_CLOCK_FORMAT_CMD  0xA240</span>
<span class="cp">#define AKM_CODEC_MUTE_CMD          0xA38D</span>
<span class="cp">#define AKM_CODEC_UNMUTE_CMD        0xA30D</span>
<span class="cp">#define AKM_CODEC_LEFT_LEVEL_CMD    0xA400</span>
<span class="cp">#define AKM_CODEC_RIGHT_LEVEL_CMD   0xA500</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">vx2_akm_gains_lut</span><span class="p">[</span><span class="n">VX2_AKM_LEVEL_MAX</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mh">0x7f</span><span class="p">,</span>       <span class="c1">// [000] =  +0.000 dB  -&gt;  AKM(0x7f) =  +0.000 dB  error(+0.000 dB)</span>
    <span class="mh">0x7d</span><span class="p">,</span>       <span class="c1">// [001] =  -0.500 dB  -&gt;  AKM(0x7d) =  -0.572 dB  error(-0.072 dB)</span>
    <span class="mh">0x7c</span><span class="p">,</span>       <span class="c1">// [002] =  -1.000 dB  -&gt;  AKM(0x7c) =  -0.873 dB  error(+0.127 dB)</span>
    <span class="mh">0x7a</span><span class="p">,</span>       <span class="c1">// [003] =  -1.500 dB  -&gt;  AKM(0x7a) =  -1.508 dB  error(-0.008 dB)</span>
    <span class="mh">0x79</span><span class="p">,</span>       <span class="c1">// [004] =  -2.000 dB  -&gt;  AKM(0x79) =  -1.844 dB  error(+0.156 dB)</span>
    <span class="mh">0x77</span><span class="p">,</span>       <span class="c1">// [005] =  -2.500 dB  -&gt;  AKM(0x77) =  -2.557 dB  error(-0.057 dB)</span>
    <span class="mh">0x76</span><span class="p">,</span>       <span class="c1">// [006] =  -3.000 dB  -&gt;  AKM(0x76) =  -2.937 dB  error(+0.063 dB)</span>
    <span class="mh">0x75</span><span class="p">,</span>       <span class="c1">// [007] =  -3.500 dB  -&gt;  AKM(0x75) =  -3.334 dB  error(+0.166 dB)</span>
    <span class="mh">0x73</span><span class="p">,</span>       <span class="c1">// [008] =  -4.000 dB  -&gt;  AKM(0x73) =  -4.188 dB  error(-0.188 dB)</span>
    <span class="mh">0x72</span><span class="p">,</span>       <span class="c1">// [009] =  -4.500 dB  -&gt;  AKM(0x72) =  -4.648 dB  error(-0.148 dB)</span>
    <span class="mh">0x71</span><span class="p">,</span>       <span class="c1">// [010] =  -5.000 dB  -&gt;  AKM(0x71) =  -5.134 dB  error(-0.134 dB)</span>
    <span class="mh">0x70</span><span class="p">,</span>       <span class="c1">// [011] =  -5.500 dB  -&gt;  AKM(0x70) =  -5.649 dB  error(-0.149 dB)</span>
    <span class="mh">0x6f</span><span class="p">,</span>       <span class="c1">// [012] =  -6.000 dB  -&gt;  AKM(0x6f) =  -6.056 dB  error(-0.056 dB)</span>
    <span class="mh">0x6d</span><span class="p">,</span>       <span class="c1">// [013] =  -6.500 dB  -&gt;  AKM(0x6d) =  -6.631 dB  error(-0.131 dB)</span>
    <span class="mh">0x6c</span><span class="p">,</span>       <span class="c1">// [014] =  -7.000 dB  -&gt;  AKM(0x6c) =  -6.933 dB  error(+0.067 dB)</span>
    <span class="mh">0x6a</span><span class="p">,</span>       <span class="c1">// [015] =  -7.500 dB  -&gt;  AKM(0x6a) =  -7.571 dB  error(-0.071 dB)</span>
    <span class="mh">0x69</span><span class="p">,</span>       <span class="c1">// [016] =  -8.000 dB  -&gt;  AKM(0x69) =  -7.909 dB  error(+0.091 dB)</span>
    <span class="mh">0x67</span><span class="p">,</span>       <span class="c1">// [017] =  -8.500 dB  -&gt;  AKM(0x67) =  -8.626 dB  error(-0.126 dB)</span>
    <span class="mh">0x66</span><span class="p">,</span>       <span class="c1">// [018] =  -9.000 dB  -&gt;  AKM(0x66) =  -9.008 dB  error(-0.008 dB)</span>
    <span class="mh">0x65</span><span class="p">,</span>       <span class="c1">// [019] =  -9.500 dB  -&gt;  AKM(0x65) =  -9.407 dB  error(+0.093 dB)</span>
    <span class="mh">0x64</span><span class="p">,</span>       <span class="c1">// [020] = -10.000 dB  -&gt;  AKM(0x64) =  -9.826 dB  error(+0.174 dB)</span>
    <span class="mh">0x62</span><span class="p">,</span>       <span class="c1">// [021] = -10.500 dB  -&gt;  AKM(0x62) = -10.730 dB  error(-0.230 dB)</span>
    <span class="mh">0x61</span><span class="p">,</span>       <span class="c1">// [022] = -11.000 dB  -&gt;  AKM(0x61) = -11.219 dB  error(-0.219 dB)</span>
    <span class="mh">0x60</span><span class="p">,</span>       <span class="c1">// [023] = -11.500 dB  -&gt;  AKM(0x60) = -11.738 dB  error(-0.238 dB)</span>
    <span class="mh">0x5f</span><span class="p">,</span>       <span class="c1">// [024] = -12.000 dB  -&gt;  AKM(0x5f) = -12.149 dB  error(-0.149 dB)</span>
    <span class="mh">0x5e</span><span class="p">,</span>       <span class="c1">// [025] = -12.500 dB  -&gt;  AKM(0x5e) = -12.434 dB  error(+0.066 dB)</span>
    <span class="mh">0x5c</span><span class="p">,</span>       <span class="c1">// [026] = -13.000 dB  -&gt;  AKM(0x5c) = -13.033 dB  error(-0.033 dB)</span>
    <span class="mh">0x5b</span><span class="p">,</span>       <span class="c1">// [027] = -13.500 dB  -&gt;  AKM(0x5b) = -13.350 dB  error(+0.150 dB)</span>
    <span class="mh">0x59</span><span class="p">,</span>       <span class="c1">// [028] = -14.000 dB  -&gt;  AKM(0x59) = -14.018 dB  error(-0.018 dB)</span>
    <span class="mh">0x58</span><span class="p">,</span>       <span class="c1">// [029] = -14.500 dB  -&gt;  AKM(0x58) = -14.373 dB  error(+0.127 dB)</span>
    <span class="mh">0x56</span><span class="p">,</span>       <span class="c1">// [030] = -15.000 dB  -&gt;  AKM(0x56) = -15.130 dB  error(-0.130 dB)</span>
    <span class="mh">0x55</span><span class="p">,</span>       <span class="c1">// [031] = -15.500 dB  -&gt;  AKM(0x55) = -15.534 dB  error(-0.034 dB)</span>
    <span class="mh">0x54</span><span class="p">,</span>       <span class="c1">// [032] = -16.000 dB  -&gt;  AKM(0x54) = -15.958 dB  error(+0.042 dB)</span>
    <span class="mh">0x53</span><span class="p">,</span>       <span class="c1">// [033] = -16.500 dB  -&gt;  AKM(0x53) = -16.404 dB  error(+0.096 dB)</span>
    <span class="mh">0x52</span><span class="p">,</span>       <span class="c1">// [034] = -17.000 dB  -&gt;  AKM(0x52) = -16.874 dB  error(+0.126 dB)</span>
    <span class="mh">0x51</span><span class="p">,</span>       <span class="c1">// [035] = -17.500 dB  -&gt;  AKM(0x51) = -17.371 dB  error(+0.129 dB)</span>
    <span class="mh">0x50</span><span class="p">,</span>       <span class="c1">// [036] = -18.000 dB  -&gt;  AKM(0x50) = -17.898 dB  error(+0.102 dB)</span>
    <span class="mh">0x4e</span><span class="p">,</span>       <span class="c1">// [037] = -18.500 dB  -&gt;  AKM(0x4e) = -18.605 dB  error(-0.105 dB)</span>
    <span class="mh">0x4d</span><span class="p">,</span>       <span class="c1">// [038] = -19.000 dB  -&gt;  AKM(0x4d) = -18.905 dB  error(+0.095 dB)</span>
    <span class="mh">0x4b</span><span class="p">,</span>       <span class="c1">// [039] = -19.500 dB  -&gt;  AKM(0x4b) = -19.538 dB  error(-0.038 dB)</span>
    <span class="mh">0x4a</span><span class="p">,</span>       <span class="c1">// [040] = -20.000 dB  -&gt;  AKM(0x4a) = -19.872 dB  error(+0.128 dB)</span>
    <span class="mh">0x48</span><span class="p">,</span>       <span class="c1">// [041] = -20.500 dB  -&gt;  AKM(0x48) = -20.583 dB  error(-0.083 dB)</span>
    <span class="mh">0x47</span><span class="p">,</span>       <span class="c1">// [042] = -21.000 dB  -&gt;  AKM(0x47) = -20.961 dB  error(+0.039 dB)</span>
    <span class="mh">0x46</span><span class="p">,</span>       <span class="c1">// [043] = -21.500 dB  -&gt;  AKM(0x46) = -21.356 dB  error(+0.144 dB)</span>
    <span class="mh">0x44</span><span class="p">,</span>       <span class="c1">// [044] = -22.000 dB  -&gt;  AKM(0x44) = -22.206 dB  error(-0.206 dB)</span>
    <span class="mh">0x43</span><span class="p">,</span>       <span class="c1">// [045] = -22.500 dB  -&gt;  AKM(0x43) = -22.664 dB  error(-0.164 dB)</span>
    <span class="mh">0x42</span><span class="p">,</span>       <span class="c1">// [046] = -23.000 dB  -&gt;  AKM(0x42) = -23.147 dB  error(-0.147 dB)</span>
    <span class="mh">0x41</span><span class="p">,</span>       <span class="c1">// [047] = -23.500 dB  -&gt;  AKM(0x41) = -23.659 dB  error(-0.159 dB)</span>
    <span class="mh">0x40</span><span class="p">,</span>       <span class="c1">// [048] = -24.000 dB  -&gt;  AKM(0x40) = -24.203 dB  error(-0.203 dB)</span>
    <span class="mh">0x3f</span><span class="p">,</span>       <span class="c1">// [049] = -24.500 dB  -&gt;  AKM(0x3f) = -24.635 dB  error(-0.135 dB)</span>
    <span class="mh">0x3e</span><span class="p">,</span>       <span class="c1">// [050] = -25.000 dB  -&gt;  AKM(0x3e) = -24.935 dB  error(+0.065 dB)</span>
    <span class="mh">0x3c</span><span class="p">,</span>       <span class="c1">// [051] = -25.500 dB  -&gt;  AKM(0x3c) = -25.569 dB  error(-0.069 dB)</span>
    <span class="mh">0x3b</span><span class="p">,</span>       <span class="c1">// [052] = -26.000 dB  -&gt;  AKM(0x3b) = -25.904 dB  error(+0.096 dB)</span>
    <span class="mh">0x39</span><span class="p">,</span>       <span class="c1">// [053] = -26.500 dB  -&gt;  AKM(0x39) = -26.615 dB  error(-0.115 dB)</span>
    <span class="mh">0x38</span><span class="p">,</span>       <span class="c1">// [054] = -27.000 dB  -&gt;  AKM(0x38) = -26.994 dB  error(+0.006 dB)</span>
    <span class="mh">0x37</span><span class="p">,</span>       <span class="c1">// [055] = -27.500 dB  -&gt;  AKM(0x37) = -27.390 dB  error(+0.110 dB)</span>
    <span class="mh">0x36</span><span class="p">,</span>       <span class="c1">// [056] = -28.000 dB  -&gt;  AKM(0x36) = -27.804 dB  error(+0.196 dB)</span>
    <span class="mh">0x34</span><span class="p">,</span>       <span class="c1">// [057] = -28.500 dB  -&gt;  AKM(0x34) = -28.699 dB  error(-0.199 dB)</span>
    <span class="mh">0x33</span><span class="p">,</span>       <span class="c1">// [058] = -29.000 dB  -&gt;  AKM(0x33) = -29.183 dB  error(-0.183 dB)</span>
    <span class="mh">0x32</span><span class="p">,</span>       <span class="c1">// [059] = -29.500 dB  -&gt;  AKM(0x32) = -29.696 dB  error(-0.196 dB)</span>
    <span class="mh">0x31</span><span class="p">,</span>       <span class="c1">// [060] = -30.000 dB  -&gt;  AKM(0x31) = -30.241 dB  error(-0.241 dB)</span>
    <span class="mh">0x31</span><span class="p">,</span>       <span class="c1">// [061] = -30.500 dB  -&gt;  AKM(0x31) = -30.241 dB  error(+0.259 dB)</span>
    <span class="mh">0x30</span><span class="p">,</span>       <span class="c1">// [062] = -31.000 dB  -&gt;  AKM(0x30) = -30.823 dB  error(+0.177 dB)</span>
    <span class="mh">0x2e</span><span class="p">,</span>       <span class="c1">// [063] = -31.500 dB  -&gt;  AKM(0x2e) = -31.610 dB  error(-0.110 dB)</span>
    <span class="mh">0x2d</span><span class="p">,</span>       <span class="c1">// [064] = -32.000 dB  -&gt;  AKM(0x2d) = -31.945 dB  error(+0.055 dB)</span>
    <span class="mh">0x2b</span><span class="p">,</span>       <span class="c1">// [065] = -32.500 dB  -&gt;  AKM(0x2b) = -32.659 dB  error(-0.159 dB)</span>
    <span class="mh">0x2a</span><span class="p">,</span>       <span class="c1">// [066] = -33.000 dB  -&gt;  AKM(0x2a) = -33.038 dB  error(-0.038 dB)</span>
    <span class="mh">0x29</span><span class="p">,</span>       <span class="c1">// [067] = -33.500 dB  -&gt;  AKM(0x29) = -33.435 dB  error(+0.065 dB)</span>
    <span class="mh">0x28</span><span class="p">,</span>       <span class="c1">// [068] = -34.000 dB  -&gt;  AKM(0x28) = -33.852 dB  error(+0.148 dB)</span>
    <span class="mh">0x27</span><span class="p">,</span>       <span class="c1">// [069] = -34.500 dB  -&gt;  AKM(0x27) = -34.289 dB  error(+0.211 dB)</span>
    <span class="mh">0x25</span><span class="p">,</span>       <span class="c1">// [070] = -35.000 dB  -&gt;  AKM(0x25) = -35.235 dB  error(-0.235 dB)</span>
    <span class="mh">0x24</span><span class="p">,</span>       <span class="c1">// [071] = -35.500 dB  -&gt;  AKM(0x24) = -35.750 dB  error(-0.250 dB)</span>
    <span class="mh">0x24</span><span class="p">,</span>       <span class="c1">// [072] = -36.000 dB  -&gt;  AKM(0x24) = -35.750 dB  error(+0.250 dB)</span>
    <span class="mh">0x23</span><span class="p">,</span>       <span class="c1">// [073] = -36.500 dB  -&gt;  AKM(0x23) = -36.297 dB  error(+0.203 dB)</span>
    <span class="mh">0x22</span><span class="p">,</span>       <span class="c1">// [074] = -37.000 dB  -&gt;  AKM(0x22) = -36.881 dB  error(+0.119 dB)</span>
    <span class="mh">0x21</span><span class="p">,</span>       <span class="c1">// [075] = -37.500 dB  -&gt;  AKM(0x21) = -37.508 dB  error(-0.008 dB)</span>
    <span class="mh">0x20</span><span class="p">,</span>       <span class="c1">// [076] = -38.000 dB  -&gt;  AKM(0x20) = -38.183 dB  error(-0.183 dB)</span>
    <span class="mh">0x1f</span><span class="p">,</span>       <span class="c1">// [077] = -38.500 dB  -&gt;  AKM(0x1f) = -38.726 dB  error(-0.226 dB)</span>
    <span class="mh">0x1e</span><span class="p">,</span>       <span class="c1">// [078] = -39.000 dB  -&gt;  AKM(0x1e) = -39.108 dB  error(-0.108 dB)</span>
    <span class="mh">0x1d</span><span class="p">,</span>       <span class="c1">// [079] = -39.500 dB  -&gt;  AKM(0x1d) = -39.507 dB  error(-0.007 dB)</span>
    <span class="mh">0x1c</span><span class="p">,</span>       <span class="c1">// [080] = -40.000 dB  -&gt;  AKM(0x1c) = -39.926 dB  error(+0.074 dB)</span>
    <span class="mh">0x1b</span><span class="p">,</span>       <span class="c1">// [081] = -40.500 dB  -&gt;  AKM(0x1b) = -40.366 dB  error(+0.134 dB)</span>
    <span class="mh">0x1a</span><span class="p">,</span>       <span class="c1">// [082] = -41.000 dB  -&gt;  AKM(0x1a) = -40.829 dB  error(+0.171 dB)</span>
    <span class="mh">0x19</span><span class="p">,</span>       <span class="c1">// [083] = -41.500 dB  -&gt;  AKM(0x19) = -41.318 dB  error(+0.182 dB)</span>
    <span class="mh">0x18</span><span class="p">,</span>       <span class="c1">// [084] = -42.000 dB  -&gt;  AKM(0x18) = -41.837 dB  error(+0.163 dB)</span>
    <span class="mh">0x17</span><span class="p">,</span>       <span class="c1">// [085] = -42.500 dB  -&gt;  AKM(0x17) = -42.389 dB  error(+0.111 dB)</span>
    <span class="mh">0x16</span><span class="p">,</span>       <span class="c1">// [086] = -43.000 dB  -&gt;  AKM(0x16) = -42.978 dB  error(+0.022 dB)</span>
    <span class="mh">0x15</span><span class="p">,</span>       <span class="c1">// [087] = -43.500 dB  -&gt;  AKM(0x15) = -43.610 dB  error(-0.110 dB)</span>
    <span class="mh">0x14</span><span class="p">,</span>       <span class="c1">// [088] = -44.000 dB  -&gt;  AKM(0x14) = -44.291 dB  error(-0.291 dB)</span>
    <span class="mh">0x14</span><span class="p">,</span>       <span class="c1">// [089] = -44.500 dB  -&gt;  AKM(0x14) = -44.291 dB  error(+0.209 dB)</span>
    <span class="mh">0x13</span><span class="p">,</span>       <span class="c1">// [090] = -45.000 dB  -&gt;  AKM(0x13) = -45.031 dB  error(-0.031 dB)</span>
    <span class="mh">0x12</span><span class="p">,</span>       <span class="c1">// [091] = -45.500 dB  -&gt;  AKM(0x12) = -45.840 dB  error(-0.340 dB)</span>
    <span class="mh">0x12</span><span class="p">,</span>       <span class="c1">// [092] = -46.000 dB  -&gt;  AKM(0x12) = -45.840 dB  error(+0.160 dB)</span>
    <span class="mh">0x11</span><span class="p">,</span>       <span class="c1">// [093] = -46.500 dB  -&gt;  AKM(0x11) = -46.731 dB  error(-0.231 dB)</span>
    <span class="mh">0x11</span><span class="p">,</span>       <span class="c1">// [094] = -47.000 dB  -&gt;  AKM(0x11) = -46.731 dB  error(+0.269 dB)</span>
    <span class="mh">0x10</span><span class="p">,</span>       <span class="c1">// [095] = -47.500 dB  -&gt;  AKM(0x10) = -47.725 dB  error(-0.225 dB)</span>
    <span class="mh">0x10</span><span class="p">,</span>       <span class="c1">// [096] = -48.000 dB  -&gt;  AKM(0x10) = -47.725 dB  error(+0.275 dB)</span>
    <span class="mh">0x0f</span><span class="p">,</span>       <span class="c1">// [097] = -48.500 dB  -&gt;  AKM(0x0f) = -48.553 dB  error(-0.053 dB)</span>
    <span class="mh">0x0e</span><span class="p">,</span>       <span class="c1">// [098] = -49.000 dB  -&gt;  AKM(0x0e) = -49.152 dB  error(-0.152 dB)</span>
    <span class="mh">0x0d</span><span class="p">,</span>       <span class="c1">// [099] = -49.500 dB  -&gt;  AKM(0x0d) = -49.796 dB  error(-0.296 dB)</span>
    <span class="mh">0x0d</span><span class="p">,</span>       <span class="c1">// [100] = -50.000 dB  -&gt;  AKM(0x0d) = -49.796 dB  error(+0.204 dB)</span>
    <span class="mh">0x0c</span><span class="p">,</span>       <span class="c1">// [101] = -50.500 dB  -&gt;  AKM(0x0c) = -50.491 dB  error(+0.009 dB)</span>
    <span class="mh">0x0b</span><span class="p">,</span>       <span class="c1">// [102] = -51.000 dB  -&gt;  AKM(0x0b) = -51.247 dB  error(-0.247 dB)</span>
    <span class="mh">0x0b</span><span class="p">,</span>       <span class="c1">// [103] = -51.500 dB  -&gt;  AKM(0x0b) = -51.247 dB  error(+0.253 dB)</span>
    <span class="mh">0x0a</span><span class="p">,</span>       <span class="c1">// [104] = -52.000 dB  -&gt;  AKM(0x0a) = -52.075 dB  error(-0.075 dB)</span>
    <span class="mh">0x0a</span><span class="p">,</span>       <span class="c1">// [105] = -52.500 dB  -&gt;  AKM(0x0a) = -52.075 dB  error(+0.425 dB)</span>
    <span class="mh">0x09</span><span class="p">,</span>       <span class="c1">// [106] = -53.000 dB  -&gt;  AKM(0x09) = -52.990 dB  error(+0.010 dB)</span>
    <span class="mh">0x09</span><span class="p">,</span>       <span class="c1">// [107] = -53.500 dB  -&gt;  AKM(0x09) = -52.990 dB  error(+0.510 dB)</span>
    <span class="mh">0x08</span><span class="p">,</span>       <span class="c1">// [108] = -54.000 dB  -&gt;  AKM(0x08) = -54.013 dB  error(-0.013 dB)</span>
    <span class="mh">0x08</span><span class="p">,</span>       <span class="c1">// [109] = -54.500 dB  -&gt;  AKM(0x08) = -54.013 dB  error(+0.487 dB)</span>
    <span class="mh">0x07</span><span class="p">,</span>       <span class="c1">// [110] = -55.000 dB  -&gt;  AKM(0x07) = -55.173 dB  error(-0.173 dB)</span>
    <span class="mh">0x07</span><span class="p">,</span>       <span class="c1">// [111] = -55.500 dB  -&gt;  AKM(0x07) = -55.173 dB  error(+0.327 dB)</span>
    <span class="mh">0x06</span><span class="p">,</span>       <span class="c1">// [112] = -56.000 dB  -&gt;  AKM(0x06) = -56.512 dB  error(-0.512 dB)</span>
    <span class="mh">0x06</span><span class="p">,</span>       <span class="c1">// [113] = -56.500 dB  -&gt;  AKM(0x06) = -56.512 dB  error(-0.012 dB)</span>
    <span class="mh">0x06</span><span class="p">,</span>       <span class="c1">// [114] = -57.000 dB  -&gt;  AKM(0x06) = -56.512 dB  error(+0.488 dB)</span>
    <span class="mh">0x05</span><span class="p">,</span>       <span class="c1">// [115] = -57.500 dB  -&gt;  AKM(0x05) = -58.095 dB  error(-0.595 dB)</span>
    <span class="mh">0x05</span><span class="p">,</span>       <span class="c1">// [116] = -58.000 dB  -&gt;  AKM(0x05) = -58.095 dB  error(-0.095 dB)</span>
    <span class="mh">0x05</span><span class="p">,</span>       <span class="c1">// [117] = -58.500 dB  -&gt;  AKM(0x05) = -58.095 dB  error(+0.405 dB)</span>
    <span class="mh">0x05</span><span class="p">,</span>       <span class="c1">// [118] = -59.000 dB  -&gt;  AKM(0x05) = -58.095 dB  error(+0.905 dB)</span>
    <span class="mh">0x04</span><span class="p">,</span>       <span class="c1">// [119] = -59.500 dB  -&gt;  AKM(0x04) = -60.034 dB  error(-0.534 dB)</span>
    <span class="mh">0x04</span><span class="p">,</span>       <span class="c1">// [120] = -60.000 dB  -&gt;  AKM(0x04) = -60.034 dB  error(-0.034 dB)</span>
    <span class="mh">0x04</span><span class="p">,</span>       <span class="c1">// [121] = -60.500 dB  -&gt;  AKM(0x04) = -60.034 dB  error(+0.466 dB)</span>
    <span class="mh">0x04</span><span class="p">,</span>       <span class="c1">// [122] = -61.000 dB  -&gt;  AKM(0x04) = -60.034 dB  error(+0.966 dB)</span>
    <span class="mh">0x03</span><span class="p">,</span>       <span class="c1">// [123] = -61.500 dB  -&gt;  AKM(0x03) = -62.532 dB  error(-1.032 dB)</span>
    <span class="mh">0x03</span><span class="p">,</span>       <span class="c1">// [124] = -62.000 dB  -&gt;  AKM(0x03) = -62.532 dB  error(-0.532 dB)</span>
    <span class="mh">0x03</span><span class="p">,</span>       <span class="c1">// [125] = -62.500 dB  -&gt;  AKM(0x03) = -62.532 dB  error(-0.032 dB)</span>
    <span class="mh">0x03</span><span class="p">,</span>       <span class="c1">// [126] = -63.000 dB  -&gt;  AKM(0x03) = -62.532 dB  error(+0.468 dB)</span>
    <span class="mh">0x03</span><span class="p">,</span>       <span class="c1">// [127] = -63.500 dB  -&gt;  AKM(0x03) = -62.532 dB  error(+0.968 dB)</span>
    <span class="mh">0x03</span><span class="p">,</span>       <span class="c1">// [128] = -64.000 dB  -&gt;  AKM(0x03) = -62.532 dB  error(+1.468 dB)</span>
    <span class="mh">0x02</span><span class="p">,</span>       <span class="c1">// [129] = -64.500 dB  -&gt;  AKM(0x02) = -66.054 dB  error(-1.554 dB)</span>
    <span class="mh">0x02</span><span class="p">,</span>       <span class="c1">// [130] = -65.000 dB  -&gt;  AKM(0x02) = -66.054 dB  error(-1.054 dB)</span>
    <span class="mh">0x02</span><span class="p">,</span>       <span class="c1">// [131] = -65.500 dB  -&gt;  AKM(0x02) = -66.054 dB  error(-0.554 dB)</span>
    <span class="mh">0x02</span><span class="p">,</span>       <span class="c1">// [132] = -66.000 dB  -&gt;  AKM(0x02) = -66.054 dB  error(-0.054 dB)</span>
    <span class="mh">0x02</span><span class="p">,</span>       <span class="c1">// [133] = -66.500 dB  -&gt;  AKM(0x02) = -66.054 dB  error(+0.446 dB)</span>
    <span class="mh">0x02</span><span class="p">,</span>       <span class="c1">// [134] = -67.000 dB  -&gt;  AKM(0x02) = -66.054 dB  error(+0.946 dB)</span>
    <span class="mh">0x02</span><span class="p">,</span>       <span class="c1">// [135] = -67.500 dB  -&gt;  AKM(0x02) = -66.054 dB  error(+1.446 dB)</span>
    <span class="mh">0x02</span><span class="p">,</span>       <span class="c1">// [136] = -68.000 dB  -&gt;  AKM(0x02) = -66.054 dB  error(+1.946 dB)</span>
    <span class="mh">0x02</span><span class="p">,</span>       <span class="c1">// [137] = -68.500 dB  -&gt;  AKM(0x02) = -66.054 dB  error(+2.446 dB)</span>
    <span class="mh">0x02</span><span class="p">,</span>       <span class="c1">// [138] = -69.000 dB  -&gt;  AKM(0x02) = -66.054 dB  error(+2.946 dB)</span>
    <span class="mh">0x01</span><span class="p">,</span>       <span class="c1">// [139] = -69.500 dB  -&gt;  AKM(0x01) = -72.075 dB  error(-2.575 dB)</span>
    <span class="mh">0x01</span><span class="p">,</span>       <span class="c1">// [140] = -70.000 dB  -&gt;  AKM(0x01) = -72.075 dB  error(-2.075 dB)</span>
    <span class="mh">0x01</span><span class="p">,</span>       <span class="c1">// [141] = -70.500 dB  -&gt;  AKM(0x01) = -72.075 dB  error(-1.575 dB)</span>
    <span class="mh">0x01</span><span class="p">,</span>       <span class="c1">// [142] = -71.000 dB  -&gt;  AKM(0x01) = -72.075 dB  error(-1.075 dB)</span>
    <span class="mh">0x01</span><span class="p">,</span>       <span class="c1">// [143] = -71.500 dB  -&gt;  AKM(0x01) = -72.075 dB  error(-0.575 dB)</span>
    <span class="mh">0x01</span><span class="p">,</span>       <span class="c1">// [144] = -72.000 dB  -&gt;  AKM(0x01) = -72.075 dB  error(-0.075 dB)</span>
    <span class="mh">0x01</span><span class="p">,</span>       <span class="c1">// [145] = -72.500 dB  -&gt;  AKM(0x01) = -72.075 dB  error(+0.425 dB)</span>
    <span class="mh">0x01</span><span class="p">,</span>       <span class="c1">// [146] = -73.000 dB  -&gt;  AKM(0x01) = -72.075 dB  error(+0.925 dB)</span>
    <span class="mh">0x00</span><span class="p">};</span>      <span class="c1">// [147] = -73.500 dB  -&gt;  AKM(0x00) =  mute       error(+infini)</span>

<span class="cm">/*</span>
<span class="cm"> * pseudo-codec write entry</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_write_akm</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="n">XX_CODEC_DAC_CONTROL_REGISTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vx2_write_codec_reg</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">data</span> <span class="o">?</span> <span class="n">AKM_CODEC_MUTE_CMD</span> <span class="o">:</span> <span class="n">AKM_CODEC_UNMUTE_CMD</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* `data&#39; is a value between 0x0 and VX2_AKM_LEVEL_MAX = 0x093, in the case of the AKM codecs, we need</span>
<span class="cm">	   a look up table, as there is no linear matching between the driver codec values</span>
<span class="cm">	   and the real dBu value</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vx2_akm_gains_lut</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">XX_CODEC_LEVEL_LEFT_REGISTER</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">AKM_CODEC_LEFT_LEVEL_CMD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">XX_CODEC_LEVEL_RIGHT_REGISTER</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">AKM_CODEC_RIGHT_LEVEL_CMD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">snd_BUG</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">vx2_akm_gains_lut</span><span class="p">[</span><span class="n">data</span><span class="p">];</span>

	<span class="n">vx2_write_codec_reg</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * write codec bit for old VX222 board</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_old_write_codec_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* activate access to codec registers */</span>
	<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">HIFREQ</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">data</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DATA</span><span class="p">,</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0x800000</span><span class="p">)</span> <span class="o">?</span> <span class="n">VX_DATA_CODEC_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>

	<span class="cm">/* Terminate access to codec registers */</span>
	<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RUER</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * reset codec bit</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_reset_codec</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">_chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="p">)</span><span class="n">_chip</span><span class="p">;</span>

	<span class="cm">/* Set the reset CODEC bit to 0. */</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CDSP</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCDSP</span> <span class="o">&amp;~</span> <span class="n">VX_CDSP_CODEC_RESET_MASK</span><span class="p">);</span>
	<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CDSP</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="cm">/* Set the reset CODEC bit to 1. */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCDSP</span> <span class="o">|=</span> <span class="n">VX_CDSP_CODEC_RESET_MASK</span><span class="p">;</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CDSP</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCDSP</span><span class="p">);</span>
	<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CDSP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_chip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">VX_TYPE_BOARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="cm">/* additionnel wait time for AKM&#39;s */</span>

	<span class="n">vx2_write_codec_reg</span><span class="p">(</span><span class="n">_chip</span><span class="p">,</span> <span class="n">AKM_CODEC_POWER_CONTROL_CMD</span><span class="p">);</span> <span class="cm">/* DAC power up, ADC power up, Vref power down */</span>
	
	<span class="n">vx2_write_codec_reg</span><span class="p">(</span><span class="n">_chip</span><span class="p">,</span> <span class="n">AKM_CODEC_CLOCK_FORMAT_CMD</span><span class="p">);</span> <span class="cm">/* default */</span>
	<span class="n">vx2_write_codec_reg</span><span class="p">(</span><span class="n">_chip</span><span class="p">,</span> <span class="n">AKM_CODEC_MUTE_CMD</span><span class="p">);</span> <span class="cm">/* Mute = ON ,Deemphasis = OFF */</span>
	<span class="n">vx2_write_codec_reg</span><span class="p">(</span><span class="n">_chip</span><span class="p">,</span> <span class="n">AKM_CODEC_RESET_OFF_CMD</span><span class="p">);</span> <span class="cm">/* DAC and ADC normal operation */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_chip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">VX_TYPE_MIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* set up the micro input selector */</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">regSELMIC</span> <span class="o">=</span>  <span class="n">MICRO_SELECT_INPUT_NORM</span> <span class="o">|</span>
			<span class="n">MICRO_SELECT_PREAMPLI_G_0</span> <span class="o">|</span>
			<span class="n">MICRO_SELECT_NOISE_T_52DB</span><span class="p">;</span>

		<span class="cm">/* reset phantom power supply */</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">regSELMIC</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MICRO_SELECT_PHANTOM_ALIM</span><span class="p">;</span>

		<span class="n">vx_outl</span><span class="p">(</span><span class="n">_chip</span><span class="p">,</span> <span class="n">SELMIC</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">regSELMIC</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * change the audio source</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_change_audio_source</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">_chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="p">)</span><span class="n">_chip</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VX_AUDIO_SRC_DIGITAL</span>:
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCFG</span> <span class="o">|=</span> <span class="n">VX_CFG_DATAIN_SEL_MASK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCFG</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VX_CFG_DATAIN_SEL_MASK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CFG</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCFG</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * set the clock source</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_set_clock_source</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">_chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">source</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="p">)</span><span class="n">_chip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">source</span> <span class="o">==</span> <span class="n">INTERNAL_QUARTZ</span><span class="p">)</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCFG</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VX_CFG_CLOCKIN_SEL_MASK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCFG</span> <span class="o">|=</span> <span class="n">VX_CFG_CLOCKIN_SEL_MASK</span><span class="p">;</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CFG</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCFG</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * reset the board</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_reset_board</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">_chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cold_reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="p">)</span><span class="n">_chip</span><span class="p">;</span>

	<span class="cm">/* initialize the register values */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCDSP</span> <span class="o">=</span> <span class="n">VX_CDSP_CODEC_RESET_MASK</span> <span class="o">|</span> <span class="n">VX_CDSP_DSP_RESET_MASK</span> <span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">regCFG</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * input level controls for VX222 Mic</span>
<span class="cm"> */</span>

<span class="cm">/* Micro level is specified to be adjustable from -96dB to 63 dB (board coded 0x00 ... 318),</span>
<span class="cm"> * 318 = 210 + 36 + 36 + 36   (210 = +9dB variable) (3 * 36 = 3 steps of 18dB pre ampli)</span>
<span class="cm"> * as we will mute if less than -110dB, so let&#39;s simply use line input coded levels and add constant offset !</span>
<span class="cm"> */</span>
<span class="cp">#define V2_MICRO_LEVEL_RANGE        (318 - 255)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx2_set_input_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">miclevel</span><span class="p">,</span> <span class="n">preamp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">miclevel</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mic_level</span><span class="p">;</span>
	<span class="n">miclevel</span> <span class="o">+=</span> <span class="n">V2_MICRO_LEVEL_RANGE</span><span class="p">;</span> <span class="cm">/* add 318 - 0xff */</span>
	<span class="n">preamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">miclevel</span> <span class="o">&gt;</span> <span class="mi">210</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* limitation to +9dB of 3310 real gain */</span>
		<span class="n">preamp</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* raise pre ampli + 18dB */</span>
		<span class="n">miclevel</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">18</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>   <span class="cm">/* lower level 18 dB (*2 because of 0.5 dB steps !) */</span>
        <span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">preamp</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* set pre-amp level */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">regSELMIC</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MICRO_SELECT_PREAMPLI_MASK</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">regSELMIC</span> <span class="o">|=</span> <span class="p">(</span><span class="n">preamp</span> <span class="o">&lt;&lt;</span> <span class="n">MICRO_SELECT_PREAMPLI_OFFSET</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MICRO_SELECT_PREAMPLI_MASK</span><span class="p">;</span>
	<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">SELMIC</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">regSELMIC</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">miclevel</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_level</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_level</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DATA</span><span class="p">);</span> <span class="cm">/* Activate input level programming */</span>

	<span class="cm">/* We have to send 32 bits (4 x 8 bits) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">data</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">vx_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DATA</span><span class="p">,</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="o">?</span> <span class="n">VX_DATA_CODEC_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>

	<span class="n">vx_inl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RUER</span><span class="p">);</span> <span class="cm">/* Terminate input level programming */</span>
<span class="p">}</span>


<span class="cp">#define MIC_LEVEL_MAX	0xff</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">DECLARE_TLV_DB_SCALE</span><span class="p">(</span><span class="n">db_scale_mic</span><span class="p">,</span> <span class="o">-</span><span class="mi">6450</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * controls API for input levels</span>
<span class="cm"> */</span>

<span class="cm">/* input levels */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_input_level_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_INTEGER</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">MIC_LEVEL_MAX</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_input_level_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">_chip</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="p">)</span><span class="n">_chip</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_chip</span><span class="o">-&gt;</span><span class="n">mixer_mutex</span><span class="p">);</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_level</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_level</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_chip</span><span class="o">-&gt;</span><span class="n">mixer_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_input_level_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">_chip</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="p">)</span><span class="n">_chip</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">MIC_LEVEL_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">MIC_LEVEL_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_chip</span><span class="o">-&gt;</span><span class="n">mixer_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span>
	    <span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_level</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_level</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">vx2_set_input_level</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_chip</span><span class="o">-&gt;</span><span class="n">mixer_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_chip</span><span class="o">-&gt;</span><span class="n">mixer_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* mic level */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_mic_level_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_INTEGER</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">MIC_LEVEL_MAX</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_mic_level_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">_chip</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="p">)</span><span class="n">_chip</span><span class="p">;</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mic_level</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_mic_level_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">_chip</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="p">)</span><span class="n">_chip</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">MIC_LEVEL_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_chip</span><span class="o">-&gt;</span><span class="n">mixer_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mic_level</span> <span class="o">!=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">mic_level</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">vx2_set_input_level</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_chip</span><span class="o">-&gt;</span><span class="n">mixer_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_chip</span><span class="o">-&gt;</span><span class="n">mixer_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">vx_control_input_level</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">iface</span> <span class="o">=</span>	<span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">access</span> <span class="o">=</span>	<span class="p">(</span><span class="n">SNDRV_CTL_ELEM_ACCESS_READWRITE</span> <span class="o">|</span>
			 <span class="n">SNDRV_CTL_ELEM_ACCESS_TLV_READ</span><span class="p">),</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;Capture Volume&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span>		<span class="n">vx_input_level_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span>		<span class="n">vx_input_level_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span> <span class="o">=</span>		<span class="n">vx_input_level_put</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlv</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">db_scale_mic</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">vx_control_mic_level</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">iface</span> <span class="o">=</span>	<span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">access</span> <span class="o">=</span>	<span class="p">(</span><span class="n">SNDRV_CTL_ELEM_ACCESS_READWRITE</span> <span class="o">|</span>
			 <span class="n">SNDRV_CTL_ELEM_ACCESS_TLV_READ</span><span class="p">),</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;Mic Capture Volume&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span>		<span class="n">vx_mic_level_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span>		<span class="n">vx_mic_level_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span> <span class="o">=</span>		<span class="n">vx_mic_level_put</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tlv</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">db_scale_mic</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * FIXME: compressor/limiter implementation is missing yet...</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx2_add_mic_controls</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">_chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_vx222</span> <span class="o">*</span><span class="p">)</span><span class="n">_chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_chip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">VX_TYPE_MIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* mute input levels */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_level</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">mic_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vx2_set_input_level</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* controls */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_ctl_add</span><span class="p">(</span><span class="n">_chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">snd_ctl_new1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vx_control_input_level</span><span class="p">,</span> <span class="n">chip</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_ctl_add</span><span class="p">(</span><span class="n">_chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">snd_ctl_new1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vx_control_mic_level</span><span class="p">,</span> <span class="n">chip</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * callbacks</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">snd_vx_ops</span> <span class="n">vx222_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">in8</span> <span class="o">=</span> <span class="n">vx2_inb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">in32</span> <span class="o">=</span> <span class="n">vx2_inl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">out8</span> <span class="o">=</span> <span class="n">vx2_outb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">out32</span> <span class="o">=</span> <span class="n">vx2_outl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">test_and_ack</span> <span class="o">=</span> <span class="n">vx2_test_and_ack</span><span class="p">,</span>
	<span class="p">.</span><span class="n">validate_irq</span> <span class="o">=</span> <span class="n">vx2_validate_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">akm_write</span> <span class="o">=</span> <span class="n">vx2_write_akm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_codec</span> <span class="o">=</span> <span class="n">vx2_reset_codec</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change_audio_source</span> <span class="o">=</span> <span class="n">vx2_change_audio_source</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_clock_source</span> <span class="o">=</span> <span class="n">vx2_set_clock_source</span><span class="p">,</span>
	<span class="p">.</span><span class="n">load_dsp</span> <span class="o">=</span> <span class="n">vx2_load_dsp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_dsp</span> <span class="o">=</span> <span class="n">vx2_reset_dsp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_board</span> <span class="o">=</span> <span class="n">vx2_reset_board</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_write</span> <span class="o">=</span> <span class="n">vx2_dma_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_read</span> <span class="o">=</span> <span class="n">vx2_dma_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">add_controls</span> <span class="o">=</span> <span class="n">vx2_add_mic_controls</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* for old VX222 board */</span>
<span class="k">struct</span> <span class="n">snd_vx_ops</span> <span class="n">vx222_old_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">in8</span> <span class="o">=</span> <span class="n">vx2_inb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">in32</span> <span class="o">=</span> <span class="n">vx2_inl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">out8</span> <span class="o">=</span> <span class="n">vx2_outb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">out32</span> <span class="o">=</span> <span class="n">vx2_outl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">test_and_ack</span> <span class="o">=</span> <span class="n">vx2_test_and_ack</span><span class="p">,</span>
	<span class="p">.</span><span class="n">validate_irq</span> <span class="o">=</span> <span class="n">vx2_validate_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_codec</span> <span class="o">=</span> <span class="n">vx2_old_write_codec_bit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_codec</span> <span class="o">=</span> <span class="n">vx2_reset_codec</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change_audio_source</span> <span class="o">=</span> <span class="n">vx2_change_audio_source</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_clock_source</span> <span class="o">=</span> <span class="n">vx2_set_clock_source</span><span class="p">,</span>
	<span class="p">.</span><span class="n">load_dsp</span> <span class="o">=</span> <span class="n">vx2_load_dsp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_dsp</span> <span class="o">=</span> <span class="n">vx2_reset_dsp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_board</span> <span class="o">=</span> <span class="n">vx2_reset_board</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_write</span> <span class="o">=</span> <span class="n">vx2_dma_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_read</span> <span class="o">=</span> <span class="n">vx2_dma_read</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
