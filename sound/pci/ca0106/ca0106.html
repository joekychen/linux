<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › pci › ca0106 › ca0106.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ca0106.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Copyright (c) 2004 James Courtier-Dutton &lt;James@superbug.demon.co.uk&gt;</span>
<span class="cm"> *  Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit</span>
<span class="cm"> *  Version: 0.0.22</span>
<span class="cm"> *</span>
<span class="cm"> *  FEATURES currently supported:</span>
<span class="cm"> *    See ca0106_main.c for features.</span>
<span class="cm"> * </span>
<span class="cm"> *  Changelog:</span>
<span class="cm"> *    Support interrupts per period.</span>
<span class="cm"> *    Removed noise from Center/LFE channel when in Analog mode.</span>
<span class="cm"> *    Rename and remove mixer controls.</span>
<span class="cm"> *  0.0.6</span>
<span class="cm"> *    Use separate card based DMA buffer for periods table list.</span>
<span class="cm"> *  0.0.7</span>
<span class="cm"> *    Change remove and rename ctrls into lists.</span>
<span class="cm"> *  0.0.8</span>
<span class="cm"> *    Try to fix capture sources.</span>
<span class="cm"> *  0.0.9</span>
<span class="cm"> *    Fix AC3 output.</span>
<span class="cm"> *    Enable S32_LE format support.</span>
<span class="cm"> *  0.0.10</span>
<span class="cm"> *    Enable playback 48000 and 96000 rates. (Rates other that these do not work, even with &quot;plug:front&quot;.)</span>
<span class="cm"> *  0.0.11</span>
<span class="cm"> *    Add Model name recognition.</span>
<span class="cm"> *  0.0.12</span>
<span class="cm"> *    Correct interrupt timing. interrupt at end of period, instead of in the middle of a playback period.</span>
<span class="cm"> *    Remove redundent &quot;voice&quot; handling.</span>
<span class="cm"> *  0.0.13</span>
<span class="cm"> *    Single trigger call for multi channels.</span>
<span class="cm"> *  0.0.14</span>
<span class="cm"> *    Set limits based on what the sound card hardware can do.</span>
<span class="cm"> *    playback periods_min=2, periods_max=8</span>
<span class="cm"> *    capture hw constraints require period_size = n * 64 bytes.</span>
<span class="cm"> *    playback hw constraints require period_size = n * 64 bytes.</span>
<span class="cm"> *  0.0.15</span>
<span class="cm"> *    Separated ca0106.c into separate functional .c files.</span>
<span class="cm"> *  0.0.16</span>
<span class="cm"> *    Implement 192000 sample rate.</span>
<span class="cm"> *  0.0.17</span>
<span class="cm"> *    Add support for SB0410 and SB0413.</span>
<span class="cm"> *  0.0.18</span>
<span class="cm"> *    Modified Copyright message.</span>
<span class="cm"> *  0.0.19</span>
<span class="cm"> *    Added I2C and SPI registers. Filled in interrupt enable.</span>
<span class="cm"> *  0.0.20</span>
<span class="cm"> *    Added GPIO info for SB Live 24bit.</span>
<span class="cm"> *  0.0.21</span>
<span class="cm"> *   Implement support for Line-in capture on SB Live 24bit.</span>
<span class="cm"> *  0.0.22</span>
<span class="cm"> *    Add support for mute control on SB Live 24bit (cards w/ SPI DAC)</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  This code was initially based on code from ALSA&#39;s emu10k1x.c which is:</span>
<span class="cm"> *  Copyright (c) by Francisco Moraes &lt;fmoraes@nc.rr.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *   GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/************************************************************************************************/</span>
<span class="cm">/* PCI function 0 registers, address = &lt;val&gt; + PCIBASE0						*/</span>
<span class="cm">/************************************************************************************************/</span>

<span class="cp">#define PTR			0x00		</span><span class="cm">/* Indexed register set pointer register	*/</span><span class="cp"></span>
						<span class="cm">/* NOTE: The CHANNELNUM and ADDRESS words can	*/</span>
						<span class="cm">/* be modified independently of each other.	*/</span>
						<span class="cm">/* CNL[1:0], ADDR[27:16]                        */</span>

<span class="cp">#define DATA			0x04		</span><span class="cm">/* Indexed register set data register		*/</span><span class="cp"></span>
						<span class="cm">/* DATA[31:0]					*/</span>

<span class="cp">#define IPR			0x08		</span><span class="cm">/* Global interrupt pending register		*/</span><span class="cp"></span>
						<span class="cm">/* Clear pending interrupts by writing a 1 to	*/</span>
						<span class="cm">/* the relevant bits and zero to the other bits	*/</span>
<span class="cp">#define IPR_MIDI_RX_B		0x00020000	</span><span class="cm">/* MIDI UART-B Receive buffer non-empty		*/</span><span class="cp"></span>
<span class="cp">#define IPR_MIDI_TX_B		0x00010000	</span><span class="cm">/* MIDI UART-B Transmit buffer empty		*/</span><span class="cp"></span>
<span class="cp">#define IPR_SPDIF_IN_USER	0x00004000      </span><span class="cm">/* SPDIF input user data has 16 more bits	*/</span><span class="cp"></span>
<span class="cp">#define IPR_SPDIF_OUT_USER	0x00002000      </span><span class="cm">/* SPDIF output user data needs 16 more bits	*/</span><span class="cp"></span>
<span class="cp">#define IPR_SPDIF_OUT_FRAME	0x00001000      </span><span class="cm">/* SPDIF frame about to start			*/</span><span class="cp"></span>
<span class="cp">#define IPR_SPI			0x00000800      </span><span class="cm">/* SPI transaction completed			*/</span><span class="cp"></span>
<span class="cp">#define IPR_I2C_EEPROM		0x00000400      </span><span class="cm">/* I2C EEPROM transaction completed		*/</span><span class="cp"></span>
<span class="cp">#define IPR_I2C_DAC		0x00000200      </span><span class="cm">/* I2C DAC transaction completed		*/</span><span class="cp"></span>
<span class="cp">#define IPR_AI			0x00000100      </span><span class="cm">/* Audio pending register changed. See PTR reg 0x76	*/</span><span class="cp"></span>
<span class="cp">#define IPR_GPI			0x00000080      </span><span class="cm">/* General Purpose input changed		*/</span><span class="cp"></span>
<span class="cp">#define IPR_SRC_LOCKED          0x00000040      </span><span class="cm">/* SRC lock status changed			*/</span><span class="cp"></span>
<span class="cp">#define IPR_SPDIF_STATUS        0x00000020      </span><span class="cm">/* SPDIF status changed				*/</span><span class="cp"></span>
<span class="cp">#define IPR_TIMER2              0x00000010      </span><span class="cm">/* 192000Hz Timer				*/</span><span class="cp"></span>
<span class="cp">#define IPR_TIMER1              0x00000008      </span><span class="cm">/* 44100Hz Timer				*/</span><span class="cp"></span>
<span class="cp">#define IPR_MIDI_RX_A		0x00000004	</span><span class="cm">/* MIDI UART-A Receive buffer non-empty		*/</span><span class="cp"></span>
<span class="cp">#define IPR_MIDI_TX_A		0x00000002	</span><span class="cm">/* MIDI UART-A Transmit buffer empty		*/</span><span class="cp"></span>
<span class="cp">#define IPR_PCI			0x00000001	</span><span class="cm">/* PCI Bus error				*/</span><span class="cp"></span>

<span class="cp">#define INTE			0x0c		</span><span class="cm">/* Interrupt enable register			*/</span><span class="cp"></span>

<span class="cp">#define INTE_MIDI_RX_B		0x00020000	</span><span class="cm">/* MIDI UART-B Receive buffer non-empty		*/</span><span class="cp"></span>
<span class="cp">#define INTE_MIDI_TX_B		0x00010000	</span><span class="cm">/* MIDI UART-B Transmit buffer empty		*/</span><span class="cp"></span>
<span class="cp">#define INTE_SPDIF_IN_USER	0x00004000      </span><span class="cm">/* SPDIF input user data has 16 more bits	*/</span><span class="cp"></span>
<span class="cp">#define INTE_SPDIF_OUT_USER	0x00002000      </span><span class="cm">/* SPDIF output user data needs 16 more bits	*/</span><span class="cp"></span>
<span class="cp">#define INTE_SPDIF_OUT_FRAME	0x00001000      </span><span class="cm">/* SPDIF frame about to start			*/</span><span class="cp"></span>
<span class="cp">#define INTE_SPI		0x00000800      </span><span class="cm">/* SPI transaction completed			*/</span><span class="cp"></span>
<span class="cp">#define INTE_I2C_EEPROM		0x00000400      </span><span class="cm">/* I2C EEPROM transaction completed		*/</span><span class="cp"></span>
<span class="cp">#define INTE_I2C_DAC		0x00000200      </span><span class="cm">/* I2C DAC transaction completed		*/</span><span class="cp"></span>
<span class="cp">#define INTE_AI			0x00000100      </span><span class="cm">/* Audio pending register changed. See PTR reg 0x75 */</span><span class="cp"></span>
<span class="cp">#define INTE_GPI		0x00000080      </span><span class="cm">/* General Purpose input changed		*/</span><span class="cp"></span>
<span class="cp">#define INTE_SRC_LOCKED         0x00000040      </span><span class="cm">/* SRC lock status changed			*/</span><span class="cp"></span>
<span class="cp">#define INTE_SPDIF_STATUS       0x00000020      </span><span class="cm">/* SPDIF status changed				*/</span><span class="cp"></span>
<span class="cp">#define INTE_TIMER2             0x00000010      </span><span class="cm">/* 192000Hz Timer				*/</span><span class="cp"></span>
<span class="cp">#define INTE_TIMER1             0x00000008      </span><span class="cm">/* 44100Hz Timer				*/</span><span class="cp"></span>
<span class="cp">#define INTE_MIDI_RX_A		0x00000004	</span><span class="cm">/* MIDI UART-A Receive buffer non-empty		*/</span><span class="cp"></span>
<span class="cp">#define INTE_MIDI_TX_A		0x00000002	</span><span class="cm">/* MIDI UART-A Transmit buffer empty		*/</span><span class="cp"></span>
<span class="cp">#define INTE_PCI		0x00000001	</span><span class="cm">/* PCI Bus error				*/</span><span class="cp"></span>

<span class="cp">#define UNKNOWN10		0x10		</span><span class="cm">/* Unknown ??. Defaults to 0 */</span><span class="cp"></span>
<span class="cp">#define HCFG			0x14		</span><span class="cm">/* Hardware config register			*/</span><span class="cp"></span>
						<span class="cm">/* 0x1000 causes AC3 to fails. It adds a dither bit. */</span>

<span class="cp">#define HCFG_STAC		0x10000000	</span><span class="cm">/* Special mode for STAC9460 Codec. */</span><span class="cp"></span>
<span class="cp">#define HCFG_CAPTURE_I2S_BYPASS	0x08000000	</span><span class="cm">/* 1 = bypass I2S input async SRC. */</span><span class="cp"></span>
<span class="cp">#define HCFG_CAPTURE_SPDIF_BYPASS 0x04000000	</span><span class="cm">/* 1 = bypass SPDIF input async SRC. */</span><span class="cp"></span>
<span class="cp">#define HCFG_PLAYBACK_I2S_BYPASS 0x02000000	</span><span class="cm">/* 0 = I2S IN mixer output, 1 = I2S IN1. */</span><span class="cp"></span>
<span class="cp">#define HCFG_FORCE_LOCK		0x01000000	</span><span class="cm">/* For test only. Force input SRC tracker to lock. */</span><span class="cp"></span>
<span class="cp">#define HCFG_PLAYBACK_ATTENUATION 0x00006000	</span><span class="cm">/* Playback attenuation mask. 0 = 0dB, 1 = 6dB, 2 = 12dB, 3 = Mute. */</span><span class="cp"></span>
<span class="cp">#define HCFG_PLAYBACK_DITHER	0x00001000	</span><span class="cm">/* 1 = Add dither bit to all playback channels. */</span><span class="cp"></span>
<span class="cp">#define HCFG_PLAYBACK_S32_LE	0x00000800	</span><span class="cm">/* 1 = S32_LE, 0 = S16_LE                       */</span><span class="cp"></span>
<span class="cp">#define HCFG_CAPTURE_S32_LE	0x00000400	</span><span class="cm">/* 1 = S32_LE, 0 = S16_LE (S32_LE current not working)	*/</span><span class="cp"></span>
<span class="cp">#define HCFG_8_CHANNEL_PLAY	0x00000200	</span><span class="cm">/* 1 = 8 channels, 0 = 2 channels per substream.*/</span><span class="cp"></span>
<span class="cp">#define HCFG_8_CHANNEL_CAPTURE	0x00000100	</span><span class="cm">/* 1 = 8 channels, 0 = 2 channels per substream.*/</span><span class="cp"></span>
<span class="cp">#define HCFG_MONO		0x00000080	</span><span class="cm">/* 1 = I2S Input mono                           */</span><span class="cp"></span>
<span class="cp">#define HCFG_I2S_OUTPUT		0x00000010	</span><span class="cm">/* 1 = I2S Output disabled                      */</span><span class="cp"></span>
<span class="cp">#define HCFG_AC97		0x00000008	</span><span class="cm">/* 0 = AC97 1.0, 1 = AC97 2.0                   */</span><span class="cp"></span>
<span class="cp">#define HCFG_LOCK_PLAYBACK_CACHE 0x00000004	</span><span class="cm">/* 1 = Cancel bustmaster accesses to soundcache */</span><span class="cp"></span>
						<span class="cm">/* NOTE: This should generally never be used.  	*/</span>
<span class="cp">#define HCFG_LOCK_CAPTURE_CACHE	0x00000002	</span><span class="cm">/* 1 = Cancel bustmaster accesses to soundcache */</span><span class="cp"></span>
						<span class="cm">/* NOTE: This should generally never be used.  	*/</span>
<span class="cp">#define HCFG_AUDIOENABLE	0x00000001	</span><span class="cm">/* 0 = CODECs transmit zero-valued samples	*/</span><span class="cp"></span>
						<span class="cm">/* Should be set to 1 when the EMU10K1 is	*/</span>
						<span class="cm">/* completely initialized.			*/</span>
<span class="cp">#define GPIO			0x18		</span><span class="cm">/* Defaults: 005f03a3-Analog, 005f02a2-SPDIF.   */</span><span class="cp"></span>
						<span class="cm">/* Here pins 0,1,2,3,4,,6 are output. 5,7 are input */</span>
						<span class="cm">/* For the Audigy LS, pin 0 (or bit 8) controls the SPDIF/Analog jack. */</span>
						<span class="cm">/* SB Live 24bit:</span>
<span class="cm">						 * bit 8 0 = SPDIF in and out / 1 = Analog (Mic or Line)-in.</span>
<span class="cm">						 * bit 9 0 = Mute / 1 = Analog out.</span>
<span class="cm">						 * bit 10 0 = Line-in / 1 = Mic-in.</span>
<span class="cm">						 * bit 11 0 = ? / 1 = ?</span>
<span class="cm">						 * bit 12 0 = 48 Khz / 1 = 96 Khz Analog out on SB Live 24bit.</span>
<span class="cm">						 * bit 13 0 = ? / 1 = ?</span>
<span class="cm">						 * bit 14 0 = Mute / 1 = Analog out</span>
<span class="cm">						 * bit 15 0 = ? / 1 = ?</span>
<span class="cm">						 * Both bit 9 and bit 14 have to be set for analog sound to work on the SB Live 24bit.</span>
<span class="cm">						 */</span>
						<span class="cm">/* 8 general purpose programmable In/Out pins.</span>
<span class="cm">						 * GPI [8:0] Read only. Default 0.</span>
<span class="cm">						 * GPO [15:8] Default 0x9. (Default to SPDIF jack enabled for SPDIF)</span>
<span class="cm">						 * GPO Enable [23:16] Default 0x0f. Setting a bit to 1, causes the pin to be an output pin.</span>
<span class="cm">						 */</span>
<span class="cp">#define AC97DATA		0x1c		</span><span class="cm">/* AC97 register set data register (16 bit)	*/</span><span class="cp"></span>

<span class="cp">#define AC97ADDRESS		0x1e		</span><span class="cm">/* AC97 register set address register (8 bit)	*/</span><span class="cp"></span>

<span class="cm">/********************************************************************************************************/</span>
<span class="cm">/* CA0106 pointer-offset register set, accessed through the PTR and DATA registers                     */</span>
<span class="cm">/********************************************************************************************************/</span>
                                                                                                                           
<span class="cm">/* Initially all registers from 0x00 to 0x3f have zero contents. */</span>
<span class="cp">#define PLAYBACK_LIST_ADDR	0x00		</span><span class="cm">/* Base DMA address of a list of pointers to each period/size */</span><span class="cp"></span>
						<span class="cm">/* One list entry: 4 bytes for DMA address, </span>
<span class="cm">						 * 4 bytes for period_size &lt;&lt; 16.</span>
<span class="cm">						 * One list entry is 8 bytes long.</span>
<span class="cm">						 * One list entry for each period in the buffer.</span>
<span class="cm">						 */</span>
						<span class="cm">/* ADDR[31:0], Default: 0x0 */</span>
<span class="cp">#define PLAYBACK_LIST_SIZE	0x01		</span><span class="cm">/* Size of list in bytes &lt;&lt; 16. E.g. 8 periods -&gt; 0x00380000  */</span><span class="cp"></span>
						<span class="cm">/* SIZE[21:16], Default: 0x8 */</span>
<span class="cp">#define PLAYBACK_LIST_PTR	0x02		</span><span class="cm">/* Pointer to the current period being played */</span><span class="cp"></span>
						<span class="cm">/* PTR[5:0], Default: 0x0 */</span>
<span class="cp">#define PLAYBACK_UNKNOWN3	0x03		</span><span class="cm">/* Not used ?? */</span><span class="cp"></span>
<span class="cp">#define PLAYBACK_DMA_ADDR	0x04		</span><span class="cm">/* Playback DMA address */</span><span class="cp"></span>
						<span class="cm">/* DMA[31:0], Default: 0x0 */</span>
<span class="cp">#define PLAYBACK_PERIOD_SIZE	0x05		</span><span class="cm">/* Playback period size. win2000 uses 0x04000000 */</span><span class="cp"></span>
						<span class="cm">/* SIZE[31:16], Default: 0x0 */</span>
<span class="cp">#define PLAYBACK_POINTER	0x06		</span><span class="cm">/* Playback period pointer. Used with PLAYBACK_LIST_PTR to determine buffer position currently in DAC */</span><span class="cp"></span>
						<span class="cm">/* POINTER[15:0], Default: 0x0 */</span>
<span class="cp">#define PLAYBACK_PERIOD_END_ADDR 0x07		</span><span class="cm">/* Playback fifo end address */</span><span class="cp"></span>
						<span class="cm">/* END_ADDR[15:0], FLAG[16] 0 = don&#39;t stop, 1 = stop */</span>
<span class="cp">#define PLAYBACK_FIFO_OFFSET_ADDRESS	0x08	</span><span class="cm">/* Current fifo offset address [21:16] */</span><span class="cp"></span>
						<span class="cm">/* Cache size valid [5:0] */</span>
<span class="cp">#define PLAYBACK_UNKNOWN9	0x09		</span><span class="cm">/* 0x9 to 0xf Unused */</span><span class="cp"></span>
<span class="cp">#define CAPTURE_DMA_ADDR	0x10		</span><span class="cm">/* Capture DMA address */</span><span class="cp"></span>
						<span class="cm">/* DMA[31:0], Default: 0x0 */</span>
<span class="cp">#define CAPTURE_BUFFER_SIZE	0x11		</span><span class="cm">/* Capture buffer size */</span><span class="cp"></span>
						<span class="cm">/* SIZE[31:16], Default: 0x0 */</span>
<span class="cp">#define CAPTURE_POINTER		0x12		</span><span class="cm">/* Capture buffer pointer. Sample currently in ADC */</span><span class="cp"></span>
						<span class="cm">/* POINTER[15:0], Default: 0x0 */</span>
<span class="cp">#define CAPTURE_FIFO_OFFSET_ADDRESS	0x13	</span><span class="cm">/* Current fifo offset address [21:16] */</span><span class="cp"></span>
						<span class="cm">/* Cache size valid [5:0] */</span>
<span class="cp">#define PLAYBACK_LAST_SAMPLE    0x20		</span><span class="cm">/* The sample currently being played */</span><span class="cp"></span>
<span class="cm">/* 0x21 - 0x3f unused */</span>
<span class="cp">#define BASIC_INTERRUPT         0x40		</span><span class="cm">/* Used by both playback and capture interrupt handler */</span><span class="cp"></span>
						<span class="cm">/* Playback (0x1&lt;&lt;channel_id) */</span>
						<span class="cm">/* Capture  (0x100&lt;&lt;channel_id) */</span>
						<span class="cm">/* Playback sample rate 96000 = 0x20000 */</span>
						<span class="cm">/* Start Playback [3:0] (one bit per channel)</span>
<span class="cm">						 * Start Capture [11:8] (one bit per channel)</span>
<span class="cm">						 * Playback rate [23:16] (2 bits per channel) (0=48kHz, 1=44.1kHz, 2=96kHz, 3=192Khz)</span>
<span class="cm">						 * Playback mixer in enable [27:24] (one bit per channel)</span>
<span class="cm">						 * Playback mixer out enable [31:28] (one bit per channel)</span>
<span class="cm">						 */</span>
<span class="cm">/* The Digital out jack is shared with the Center/LFE Analogue output. </span>
<span class="cm"> * The jack has 4 poles. I will call 1 - Tip, 2 - Next to 1, 3 - Next to 2, 4 - Next to 3</span>
<span class="cm"> * For Analogue: 1 -&gt; Center Speaker, 2 -&gt; Sub Woofer, 3 -&gt; Ground, 4 -&gt; Ground</span>
<span class="cm"> * For Digital: 1 -&gt; Front SPDIF, 2 -&gt; Rear SPDIF, 3 -&gt; Center/Subwoofer SPDIF, 4 -&gt; Ground.</span>
<span class="cm"> * Standard 4 pole Video A/V cable with RCA outputs: 1 -&gt; White, 2 -&gt; Yellow, 3 -&gt; Shield on all three, 4 -&gt; Red.</span>
<span class="cm"> * So, from this you can see that you cannot use a Standard 4 pole Video A/V cable with the SB Audigy LS card.</span>
<span class="cm"> */</span>
<span class="cm">/* The Front SPDIF PCM gets mixed with samples from the AC97 codec, so can only work for Stereo PCM and not AC3/DTS</span>
<span class="cm"> * The Rear SPDIF can be used for Stereo PCM and also AC3/DTS</span>
<span class="cm"> * The Center/LFE SPDIF cannot be used for AC3/DTS, but can be used for Stereo PCM.</span>
<span class="cm"> * Summary: For ALSA we use the Rear channel for SPDIF Digital AC3/DTS output</span>
<span class="cm"> */</span>
<span class="cm">/* A standard 2 pole mono mini-jack to RCA plug can be used for SPDIF Stereo PCM output from the Front channel.</span>
<span class="cm"> * A standard 3 pole stereo mini-jack to 2 RCA plugs can be used for SPDIF AC3/DTS and Stereo PCM output utilising the Rear channel and just one of the RCA plugs. </span>
<span class="cm"> */</span>
<span class="cp">#define SPCS0			0x41		</span><span class="cm">/* SPDIF output Channel Status 0 register. For Rear. default=0x02108004, non-audio=0x02108006	*/</span><span class="cp"></span>
<span class="cp">#define SPCS1			0x42		</span><span class="cm">/* SPDIF output Channel Status 1 register. For Front */</span><span class="cp"></span>
<span class="cp">#define SPCS2			0x43		</span><span class="cm">/* SPDIF output Channel Status 2 register. For Center/LFE */</span><span class="cp"></span>
<span class="cp">#define SPCS3			0x44		</span><span class="cm">/* SPDIF output Channel Status 3 register. Unknown */</span><span class="cp"></span>
						<span class="cm">/* When Channel set to 0: */</span>
<span class="cp">#define SPCS_CLKACCYMASK	0x30000000	</span><span class="cm">/* Clock accuracy				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_CLKACCY_1000PPM	0x00000000	</span><span class="cm">/* 1000 parts per million			*/</span><span class="cp"></span>
<span class="cp">#define SPCS_CLKACCY_50PPM	0x10000000	</span><span class="cm">/* 50 parts per million				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_CLKACCY_VARIABLE	0x20000000	</span><span class="cm">/* Variable accuracy				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_SAMPLERATEMASK	0x0f000000	</span><span class="cm">/* Sample rate					*/</span><span class="cp"></span>
<span class="cp">#define SPCS_SAMPLERATE_44	0x00000000	</span><span class="cm">/* 44.1kHz sample rate				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_SAMPLERATE_48	0x02000000	</span><span class="cm">/* 48kHz sample rate				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_SAMPLERATE_32	0x03000000	</span><span class="cm">/* 32kHz sample rate				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_CHANNELNUMMASK	0x00f00000	</span><span class="cm">/* Channel number				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_CHANNELNUM_UNSPEC	0x00000000	</span><span class="cm">/* Unspecified channel number			*/</span><span class="cp"></span>
<span class="cp">#define SPCS_CHANNELNUM_LEFT	0x00100000	</span><span class="cm">/* Left channel					*/</span><span class="cp"></span>
<span class="cp">#define SPCS_CHANNELNUM_RIGHT	0x00200000	</span><span class="cm">/* Right channel				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_SOURCENUMMASK	0x000f0000	</span><span class="cm">/* Source number				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_SOURCENUM_UNSPEC	0x00000000	</span><span class="cm">/* Unspecified source number			*/</span><span class="cp"></span>
<span class="cp">#define SPCS_GENERATIONSTATUS	0x00008000	</span><span class="cm">/* Originality flag (see IEC-958 spec)		*/</span><span class="cp"></span>
<span class="cp">#define SPCS_CATEGORYCODEMASK	0x00007f00	</span><span class="cm">/* Category code (see IEC-958 spec)		*/</span><span class="cp"></span>
<span class="cp">#define SPCS_MODEMASK		0x000000c0	</span><span class="cm">/* Mode (see IEC-958 spec)			*/</span><span class="cp"></span>
<span class="cp">#define SPCS_EMPHASISMASK	0x00000038	</span><span class="cm">/* Emphasis					*/</span><span class="cp"></span>
<span class="cp">#define SPCS_EMPHASIS_NONE	0x00000000	</span><span class="cm">/* No emphasis					*/</span><span class="cp"></span>
<span class="cp">#define SPCS_EMPHASIS_50_15	0x00000008	</span><span class="cm">/* 50/15 usec 2 channel				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_COPYRIGHT		0x00000004	</span><span class="cm">/* Copyright asserted flag -- do not modify	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_NOTAUDIODATA	0x00000002	</span><span class="cm">/* 0 = Digital audio, 1 = not audio		*/</span><span class="cp"></span>
<span class="cp">#define SPCS_PROFESSIONAL	0x00000001	</span><span class="cm">/* 0 = Consumer (IEC-958), 1 = pro (AES3-1992)	*/</span><span class="cp"></span>

						<span class="cm">/* When Channel set to 1: */</span>
<span class="cp">#define SPCS_WORD_LENGTH_MASK	0x0000000f	</span><span class="cm">/* Word Length Mask				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_WORD_LENGTH_16	0x00000008	</span><span class="cm">/* Word Length 16 bit				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_WORD_LENGTH_17	0x00000006	</span><span class="cm">/* Word Length 17 bit				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_WORD_LENGTH_18	0x00000004	</span><span class="cm">/* Word Length 18 bit				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_WORD_LENGTH_19	0x00000002	</span><span class="cm">/* Word Length 19 bit				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_WORD_LENGTH_20A	0x0000000a	</span><span class="cm">/* Word Length 20 bit				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_WORD_LENGTH_20	0x00000009	</span><span class="cm">/* Word Length 20 bit (both 0xa and 0x9 are 20 bit) */</span><span class="cp"></span>
<span class="cp">#define SPCS_WORD_LENGTH_21	0x00000007	</span><span class="cm">/* Word Length 21 bit				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_WORD_LENGTH_22	0x00000005	</span><span class="cm">/* Word Length 22 bit				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_WORD_LENGTH_23	0x00000003	</span><span class="cm">/* Word Length 23 bit				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_WORD_LENGTH_24	0x0000000b	</span><span class="cm">/* Word Length 24 bit				*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_MASK	0x000000f0 </span><span class="cm">/* Original Sample rate			*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_NONE	0x00000000 </span><span class="cm">/* Original Sample rate not indicated	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_16000	0x00000010 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_RES1	0x00000020 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_32000	0x00000030 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_12000	0x00000040 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_11025	0x00000050 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_8000	0x00000060 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_RES2	0x00000070 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_192000 0x00000080 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_24000	0x00000090 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_96000	0x000000a0 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_48000	0x000000b0 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_176400 0x000000c0 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_22050	0x000000d0 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_88200	0x000000e0 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>
<span class="cp">#define SPCS_ORIGINAL_SAMPLE_RATE_44100	0x000000f0 </span><span class="cm">/* Original Sample rate	*/</span><span class="cp"></span>

<span class="cp">#define SPDIF_SELECT1		0x45		</span><span class="cm">/* Enables SPDIF or Analogue outputs 0-SPDIF, 0xf00-Analogue */</span><span class="cp"></span>
						<span class="cm">/* 0x100 - Front, 0x800 - Rear, 0x200 - Center/LFE.</span>
<span class="cm">						 * But as the jack is shared, use 0xf00.</span>
<span class="cm">						 * The Windows2000 driver uses 0x0000000f for both digital and analog.</span>
<span class="cm">						 * 0xf00 introduces interesting noises onto the Center/LFE.</span>
<span class="cm">						 * If you turn the volume up, you hear computer noise,</span>
<span class="cm">						 * e.g. mouse moving, changing between app windows etc.</span>
<span class="cm">						 * So, I am going to set this to 0x0000000f all the time now,</span>
<span class="cm">						 * same as the windows driver does.</span>
<span class="cm">						 * Use register SPDIF_SELECT2(0x72) to switch between SPDIF and Analog.</span>
<span class="cm">						 */</span>
						<span class="cm">/* When Channel = 0:</span>
<span class="cm">						 * Wide SPDIF format [3:0] (one bit for each channel) (0=20bit, 1=24bit)</span>
<span class="cm">						 * Tristate SPDIF Output [11:8] (one bit for each channel) (0=Not tristate, 1=Tristate)</span>
<span class="cm">						 * SPDIF Bypass enable [19:16] (one bit for each channel) (0=Not bypass, 1=Bypass)</span>
<span class="cm">						 */</span>
						<span class="cm">/* When Channel = 1:</span>
<span class="cm">						 * SPDIF 0 User data [7:0]</span>
<span class="cm">						 * SPDIF 1 User data [15:8]</span>
<span class="cm">						 * SPDIF 0 User data [23:16]</span>
<span class="cm">						 * SPDIF 0 User data [31:24]</span>
<span class="cm">						 * User data can be sent by using the SPDIF output frame pending and SPDIF output user bit interrupts.</span>
<span class="cm">						 */</span>
<span class="cp">#define WATERMARK		0x46		</span><span class="cm">/* Test bit to indicate cache usage level */</span><span class="cp"></span>
<span class="cp">#define SPDIF_INPUT_STATUS	0x49		</span><span class="cm">/* SPDIF Input status register. Bits the same as SPCS.</span>
<span class="cm">						 * When Channel = 0: Bits the same as SPCS channel 0.</span>
<span class="cm">						 * When Channel = 1: Bits the same as SPCS channel 1.</span>
<span class="cm">						 * When Channel = 2:</span>
<span class="cm">						 * SPDIF Input User data [16:0]</span>
<span class="cm">						 * SPDIF Input Frame count [21:16]</span>
<span class="cm">						 */</span><span class="cp"></span>
<span class="cp">#define CAPTURE_CACHE_DATA	0x50		</span><span class="cm">/* 0x50-0x5f Recorded samples. */</span><span class="cp"></span>
<span class="cp">#define CAPTURE_SOURCE          0x60            </span><span class="cm">/* Capture Source 0 = MIC */</span><span class="cp"></span>
<span class="cp">#define CAPTURE_SOURCE_CHANNEL0 0xf0000000	</span><span class="cm">/* Mask for selecting the Capture sources */</span><span class="cp"></span>
<span class="cp">#define CAPTURE_SOURCE_CHANNEL1 0x0f000000	</span><span class="cm">/* 0 - SPDIF mixer output. */</span><span class="cp"></span>
<span class="cp">#define CAPTURE_SOURCE_CHANNEL2 0x00f00000      </span><span class="cm">/* 1 - What you hear or . 2 - ?? */</span><span class="cp"></span>
<span class="cp">#define CAPTURE_SOURCE_CHANNEL3 0x000f0000	</span><span class="cm">/* 3 - Mic in, Line in, TAD in, Aux in. */</span><span class="cp"></span>
<span class="cp">#define CAPTURE_SOURCE_RECORD_MAP 0x0000ffff	</span><span class="cm">/* Default 0x00e4 */</span><span class="cp"></span>
						<span class="cm">/* Record Map [7:0] (2 bits per channel) 0=mapped to channel 0, 1=mapped to channel 1, 2=mapped to channel2, 3=mapped to channel3 </span>
<span class="cm">						 * Record source select for channel 0 [18:16]</span>
<span class="cm">						 * Record source select for channel 1 [22:20]</span>
<span class="cm">						 * Record source select for channel 2 [26:24]</span>
<span class="cm">						 * Record source select for channel 3 [30:28]</span>
<span class="cm">						 * 0 - SPDIF mixer output.</span>
<span class="cm">						 * 1 - i2s mixer output.</span>
<span class="cm">						 * 2 - SPDIF input.</span>
<span class="cm">						 * 3 - i2s input.</span>
<span class="cm">						 * 4 - AC97 capture.</span>
<span class="cm">						 * 5 - SRC output.</span>
<span class="cm">						 */</span>
<span class="cp">#define CAPTURE_VOLUME1         0x61            </span><span class="cm">/* Capture  volume per channel 0-3 */</span><span class="cp"></span>
<span class="cp">#define CAPTURE_VOLUME2         0x62            </span><span class="cm">/* Capture  volume per channel 4-7 */</span><span class="cp"></span>

<span class="cp">#define PLAYBACK_ROUTING1       0x63            </span><span class="cm">/* Playback routing of channels 0-7. Effects AC3 output. Default 0x32765410 */</span><span class="cp"></span>
<span class="cp">#define ROUTING1_REAR           0x77000000      </span><span class="cm">/* Channel_id 0 sends to 10, Channel_id 1 sends to 32 */</span><span class="cp"></span>
<span class="cp">#define ROUTING1_NULL           0x00770000      </span><span class="cm">/* Channel_id 2 sends to 54, Channel_id 3 sends to 76 */</span><span class="cp"></span>
<span class="cp">#define ROUTING1_CENTER_LFE     0x00007700      </span><span class="cm">/* 0x32765410 means, send Channel_id 0 to FRONT, Channel_id 1 to REAR */</span><span class="cp"></span>
<span class="cp">#define ROUTING1_FRONT          0x00000077	</span><span class="cm">/* Channel_id 2 to CENTER_LFE, Channel_id 3 to NULL. */</span><span class="cp"></span>
						<span class="cm">/* Channel_id&#39;s handle stereo channels. Channel X is a single mono channel */</span>
						<span class="cm">/* Host is input from the PCI bus. */</span>
						<span class="cm">/* Host channel 0 [2:0] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 * Host channel 1 [6:4] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 * Host channel 2 [10:8] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 * Host channel 3 [14:12] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 * Host channel 4 [18:16] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 * Host channel 5 [22:20] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 * Host channel 6 [26:24] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 * Host channel 7 [30:28] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 */</span>

<span class="cp">#define PLAYBACK_ROUTING2       0x64            </span><span class="cm">/* Playback Routing . Feeding Capture channels back into Playback. Effects AC3 output. Default 0x76767676 */</span><span class="cp"></span>
						<span class="cm">/* SRC is input from the capture inputs. */</span>
						<span class="cm">/* SRC channel 0 [2:0] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 * SRC channel 1 [6:4] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 * SRC channel 2 [10:8] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 * SRC channel 3 [14:12] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 * SRC channel 4 [18:16] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 * SRC channel 5 [22:20] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 * SRC channel 6 [26:24] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 * SRC channel 7 [30:28] -&gt; SPDIF Mixer/Router channel 0-7.</span>
<span class="cm">						 */</span>

<span class="cp">#define PLAYBACK_MUTE           0x65            </span><span class="cm">/* Unknown. While playing 0x0, while silent 0x00fc0000 */</span><span class="cp"></span>
						<span class="cm">/* SPDIF Mixer input control:</span>
<span class="cm">						 * Invert SRC to SPDIF Mixer [7-0] (One bit per channel)</span>
<span class="cm">						 * Invert Host to SPDIF Mixer [15:8] (One bit per channel)</span>
<span class="cm">						 * SRC to SPDIF Mixer disable [23:16] (One bit per channel)</span>
<span class="cm">						 * Host to SPDIF Mixer disable [31:24] (One bit per channel)</span>
<span class="cm">						 */</span>
<span class="cp">#define PLAYBACK_VOLUME1        0x66            </span><span class="cm">/* Playback SPDIF volume per channel. Set to the same PLAYBACK_VOLUME(0x6a) */</span><span class="cp"></span>
						<span class="cm">/* PLAYBACK_VOLUME1 must be set to 30303030 for SPDIF AC3 Playback */</span>
						<span class="cm">/* SPDIF mixer input volume. 0=12dB, 0x30=0dB, 0xFE=-51.5dB, 0xff=Mute */</span>
						<span class="cm">/* One register for each of the 4 stereo streams. */</span>
						<span class="cm">/* SRC Right volume [7:0]</span>
<span class="cm">						 * SRC Left  volume [15:8]</span>
<span class="cm">						 * Host Right volume [23:16]</span>
<span class="cm">						 * Host Left  volume [31:24]</span>
<span class="cm">						 */</span>
<span class="cp">#define CAPTURE_ROUTING1        0x67            </span><span class="cm">/* Capture Routing. Default 0x32765410 */</span><span class="cp"></span>
						<span class="cm">/* Similar to register 0x63, except that the destination is the I2S mixer instead of the SPDIF mixer. I.E. Outputs to the Analog outputs instead of SPDIF. */</span>
<span class="cp">#define CAPTURE_ROUTING2        0x68            </span><span class="cm">/* Unknown Routing. Default 0x76767676 */</span><span class="cp"></span>
						<span class="cm">/* Similar to register 0x64, except that the destination is the I2S mixer instead of the SPDIF mixer. I.E. Outputs to the Analog outputs instead of SPDIF. */</span>
<span class="cp">#define CAPTURE_MUTE            0x69            </span><span class="cm">/* Unknown. While capturing 0x0, while silent 0x00fc0000 */</span><span class="cp"></span>
						<span class="cm">/* Similar to register 0x65, except that the destination is the I2S mixer instead of the SPDIF mixer. I.E. Outputs to the Analog outputs instead of SPDIF. */</span>
<span class="cp">#define PLAYBACK_VOLUME2        0x6a            </span><span class="cm">/* Playback Analog volume per channel. Does not effect AC3 output */</span><span class="cp"></span>
						<span class="cm">/* Similar to register 0x66, except that the destination is the I2S mixer instead of the SPDIF mixer. I.E. Outputs to the Analog outputs instead of SPDIF. */</span>
<span class="cp">#define UNKNOWN6b               0x6b            </span><span class="cm">/* Unknown. Readonly. Default 00400000 00400000 00400000 00400000 */</span><span class="cp"></span>
<span class="cp">#define MIDI_UART_A_DATA		0x6c            </span><span class="cm">/* Midi Uart A Data */</span><span class="cp"></span>
<span class="cp">#define MIDI_UART_A_CMD		0x6d            </span><span class="cm">/* Midi Uart A Command/Status */</span><span class="cp"></span>
<span class="cp">#define MIDI_UART_B_DATA		0x6e            </span><span class="cm">/* Midi Uart B Data (currently unused) */</span><span class="cp"></span>
<span class="cp">#define MIDI_UART_B_CMD		0x6f            </span><span class="cm">/* Midi Uart B Command/Status (currently unused) */</span><span class="cp"></span>

<span class="cm">/* unique channel identifier for midi-&gt;channel */</span>

<span class="cp">#define CA0106_MIDI_CHAN_A		0x1</span>
<span class="cp">#define CA0106_MIDI_CHAN_B		0x2</span>

<span class="cm">/* from mpu401 */</span>

<span class="cp">#define CA0106_MIDI_INPUT_AVAIL 	0x80</span>
<span class="cp">#define CA0106_MIDI_OUTPUT_READY	0x40</span>
<span class="cp">#define CA0106_MPU401_RESET		0xff</span>
<span class="cp">#define CA0106_MPU401_ENTER_UART	0x3f</span>
<span class="cp">#define CA0106_MPU401_ACK		0xfe</span>

<span class="cp">#define SAMPLE_RATE_TRACKER_STATUS 0x70         </span><span class="cm">/* Readonly. Default 00108000 00108000 00500000 00500000 */</span><span class="cp"></span>
						<span class="cm">/* Estimated sample rate [19:0] Relative to 48kHz. 0x8000 =  1.0</span>
<span class="cm">						 * Rate Locked [20]</span>
<span class="cm">						 * SPDIF Locked [21] For SPDIF channel only.</span>
<span class="cm">						 * Valid Audio [22] For SPDIF channel only.</span>
<span class="cm">						 */</span>
<span class="cp">#define CAPTURE_CONTROL         0x71            </span><span class="cm">/* Some sort of routing. default = 40c81000 30303030 30300000 00700000 */</span><span class="cp"></span>
						<span class="cm">/* Channel_id 0: 0x40c81000 must be changed to 0x40c80000 for SPDIF AC3 input or output. */</span>
						<span class="cm">/* Channel_id 1: 0xffffffff(mute) 0x30303030(max) controls CAPTURE feedback into PLAYBACK. */</span>
						<span class="cm">/* Sample rate output control register Channel=0</span>
<span class="cm">						 * Sample output rate [1:0] (0=48kHz, 1=44.1kHz, 2=96kHz, 3=192Khz)</span>
<span class="cm">						 * Sample input rate [3:2] (0=48kHz, 1=Not available, 2=96kHz, 3=192Khz)</span>
<span class="cm">						 * SRC input source select [4] 0=Audio from digital mixer, 1=Audio from analog source.</span>
<span class="cm">						 * Record rate [9:8] (0=48kHz, 1=Not available, 2=96kHz, 3=192Khz)</span>
<span class="cm">						 * Record mixer output enable [12:10] </span>
<span class="cm">						 * I2S input rate master mode [15:14] (0=48kHz, 1=44.1kHz, 2=96kHz, 3=192Khz)</span>
<span class="cm">						 * I2S output rate [17:16] (0=48kHz, 1=44.1kHz, 2=96kHz, 3=192Khz)</span>
<span class="cm">						 * I2S output source select [18] (0=Audio from host, 1=Audio from SRC)</span>
<span class="cm">						 * Record mixer I2S enable [20:19] (enable/disable i2sin1 and i2sin0)</span>
<span class="cm">						 * I2S output master clock select [21] (0=256*I2S output rate, 1=512*I2S output rate.)</span>
<span class="cm">						 * I2S input master clock select [22] (0=256*I2S input rate, 1=512*I2S input rate.)</span>
<span class="cm">						 * I2S input mode [23] (0=Slave, 1=Master)</span>
<span class="cm">						 * SPDIF output rate [25:24] (0=48kHz, 1=44.1kHz, 2=96kHz, 3=192Khz)</span>
<span class="cm">						 * SPDIF output source select [26] (0=host, 1=SRC)</span>
<span class="cm">						 * Not used [27]</span>
<span class="cm">						 * Record Source 0 input [29:28] (0=SPDIF in, 1=I2S in, 2=AC97 Mic, 3=AC97 PCM)</span>
<span class="cm">						 * Record Source 1 input [31:30] (0=SPDIF in, 1=I2S in, 2=AC97 Mic, 3=AC97 PCM)</span>
<span class="cm">						 */</span> 
						<span class="cm">/* Sample rate output control register Channel=1</span>
<span class="cm">						 * I2S Input 0 volume Right [7:0]</span>
<span class="cm">						 * I2S Input 0 volume Left [15:8]</span>
<span class="cm">						 * I2S Input 1 volume Right [23:16]</span>
<span class="cm">						 * I2S Input 1 volume Left [31:24]</span>
<span class="cm">						 */</span>
						<span class="cm">/* Sample rate output control register Channel=2</span>
<span class="cm">						 * SPDIF Input volume Right [23:16]</span>
<span class="cm">						 * SPDIF Input volume Left [31:24]</span>
<span class="cm">						 */</span>
						<span class="cm">/* Sample rate output control register Channel=3</span>
<span class="cm">						 * No used</span>
<span class="cm">						 */</span>
<span class="cp">#define SPDIF_SELECT2           0x72            </span><span class="cm">/* Some sort of routing. Channel_id 0 only. default = 0x0f0f003f. Analog 0x000b0000, Digital 0x0b000000 */</span><span class="cp"></span>
<span class="cp">#define ROUTING2_FRONT_MASK     0x00010000      </span><span class="cm">/* Enable for Front speakers. */</span><span class="cp"></span>
<span class="cp">#define ROUTING2_CENTER_LFE_MASK 0x00020000     </span><span class="cm">/* Enable for Center/LFE speakers. */</span><span class="cp"></span>
<span class="cp">#define ROUTING2_REAR_MASK      0x00080000      </span><span class="cm">/* Enable for Rear speakers. */</span><span class="cp"></span>
						<span class="cm">/* Audio output control</span>
<span class="cm">						 * AC97 output enable [5:0]</span>
<span class="cm">						 * I2S output enable [19:16]</span>
<span class="cm">						 * SPDIF output enable [27:24]</span>
<span class="cm">						 */</span> 
<span class="cp">#define UNKNOWN73               0x73            </span><span class="cm">/* Unknown. Readonly. Default 0x0 */</span><span class="cp"></span>
<span class="cp">#define CHIP_VERSION            0x74            </span><span class="cm">/* P17 Chip version. Channel_id 0 only. Default 00000071 */</span><span class="cp"></span>
<span class="cp">#define EXTENDED_INT_MASK       0x75            </span><span class="cm">/* Used by both playback and capture interrupt handler */</span><span class="cp"></span>
						<span class="cm">/* Sets which Interrupts are enabled. */</span>
						<span class="cm">/* 0x00000001 = Half period. Playback.</span>
<span class="cm">						 * 0x00000010 = Full period. Playback.</span>
<span class="cm">						 * 0x00000100 = Half buffer. Playback.</span>
<span class="cm">						 * 0x00001000 = Full buffer. Playback.</span>
<span class="cm">						 * 0x00010000 = Half buffer. Capture.</span>
<span class="cm">						 * 0x00100000 = Full buffer. Capture.</span>
<span class="cm">						 * Capture can only do 2 periods.</span>
<span class="cm">						 * 0x01000000 = End audio. Playback.</span>
<span class="cm">						 * 0x40000000 = Half buffer Playback,Caputre xrun.</span>
<span class="cm">						 * 0x80000000 = Full buffer Playback,Caputre xrun.</span>
<span class="cm">						 */</span>
<span class="cp">#define EXTENDED_INT            0x76            </span><span class="cm">/* Used by both playback and capture interrupt handler */</span><span class="cp"></span>
						<span class="cm">/* Shows which interrupts are active at the moment. */</span>
						<span class="cm">/* Same bit layout as EXTENDED_INT_MASK */</span>
<span class="cp">#define COUNTER77               0x77		</span><span class="cm">/* Counter range 0 to 0x3fffff, 192000 counts per second. */</span><span class="cp"></span>
<span class="cp">#define COUNTER78               0x78		</span><span class="cm">/* Counter range 0 to 0x3fffff, 44100 counts per second. */</span><span class="cp"></span>
<span class="cp">#define EXTENDED_INT_TIMER      0x79            </span><span class="cm">/* Channel_id 0 only. Used by both playback and capture interrupt handler */</span><span class="cp"></span>
						<span class="cm">/* Causes interrupts based on timer intervals. */</span>
<span class="cp">#define SPI			0x7a		</span><span class="cm">/* SPI: Serial Interface Register */</span><span class="cp"></span>
<span class="cp">#define I2C_A			0x7b		</span><span class="cm">/* I2C Address. 32 bit */</span><span class="cp"></span>
<span class="cp">#define I2C_D0			0x7c		</span><span class="cm">/* I2C Data Port 0. 32 bit */</span><span class="cp"></span>
<span class="cp">#define I2C_D1			0x7d		</span><span class="cm">/* I2C Data Port 1. 32 bit */</span><span class="cp"></span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>I2C values</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define I2C_A_ADC_ADD_MASK	0x000000fe	</span><span class="c1">//The address is a 7 bit address</span>
<span class="cp">#define I2C_A_ADC_RW_MASK	0x00000001	</span><span class="c1">//bit mask for R/W</span>
<span class="cp">#define I2C_A_ADC_TRANS_MASK	0x00000010  	</span><span class="c1">//Bit mask for I2c address DAC value</span>
<span class="cp">#define I2C_A_ADC_ABORT_MASK	0x00000020	</span><span class="c1">//Bit mask for I2C transaction abort flag</span>
<span class="cp">#define I2C_A_ADC_LAST_MASK	0x00000040	</span><span class="c1">//Bit mask for Last word transaction</span>
<span class="cp">#define I2C_A_ADC_BYTE_MASK	0x00000080	</span><span class="c1">//Bit mask for Byte Mode</span>

<span class="cp">#define I2C_A_ADC_ADD		0x00000034	</span><span class="c1">//This is the Device address for ADC </span>
<span class="cp">#define I2C_A_ADC_READ		0x00000001	</span><span class="c1">//To perform a read operation</span>
<span class="cp">#define I2C_A_ADC_START		0x00000100	</span><span class="c1">//Start I2C transaction</span>
<span class="cp">#define I2C_A_ADC_ABORT		0x00000200	</span><span class="c1">//I2C transaction abort</span>
<span class="cp">#define I2C_A_ADC_LAST		0x00000400	</span><span class="c1">//I2C last transaction</span>
<span class="cp">#define I2C_A_ADC_BYTE		0x00000800	</span><span class="c1">//I2C one byte mode</span>

<span class="cp">#define I2C_D_ADC_REG_MASK	0xfe000000  	</span><span class="c1">//ADC address register </span>
<span class="cp">#define I2C_D_ADC_DAT_MASK	0x01ff0000  	</span><span class="c1">//ADC data register</span>

<span class="cp">#define ADC_TIMEOUT		0x00000007	</span><span class="c1">//ADC Timeout Clock Disable</span>
<span class="cp">#define ADC_IFC_CTRL		0x0000000b	</span><span class="c1">//ADC Interface Control</span>
<span class="cp">#define ADC_MASTER		0x0000000c	</span><span class="c1">//ADC Master Mode Control</span>
<span class="cp">#define ADC_POWER		0x0000000d	</span><span class="c1">//ADC PowerDown Control</span>
<span class="cp">#define ADC_ATTEN_ADCL		0x0000000e	</span><span class="c1">//ADC Attenuation ADCL</span>
<span class="cp">#define ADC_ATTEN_ADCR		0x0000000f	</span><span class="c1">//ADC Attenuation ADCR</span>
<span class="cp">#define ADC_ALC_CTRL1		0x00000010	</span><span class="c1">//ADC ALC Control 1</span>
<span class="cp">#define ADC_ALC_CTRL2		0x00000011	</span><span class="c1">//ADC ALC Control 2</span>
<span class="cp">#define ADC_ALC_CTRL3		0x00000012	</span><span class="c1">//ADC ALC Control 3</span>
<span class="cp">#define ADC_NOISE_CTRL		0x00000013	</span><span class="c1">//ADC Noise Gate Control</span>
<span class="cp">#define ADC_LIMIT_CTRL		0x00000014	</span><span class="c1">//ADC Limiter Control</span>
<span class="cp">#define ADC_MUX			0x00000015  	</span><span class="c1">//ADC Mux offset</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/* FIXME: Not tested yet. */</span>
<span class="c">#define ADC_GAIN_MASK		0x000000ff	//Mask for ADC Gain</span>
<span class="c">#define ADC_ZERODB		0x000000cf	//Value to set ADC to 0dB</span>
<span class="c">#define ADC_MUTE_MASK		0x000000c0	//Mask for ADC mute</span>
<span class="c">#define ADC_MUTE		0x000000c0	//Value to mute ADC</span>
<span class="c">#define ADC_OSR			0x00000008	//Mask for ADC oversample rate select</span>
<span class="c">#define ADC_TIMEOUT_DISABLE	0x00000008	//Value and mask to disable Timeout clock</span>
<span class="c">#define ADC_HPF_DISABLE		0x00000100	//Value and mask to disable High pass filter</span>
<span class="c">#define ADC_TRANWIN_MASK	0x00000070	//Mask for Length of Transient Window</span>
<span class="cp">#endif</span>

<span class="cp">#define ADC_MUX_MASK		0x0000000f	</span><span class="c1">//Mask for ADC Mux</span>
<span class="cp">#define ADC_MUX_PHONE		0x00000001	</span><span class="c1">//Value to select TAD at ADC Mux (Not used)</span>
<span class="cp">#define ADC_MUX_MIC		0x00000002	</span><span class="c1">//Value to select Mic at ADC Mux</span>
<span class="cp">#define ADC_MUX_LINEIN		0x00000004	</span><span class="c1">//Value to select LineIn at ADC Mux</span>
<span class="cp">#define ADC_MUX_AUX		0x00000008	</span><span class="c1">//Value to select Aux at ADC Mux</span>

<span class="cp">#define SET_CHANNEL 0  </span><span class="cm">/* Testing channel outputs 0=Front, 1=Center/LFE, 2=Unknown, 3=Rear */</span><span class="cp"></span>
<span class="cp">#define PCM_FRONT_CHANNEL 0</span>
<span class="cp">#define PCM_REAR_CHANNEL 1</span>
<span class="cp">#define PCM_CENTER_LFE_CHANNEL 2</span>
<span class="cp">#define PCM_UNKNOWN_CHANNEL 3</span>
<span class="cp">#define CONTROL_FRONT_CHANNEL 0</span>
<span class="cp">#define CONTROL_REAR_CHANNEL 3</span>
<span class="cp">#define CONTROL_CENTER_LFE_CHANNEL 1</span>
<span class="cp">#define CONTROL_UNKNOWN_CHANNEL 2</span>


<span class="cm">/* Based on WM8768 Datasheet Rev 4.2 page 32 */</span>
<span class="cp">#define SPI_REG_MASK	0x1ff	</span><span class="cm">/* 16-bit SPI writes have a 7-bit address */</span><span class="cp"></span>
<span class="cp">#define SPI_REG_SHIFT	9	</span><span class="cm">/* followed by 9 bits of data */</span><span class="cp"></span>

<span class="cp">#define SPI_LDA1_REG		0	</span><span class="cm">/* digital attenuation */</span><span class="cp"></span>
<span class="cp">#define SPI_RDA1_REG		1</span>
<span class="cp">#define SPI_LDA2_REG		4</span>
<span class="cp">#define SPI_RDA2_REG		5</span>
<span class="cp">#define SPI_LDA3_REG		6</span>
<span class="cp">#define SPI_RDA3_REG		7</span>
<span class="cp">#define SPI_LDA4_REG		13</span>
<span class="cp">#define SPI_RDA4_REG		14</span>
<span class="cp">#define SPI_MASTDA_REG		8</span>

<span class="cp">#define SPI_DA_BIT_UPDATE	(1&lt;&lt;8)	</span><span class="cm">/* update attenuation values */</span><span class="cp"></span>
<span class="cp">#define SPI_DA_BIT_0dB		0xff	</span><span class="cm">/* 0 dB */</span><span class="cp"></span>
<span class="cp">#define SPI_DA_BIT_infdB	0x00	</span><span class="cm">/* inf dB attenuation (mute) */</span><span class="cp"></span>

<span class="cp">#define SPI_PL_REG		2</span>
<span class="cp">#define SPI_PL_BIT_L_M		(0&lt;&lt;5)	</span><span class="cm">/* left channel = mute */</span><span class="cp"></span>
<span class="cp">#define SPI_PL_BIT_L_L		(1&lt;&lt;5)	</span><span class="cm">/* left channel = left */</span><span class="cp"></span>
<span class="cp">#define SPI_PL_BIT_L_R		(2&lt;&lt;5)	</span><span class="cm">/* left channel = right */</span><span class="cp"></span>
<span class="cp">#define SPI_PL_BIT_L_C		(3&lt;&lt;5)	</span><span class="cm">/* left channel = (L+R)/2 */</span><span class="cp"></span>
<span class="cp">#define SPI_PL_BIT_R_M		(0&lt;&lt;7)	</span><span class="cm">/* right channel = mute */</span><span class="cp"></span>
<span class="cp">#define SPI_PL_BIT_R_L		(1&lt;&lt;7)	</span><span class="cm">/* right channel = left */</span><span class="cp"></span>
<span class="cp">#define SPI_PL_BIT_R_R		(2&lt;&lt;7)	</span><span class="cm">/* right channel = right */</span><span class="cp"></span>
<span class="cp">#define SPI_PL_BIT_R_C		(3&lt;&lt;7)	</span><span class="cm">/* right channel = (L+R)/2 */</span><span class="cp"></span>
<span class="cp">#define SPI_IZD_REG		2</span>
<span class="cp">#define SPI_IZD_BIT		(1&lt;&lt;4)	</span><span class="cm">/* infinite zero detect */</span><span class="cp"></span>

<span class="cp">#define SPI_FMT_REG		3</span>
<span class="cp">#define SPI_FMT_BIT_RJ		(0&lt;&lt;0)	</span><span class="cm">/* right justified mode */</span><span class="cp"></span>
<span class="cp">#define SPI_FMT_BIT_LJ		(1&lt;&lt;0)	</span><span class="cm">/* left justified mode */</span><span class="cp"></span>
<span class="cp">#define SPI_FMT_BIT_I2S		(2&lt;&lt;0)	</span><span class="cm">/* I2S mode */</span><span class="cp"></span>
<span class="cp">#define SPI_FMT_BIT_DSP		(3&lt;&lt;0)	</span><span class="cm">/* DSP Modes A or B */</span><span class="cp"></span>
<span class="cp">#define SPI_LRP_REG		3</span>
<span class="cp">#define SPI_LRP_BIT		(1&lt;&lt;2)	</span><span class="cm">/* invert LRCLK polarity */</span><span class="cp"></span>
<span class="cp">#define SPI_BCP_REG		3</span>
<span class="cp">#define SPI_BCP_BIT		(1&lt;&lt;3)	</span><span class="cm">/* invert BCLK polarity */</span><span class="cp"></span>
<span class="cp">#define SPI_IWL_REG		3</span>
<span class="cp">#define SPI_IWL_BIT_16		(0&lt;&lt;4)	</span><span class="cm">/* 16-bit world length */</span><span class="cp"></span>
<span class="cp">#define SPI_IWL_BIT_20		(1&lt;&lt;4)	</span><span class="cm">/* 20-bit world length */</span><span class="cp"></span>
<span class="cp">#define SPI_IWL_BIT_24		(2&lt;&lt;4)	</span><span class="cm">/* 24-bit world length */</span><span class="cp"></span>
<span class="cp">#define SPI_IWL_BIT_32		(3&lt;&lt;4)	</span><span class="cm">/* 32-bit world length */</span><span class="cp"></span>

<span class="cp">#define SPI_MS_REG		10</span>
<span class="cp">#define SPI_MS_BIT		(1&lt;&lt;5)	</span><span class="cm">/* master mode */</span><span class="cp"></span>
<span class="cp">#define SPI_RATE_REG		10	</span><span class="cm">/* only applies in master mode */</span><span class="cp"></span>
<span class="cp">#define SPI_RATE_BIT_128	(0&lt;&lt;6)	</span><span class="cm">/* MCLK = LRCLK * 128 */</span><span class="cp"></span>
<span class="cp">#define SPI_RATE_BIT_192	(1&lt;&lt;6)</span>
<span class="cp">#define SPI_RATE_BIT_256	(2&lt;&lt;6)</span>
<span class="cp">#define SPI_RATE_BIT_384	(3&lt;&lt;6)</span>
<span class="cp">#define SPI_RATE_BIT_512	(4&lt;&lt;6)</span>
<span class="cp">#define SPI_RATE_BIT_768	(5&lt;&lt;6)</span>

<span class="cm">/* They really do label the bit for the 4th channel &quot;4&quot; and not &quot;3&quot; */</span>
<span class="cp">#define SPI_DMUTE0_REG		9</span>
<span class="cp">#define SPI_DMUTE1_REG		9</span>
<span class="cp">#define SPI_DMUTE2_REG		9</span>
<span class="cp">#define SPI_DMUTE4_REG		15</span>
<span class="cp">#define SPI_DMUTE0_BIT		(1&lt;&lt;3)</span>
<span class="cp">#define SPI_DMUTE1_BIT		(1&lt;&lt;4)</span>
<span class="cp">#define SPI_DMUTE2_BIT		(1&lt;&lt;5)</span>
<span class="cp">#define SPI_DMUTE4_BIT		(1&lt;&lt;2)</span>

<span class="cp">#define SPI_PHASE0_REG		3</span>
<span class="cp">#define SPI_PHASE1_REG		3</span>
<span class="cp">#define SPI_PHASE2_REG		3</span>
<span class="cp">#define SPI_PHASE4_REG		15</span>
<span class="cp">#define SPI_PHASE0_BIT		(1&lt;&lt;6)</span>
<span class="cp">#define SPI_PHASE1_BIT		(1&lt;&lt;7)</span>
<span class="cp">#define SPI_PHASE2_BIT		(1&lt;&lt;8)</span>
<span class="cp">#define SPI_PHASE4_BIT		(1&lt;&lt;3)</span>

<span class="cp">#define SPI_PDWN_REG		2	</span><span class="cm">/* power down all DACs */</span><span class="cp"></span>
<span class="cp">#define SPI_PDWN_BIT		(1&lt;&lt;2)</span>
<span class="cp">#define SPI_DACD0_REG		10	</span><span class="cm">/* power down individual DACs */</span><span class="cp"></span>
<span class="cp">#define SPI_DACD1_REG		10</span>
<span class="cp">#define SPI_DACD2_REG		10</span>
<span class="cp">#define SPI_DACD4_REG		15</span>
<span class="cp">#define SPI_DACD0_BIT		(1&lt;&lt;1)</span>
<span class="cp">#define SPI_DACD1_BIT		(1&lt;&lt;2)</span>
<span class="cp">#define SPI_DACD2_BIT		(1&lt;&lt;3)</span>
<span class="cp">#define SPI_DACD4_BIT		(1&lt;&lt;0)	</span><span class="cm">/* datasheet error says it&#39;s 1 */</span><span class="cp"></span>

<span class="cp">#define SPI_PWRDNALL_REG	10	</span><span class="cm">/* power down everything */</span><span class="cp"></span>
<span class="cp">#define SPI_PWRDNALL_BIT	(1&lt;&lt;4)</span>

<span class="cp">#include &quot;ca_midi.h&quot;</span>

<span class="k">struct</span> <span class="n">snd_ca0106</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">snd_ca0106_channel</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_ca0106</span> <span class="o">*</span><span class="n">emu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">interrupt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_ca0106</span> <span class="o">*</span><span class="n">emu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_ca0106_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_ca0106_pcm</span> <span class="o">*</span><span class="n">epcm</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_ca0106_pcm</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_ca0106</span> <span class="o">*</span><span class="n">emu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">channel_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">running</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_ca0106_details</span> <span class="p">{</span>
        <span class="n">u32</span> <span class="n">serial</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ac97</span><span class="p">;</span>	<span class="cm">/* ac97 = 0 -&gt; Select MIC, Line in, TAD in, AUX in.</span>
<span class="cm">			   ac97 = 1 -&gt; Default to AC97 in. */</span>
	<span class="kt">int</span> <span class="n">gpio_type</span><span class="p">;</span>	<span class="cm">/* gpio_type = 1 -&gt; shared mic-in/line-in</span>
<span class="cm">			   gpio_type = 2 -&gt; shared side-out/line-in. */</span>
	<span class="kt">int</span> <span class="n">i2c_adc</span><span class="p">;</span>	<span class="cm">/* with i2c_adc=1, the driver adds some capture volume</span>
<span class="cm">			   controls, phone, mic, line-in and aux. */</span>
	<span class="n">u16</span> <span class="n">spi_dac</span><span class="p">;</span>	<span class="cm">/* spi_dac = 0 -&gt; no spi interface for DACs</span>
<span class="cm">			   spi_dac = 0x&lt;front&gt;&lt;rear&gt;&lt;center-lfe&gt;&lt;side&gt;</span>
<span class="cm">			   -&gt; specifies DAC id for each channel pair. */</span>
<span class="p">};</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>definition of the chip-specific record</p></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">snd_ca0106</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_ca0106_details</span> <span class="o">*</span><span class="n">details</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res_port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">serial</span><span class="p">;</span>            <span class="cm">/* serial number */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">model</span><span class="p">;</span>		<span class="cm">/* subsystem id */</span>

	<span class="n">spinlock_t</span> <span class="n">emu_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">snd_ac97</span> <span class="o">*</span><span class="n">ac97</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm</span> <span class="o">*</span><span class="n">pcm</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">snd_ca0106_channel</span> <span class="n">playback_channels</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">snd_ca0106_channel</span> <span class="n">capture_channels</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">spdif_bits</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>             <span class="cm">/* s/pdif out default setup */</span>
	<span class="n">u32</span> <span class="n">spdif_str_bits</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>         <span class="cm">/* s/pdif out per-stream setup */</span>
	<span class="kt">int</span> <span class="n">spdif_enable</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">capture_source</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i2c_capture_source</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">i2c_capture_volume</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">capture_mic_line_in</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">snd_dma_buffer</span> <span class="n">buffer</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">snd_ca_midi</span> <span class="n">midi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_ca_midi</span> <span class="n">midi2</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">spi_dac_reg</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cp">#define NUM_SAVED_VOLUMES	9</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">saved_vol</span><span class="p">[</span><span class="n">NUM_SAVED_VOLUMES</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">snd_ca0106_mixer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_ca0106</span> <span class="o">*</span><span class="n">emu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">snd_ca0106_proc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_ca0106</span> <span class="o">*</span> <span class="n">emu</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">snd_ca0106_ptr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_ca0106</span> <span class="o">*</span> <span class="n">emu</span><span class="p">,</span> 
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> 
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chn</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">snd_ca0106_ptr_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_ca0106</span> <span class="o">*</span><span class="n">emu</span><span class="p">,</span> 
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> 
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chn</span><span class="p">,</span> 
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">snd_ca0106_i2c_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_ca0106</span> <span class="o">*</span><span class="n">emu</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">snd_ca0106_spi_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_ca0106</span> <span class="o">*</span> <span class="n">emu</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="kt">void</span> <span class="n">snd_ca0106_mixer_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_ca0106</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">snd_ca0106_mixer_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_ca0106</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define snd_ca0106_mixer_suspend(chip)	do { } while (0)</span>
<span class="cp">#define snd_ca0106_mixer_resume(chip)	do { } while (0)</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
