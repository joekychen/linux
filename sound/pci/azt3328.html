<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › pci › azt3328.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>azt3328.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*  azt3328.c - driver for Aztech AZF3328 based soundcards (e.g. PCI168).</span>
<span class="cm"> *  Copyright (C) 2002, 2005 - 2011 by Andreas Mohr &lt;andi AT lisas.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Framework borrowed from Bart Hartgers&#39;s als4000.c.</span>
<span class="cm"> *  Driver developed on PCI168 AP(W) version (PCI rev. 10, subsystem ID 1801),</span>
<span class="cm"> *  found in a Fujitsu-Siemens PC (&quot;Cordant&quot;, aluminum case).</span>
<span class="cm"> *  Other versions are:</span>
<span class="cm"> *  PCI168 A(W), sub ID 1800</span>
<span class="cm"> *  PCI168 A/AP, sub ID 8000</span>
<span class="cm"> *  Please give me feedback in case you try my driver with one of these!!</span>
<span class="cm"> *</span>
<span class="cm"> *  Keywords: Windows XP Vista 168nt4-125.zip 168win95-125.zip PCI 168 download</span>
<span class="cm"> *  (XP/Vista do not support this card at all but every Linux distribution</span>
<span class="cm"> *   has very good support out of the box;</span>
<span class="cm"> *   just to make sure that the right people hit this and get to know that,</span>
<span class="cm"> *   despite the high level of Internet ignorance - as usual :-P -</span>
<span class="cm"> *   about very good support for this card - on Linux!)</span>
<span class="cm"> *</span>
<span class="cm"> * GPL LICENSE</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>

<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * NOTES</span>
<span class="cm"> *  Since Aztech does not provide any chipset documentation,</span>
<span class="cm"> *  even on repeated request to various addresses,</span>
<span class="cm"> *  and the answer that was finally given was negative</span>
<span class="cm"> *  (and I was stupid enough to manage to get hold of a PCI168 soundcard</span>
<span class="cm"> *  in the first place &gt;:-P}),</span>
<span class="cm"> *  I was forced to base this driver on reverse engineering</span>
<span class="cm"> *  (3 weeks&#39; worth of evenings filled with driver work).</span>
<span class="cm"> *  (and no, I did NOT go the easy way: to pick up a SB PCI128 for 9 Euros)</span>
<span class="cm"> *</span>
<span class="cm"> *  It is quite likely that the AZF3328 chip is the PCI cousin of the</span>
<span class="cm"> *  AZF3318 (&quot;azt1020 pnp&quot;, &quot;MM Pro 16&quot;) ISA chip, given very similar specs.</span>
<span class="cm"> *</span>
<span class="cm"> *  The AZF3328 chip (note: AZF3328, *not* AZT3328, that&#39;s just the driver name</span>
<span class="cm"> *  for compatibility reasons) from Azfin (joint-venture of Aztech and Fincitec,</span>
<span class="cm"> *  Fincitec acquired by National Semiconductor in 2002, together with the</span>
<span class="cm"> *  Fincitec-related company ARSmikro) has the following features:</span>
<span class="cm"> *</span>
<span class="cm"> *  - compatibility &amp; compliance:</span>
<span class="cm"> *    - Microsoft PC 97 (&quot;PC 97 Hardware Design Guide&quot;,</span>
<span class="cm"> *                       http://www.microsoft.com/whdc/archive/pcguides.mspx)</span>
<span class="cm"> *    - Microsoft PC 98 Baseline Audio</span>
<span class="cm"> *    - MPU401 UART</span>
<span class="cm"> *    - Sound Blaster Emulation (DOS Box)</span>
<span class="cm"> *  - builtin AC97 conformant codec (SNR over 80dB)</span>
<span class="cm"> *    Note that &quot;conformant&quot; != &quot;compliant&quot;!! this chip&#39;s mixer register layout</span>
<span class="cm"> *    *differs* from the standard AC97 layout:</span>
<span class="cm"> *    they chose to not implement the headphone register (which is not a</span>
<span class="cm"> *    problem since it&#39;s merely optional), yet when doing this, they committed</span>
<span class="cm"> *    the grave sin of letting other registers follow immediately instead of</span>
<span class="cm"> *    keeping a headphone dummy register, thereby shifting the mixer register</span>
<span class="cm"> *    addresses illegally. So far unfortunately it looks like the very flexible</span>
<span class="cm"> *    ALSA AC97 support is still not enough to easily compensate for such a</span>
<span class="cm"> *    grave layout violation despite all tweaks and quirks mechanisms it offers.</span>
<span class="cm"> *    Well, not quite: now ac97 layer is much improved (bus-specific ops!),</span>
<span class="cm"> *    thus I was able to implement support - it&#39;s actually working quite well.</span>
<span class="cm"> *    An interesting item might be Aztech AMR 2800-W, since it&#39;s an AC97</span>
<span class="cm"> *    modem card which might reveal the Aztech-specific codec ID which</span>
<span class="cm"> *    we might want to pretend, too. Dito PCI168&#39;s brother, PCI368,</span>
<span class="cm"> *    where the advertising datasheet says it&#39;s AC97-based and has a</span>
<span class="cm"> *    Digital Enhanced Game Port.</span>
<span class="cm"> *  - builtin genuine OPL3 - verified to work fine, 20080506</span>
<span class="cm"> *  - full duplex 16bit playback/record at independent sampling rate</span>
<span class="cm"> *  - MPU401 (+ legacy address support, claimed by one official spec sheet)</span>
<span class="cm"> *    FIXME: how to enable legacy addr??</span>
<span class="cm"> *  - game port (legacy address support)</span>
<span class="cm"> *  - builtin DirectInput support, helps reduce CPU overhead (interrupt-driven</span>
<span class="cm"> *    features supported). - See common term &quot;Digital Enhanced Game Port&quot;...</span>
<span class="cm"> *    (probably DirectInput 3.0 spec - confirm)</span>
<span class="cm"> *  - builtin 3D enhancement (said to be YAMAHA Ymersion)</span>
<span class="cm"> *  - built-in General DirectX timer having a 20 bits counter</span>
<span class="cm"> *    with 1us resolution (see below!)</span>
<span class="cm"> *  - I2S serial output port for external DAC</span>
<span class="cm"> *    [FIXME: 3.3V or 5V level? maximum rate is 66.2kHz right?]</span>
<span class="cm"> *  - supports 33MHz PCI spec 2.1, PCI power management 1.0, compliant with ACPI</span>
<span class="cm"> *  - supports hardware volume control</span>
<span class="cm"> *  - single chip low cost solution (128 pin QFP)</span>
<span class="cm"> *  - supports programmable Sub-vendor and Sub-system ID [24C02 SEEPROM chip]</span>
<span class="cm"> *    required for Microsoft&#39;s logo compliance (FIXME: where?)</span>
<span class="cm"> *    At least the Trident 4D Wave DX has one bit somewhere</span>
<span class="cm"> *    to enable writes to PCI subsystem VID registers, that should be it.</span>
<span class="cm"> *    This might easily be in extended PCI reg space, since PCI168 also has</span>
<span class="cm"> *    some custom data starting at 0x80. What kind of config settings</span>
<span class="cm"> *    are located in our extended PCI space anyway??</span>
<span class="cm"> *  - PCI168 AP(W) card: power amplifier with 4 Watts/channel at 4 Ohms</span>
<span class="cm"> *    [TDA1517P chip]</span>
<span class="cm"> *</span>
<span class="cm"> *  Note that this driver now is actually *better* than the Windows driver,</span>
<span class="cm"> *  since it additionally supports the card&#39;s 1MHz DirectX timer - just try</span>
<span class="cm"> *  the following snd-seq module parameters etc.:</span>
<span class="cm"> *  - options snd-seq seq_default_timer_class=2 seq_default_timer_sclass=0</span>
<span class="cm"> *    seq_default_timer_card=0 seq_client_load=1 seq_default_timer_device=0</span>
<span class="cm"> *    seq_default_timer_subdevice=0 seq_default_timer_resolution=1000000</span>
<span class="cm"> *  - &quot;timidity -iAv -B2,8 -Os -EFreverb=0&quot;</span>
<span class="cm"> *  - &quot;pmidi -p 128:0 jazz.mid&quot;</span>
<span class="cm"> *</span>
<span class="cm"> *  OPL3 hardware playback testing, try something like:</span>
<span class="cm"> *  cat /proc/asound/hwdep</span>
<span class="cm"> *  and</span>
<span class="cm"> *  aconnect -o</span>
<span class="cm"> *  Then use</span>
<span class="cm"> *  sbiload -Dhw:x,y --opl3 /usr/share/sounds/opl3/std.o3 ......./drums.o3</span>
<span class="cm"> *  where x,y is the xx-yy number as given in hwdep.</span>
<span class="cm"> *  Then try</span>
<span class="cm"> *  pmidi -p a:b jazz.mid</span>
<span class="cm"> *  where a:b is the client number plus 0 usually, as given by aconnect above.</span>
<span class="cm"> *  Oh, and make sure to unmute the FM mixer control (doh!)</span>
<span class="cm"> *  NOTE: power use during OPL3 playback is _VERY_ high (70W --&gt; 90W!)</span>
<span class="cm"> *  despite no CPU activity, possibly due to hindering ACPI idling somehow.</span>
<span class="cm"> *  Shouldn&#39;t be a problem of the AZF3328 chip itself, I&#39;d hope.</span>
<span class="cm"> *  Higher PCM / FM mixer levels seem to conflict (causes crackling),</span>
<span class="cm"> *  at least sometimes.   Maybe even use with hardware sequencer timer above :)</span>
<span class="cm"> *  adplay/adplug-utils might soon offer hardware-based OPL3 playback, too.</span>
<span class="cm"> *</span>
<span class="cm"> *  Certain PCI versions of this card are susceptible to DMA traffic underruns</span>
<span class="cm"> *  in some systems (resulting in sound crackling/clicking/popping),</span>
<span class="cm"> *  probably because they don&#39;t have a DMA FIFO buffer or so.</span>
<span class="cm"> *  Overview (PCI ID/PCI subID/PCI rev.):</span>
<span class="cm"> *  - no DMA crackling on SiS735: 0x50DC/0x1801/16</span>
<span class="cm"> *  - unknown performance: 0x50DC/0x1801/10</span>
<span class="cm"> *    (well, it&#39;s not bad on an Athlon 1800 with now very optimized IRQ handler)</span>
<span class="cm"> *</span>
<span class="cm"> *  Crackling happens with VIA chipsets or, in my case, an SiS735, which is</span>
<span class="cm"> *  supposed to be very fast and supposed to get rid of crackling much</span>
<span class="cm"> *  better than a VIA, yet ironically I still get crackling, like many other</span>
<span class="cm"> *  people with the same chipset.</span>
<span class="cm"> *  Possible remedies:</span>
<span class="cm"> *  - use speaker (amplifier) output instead of headphone output</span>
<span class="cm"> *    (in case crackling is due to overloaded output clipping)</span>
<span class="cm"> *  - plug card into a different PCI slot, preferably one that isn&#39;t shared</span>
<span class="cm"> *    too much (this helps a lot, but not completely!)</span>
<span class="cm"> *  - get rid of PCI VGA card, use AGP instead</span>
<span class="cm"> *  - upgrade or downgrade BIOS</span>
<span class="cm"> *  - fiddle with PCI latency settings (setpci -v -s BUSID latency_timer=XX)</span>
<span class="cm"> *    Not too helpful.</span>
<span class="cm"> *  - Disable ACPI/power management/&quot;Auto Detect RAM/PCI Clk&quot; in BIOS</span>
<span class="cm"> *</span>
<span class="cm"> * BUGS</span>
<span class="cm"> *  - full-duplex might *still* be problematic, however a recent test was fine</span>
<span class="cm"> *  - (non-bug) &quot;Bass/Treble or 3D settings don&#39;t work&quot; - they do get evaluated</span>
<span class="cm"> *    if you set PCM output switch to &quot;pre 3D&quot; instead of &quot;post 3D&quot;.</span>
<span class="cm"> *    If this can&#39;t be set, then get a mixer application that Isn&#39;t Stupid (tm)</span>
<span class="cm"> *    (e.g. kmix, gamix) - unfortunately several are!!</span>
<span class="cm"> *  - locking is not entirely clean, especially the audio stream activity</span>
<span class="cm"> *    ints --&gt; may be racy</span>
<span class="cm"> *  - an _unconnected_ secondary joystick at the gameport will be reported</span>
<span class="cm"> *    to be &quot;active&quot; (floating values, not precisely -1) due to the way we need</span>
<span class="cm"> *    to read the Digital Enhanced Game Port. Not sure whether it is fixable.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO</span>
<span class="cm"> *  - use PCI_VDEVICE</span>
<span class="cm"> *  - verify driver status on x86_64</span>
<span class="cm"> *  - test multi-card driver operation</span>
<span class="cm"> *  - (ab)use 1MHz DirectX timer as kernel clocksource</span>
<span class="cm"> *  - test MPU401 MIDI playback etc.</span>
<span class="cm"> *  - add more power micro-management (disable various units of the card</span>
<span class="cm"> *    as long as they&#39;re unused, to improve audio quality and save power).</span>
<span class="cm"> *    However this requires more I/O ports which I haven&#39;t figured out yet</span>
<span class="cm"> *    and which thus might not even exist...</span>
<span class="cm"> *    The standard suspend/resume functionality could probably make use of</span>
<span class="cm"> *    some improvement, too...</span>
<span class="cm"> *  - figure out what all unknown port bits are responsible for</span>
<span class="cm"> *  - figure out some cleverly evil scheme to possibly make ALSA AC97 code</span>
<span class="cm"> *    fully accept our quite incompatible &quot;&quot;AC97&quot;&quot; mixer and thus save some</span>
<span class="cm"> *    code (but I&#39;m not too optimistic that doing this is possible at all)</span>
<span class="cm"> *  - use MMIO (memory-mapped I/O)? Slightly faster access, e.g. for gameport.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt; </span><span class="cm">/* WARN_ONCE */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/gameport.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;sound/core.h&gt;</span>
<span class="cp">#include &lt;sound/control.h&gt;</span>
<span class="cp">#include &lt;sound/pcm.h&gt;</span>
<span class="cp">#include &lt;sound/rawmidi.h&gt;</span>
<span class="cp">#include &lt;sound/mpu401.h&gt;</span>
<span class="cp">#include &lt;sound/opl3.h&gt;</span>
<span class="cp">#include &lt;sound/initval.h&gt;</span>
<span class="cm">/*</span>
<span class="cm"> * Config switch, to use ALSA&#39;s AC97 layer instead of old custom mixer crap.</span>
<span class="cm"> * If the AC97 compatibility parts we needed to implement locally turn out</span>
<span class="cm"> * to work nicely, then remove the old implementation eventually.</span>
<span class="cm"> */</span>
<span class="cp">#define AZF_USE_AC97_LAYER 1</span>

<span class="cp">#ifdef AZF_USE_AC97_LAYER</span>
<span class="cp">#include &lt;sound/ac97_codec.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &quot;azt3328.h&quot;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Andreas Mohr &lt;andi AT lisas.de&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Aztech AZF3328 (PCI168)&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_SUPPORTED_DEVICE</span><span class="p">(</span><span class="s">&quot;{{Aztech,AZF3328}}&quot;</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_GAMEPORT) || (defined(MODULE) &amp;&amp; defined(CONFIG_GAMEPORT_MODULE))</span>
<span class="cp">#define SUPPORT_GAMEPORT 1</span>
<span class="cp">#endif</span>

<span class="cm">/* === Debug settings ===</span>
<span class="cm">  Further diagnostic functionality than the settings below</span>
<span class="cm">  does not need to be provided, since one can easily write a POSIX shell script</span>
<span class="cm">  to dump the card&#39;s I/O ports (those listed in lspci -v -v):</span>
<span class="cm">  dump()</span>
<span class="cm">  {</span>
<span class="cm">    local descr=$1; local addr=$2; local count=$3</span>

<span class="cm">    echo &quot;${descr}: ${count} @ ${addr}:&quot;</span>
<span class="cm">    dd if=/dev/port skip=`printf %d ${addr}` count=${count} bs=1 \</span>
<span class="cm">      2&gt;/dev/null| hexdump -C</span>
<span class="cm">  }</span>
<span class="cm">  and then use something like</span>
<span class="cm">  &quot;dump joy200 0x200 8&quot;, &quot;dump mpu388 0x388 4&quot;, &quot;dump joy 0xb400 8&quot;,</span>
<span class="cm">  &quot;dump codec00 0xa800 32&quot;, &quot;dump mixer 0xb800 64&quot;, &quot;dump synth 0xbc00 8&quot;,</span>
<span class="cm">  possibly within a &quot;while true; do ... sleep 1; done&quot; loop.</span>
<span class="cm">  Tweaking ports could be done using</span>
<span class="cm">  VALSTRING=&quot;`printf &quot;%02x&quot; $value`&quot;</span>
<span class="cm">  printf &quot;\x&quot;&quot;$VALSTRING&quot;|dd of=/dev/port seek=`printf %d ${addr}` bs=1 \</span>
<span class="cm">    2&gt;/dev/null</span>
<span class="cm">*/</span>

<span class="cp">#define DEBUG_MISC	0</span>
<span class="cp">#define DEBUG_CALLS	0</span>
<span class="cp">#define DEBUG_MIXER	0</span>
<span class="cp">#define DEBUG_CODEC	0</span>
<span class="cp">#define DEBUG_TIMER	0</span>
<span class="cp">#define DEBUG_GAME	0</span>
<span class="cp">#define DEBUG_PM	0</span>
<span class="cp">#define MIXER_TESTING	0</span>

<span class="cp">#if DEBUG_MISC</span>
<span class="cp">#define snd_azf3328_dbgmisc(format, args...) printk(KERN_DEBUG format, ##args)</span>
<span class="cp">#else</span>
<span class="cp">#define snd_azf3328_dbgmisc(format, args...)</span>
<span class="cp">#endif</span>

<span class="cp">#if DEBUG_CALLS</span>
<span class="cp">#define snd_azf3328_dbgcalls(format, args...) printk(format, ##args)</span>
<span class="cp">#define snd_azf3328_dbgcallenter() printk(KERN_DEBUG &quot;--&gt; %s\n&quot;, __func__)</span>
<span class="cp">#define snd_azf3328_dbgcallleave() printk(KERN_DEBUG &quot;&lt;-- %s\n&quot;, __func__)</span>
<span class="cp">#else</span>
<span class="cp">#define snd_azf3328_dbgcalls(format, args...)</span>
<span class="cp">#define snd_azf3328_dbgcallenter()</span>
<span class="cp">#define snd_azf3328_dbgcallleave()</span>
<span class="cp">#endif</span>

<span class="cp">#if DEBUG_MIXER</span>
<span class="cp">#define snd_azf3328_dbgmixer(format, args...) printk(KERN_DEBUG format, ##args)</span>
<span class="cp">#else</span>
<span class="cp">#define snd_azf3328_dbgmixer(format, args...)</span>
<span class="cp">#endif</span>

<span class="cp">#if DEBUG_CODEC</span>
<span class="cp">#define snd_azf3328_dbgcodec(format, args...) printk(KERN_DEBUG format, ##args)</span>
<span class="cp">#else</span>
<span class="cp">#define snd_azf3328_dbgcodec(format, args...)</span>
<span class="cp">#endif</span>

<span class="cp">#if DEBUG_MISC</span>
<span class="cp">#define snd_azf3328_dbgtimer(format, args...) printk(KERN_DEBUG format, ##args)</span>
<span class="cp">#else</span>
<span class="cp">#define snd_azf3328_dbgtimer(format, args...)</span>
<span class="cp">#endif</span>

<span class="cp">#if DEBUG_GAME</span>
<span class="cp">#define snd_azf3328_dbggame(format, args...) printk(KERN_DEBUG format, ##args)</span>
<span class="cp">#else</span>
<span class="cp">#define snd_azf3328_dbggame(format, args...)</span>
<span class="cp">#endif</span>

<span class="cp">#if DEBUG_PM</span>
<span class="cp">#define snd_azf3328_dbgpm(format, args...) printk(KERN_DEBUG format, ##args)</span>
<span class="cp">#else</span>
<span class="cp">#define snd_azf3328_dbgpm(format, args...)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">index</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="n">SNDRV_DEFAULT_IDX</span><span class="p">;</span>	<span class="cm">/* Index 0-MAX */</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s">&quot;Index value for AZF3328 soundcard.&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="n">SNDRV_DEFAULT_STR</span><span class="p">;</span>	<span class="cm">/* ID for this card */</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="s">&quot;ID string for AZF3328 soundcard.&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="n">SNDRV_DEFAULT_ENABLE_PNP</span><span class="p">;</span>	<span class="cm">/* Enable this card */</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">enable</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">enable</span><span class="p">,</span> <span class="s">&quot;Enable AZF3328 soundcard.&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">seqtimer_scaling</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">seqtimer_scaling</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">seqtimer_scaling</span><span class="p">,</span> <span class="s">&quot;Set 1024000Hz sequencer timer scale factor (lockup danger!). Default 128.&quot;</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">snd_azf3328_codec_type</span> <span class="p">{</span>
  <span class="cm">/* warning: fixed indices (also used for bitmask checks!) */</span>
  <span class="n">AZF_CODEC_PLAYBACK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">AZF_CODEC_CAPTURE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">AZF_CODEC_I2S_OUT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_base</span><span class="p">;</span> <span class="cm">/* keep first! (avoid offset calc) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dma_base</span><span class="p">;</span> <span class="cm">/* helper to avoid an indirection in hotpath */</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span> <span class="cm">/* TODO: convert to our own per-codec lock member */</span>
	<span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">running</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">snd_azf3328_codec_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="p">{</span>
	<span class="cm">/* often-used fields towards beginning, then grouped */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ctrl_io</span><span class="p">;</span> <span class="cm">/* usually 0xb000, size 128 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">game_io</span><span class="p">;</span>  <span class="cm">/* usually 0xb400, size 8 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mpu_io</span><span class="p">;</span>   <span class="cm">/* usually 0xb800, size 4 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">opl3_io</span><span class="p">;</span> <span class="cm">/* usually 0xbc00, size 8 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mixer_io</span><span class="p">;</span> <span class="cm">/* usually 0xc000, size 64 */</span>

	<span class="n">spinlock_t</span> <span class="n">reg_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">snd_timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">snd_pcm</span> <span class="o">*</span><span class="n">pcm</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="cm">/* playback, recording and I2S out codecs */</span>
	<span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="n">codecs</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="cp">#ifdef AZF_USE_AC97_LAYER</span>
	<span class="k">struct</span> <span class="n">snd_ac97</span> <span class="o">*</span><span class="n">ac97</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_rawmidi</span> <span class="o">*</span><span class="n">rmidi</span><span class="p">;</span>

<span class="cp">#ifdef SUPPORT_GAMEPORT</span>
	<span class="k">struct</span> <span class="n">gameport</span> <span class="o">*</span><span class="n">gameport</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">axes</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="cm">/* register 0x6a is write-only, thus need to remember setting.</span>
<span class="cm">	 * If we need to add more registers here, then we might try to fold this</span>
<span class="cm">	 * into some transparent combined shadow register handling with</span>
<span class="cm">	 * CONFIG_PM register storage below, but that&#39;s slightly difficult. */</span>
	<span class="n">u16</span> <span class="n">shadow_reg_ctrl_6AH</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PM</span>
	<span class="cm">/* register value containers for power management</span>
<span class="cm">	 * Note: not always full I/O range preserved (similar to Win driver!) */</span>
	<span class="n">u32</span> <span class="n">saved_regs_ctrl</span><span class="p">[</span><span class="n">AZF_ALIGN</span><span class="p">(</span><span class="n">AZF_IO_SIZE_CTRL_PM</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">saved_regs_game</span><span class="p">[</span><span class="n">AZF_ALIGN</span><span class="p">(</span><span class="n">AZF_IO_SIZE_GAME_PM</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">saved_regs_mpu</span><span class="p">[</span><span class="n">AZF_ALIGN</span><span class="p">(</span><span class="n">AZF_IO_SIZE_MPU_PM</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">saved_regs_opl3</span><span class="p">[</span><span class="n">AZF_ALIGN</span><span class="p">(</span><span class="n">AZF_IO_SIZE_OPL3_PM</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">saved_regs_mixer</span><span class="p">[</span><span class="n">AZF_ALIGN</span><span class="p">(</span><span class="n">AZF_IO_SIZE_MIXER_PM</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">snd_azf3328_ids</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mh">0x122D</span><span class="p">,</span> <span class="mh">0x50DC</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>   <span class="cm">/* PCI168/3328 */</span>
	<span class="p">{</span> <span class="mh">0x122D</span><span class="p">,</span> <span class="mh">0x80DA</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>   <span class="cm">/* 3328 */</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">snd_azf3328_ids</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_io_reg_setb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">,</span> <span class="n">bool</span> <span class="n">do_set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Well, strictly spoken, the inb/outb sequence isn&#39;t atomic</span>
<span class="cm">	   and would need locking. However we currently don&#39;t care</span>
<span class="cm">	   since it potentially complicates matters. */</span>
	<span class="n">u8</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">reg</span><span class="p">),</span> <span class="n">new</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="n">do_set</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">prev</span><span class="o">|</span><span class="n">mask</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">);</span>
	<span class="cm">/* we need to always write the new value no matter whether it differs</span>
<span class="cm">	 * or not, since some register bits don&#39;t indicate their setting */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_codec_outb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span>
		       <span class="n">u8</span> <span class="n">value</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span>
<span class="nf">snd_azf3328_codec_inb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inb</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_codec_outw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span>
		       <span class="n">u16</span> <span class="n">value</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span>
<span class="nf">snd_azf3328_codec_inw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inw</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_codec_outl</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span>
		       <span class="n">u32</span> <span class="n">value</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">outl</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_codec_outl_multi</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">outl</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="n">addr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span>
<span class="nf">snd_azf3328_codec_inl</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inl</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_ctrl_outb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ctrl_io</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span>
<span class="nf">snd_azf3328_ctrl_inb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inb</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ctrl_io</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_ctrl_outw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ctrl_io</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_ctrl_outl</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outl</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ctrl_io</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_game_outb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">game_io</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_game_outw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">game_io</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span>
<span class="nf">snd_azf3328_game_inb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inb</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">game_io</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span>
<span class="nf">snd_azf3328_game_inw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inw</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">game_io</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_mixer_outw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outw</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_io</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span>
<span class="nf">snd_azf3328_mixer_inw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inw</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_io</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define AZF_MUTE_BIT 0x80</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">snd_azf3328_mixer_mute_control</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">do_mute</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">portbase</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_io</span> <span class="o">+</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">updated</span><span class="p">;</span>

	<span class="cm">/* the mute bit is on the *second* (i.e. right) register of a</span>
<span class="cm">	 * left/right channel setting */</span>
	<span class="n">updated</span> <span class="o">=</span> <span class="n">snd_azf3328_io_reg_setb</span><span class="p">(</span><span class="n">portbase</span><span class="p">,</span> <span class="n">AZF_MUTE_BIT</span><span class="p">,</span> <span class="n">do_mute</span><span class="p">);</span>

	<span class="cm">/* indicate whether it was muted before */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">do_mute</span><span class="p">)</span> <span class="o">?</span> <span class="o">!</span><span class="n">updated</span> <span class="o">:</span> <span class="n">updated</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">snd_azf3328_mixer_mute_control_master</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			   <span class="n">bool</span> <span class="n">do_mute</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snd_azf3328_mixer_mute_control</span><span class="p">(</span>
		<span class="n">chip</span><span class="p">,</span>
		<span class="n">IDX_MIXER_PLAY_MASTER</span><span class="p">,</span>
		<span class="n">do_mute</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">snd_azf3328_mixer_mute_control_pcm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			   <span class="n">bool</span> <span class="n">do_mute</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snd_azf3328_mixer_mute_control</span><span class="p">(</span>
		<span class="n">chip</span><span class="p">,</span>
		<span class="n">IDX_MIXER_WAVEOUT</span><span class="p">,</span>
		<span class="n">do_mute</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_mixer_reset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* reset (close) mixer:</span>
<span class="cm">	 * first mute master volume, then reset</span>
<span class="cm">	 */</span>
	<span class="n">snd_azf3328_mixer_mute_control_master</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">snd_azf3328_mixer_outw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IDX_MIXER_RESET</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef AZF_USE_AC97_LAYER</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_mixer_ac97_map_unsupported</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* need to add some more or less clever emulation? */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		<span class="s">&quot;azt3328: missing %s emulation for AC97 register 0x%02x!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">mode</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Need to have _special_ AC97 mixer hardware register index mapper,</span>
<span class="cm"> * to compensate for the issue of a rather AC97-incompatible hardware layout.</span>
<span class="cm"> */</span>
<span class="cp">#define AZF_REG_MASK 0x3f</span>
<span class="cp">#define AZF_AC97_REG_UNSUPPORTED 0x8000</span>
<span class="cp">#define AZF_AC97_REG_REAL_IO_READ 0x4000</span>
<span class="cp">#define AZF_AC97_REG_REAL_IO_WRITE 0x2000</span>
<span class="cp">#define AZF_AC97_REG_REAL_IO_RW \</span>
<span class="cp">	(AZF_AC97_REG_REAL_IO_READ | AZF_AC97_REG_REAL_IO_WRITE)</span>
<span class="cp">#define AZF_AC97_REG_EMU_IO_READ 0x0400</span>
<span class="cp">#define AZF_AC97_REG_EMU_IO_WRITE 0x0200</span>
<span class="cp">#define AZF_AC97_REG_EMU_IO_RW \</span>
<span class="cp">	(AZF_AC97_REG_EMU_IO_READ | AZF_AC97_REG_EMU_IO_WRITE)</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span>
<span class="nf">snd_azf3328_mixer_ac97_map_reg_idx</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">azf_reg</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">azf_reg_mapper</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="cm">/* Especially when taking into consideration</span>
<span class="cm">		 * mono/stereo-based sequence of azf vs. AC97 control series,</span>
<span class="cm">		 * it&#39;s quite obvious that azf simply got rid</span>
<span class="cm">		 * of the AC97_HEADPHONE control at its intended offset,</span>
<span class="cm">		 * thus shifted _all_ controls by one,</span>
<span class="cm">		 * and _then_ simply added it as an FMSYNTH control at the end,</span>
<span class="cm">		 * to make up for the offset.</span>
<span class="cm">		 * This means we&#39;ll have to translate indices here as</span>
<span class="cm">		 * needed and then do some tiny AC97 patch action</span>
<span class="cm">		 * (snd_ac97_rename_vol_ctl() etc.) - that&#39;s it.</span>
<span class="cm">		 */</span>
		<span class="p">{</span> <span class="cm">/* AC97_RESET */</span> <span class="n">IDX_MIXER_RESET</span>
			<span class="o">|</span> <span class="n">AZF_AC97_REG_REAL_IO_WRITE</span>
			<span class="o">|</span> <span class="n">AZF_AC97_REG_EMU_IO_READ</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_MASTER */</span> <span class="n">IDX_MIXER_PLAY_MASTER</span> <span class="p">},</span>
		 <span class="cm">/* note large shift: AC97_HEADPHONE to IDX_MIXER_FMSYNTH! */</span>
		<span class="p">{</span> <span class="cm">/* AC97_HEADPHONE */</span> <span class="n">IDX_MIXER_FMSYNTH</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_MASTER_MONO */</span> <span class="n">IDX_MIXER_MODEMOUT</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_MASTER_TONE */</span> <span class="n">IDX_MIXER_BASSTREBLE</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_PC_BEEP */</span> <span class="n">IDX_MIXER_PCBEEP</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_PHONE */</span> <span class="n">IDX_MIXER_MODEMIN</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_MIC */</span> <span class="n">IDX_MIXER_MIC</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_LINE */</span> <span class="n">IDX_MIXER_LINEIN</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_CD */</span> <span class="n">IDX_MIXER_CDAUDIO</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_VIDEO */</span> <span class="n">IDX_MIXER_VIDEO</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_AUX */</span> <span class="n">IDX_MIXER_AUX</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_PCM */</span> <span class="n">IDX_MIXER_WAVEOUT</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_REC_SEL */</span> <span class="n">IDX_MIXER_REC_SELECT</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_REC_GAIN */</span> <span class="n">IDX_MIXER_REC_VOLUME</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_REC_GAIN_MIC */</span> <span class="n">AZF_AC97_REG_EMU_IO_RW</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_GENERAL_PURPOSE */</span> <span class="n">IDX_MIXER_ADVCTL2</span> <span class="p">},</span>
		<span class="p">{</span> <span class="cm">/* AC97_3D_CONTROL */</span> <span class="n">IDX_MIXER_ADVCTL1</span> <span class="p">},</span>
	<span class="p">};</span>

	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg_azf</span> <span class="o">=</span> <span class="n">AZF_AC97_REG_UNSUPPORTED</span><span class="p">;</span>

	<span class="cm">/* azf3328 supports the low-numbered and low-spec:ed range</span>
<span class="cm">	   of AC97 regs only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&lt;=</span> <span class="n">AC97_3D_CONTROL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg_idx</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">reg_azf</span> <span class="o">=</span> <span class="n">azf_reg_mapper</span><span class="p">[</span><span class="n">reg_idx</span><span class="p">].</span><span class="n">azf_reg</span><span class="p">;</span>
		<span class="cm">/* a translation-only entry means it&#39;s real read/write: */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">reg_azf</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AZF_REG_MASK</span><span class="p">))</span>
			<span class="n">reg_azf</span> <span class="o">|=</span> <span class="n">AZF_AC97_REG_REAL_IO_RW</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AC97_POWERDOWN</span>:
			<span class="n">reg_azf</span> <span class="o">=</span> <span class="n">AZF_AC97_REG_EMU_IO_RW</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AC97_EXTENDED_ID</span>:
			<span class="n">reg_azf</span> <span class="o">=</span> <span class="n">AZF_AC97_REG_EMU_IO_READ</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AC97_EXTENDED_STATUS</span>:
			<span class="cm">/* I don&#39;t know what the h*ll AC97 layer</span>
<span class="cm">			 * would consult this _extended_ register for</span>
<span class="cm">			 * given a base-AC97-advertised card,</span>
<span class="cm">			 * but let&#39;s just emulate it anyway :-P</span>
<span class="cm">			 */</span>
			<span class="n">reg_azf</span> <span class="o">=</span> <span class="n">AZF_AC97_REG_EMU_IO_RW</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AC97_VENDOR_ID1</span>:
		<span class="k">case</span> <span class="n">AC97_VENDOR_ID2</span>:
			<span class="n">reg_azf</span> <span class="o">=</span> <span class="n">AZF_AC97_REG_EMU_IO_READ</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">reg_azf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span>
<span class="n">azf_emulated_ac97_caps</span> <span class="o">=</span>
	<span class="n">AC97_BC_DEDICATED_MIC</span> <span class="o">|</span>
	<span class="n">AC97_BC_BASS_TREBLE</span> <span class="o">|</span>
	<span class="cm">/* Headphone is an FM Synth control here */</span>
	<span class="n">AC97_BC_HEADPHONE</span> <span class="o">|</span>
	<span class="cm">/* no AC97_BC_LOUDNESS! */</span>
	<span class="cm">/* mask 0x7c00 is</span>
<span class="cm">	   vendor-specific 3D enhancement</span>
<span class="cm">	   vendor indicator.</span>
<span class="cm">	   Since there actually _is_ an</span>
<span class="cm">	   entry for Aztech Labs</span>
<span class="cm">	   (13), make damn sure</span>
<span class="cm">	   to indicate it. */</span>
	<span class="p">(</span><span class="mi">13</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span>
<span class="n">azf_emulated_ac97_powerdown</span> <span class="o">=</span>
	<span class="cm">/* pretend everything to be active */</span>
		<span class="n">AC97_PD_ADC_STATUS</span> <span class="o">|</span>
		<span class="n">AC97_PD_DAC_STATUS</span> <span class="o">|</span>
		<span class="n">AC97_PD_MIXER_STATUS</span> <span class="o">|</span>
		<span class="n">AC97_PD_VREF_STATUS</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Emulated, _inofficial_ vendor ID</span>
<span class="cm"> * (there might be some devices such as the MR 2800-W</span>
<span class="cm"> * which could reveal the real Aztech AC97 ID).</span>
<span class="cm"> * We choose to use &quot;AZT&quot; prefix, and then use 1 to indicate PCI168</span>
<span class="cm"> * (better don&#39;t use 0x68 since there&#39;s a PCI368 as well).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="n">azf_emulated_ac97_vendor_id</span> <span class="o">=</span> <span class="mh">0x415a5401</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span>
<span class="nf">snd_azf3328_mixer_ac97_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_ac97</span> <span class="o">*</span><span class="n">ac97</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg_ac97</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">ac97</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg_azf</span> <span class="o">=</span> <span class="n">snd_azf3328_mixer_ac97_map_reg_idx</span><span class="p">(</span><span class="n">reg_ac97</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">unsupported</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgmixer</span><span class="p">(</span>
		<span class="s">&quot;snd_azf3328_mixer_ac97_read reg_ac97 %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">reg_ac97</span>
	<span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg_azf</span> <span class="o">&amp;</span> <span class="n">AZF_AC97_REG_UNSUPPORTED</span><span class="p">)</span>
		<span class="n">unsupported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg_azf</span> <span class="o">&amp;</span> <span class="n">AZF_AC97_REG_REAL_IO_READ</span><span class="p">)</span>
			<span class="n">reg_val</span> <span class="o">=</span> <span class="n">snd_azf3328_mixer_inw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span>
						<span class="n">reg_azf</span> <span class="o">&amp;</span> <span class="n">AZF_REG_MASK</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Proceed with dummy I/O read,</span>
<span class="cm">			 * to ensure compatible timing where this may matter.</span>
<span class="cm">			 * (ALSA AC97 layer usually doesn&#39;t call I/O functions</span>
<span class="cm">			 * due to intelligent I/O caching anyway)</span>
<span class="cm">			 * Choose a mixer register that&#39;s thoroughly unrelated</span>
<span class="cm">			 * to common audio (try to minimize distortion).</span>
<span class="cm">			 */</span>
			<span class="n">snd_azf3328_mixer_inw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IDX_MIXER_SOMETHING30H</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reg_azf</span> <span class="o">&amp;</span> <span class="n">AZF_AC97_REG_EMU_IO_READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">reg_ac97</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">AC97_RESET</span>:
				<span class="n">reg_val</span> <span class="o">|=</span> <span class="n">azf_emulated_ac97_caps</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">AC97_POWERDOWN</span>:
				<span class="n">reg_val</span> <span class="o">|=</span> <span class="n">azf_emulated_ac97_powerdown</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">AC97_EXTENDED_ID</span>:
			<span class="k">case</span> <span class="n">AC97_EXTENDED_STATUS</span>:
				<span class="cm">/* AFAICS we simply can&#39;t support anything: */</span>
				<span class="n">reg_val</span> <span class="o">|=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">AC97_VENDOR_ID1</span>:
				<span class="n">reg_val</span> <span class="o">=</span> <span class="n">azf_emulated_ac97_vendor_id</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">AC97_VENDOR_ID2</span>:
				<span class="n">reg_val</span> <span class="o">=</span> <span class="n">azf_emulated_ac97_vendor_id</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">unsupported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unsupported</span><span class="p">)</span>
		<span class="n">snd_azf3328_mixer_ac97_map_unsupported</span><span class="p">(</span><span class="n">reg_ac97</span><span class="p">,</span> <span class="s">&quot;read&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">reg_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_mixer_ac97_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_ac97</span> <span class="o">*</span><span class="n">ac97</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg_ac97</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">ac97</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg_azf</span> <span class="o">=</span> <span class="n">snd_azf3328_mixer_ac97_map_reg_idx</span><span class="p">(</span><span class="n">reg_ac97</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">unsupported</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgmixer</span><span class="p">(</span>
		<span class="s">&quot;snd_azf3328_mixer_ac97_write reg_ac97 %u val %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">reg_ac97</span><span class="p">,</span> <span class="n">val</span>
	<span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg_azf</span> <span class="o">&amp;</span> <span class="n">AZF_AC97_REG_UNSUPPORTED</span><span class="p">)</span>
		<span class="n">unsupported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg_azf</span> <span class="o">&amp;</span> <span class="n">AZF_AC97_REG_REAL_IO_WRITE</span><span class="p">)</span>
			<span class="n">snd_azf3328_mixer_outw</span><span class="p">(</span>
				<span class="n">chip</span><span class="p">,</span>
				<span class="n">reg_azf</span> <span class="o">&amp;</span> <span class="n">AZF_REG_MASK</span><span class="p">,</span>
				<span class="n">val</span>
			<span class="p">);</span>
		<span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg_azf</span> <span class="o">&amp;</span> <span class="n">AZF_AC97_REG_EMU_IO_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">reg_ac97</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">AC97_REC_GAIN_MIC</span>:
			<span class="k">case</span> <span class="n">AC97_POWERDOWN</span>:
			<span class="k">case</span> <span class="n">AC97_EXTENDED_STATUS</span>:
				<span class="cm">/*</span>
<span class="cm">				 * Silently swallow these writes.</span>
<span class="cm">				 * Since for most registers our card doesn&#39;t</span>
<span class="cm">				 * actually support a comparable feature,</span>
<span class="cm">				 * this is exactly what we should do here.</span>
<span class="cm">				 * The AC97 layer&#39;s I/O caching probably</span>
<span class="cm">				 * automatically takes care of all the rest...</span>
<span class="cm">				 * (remembers written values etc.)</span>
<span class="cm">				 */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">unsupported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unsupported</span><span class="p">)</span>
		<span class="n">snd_azf3328_mixer_ac97_map_unsupported</span><span class="p">(</span><span class="n">reg_ac97</span><span class="p">,</span> <span class="s">&quot;write&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">snd_azf3328_mixer_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_ac97_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_ac97_template</span> <span class="n">ac97</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_ac97_bus_ops</span> <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">snd_azf3328_mixer_ac97_write</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">snd_azf3328_mixer_ac97_read</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ac97</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ac97</span><span class="p">));</span>
	<span class="n">ac97</span><span class="p">.</span><span class="n">scaps</span> <span class="o">=</span> <span class="n">AC97_SCAP_SKIP_MODEM</span>
			<span class="o">|</span> <span class="n">AC97_SCAP_AUDIO</span> <span class="cm">/* we support audio! */</span>
			<span class="o">|</span> <span class="n">AC97_SCAP_NO_SPDIF</span><span class="p">;</span>
	<span class="n">ac97</span><span class="p">.</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">ac97</span><span class="p">.</span><span class="n">pci</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ALSA&#39;s AC97 layer has terrible init crackling issues,</span>
<span class="cm">	 * unfortunately, and since it makes use of AC97_RESET,</span>
<span class="cm">	 * there&#39;s no use trying to mute Master Playback proactively.</span>
<span class="cm">	 */</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">snd_ac97_bus</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">snd_ac97_mixer</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ac97</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ac97</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make sure to complain loudly in case of AC97 init failure,</span>
<span class="cm">		 * since failure may happen quite often,</span>
<span class="cm">		 * due to this card being a very quirky AC97 &quot;lookalike&quot;.</span>
<span class="cm">		 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;azt3328: AC97 init failed, err %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="cm">/* If we return an error here, then snd_card_free() should</span>
<span class="cm">	 * free up any ac97 codecs that got created, as well as the bus.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* AZF_USE_AC97_LAYER */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_mixer_write_volume_gradually</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dst_vol_left</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dst_vol_right</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">chan_sel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delay</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">portbase</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_io</span> <span class="o">+</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">curr_vol_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">curr_vol_right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">left_change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right_change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chan_sel</span> <span class="o">&amp;</span> <span class="n">SET_CHAN_LEFT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr_vol_left</span>  <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">portbase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* take care of muting flag contained in left channel */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr_vol_left</span> <span class="o">&amp;</span> <span class="n">AZF_MUTE_BIT</span><span class="p">)</span>
			<span class="n">dst_vol_left</span> <span class="o">|=</span> <span class="n">AZF_MUTE_BIT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dst_vol_left</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AZF_MUTE_BIT</span><span class="p">;</span>

		<span class="n">left_change</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_vol_left</span> <span class="o">&gt;</span> <span class="n">dst_vol_left</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chan_sel</span> <span class="o">&amp;</span> <span class="n">SET_CHAN_RIGHT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr_vol_right</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">portbase</span> <span class="o">+</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">right_change</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_vol_right</span> <span class="o">&gt;</span> <span class="n">dst_vol_right</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left_change</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr_vol_left</span> <span class="o">!=</span> <span class="n">dst_vol_left</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">curr_vol_left</span> <span class="o">+=</span> <span class="n">left_change</span><span class="p">;</span>
				<span class="n">outb</span><span class="p">(</span><span class="n">curr_vol_left</span><span class="p">,</span> <span class="n">portbase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
			    <span class="n">left_change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">right_change</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr_vol_right</span> <span class="o">!=</span> <span class="n">dst_vol_right</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">curr_vol_right</span> <span class="o">+=</span> <span class="n">right_change</span><span class="p">;</span>

			<span class="cm">/* during volume change, the right channel is crackling</span>
<span class="cm">			 * somewhat more than the left channel, unfortunately.</span>
<span class="cm">			 * This seems to be a hardware issue. */</span>
				<span class="n">outb</span><span class="p">(</span><span class="n">curr_vol_right</span><span class="p">,</span> <span class="n">portbase</span> <span class="o">+</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
			    <span class="n">right_change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delay</span><span class="p">)</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="n">delay</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">left_change</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">right_change</span><span class="p">));</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * general mixer element</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">azf3328_mixer_reg</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lchan_shift</span><span class="p">,</span> <span class="n">rchan_shift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">invert</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stereo</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enum_c</span><span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define COMPOSE_MIXER_REG(reg,lchan_shift,rchan_shift,mask,invert,stereo,enum_c) \</span>
<span class="cp"> ((reg) | (lchan_shift &lt;&lt; 8) | (rchan_shift &lt;&lt; 12) | \</span>
<span class="cp">  (mask &lt;&lt; 16) | \</span>
<span class="cp">  (invert &lt;&lt; 24) | \</span>
<span class="cp">  (stereo &lt;&lt; 25) | \</span>
<span class="cp">  (enum_c &lt;&lt; 26))</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">snd_azf3328_mixer_reg_decode</span><span class="p">(</span><span class="k">struct</span> <span class="n">azf3328_mixer_reg</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">lchan_shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">rchan_shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">invert</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">stereo</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">25</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">enum_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">26</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mixer switches/volumes</span>
<span class="cm"> */</span>

<span class="cp">#define AZF3328_MIXER_SWITCH(xname, reg, shift, invert) \</span>
<span class="cp">{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span>
<span class="cp">  .info = snd_azf3328_info_mixer, \</span>
<span class="cp">  .get = snd_azf3328_get_mixer, .put = snd_azf3328_put_mixer, \</span>
<span class="cp">  .private_value = COMPOSE_MIXER_REG(reg, shift, 0, 0x1, invert, 0, 0), \</span>
<span class="cp">}</span>

<span class="cp">#define AZF3328_MIXER_VOL_STEREO(xname, reg, mask, invert) \</span>
<span class="cp">{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span>
<span class="cp">  .info = snd_azf3328_info_mixer, \</span>
<span class="cp">  .get = snd_azf3328_get_mixer, .put = snd_azf3328_put_mixer, \</span>
<span class="cp">  .private_value = COMPOSE_MIXER_REG(reg, 8, 0, mask, invert, 1, 0), \</span>
<span class="cp">}</span>

<span class="cp">#define AZF3328_MIXER_VOL_MONO(xname, reg, mask, is_right_chan) \</span>
<span class="cp">{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span>
<span class="cp">  .info = snd_azf3328_info_mixer, \</span>
<span class="cp">  .get = snd_azf3328_get_mixer, .put = snd_azf3328_put_mixer, \</span>
<span class="cp">  .private_value = COMPOSE_MIXER_REG(reg, is_right_chan ? 0 : 8, 0, mask, 1, 0, 0), \</span>
<span class="cp">}</span>

<span class="cp">#define AZF3328_MIXER_VOL_SPECIAL(xname, reg, mask, shift, invert) \</span>
<span class="cp">{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span>
<span class="cp">  .info = snd_azf3328_info_mixer, \</span>
<span class="cp">  .get = snd_azf3328_get_mixer, .put = snd_azf3328_put_mixer, \</span>
<span class="cp">  .private_value = COMPOSE_MIXER_REG(reg, shift, 0, mask, invert, 0, 0), \</span>
<span class="cp">}</span>

<span class="cp">#define AZF3328_MIXER_ENUM(xname, reg, enum_c, shift) \</span>
<span class="cp">{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span>
<span class="cp">  .info = snd_azf3328_info_mixer_enum, \</span>
<span class="cp">  .get = snd_azf3328_get_mixer_enum, .put = snd_azf3328_put_mixer_enum, \</span>
<span class="cp">  .private_value = COMPOSE_MIXER_REG(reg, shift, 0, 0, 0, 0, enum_c), \</span>
<span class="cp">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_info_mixer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">azf3328_mixer_reg</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="n">snd_azf3328_mixer_reg_decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">);</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span>
		<span class="n">SNDRV_CTL_ELEM_TYPE_BOOLEAN</span> <span class="o">:</span> <span class="n">SNDRV_CTL_ELEM_TYPE_INTEGER</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">stereo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_get_mixer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azf3328_mixer_reg</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">oreg</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="n">snd_azf3328_mixer_reg_decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">);</span>

	<span class="n">oreg</span> <span class="o">=</span> <span class="n">snd_azf3328_mixer_inw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">oreg</span> <span class="o">&gt;&gt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">lchan_shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">reg</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">invert</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">mask</span> <span class="o">-</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">stereo</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">oreg</span> <span class="o">&gt;&gt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">rchan_shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">reg</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">invert</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">mask</span> <span class="o">-</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">snd_azf3328_dbgmixer</span><span class="p">(</span><span class="s">&quot;get: %02x is %04x -&gt; vol %02lx|%02lx &quot;</span>
			     <span class="s">&quot;(shift %02d|%02d, mask %02x, inv. %d, stereo %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">reg</span><span class="p">.</span><span class="n">reg</span><span class="p">,</span> <span class="n">oreg</span><span class="p">,</span>
		<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		<span class="n">reg</span><span class="p">.</span><span class="n">lchan_shift</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">rchan_shift</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">invert</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">stereo</span><span class="p">);</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_put_mixer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azf3328_mixer_reg</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">oreg</span><span class="p">,</span> <span class="n">nreg</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="n">snd_azf3328_mixer_reg_decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">);</span>
	<span class="n">oreg</span> <span class="o">=</span> <span class="n">snd_azf3328_mixer_inw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">reg</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">invert</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">mask</span> <span class="o">-</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">nreg</span> <span class="o">=</span> <span class="n">oreg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">lchan_shift</span><span class="p">);</span>
	<span class="n">nreg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">lchan_shift</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">stereo</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">reg</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">invert</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">mask</span> <span class="o">-</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">nreg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">rchan_shift</span><span class="p">);</span>
		<span class="n">nreg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">rchan_shift</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">mask</span> <span class="o">&gt;=</span> <span class="mh">0x07</span><span class="p">)</span> <span class="cm">/* it&#39;s a volume control, so better take care */</span>
		<span class="n">snd_azf3328_mixer_write_volume_gradually</span><span class="p">(</span>
			<span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">reg</span><span class="p">,</span> <span class="n">nreg</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="n">nreg</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span>
			<span class="cm">/* just set both channels, doesn&#39;t matter */</span>
			<span class="n">SET_CHAN_LEFT</span><span class="o">|</span><span class="n">SET_CHAN_RIGHT</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
        	<span class="n">snd_azf3328_mixer_outw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">reg</span><span class="p">,</span> <span class="n">nreg</span><span class="p">);</span>

	<span class="n">snd_azf3328_dbgmixer</span><span class="p">(</span><span class="s">&quot;put: %02x to %02lx|%02lx, &quot;</span>
			     <span class="s">&quot;oreg %04x; shift %02d|%02d -&gt; nreg %04x; after: %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">reg</span><span class="p">.</span><span class="n">reg</span><span class="p">,</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		<span class="n">oreg</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">lchan_shift</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">rchan_shift</span><span class="p">,</span>
		<span class="n">nreg</span><span class="p">,</span> <span class="n">snd_azf3328_mixer_inw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">reg</span><span class="p">));</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">nreg</span> <span class="o">!=</span> <span class="n">oreg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_info_mixer_enum</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">texts1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;Mic1&quot;</span><span class="p">,</span> <span class="s">&quot;Mic2&quot;</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">texts2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;Mix&quot;</span><span class="p">,</span> <span class="s">&quot;Mic&quot;</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">texts3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;Mic&quot;</span><span class="p">,</span> <span class="s">&quot;CD&quot;</span><span class="p">,</span> <span class="s">&quot;Video&quot;</span><span class="p">,</span> <span class="s">&quot;Aux&quot;</span><span class="p">,</span>
		<span class="s">&quot;Line&quot;</span><span class="p">,</span> <span class="s">&quot;Mix&quot;</span><span class="p">,</span> <span class="s">&quot;Mix Mono&quot;</span><span class="p">,</span> <span class="s">&quot;Phone&quot;</span>
        <span class="p">};</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">texts4</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;pre 3D&quot;</span><span class="p">,</span> <span class="s">&quot;post 3D&quot;</span>
        <span class="p">};</span>
	<span class="k">struct</span> <span class="n">azf3328_mixer_reg</span> <span class="n">reg</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">snd_azf3328_mixer_reg_decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">);</span>
        <span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_ENUMERATED</span><span class="p">;</span>
        <span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">reg</span> <span class="o">==</span> <span class="n">IDX_MIXER_REC_SELECT</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">enum_c</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span> <span class="o">&gt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">enum_c</span> <span class="o">-</span> <span class="mi">1U</span><span class="p">)</span>
                <span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">enum_c</span> <span class="o">-</span> <span class="mi">1U</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">reg</span> <span class="o">==</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">lchan_shift</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">8</span>: <span class="cm">/* modem out sel */</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">texts1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">9</span>: <span class="cm">/* mono sel source */</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">texts2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">15</span>: <span class="cm">/* PCM Out Path */</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">texts4</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">reg</span> <span class="o">==</span> <span class="n">IDX_MIXER_REC_SELECT</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">texts3</span><span class="p">;</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_get_mixer_enum</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azf3328_mixer_reg</span> <span class="n">reg</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">snd_azf3328_mixer_reg_decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">snd_azf3328_mixer_inw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">reg</span> <span class="o">==</span> <span class="n">IDX_MIXER_REC_SELECT</span><span class="p">)</span> <span class="p">{</span>
        	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">enum_c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">enum_c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
        	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">lchan_shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">enum_c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">snd_azf3328_dbgmixer</span><span class="p">(</span><span class="s">&quot;get_enum: %02x is %04x -&gt; %d|%d (shift %02d, enum_c %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">reg</span><span class="p">.</span><span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		<span class="n">reg</span><span class="p">.</span><span class="n">lchan_shift</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">enum_c</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_put_mixer_enum</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">azf3328_mixer_reg</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">oreg</span><span class="p">,</span> <span class="n">nreg</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">snd_azf3328_mixer_reg_decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="p">,</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">);</span>
	<span class="n">oreg</span> <span class="o">=</span> <span class="n">snd_azf3328_mixer_inw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">oreg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">reg</span> <span class="o">==</span> <span class="n">IDX_MIXER_REC_SELECT</span><span class="p">)</span> <span class="p">{</span>
        	<span class="k">if</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">enum_c</span> <span class="o">-</span> <span class="mi">1U</span> <span class="o">||</span>
            	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">enum_c</span> <span class="o">-</span> <span class="mi">1U</span><span class="p">)</span>
                	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
        	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
        	      <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        	<span class="k">if</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">enum_c</span> <span class="o">-</span> <span class="mi">1U</span><span class="p">)</span>
                	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="n">reg</span><span class="p">.</span><span class="n">enum_c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">lchan_shift</span><span class="p">);</span>
        	<span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">reg</span><span class="p">.</span><span class="n">lchan_shift</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">snd_azf3328_mixer_outw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">nreg</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgmixer</span><span class="p">(</span><span class="s">&quot;put_enum: %02x to %04x, oreg %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">oreg</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">nreg</span> <span class="o">!=</span> <span class="n">oreg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">snd_azf3328_mixer_controls</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;Master Playback Switch&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_PLAY_MASTER</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_VOL_STEREO</span><span class="p">(</span><span class="s">&quot;Master Playback Volume&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_PLAY_MASTER</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;PCM Playback Switch&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_WAVEOUT</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_VOL_STEREO</span><span class="p">(</span><span class="s">&quot;PCM Playback Volume&quot;</span><span class="p">,</span>
					<span class="n">IDX_MIXER_WAVEOUT</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;PCM 3D Bypass Playback Switch&quot;</span><span class="p">,</span>
					<span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;FM Playback Switch&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_FMSYNTH</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_VOL_STEREO</span><span class="p">(</span><span class="s">&quot;FM Playback Volume&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_FMSYNTH</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;CD Playback Switch&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_CDAUDIO</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_VOL_STEREO</span><span class="p">(</span><span class="s">&quot;CD Playback Volume&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_CDAUDIO</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;Capture Switch&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_REC_VOLUME</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_VOL_STEREO</span><span class="p">(</span><span class="s">&quot;Capture Volume&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_REC_VOLUME</span><span class="p">,</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_ENUM</span><span class="p">(</span><span class="s">&quot;Capture Source&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_REC_SELECT</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;Mic Playback Switch&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_MIC</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_VOL_MONO</span><span class="p">(</span><span class="s">&quot;Mic Playback Volume&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_MIC</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;Mic Boost (+20dB)&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_MIC</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;Line Playback Switch&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_LINEIN</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_VOL_STEREO</span><span class="p">(</span><span class="s">&quot;Line Playback Volume&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_LINEIN</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;Beep Playback Switch&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_PCBEEP</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_VOL_SPECIAL</span><span class="p">(</span><span class="s">&quot;Beep Playback Volume&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_PCBEEP</span><span class="p">,</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;Video Playback Switch&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_VIDEO</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_VOL_STEREO</span><span class="p">(</span><span class="s">&quot;Video Playback Volume&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_VIDEO</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;Aux Playback Switch&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_AUX</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_VOL_STEREO</span><span class="p">(</span><span class="s">&quot;Aux Playback Volume&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_AUX</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;Modem Playback Switch&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_MODEMOUT</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_VOL_MONO</span><span class="p">(</span><span class="s">&quot;Modem Playback Volume&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_MODEMOUT</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;Modem Capture Switch&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_MODEMIN</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_VOL_MONO</span><span class="p">(</span><span class="s">&quot;Modem Capture Volume&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_MODEMIN</span><span class="p">,</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_ENUM</span><span class="p">(</span><span class="s">&quot;Mic Select&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_ENUM</span><span class="p">(</span><span class="s">&quot;Mono Output Select&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_ENUM</span><span class="p">(</span><span class="s">&quot;PCM Output Route&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="cm">/* PCM Out Path, place in front since it controls *both* 3D and Bass/Treble! */</span>
	<span class="n">AZF3328_MIXER_VOL_SPECIAL</span><span class="p">(</span><span class="s">&quot;Tone Control - Treble&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_BASSTREBLE</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_VOL_SPECIAL</span><span class="p">(</span><span class="s">&quot;Tone Control - Bass&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_BASSTREBLE</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;3D Control - Switch&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_VOL_SPECIAL</span><span class="p">(</span><span class="s">&quot;3D Control - Width&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL1</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* &quot;3D Width&quot; */</span>
	<span class="n">AZF3328_MIXER_VOL_SPECIAL</span><span class="p">(</span><span class="s">&quot;3D Control - Depth&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL1</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* &quot;Hifi 3D&quot; */</span>
<span class="cp">#if MIXER_TESTING</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;0&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;3&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;4&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;5&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;6&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;7&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;8&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;9&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;10&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;11&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;12&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;13&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;14&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">AZF3328_MIXER_SWITCH</span><span class="p">(</span><span class="s">&quot;15&quot;</span><span class="p">,</span> <span class="n">IDX_MIXER_ADVCTL2</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">u16</span> <span class="n">__devinitdata</span> <span class="n">snd_azf3328_init_values</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="n">IDX_MIXER_PLAY_MASTER</span><span class="p">,</span>	<span class="n">MIXER_MUTE_MASK</span><span class="o">|</span><span class="mh">0x1f1f</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">IDX_MIXER_MODEMOUT</span><span class="p">,</span>		<span class="n">MIXER_MUTE_MASK</span><span class="o">|</span><span class="mh">0x1f1f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">IDX_MIXER_BASSTREBLE</span><span class="p">,</span>		<span class="mh">0x0000</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">IDX_MIXER_PCBEEP</span><span class="p">,</span>		<span class="n">MIXER_MUTE_MASK</span><span class="o">|</span><span class="mh">0x1f1f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">IDX_MIXER_MODEMIN</span><span class="p">,</span>		<span class="n">MIXER_MUTE_MASK</span><span class="o">|</span><span class="mh">0x1f1f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">IDX_MIXER_MIC</span><span class="p">,</span>		<span class="n">MIXER_MUTE_MASK</span><span class="o">|</span><span class="mh">0x001f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">IDX_MIXER_LINEIN</span><span class="p">,</span>		<span class="n">MIXER_MUTE_MASK</span><span class="o">|</span><span class="mh">0x1f1f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">IDX_MIXER_CDAUDIO</span><span class="p">,</span>		<span class="n">MIXER_MUTE_MASK</span><span class="o">|</span><span class="mh">0x1f1f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">IDX_MIXER_VIDEO</span><span class="p">,</span>		<span class="n">MIXER_MUTE_MASK</span><span class="o">|</span><span class="mh">0x1f1f</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">IDX_MIXER_AUX</span><span class="p">,</span>		<span class="n">MIXER_MUTE_MASK</span><span class="o">|</span><span class="mh">0x1f1f</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">IDX_MIXER_WAVEOUT</span><span class="p">,</span>		<span class="n">MIXER_MUTE_MASK</span><span class="o">|</span><span class="mh">0x1f1f</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">IDX_MIXER_FMSYNTH</span><span class="p">,</span>		<span class="n">MIXER_MUTE_MASK</span><span class="o">|</span><span class="mh">0x1f1f</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">IDX_MIXER_REC_VOLUME</span><span class="p">,</span>		<span class="n">MIXER_MUTE_MASK</span><span class="o">|</span><span class="mh">0x0707</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">snd_azf3328_mixer_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="o">*</span><span class="n">sw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">chip</span> <span class="o">||</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">card</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">;</span>

	<span class="cm">/* mixer reset */</span>
	<span class="n">snd_azf3328_mixer_outw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IDX_MIXER_RESET</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>

	<span class="cm">/* mute and zero volume channels */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">snd_azf3328_init_values</span><span class="p">);</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_azf3328_mixer_outw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span>
			<span class="n">snd_azf3328_init_values</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
			<span class="n">snd_azf3328_init_values</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* add mixer controls */</span>
	<span class="n">sw</span> <span class="o">=</span> <span class="n">snd_azf3328_mixer_controls</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">snd_azf3328_mixer_controls</span><span class="p">);</span>
			<span class="o">++</span><span class="n">idx</span><span class="p">,</span> <span class="o">++</span><span class="n">sw</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_ctl_add</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">snd_ctl_new1</span><span class="p">(</span><span class="n">sw</span><span class="p">,</span> <span class="n">chip</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">snd_component_add</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;AZF3328 mixer&quot;</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">mixername</span><span class="p">,</span> <span class="s">&quot;AZF3328 mixer&quot;</span><span class="p">);</span>

	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* AZF_USE_AC97_LAYER */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_hw_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">hw_params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">snd_pcm_lib_malloc_pages</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span> <span class="n">params_buffer_bytes</span><span class="p">(</span><span class="n">hw_params</span><span class="p">));</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_hw_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="n">snd_pcm_lib_free_pages</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_codec_setfmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">azf_freq_t</span> <span class="n">bitrate</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">format_width</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channels</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">val</span> <span class="o">=</span> <span class="mh">0xff00</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">bitrate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AZF_FREQ_4000</span>:  <span class="n">freq</span> <span class="o">=</span> <span class="n">SOUNDFORMAT_FREQ_SUSPECTED_4000</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AZF_FREQ_4800</span>:  <span class="n">freq</span> <span class="o">=</span> <span class="n">SOUNDFORMAT_FREQ_SUSPECTED_4800</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AZF_FREQ_5512</span>:
		<span class="cm">/* the AZF3328 names it &quot;5510&quot; for some strange reason */</span>
			     <span class="n">freq</span> <span class="o">=</span> <span class="n">SOUNDFORMAT_FREQ_5510</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AZF_FREQ_6620</span>:  <span class="n">freq</span> <span class="o">=</span> <span class="n">SOUNDFORMAT_FREQ_6620</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AZF_FREQ_8000</span>:  <span class="n">freq</span> <span class="o">=</span> <span class="n">SOUNDFORMAT_FREQ_8000</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AZF_FREQ_9600</span>:  <span class="n">freq</span> <span class="o">=</span> <span class="n">SOUNDFORMAT_FREQ_9600</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AZF_FREQ_11025</span>: <span class="n">freq</span> <span class="o">=</span> <span class="n">SOUNDFORMAT_FREQ_11025</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AZF_FREQ_13240</span>: <span class="n">freq</span> <span class="o">=</span> <span class="n">SOUNDFORMAT_FREQ_SUSPECTED_13240</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AZF_FREQ_16000</span>: <span class="n">freq</span> <span class="o">=</span> <span class="n">SOUNDFORMAT_FREQ_16000</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AZF_FREQ_22050</span>: <span class="n">freq</span> <span class="o">=</span> <span class="n">SOUNDFORMAT_FREQ_22050</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AZF_FREQ_32000</span>: <span class="n">freq</span> <span class="o">=</span> <span class="n">SOUNDFORMAT_FREQ_32000</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;unknown bitrate %d, assuming 44.1kHz!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">);</span>
		<span class="cm">/* fall-through */</span>
	<span class="k">case</span> <span class="n">AZF_FREQ_44100</span>: <span class="n">freq</span> <span class="o">=</span> <span class="n">SOUNDFORMAT_FREQ_44100</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AZF_FREQ_48000</span>: <span class="n">freq</span> <span class="o">=</span> <span class="n">SOUNDFORMAT_FREQ_48000</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AZF_FREQ_66200</span>: <span class="n">freq</span> <span class="o">=</span> <span class="n">SOUNDFORMAT_FREQ_SUSPECTED_66200</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* val = 0xff07; 3m27.993s (65301Hz; -&gt; 64000Hz???) hmm, 66120, 65967, 66123 */</span>
	<span class="cm">/* val = 0xff09; 17m15.098s (13123,478Hz; -&gt; 12000Hz???) hmm, 13237.2Hz? */</span>
	<span class="cm">/* val = 0xff0a; 47m30.599s (4764,891Hz; -&gt; 4800Hz???) yup, 4803Hz */</span>
	<span class="cm">/* val = 0xff0c; 57m0.510s (4010,263Hz; -&gt; 4000Hz???) yup, 4003Hz */</span>
	<span class="cm">/* val = 0xff05; 5m11.556s (... -&gt; 44100Hz) */</span>
	<span class="cm">/* val = 0xff03; 10m21.529s (21872,463Hz; -&gt; 22050Hz???) */</span>
	<span class="cm">/* val = 0xff0f; 20m41.883s (10937,993Hz; -&gt; 11025Hz???) */</span>
	<span class="cm">/* val = 0xff0d; 41m23.135s (5523,600Hz; -&gt; 5512Hz???) */</span>
	<span class="cm">/* val = 0xff0e; 28m30.777s (8017Hz; -&gt; 8000Hz???) */</span>

	<span class="n">val</span> <span class="o">|=</span> <span class="n">freq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channels</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">SOUNDFORMAT_FLAG_2CHANNELS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">format_width</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">SOUNDFORMAT_FLAG_16BIT</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* set bitrate/format */</span>
	<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_SOUNDFORMAT</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/* changing the bitrate/format settings switches off the</span>
<span class="cm">	 * audio output with an annoying click in case of 8/16bit format change</span>
<span class="cm">	 * (maybe shutting down DAC/ADC?), thus immediately</span>
<span class="cm">	 * do some tweaking to reenable it and get rid of the clicking</span>
<span class="cm">	 * (FIXME: yes, it works, but what exactly am I doing here?? :)</span>
<span class="cm">	 * FIXME: does this have some side effects for full-duplex</span>
<span class="cm">	 * or other dramatic side effects? */</span>
	<span class="cm">/* do it for non-capture codecs only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AZF_CODEC_CAPTURE</span><span class="p">)</span>
		<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">,</span>
			<span class="n">snd_azf3328_codec_inw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">DMA_RUN_SOMETHING1</span> <span class="o">|</span>
			<span class="n">DMA_RUN_SOMETHING2</span> <span class="o">|</span>
			<span class="n">SOMETHING_ALMOST_ALWAYS_SET</span> <span class="o">|</span>
			<span class="n">DMA_EPILOGUE_SOMETHING</span> <span class="o">|</span>
			<span class="n">DMA_SOMETHING_ELSE</span>
		<span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_codec_setfmt_lowpower</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* choose lowest frequency for low power consumption.</span>
<span class="cm">	 * While this will cause louder noise due to rather coarse frequency,</span>
<span class="cm">	 * it should never matter since output should always</span>
<span class="cm">	 * get disabled properly when idle anyway. */</span>
	<span class="n">snd_azf3328_codec_setfmt</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">AZF_FREQ_4000</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_ctrl_reg_6AH_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="n">bitmask</span><span class="p">,</span>
					<span class="n">bool</span> <span class="n">enable</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">do_mask</span> <span class="o">=</span> <span class="o">!</span><span class="n">enable</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_mask</span><span class="p">)</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">shadow_reg_ctrl_6AH</span> <span class="o">|=</span> <span class="n">bitmask</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">shadow_reg_ctrl_6AH</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">bitmask</span><span class="p">;</span>
	<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span><span class="s">&quot;6AH_update mask 0x%04x do_mask %d: val 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bitmask</span><span class="p">,</span> <span class="n">do_mask</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">shadow_reg_ctrl_6AH</span><span class="p">);</span>
	<span class="n">snd_azf3328_ctrl_outw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IDX_IO_6AH</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">shadow_reg_ctrl_6AH</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_ctrl_enable_codecs</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span><span class="s">&quot;codec_enable %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>
	<span class="cm">/* no idea what exactly is being done here, but I strongly assume it&#39;s</span>
<span class="cm">	 * PM related */</span>
	<span class="n">snd_azf3328_ctrl_reg_6AH_update</span><span class="p">(</span>
		<span class="n">chip</span><span class="p">,</span> <span class="n">IO_6A_PAUSE_PLAYBACK_BIT8</span><span class="p">,</span> <span class="n">enable</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_ctrl_codec_activity</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">snd_azf3328_codec_type</span> <span class="n">codec_type</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">enable</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codecs</span><span class="p">[</span><span class="n">codec_type</span><span class="p">];</span>
	<span class="n">bool</span> <span class="n">need_change</span> <span class="o">=</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">!=</span> <span class="n">enable</span><span class="p">);</span>

	<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span>
		<span class="s">&quot;codec_activity: %s codec, enable %d, need_change %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">codec</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">need_change</span>
	<span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_change</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
			<span class="k">enum</span> <span class="n">snd_azf3328_codec_type</span> <span class="n">other1</span><span class="p">;</span>
			<span class="k">enum</span> <span class="n">snd_azf3328_codec_type</span> <span class="n">other2</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">peer_codecs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span>
			<span class="p">{</span> <span class="p">{</span> <span class="n">AZF_CODEC_CAPTURE</span><span class="p">,</span> <span class="n">AZF_CODEC_I2S_OUT</span> <span class="p">},</span>
			  <span class="p">{</span> <span class="n">AZF_CODEC_PLAYBACK</span><span class="p">,</span> <span class="n">AZF_CODEC_I2S_OUT</span> <span class="p">},</span>
			  <span class="p">{</span> <span class="n">AZF_CODEC_PLAYBACK</span><span class="p">,</span> <span class="n">AZF_CODEC_CAPTURE</span> <span class="p">}</span> <span class="p">};</span>
		<span class="n">bool</span> <span class="n">call_function</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
			<span class="cm">/* if enable codec, call enable_codecs func</span>
<span class="cm">			   to enable codec supply... */</span>
			<span class="n">call_function</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* ...otherwise call enable_codecs func</span>
<span class="cm">			   (which globally shuts down operation of codecs)</span>
<span class="cm">			   only in case the other codecs are currently</span>
<span class="cm">			   not active either! */</span>
			<span class="n">call_function</span> <span class="o">=</span>
				<span class="p">((</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codecs</span><span class="p">[</span><span class="n">peer_codecs</span><span class="p">[</span><span class="n">codec_type</span><span class="p">].</span><span class="n">other1</span><span class="p">]</span>
					<span class="p">.</span><span class="n">running</span><span class="p">)</span>
			     <span class="o">&amp;&amp;</span>  <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codecs</span><span class="p">[</span><span class="n">peer_codecs</span><span class="p">[</span><span class="n">codec_type</span><span class="p">].</span><span class="n">other2</span><span class="p">]</span>
					<span class="p">.</span><span class="n">running</span><span class="p">));</span>
		 <span class="p">}</span>
		 <span class="k">if</span> <span class="p">(</span><span class="n">call_function</span><span class="p">)</span>
			<span class="n">snd_azf3328_ctrl_enable_codecs</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>

		<span class="cm">/* ...and adjust clock, too</span>
<span class="cm">		 * (reduce noise and power consumption) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable</span><span class="p">)</span>
			<span class="n">snd_azf3328_codec_setfmt_lowpower</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="n">enable</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_codec_setdmaa</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">period_bytes</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer_bytes</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">period_bytes</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;odd period length!?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">buffer_bytes</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">period_bytes</span><span class="p">,</span>
		 <span class="s">&quot;missed our input expectations! %u vs. %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">buffer_bytes</span><span class="p">,</span> <span class="n">period_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* AZF3328 uses a two buffer pointer DMA transfer approach */</span>

		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="cm">/* width 32bit (prevent overflow): */</span>
		<span class="n">u32</span> <span class="n">area_length</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">codec_setup_io</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">dma_start_1</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">dma_start_2</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">dma_lengths</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">setup_io</span><span class="p">;</span>

		<span class="n">area_length</span> <span class="o">=</span> <span class="n">buffer_bytes</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

		<span class="n">setup_io</span><span class="p">.</span><span class="n">dma_start_1</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">setup_io</span><span class="p">.</span><span class="n">dma_start_2</span> <span class="o">=</span> <span class="n">addr</span><span class="o">+</span><span class="n">area_length</span><span class="p">;</span>

		<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span>
			<span class="s">&quot;setdma: buffers %08x[%u] / %08x[%u], %u, %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">setup_io</span><span class="p">.</span><span class="n">dma_start_1</span><span class="p">,</span> <span class="n">area_length</span><span class="p">,</span>
				<span class="n">setup_io</span><span class="p">.</span><span class="n">dma_start_2</span><span class="p">,</span> <span class="n">area_length</span><span class="p">,</span>
				<span class="n">period_bytes</span><span class="p">,</span> <span class="n">buffer_bytes</span><span class="p">);</span>

		<span class="cm">/* Hmm, are we really supposed to decrement this by 1??</span>
<span class="cm">		   Most definitely certainly not: configuring full length does</span>
<span class="cm">		   work properly (i.e. likely better), and BTW we</span>
<span class="cm">		   violated possibly differing frame sizes with this...</span>

<span class="cm">		area_length--; |* max. index *|</span>
<span class="cm">		*/</span>

		<span class="cm">/* build combined I/O buffer length word */</span>
		<span class="n">setup_io</span><span class="p">.</span><span class="n">dma_lengths</span> <span class="o">=</span> <span class="p">(</span><span class="n">area_length</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">area_length</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">snd_azf3328_codec_outl_multi</span><span class="p">(</span>
			<span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_START_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">setup_io</span><span class="p">,</span> <span class="mi">3</span>
		<span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_pcm_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">        unsigned int size = snd_pcm_lib_buffer_bytes(substream);</span>
<span class="c">	unsigned int count = snd_pcm_lib_period_bytes(substream);</span>
<span class="cp">#endif</span>

	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>

	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">dma_base</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	snd_azf3328_codec_setfmt(codec,</span>
<span class="c">		runtime-&gt;rate,</span>
<span class="c">		snd_pcm_format_width(runtime-&gt;format),</span>
<span class="c">		runtime-&gt;channels);</span>
<span class="c">	snd_azf3328_codec_setdmaa(codec,</span>
<span class="c">					runtime-&gt;dma_addr, count, size);</span>
<span class="cp">#endif</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_pcm_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">previously_muted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_main_mixer_playback_codec</span> <span class="o">=</span> <span class="p">(</span><span class="n">AZF_CODEC_PLAYBACK</span> <span class="o">==</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

	<span class="n">snd_azf3328_dbgcalls</span><span class="p">(</span><span class="s">&quot;snd_azf3328_pcm_trigger cmd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_START</span>:
		<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span><span class="s">&quot;START %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_main_mixer_playback_codec</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* mute WaveOut (avoid clicking during setup) */</span>
			<span class="n">previously_muted</span> <span class="o">=</span>
				<span class="n">snd_azf3328_mixer_mute_control_pcm</span><span class="p">(</span>
						<span class="n">chip</span><span class="p">,</span> <span class="mi">1</span>
				<span class="p">);</span>
		<span class="p">}</span>

		<span class="n">snd_azf3328_codec_setfmt</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span>
			<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span>
			<span class="n">snd_pcm_format_width</span><span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">),</span>
			<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* first, remember current value: */</span>
		<span class="n">flags1</span> <span class="o">=</span> <span class="n">snd_azf3328_codec_inw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">);</span>

		<span class="cm">/* stop transfer */</span>
		<span class="n">flags1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA_RESUME</span><span class="p">;</span>
		<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">,</span> <span class="n">flags1</span><span class="p">);</span>

		<span class="cm">/* FIXME: clear interrupts or what??? */</span>
		<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_IRQTYPE</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">snd_azf3328_codec_setdmaa</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span>
			<span class="n">snd_pcm_lib_period_bytes</span><span class="p">(</span><span class="n">substream</span><span class="p">),</span>
			<span class="n">snd_pcm_lib_buffer_bytes</span><span class="p">(</span><span class="n">substream</span><span class="p">)</span>
		<span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="cp">#ifdef WIN9X</span>
		<span class="cm">/* FIXME: enable playback/recording??? */</span>
		<span class="n">flags1</span> <span class="o">|=</span> <span class="n">DMA_RUN_SOMETHING1</span> <span class="o">|</span> <span class="n">DMA_RUN_SOMETHING2</span><span class="p">;</span>
		<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">,</span> <span class="n">flags1</span><span class="p">);</span>

		<span class="cm">/* start transfer again */</span>
		<span class="cm">/* FIXME: what is this value (0x0010)??? */</span>
		<span class="n">flags1</span> <span class="o">|=</span> <span class="n">DMA_RESUME</span> <span class="o">|</span> <span class="n">DMA_EPILOGUE_SOMETHING</span><span class="p">;</span>
		<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">,</span> <span class="n">flags1</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* NT4 */</span><span class="cp"></span>
		<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">,</span>
			<span class="mh">0x0000</span><span class="p">);</span>
		<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">,</span>
			<span class="n">DMA_RUN_SOMETHING1</span><span class="p">);</span>
		<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">,</span>
			<span class="n">DMA_RUN_SOMETHING1</span> <span class="o">|</span>
			<span class="n">DMA_RUN_SOMETHING2</span><span class="p">);</span>
		<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">,</span>
			<span class="n">DMA_RESUME</span> <span class="o">|</span>
			<span class="n">SOMETHING_ALMOST_ALWAYS_SET</span> <span class="o">|</span>
			<span class="n">DMA_EPILOGUE_SOMETHING</span> <span class="o">|</span>
			<span class="n">DMA_SOMETHING_ELSE</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">snd_azf3328_ctrl_codec_activity</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_main_mixer_playback_codec</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* now unmute WaveOut */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">previously_muted</span><span class="p">)</span>
				<span class="n">snd_azf3328_mixer_mute_control_pcm</span><span class="p">(</span>
						<span class="n">chip</span><span class="p">,</span> <span class="mi">0</span>
				<span class="p">);</span>
		<span class="p">}</span>

		<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span><span class="s">&quot;STARTED %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_RESUME</span>:
		<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span><span class="s">&quot;RESUME %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="cm">/* resume codec if we were active */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span>
			<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">,</span>
				<span class="n">snd_azf3328_codec_inw</span><span class="p">(</span>
					<span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span>
				<span class="p">)</span> <span class="o">|</span> <span class="n">DMA_RESUME</span>
			<span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_STOP</span>:
		<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span><span class="s">&quot;STOP %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_main_mixer_playback_codec</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* mute WaveOut (avoid clicking during setup) */</span>
			<span class="n">previously_muted</span> <span class="o">=</span>
				<span class="n">snd_azf3328_mixer_mute_control_pcm</span><span class="p">(</span>
						<span class="n">chip</span><span class="p">,</span> <span class="mi">1</span>
				<span class="p">);</span>
		<span class="p">}</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* first, remember current value: */</span>
		<span class="n">flags1</span> <span class="o">=</span> <span class="n">snd_azf3328_codec_inw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">);</span>

		<span class="cm">/* stop transfer */</span>
		<span class="n">flags1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA_RESUME</span><span class="p">;</span>
		<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">,</span> <span class="n">flags1</span><span class="p">);</span>

		<span class="cm">/* hmm, is this really required? we&#39;re resetting the same bit</span>
<span class="cm">		 * immediately thereafter... */</span>
		<span class="n">flags1</span> <span class="o">|=</span> <span class="n">DMA_RUN_SOMETHING1</span><span class="p">;</span>
		<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">,</span> <span class="n">flags1</span><span class="p">);</span>

		<span class="n">flags1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA_RUN_SOMETHING1</span><span class="p">;</span>
		<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">,</span> <span class="n">flags1</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">snd_azf3328_ctrl_codec_activity</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_main_mixer_playback_codec</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* now unmute WaveOut */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">previously_muted</span><span class="p">)</span>
				<span class="n">snd_azf3328_mixer_mute_control_pcm</span><span class="p">(</span>
						<span class="n">chip</span><span class="p">,</span> <span class="mi">0</span>
				<span class="p">);</span>
		<span class="p">}</span>

		<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span><span class="s">&quot;STOPPED %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_SUSPEND</span>:
		<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span><span class="s">&quot;SUSPEND %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="cm">/* make sure codec is stopped */</span>
		<span class="n">snd_azf3328_codec_outw</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">,</span>
			<span class="n">snd_azf3328_codec_inw</span><span class="p">(</span>
				<span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span>
			<span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DMA_RESUME</span>
		<span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_PAUSE_PUSH</span>:
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;FIXME: SNDRV_PCM_TRIGGER_PAUSE_PUSH NIY!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_PAUSE_RELEASE</span>:
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;FIXME: SNDRV_PCM_TRIGGER_PAUSE_RELEASE NIY!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;FIXME: unknown trigger mode!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">snd_pcm_uframes_t</span>
<span class="nf">snd_azf3328_pcm_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span>
		<span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">snd_pcm_uframes_t</span> <span class="n">frmres</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">snd_azf3328_codec_inl</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_CURRPOS</span><span class="p">);</span>

	<span class="cm">/* calculate offset */</span>
<span class="cp">#ifdef QUERY_HARDWARE</span>
	<span class="n">result</span> <span class="o">-=</span> <span class="n">snd_azf3328_codec_inl</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_START_1</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">result</span> <span class="o">-=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">dma_base</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">frmres</span> <span class="o">=</span> <span class="n">bytes_to_frames</span><span class="p">(</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span><span class="s">&quot;%08li %s @ 0x%8lx, frames %8ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">jiffies</span><span class="p">,</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">frmres</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">frmres</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************/</span>

<span class="cp">#ifdef SUPPORT_GAMEPORT</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_gameport_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">enable</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_azf3328_io_reg_setb</span><span class="p">(</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">game_io</span><span class="o">+</span><span class="n">IDX_GAME_HWCONFIG</span><span class="p">,</span>
		<span class="n">GAME_HWCFG_IRQ_ENABLE</span><span class="p">,</span>
		<span class="n">enable</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_gameport_legacy_address_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
					   <span class="n">bool</span> <span class="n">enable</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_azf3328_io_reg_setb</span><span class="p">(</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">game_io</span><span class="o">+</span><span class="n">IDX_GAME_HWCONFIG</span><span class="p">,</span>
		<span class="n">GAME_HWCFG_LEGACY_ADDRESS_ENABLE</span><span class="p">,</span>
		<span class="n">enable</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_gameport_set_counter_frequency</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freq_cfg</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_azf3328_io_reg_setb</span><span class="p">(</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">game_io</span><span class="o">+</span><span class="n">IDX_GAME_HWCONFIG</span><span class="p">,</span>
		<span class="mh">0x02</span><span class="p">,</span>
		<span class="p">(</span><span class="n">freq_cfg</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="p">);</span>
	<span class="n">snd_azf3328_io_reg_setb</span><span class="p">(</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">game_io</span><span class="o">+</span><span class="n">IDX_GAME_HWCONFIG</span><span class="p">,</span>
		<span class="mh">0x04</span><span class="p">,</span>
		<span class="p">(</span><span class="n">freq_cfg</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_gameport_axis_circuit_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_azf3328_ctrl_reg_6AH_update</span><span class="p">(</span>
		<span class="n">chip</span><span class="p">,</span> <span class="n">IO_6A_SOMETHING2_GAMEPORT</span><span class="p">,</span> <span class="n">enable</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_gameport_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * skeleton handler only</span>
<span class="cm">	 * (we do not want axis reading in interrupt handler - too much load!)</span>
<span class="cm">	 */</span>
	<span class="n">snd_azf3328_dbggame</span><span class="p">(</span><span class="s">&quot;gameport irq</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	 <span class="cm">/* this should ACK the gameport IRQ properly, hopefully. */</span>
	<span class="n">snd_azf3328_game_inw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IDX_GAME_AXIS_VALUE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_gameport_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">gameport</span> <span class="o">*</span><span class="n">gameport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">gameport_get_port_data</span><span class="p">(</span><span class="n">gameport</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbggame</span><span class="p">(</span><span class="s">&quot;gameport_open, mode %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GAMEPORT_MODE_COOKED</span>:
	<span class="k">case</span> <span class="n">GAMEPORT_MODE_RAW</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">snd_azf3328_gameport_set_counter_frequency</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span>
				<span class="n">GAME_HWCFG_ADC_COUNTER_FREQ_STD</span><span class="p">);</span>
	<span class="n">snd_azf3328_gameport_axis_circuit_enable</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_gameport_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">gameport</span> <span class="o">*</span><span class="n">gameport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">gameport_get_port_data</span><span class="p">(</span><span class="n">gameport</span><span class="p">);</span>

	<span class="n">snd_azf3328_dbggame</span><span class="p">(</span><span class="s">&quot;gameport_close</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">snd_azf3328_gameport_set_counter_frequency</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span>
				<span class="n">GAME_HWCFG_ADC_COUNTER_FREQ_1_200</span><span class="p">);</span>
	<span class="n">snd_azf3328_gameport_axis_circuit_enable</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_gameport_cooked_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">gameport</span> <span class="o">*</span><span class="n">gameport</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="o">*</span><span class="n">axes</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="o">*</span><span class="n">buttons</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">gameport_get_port_data</span><span class="p">(</span><span class="n">gameport</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">snd_azf3328_game_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IDX_GAME_LEGACY_COMPATIBLE</span><span class="p">);</span>
	<span class="o">*</span><span class="n">buttons</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>

	<span class="cm">/* ok, this one is a bit dirty: cooked_read is being polled by a timer,</span>
<span class="cm">	 * thus we&#39;re atomic and cannot actively wait in here</span>
<span class="cm">	 * (which would be useful for us since it probably would be better</span>
<span class="cm">	 * to trigger a measurement in here, then wait a short amount of</span>
<span class="cm">	 * time until it&#39;s finished, then read values of _this_ measurement).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Thus we simply resort to reading values if they&#39;re available already</span>
<span class="cm">	 * and trigger the next measurement.</span>
<span class="cm">	 */</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">snd_azf3328_game_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IDX_GAME_AXES_CONFIG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">GAME_AXES_SAMPLING_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">axes</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* configure the axis to read */</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0f</span><span class="p">;</span>
			<span class="n">snd_azf3328_game_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IDX_GAME_AXES_CONFIG</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">snd_azf3328_game_inw</span><span class="p">(</span>
						<span class="n">chip</span><span class="p">,</span> <span class="n">IDX_GAME_AXIS_VALUE</span>
					<span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* trigger next sampling of axes, to be evaluated the next time we</span>
<span class="cm">	 * enter this function */</span>

	<span class="cm">/* for some very, very strange reason we cannot enable</span>
<span class="cm">	 * Measurement Ready monitoring for all axes here,</span>
<span class="cm">	 * at least not when only one joystick connected */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span> <span class="cm">/* we&#39;re able to monitor axes 1 and 2 only */</span>
	<span class="n">snd_azf3328_game_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IDX_GAME_AXES_CONFIG</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">snd_azf3328_game_outw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IDX_GAME_AXIS_VALUE</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">axes</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
			<span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">snd_azf3328_dbggame</span><span class="p">(</span><span class="s">&quot;cooked_read: axes %d %d %d %d buttons %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">*</span><span class="n">buttons</span>
	<span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">snd_azf3328_gameport</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gameport</span> <span class="o">*</span><span class="n">gp</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">gameport</span> <span class="o">=</span> <span class="n">gp</span> <span class="o">=</span> <span class="n">gameport_allocate_port</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;azt3328: cannot alloc memory for gameport</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gameport_set_name</span><span class="p">(</span><span class="n">gp</span><span class="p">,</span> <span class="s">&quot;AZF3328 Gameport&quot;</span><span class="p">);</span>
	<span class="n">gameport_set_phys</span><span class="p">(</span><span class="n">gp</span><span class="p">,</span> <span class="s">&quot;pci%s/gameport0&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">));</span>
	<span class="n">gameport_set_dev_parent</span><span class="p">(</span><span class="n">gp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">gp</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">game_io</span><span class="p">;</span>
	<span class="n">gameport_set_port_data</span><span class="p">(</span><span class="n">gp</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>

	<span class="n">gp</span><span class="o">-&gt;</span><span class="n">open</span> <span class="o">=</span> <span class="n">snd_azf3328_gameport_open</span><span class="p">;</span>
	<span class="n">gp</span><span class="o">-&gt;</span><span class="n">close</span> <span class="o">=</span> <span class="n">snd_azf3328_gameport_close</span><span class="p">;</span>
	<span class="n">gp</span><span class="o">-&gt;</span><span class="n">fuzz</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="cm">/* seems ok */</span>
	<span class="n">gp</span><span class="o">-&gt;</span><span class="n">cooked_read</span> <span class="o">=</span> <span class="n">snd_azf3328_gameport_cooked_read</span><span class="p">;</span>

	<span class="cm">/* DISABLE legacy address: we don&#39;t need it! */</span>
	<span class="n">snd_azf3328_gameport_legacy_address_enable</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">snd_azf3328_gameport_set_counter_frequency</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span>
				<span class="n">GAME_HWCFG_ADC_COUNTER_FREQ_1_200</span><span class="p">);</span>
	<span class="n">snd_azf3328_gameport_axis_circuit_enable</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">gameport_register_port</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">gameport</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_gameport_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">gameport</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gameport_unregister_port</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">gameport</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">gameport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">snd_azf3328_gameport_irq_enable</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_gameport</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_gameport_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_gameport_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;huh, game port IRQ occurred!?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* SUPPORT_GAMEPORT */</span><span class="cp"></span>

<span class="cm">/******************************************************************/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_irq_log_unknown_type</span><span class="p">(</span><span class="n">u8</span> <span class="n">which</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span>
	<span class="s">&quot;azt3328: unknown IRQ type (%x) occurred, please report!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">which</span>
	<span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_pcm_interrupt</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">first_codec</span><span class="p">,</span>
			  <span class="n">u8</span> <span class="n">status</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">which</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">snd_azf3328_codec_type</span> <span class="n">codec_type</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">first_codec</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">codec_type</span> <span class="o">=</span> <span class="n">AZF_CODEC_PLAYBACK</span><span class="p">;</span>
		 <span class="n">codec_type</span> <span class="o">&lt;=</span> <span class="n">AZF_CODEC_I2S_OUT</span><span class="p">;</span>
			 <span class="o">++</span><span class="n">codec_type</span><span class="p">,</span> <span class="o">++</span><span class="n">codec</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* skip codec if there&#39;s no interrupt for it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">codec_type</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">which</span> <span class="o">=</span> <span class="n">snd_azf3328_codec_inb</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_IRQTYPE</span><span class="p">);</span>
		<span class="cm">/* ack all IRQ types immediately */</span>
		<span class="n">snd_azf3328_codec_outb</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_IRQTYPE</span><span class="p">,</span> <span class="n">which</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_pcm_period_elapsed</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">);</span>
			<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span><span class="s">&quot;%s period done (#%x), @ %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">codec</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				<span class="n">which</span><span class="p">,</span>
				<span class="n">snd_azf3328_codec_inl</span><span class="p">(</span>
					<span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_CURRPOS</span>
				<span class="p">)</span>
			<span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;azt3328: irq handler problem!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">&amp;</span> <span class="n">IRQ_SOMETHING</span><span class="p">)</span>
			<span class="n">snd_azf3328_irq_log_unknown_type</span><span class="p">(</span><span class="n">which</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">snd_azf3328_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>
<span class="cp">#if DEBUG_CODEC</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_count</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">snd_azf3328_ctrl_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IDX_IO_IRQSTATUS</span><span class="p">);</span>

        <span class="cm">/* fast path out, to ease interrupt sharing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span>
		<span class="p">(</span><span class="n">IRQ_PLAYBACK</span><span class="o">|</span><span class="n">IRQ_RECORDING</span><span class="o">|</span><span class="n">IRQ_I2S_OUT</span>
		<span class="o">|</span><span class="n">IRQ_GAMEPORT</span><span class="o">|</span><span class="n">IRQ_MPU401</span><span class="o">|</span><span class="n">IRQ_TIMER</span><span class="p">)</span>
	<span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span> <span class="cm">/* must be interrupt for another device */</span>

	<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span>
		<span class="s">&quot;irq_count %ld! IDX_IO_IRQSTATUS %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">irq_count</span><span class="o">++</span> <span class="cm">/* debug-only */</span><span class="p">,</span>
			<span class="n">status</span>
	<span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IRQ_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* snd_azf3328_dbgcodec(&quot;timer %ld\n&quot;,</span>
<span class="cm">			snd_azf3328_codec_inl(chip, IDX_IO_TIMER_VALUE)</span>
<span class="cm">				&amp; TIMER_VALUE_MASK</span>
<span class="cm">		); */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">)</span>
			<span class="n">snd_timer_interrupt</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">sticks</span><span class="p">);</span>
		<span class="cm">/* ACK timer */</span>
                <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="n">snd_azf3328_ctrl_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IDX_IO_TIMER_VALUE</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
		<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span><span class="s">&quot;azt3328: timer IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IRQ_PLAYBACK</span><span class="o">|</span><span class="n">IRQ_RECORDING</span><span class="o">|</span><span class="n">IRQ_I2S_OUT</span><span class="p">))</span>
		<span class="n">snd_azf3328_pcm_interrupt</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codecs</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IRQ_GAMEPORT</span><span class="p">)</span>
		<span class="n">snd_azf3328_gameport_interrupt</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* MPU401 has less critical IRQ requirements</span>
<span class="cm">	 * than timer and playback/recording, right? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">IRQ_MPU401</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_mpu401_uart_interrupt</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">rmidi</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>

		<span class="cm">/* hmm, do we have to ack the IRQ here somehow?</span>
<span class="cm">		 * If so, then I don&#39;t know how yet... */</span>
		<span class="n">snd_azf3328_dbgcodec</span><span class="p">(</span><span class="s">&quot;azt3328: MPU401 IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************/</span>

<span class="cm">/* as long as we think we have identical snd_pcm_hardware parameters</span>
<span class="cm">   for playback, capture and i2s out, we can use the same physical struct</span>
<span class="cm">   since the struct is simply being copied into a member.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_pcm_hardware</span> <span class="n">snd_azf3328_hardware</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="cm">/* FIXME!! Correct? */</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span>			<span class="n">SNDRV_PCM_INFO_MMAP</span> <span class="o">|</span>
				<span class="n">SNDRV_PCM_INFO_INTERLEAVED</span> <span class="o">|</span>
				<span class="n">SNDRV_PCM_INFO_MMAP_VALID</span><span class="p">,</span>
	<span class="p">.</span><span class="n">formats</span> <span class="o">=</span>		<span class="n">SNDRV_PCM_FMTBIT_S8</span> <span class="o">|</span>
				<span class="n">SNDRV_PCM_FMTBIT_U8</span> <span class="o">|</span>
				<span class="n">SNDRV_PCM_FMTBIT_S16_LE</span> <span class="o">|</span>
				<span class="n">SNDRV_PCM_FMTBIT_U16_LE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rates</span> <span class="o">=</span>		<span class="n">SNDRV_PCM_RATE_5512</span> <span class="o">|</span>
				<span class="n">SNDRV_PCM_RATE_8000_48000</span> <span class="o">|</span>
				<span class="n">SNDRV_PCM_RATE_KNOT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rate_min</span> <span class="o">=</span>		<span class="n">AZF_FREQ_4000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rate_max</span> <span class="o">=</span>		<span class="n">AZF_FREQ_66200</span><span class="p">,</span>
	<span class="p">.</span><span class="n">channels_min</span> <span class="o">=</span>		<span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">channels_max</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buffer_bytes_max</span> <span class="o">=</span>	<span class="p">(</span><span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="p">),</span>
	<span class="p">.</span><span class="n">period_bytes_min</span> <span class="o">=</span>	<span class="mi">1024</span><span class="p">,</span>
	<span class="p">.</span><span class="n">period_bytes_max</span> <span class="o">=</span>	<span class="p">(</span><span class="mi">32</span><span class="o">*</span><span class="mi">1024</span><span class="p">),</span>
	<span class="cm">/* We simply have two DMA areas (instead of a list of descriptors</span>
<span class="cm">	   such as other cards); I believe that this is a fixed hardware</span>
<span class="cm">	   attribute and there isn&#39;t much driver magic to be done to expand it.</span>
<span class="cm">	   Thus indicate that we have at least and at most 2 periods. */</span>
	<span class="p">.</span><span class="n">periods_min</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">periods_max</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="cm">/* FIXME: maybe that card actually has a FIFO?</span>
<span class="cm">	 * Hmm, it seems newer revisions do have one, but we still don&#39;t know</span>
<span class="cm">	 * its size... */</span>
	<span class="p">.</span><span class="n">fifo_size</span> <span class="o">=</span>		<span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">snd_azf3328_fixed_rates</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">AZF_FREQ_4000</span><span class="p">,</span>
	<span class="n">AZF_FREQ_4800</span><span class="p">,</span>
	<span class="n">AZF_FREQ_5512</span><span class="p">,</span>
	<span class="n">AZF_FREQ_6620</span><span class="p">,</span>
	<span class="n">AZF_FREQ_8000</span><span class="p">,</span>
	<span class="n">AZF_FREQ_9600</span><span class="p">,</span>
	<span class="n">AZF_FREQ_11025</span><span class="p">,</span>
	<span class="n">AZF_FREQ_13240</span><span class="p">,</span>
	<span class="n">AZF_FREQ_16000</span><span class="p">,</span>
	<span class="n">AZF_FREQ_22050</span><span class="p">,</span>
	<span class="n">AZF_FREQ_32000</span><span class="p">,</span>
	<span class="n">AZF_FREQ_44100</span><span class="p">,</span>
	<span class="n">AZF_FREQ_48000</span><span class="p">,</span>
	<span class="n">AZF_FREQ_66200</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_hw_constraint_list</span> <span class="n">snd_azf3328_hw_constraints_rates</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">snd_azf3328_fixed_rates</span><span class="p">),</span>
	<span class="p">.</span><span class="n">list</span> <span class="o">=</span> <span class="n">snd_azf3328_fixed_rates</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*****************************************************************/</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_pcm_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
		     <span class="k">enum</span> <span class="n">snd_azf3328_codec_type</span> <span class="n">codec_type</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codecs</span><span class="p">[</span><span class="n">codec_type</span><span class="p">];</span>

	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">substream</span> <span class="o">=</span> <span class="n">substream</span><span class="p">;</span>

	<span class="cm">/* same parameters for all our codecs - at least we think so... */</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span> <span class="o">=</span> <span class="n">snd_azf3328_hardware</span><span class="p">;</span>

	<span class="n">snd_pcm_hw_constraint_list</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_RATE</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">snd_azf3328_hw_constraints_rates</span><span class="p">);</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">codec</span><span class="p">;</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_pcm_playback_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snd_azf3328_pcm_open</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span> <span class="n">AZF_CODEC_PLAYBACK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_pcm_capture_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snd_azf3328_pcm_open</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span> <span class="n">AZF_CODEC_CAPTURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_pcm_i2s_out_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snd_azf3328_pcm_open</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span> <span class="n">AZF_CODEC_I2S_OUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_pcm_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span>
		<span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">substream</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_ops</span> <span class="n">snd_azf3328_playback_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">snd_azf3328_pcm_playback_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span>	<span class="n">snd_azf3328_pcm_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">snd_pcm_lib_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_params</span> <span class="o">=</span>	<span class="n">snd_azf3328_hw_params</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_free</span> <span class="o">=</span>	<span class="n">snd_azf3328_hw_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare</span> <span class="o">=</span>	<span class="n">snd_azf3328_pcm_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span>	<span class="n">snd_azf3328_pcm_trigger</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pointer</span> <span class="o">=</span>	<span class="n">snd_azf3328_pcm_pointer</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_ops</span> <span class="n">snd_azf3328_capture_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">snd_azf3328_pcm_capture_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span>	<span class="n">snd_azf3328_pcm_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">snd_pcm_lib_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_params</span> <span class="o">=</span>	<span class="n">snd_azf3328_hw_params</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_free</span> <span class="o">=</span>	<span class="n">snd_azf3328_hw_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare</span> <span class="o">=</span>	<span class="n">snd_azf3328_pcm_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span>	<span class="n">snd_azf3328_pcm_trigger</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pointer</span> <span class="o">=</span>	<span class="n">snd_azf3328_pcm_pointer</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_ops</span> <span class="n">snd_azf3328_i2s_out_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">snd_azf3328_pcm_i2s_out_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span>	<span class="n">snd_azf3328_pcm_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">snd_pcm_lib_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_params</span> <span class="o">=</span>	<span class="n">snd_azf3328_hw_params</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_free</span> <span class="o">=</span>	<span class="n">snd_azf3328_hw_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare</span> <span class="o">=</span>	<span class="n">snd_azf3328_pcm_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span>	<span class="n">snd_azf3328_pcm_trigger</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pointer</span> <span class="o">=</span>	<span class="n">snd_azf3328_pcm_pointer</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">snd_azf3328_pcm</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">AZF_PCMDEV_STD</span><span class="p">,</span> <span class="n">AZF_PCMDEV_I2S_OUT</span><span class="p">,</span> <span class="n">NUM_AZF_PCMDEVS</span> <span class="p">};</span> <span class="cm">/* pcm devices */</span>

	<span class="k">struct</span> <span class="n">snd_pcm</span> <span class="o">*</span><span class="n">pcm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_pcm_new</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;AZF3328 DSP&quot;</span><span class="p">,</span> <span class="n">AZF_PCMDEV_STD</span><span class="p">,</span>
								<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">snd_pcm_set_ops</span><span class="p">(</span><span class="n">pcm</span><span class="p">,</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">snd_azf3328_playback_ops</span><span class="p">);</span>
	<span class="n">snd_pcm_set_ops</span><span class="p">(</span><span class="n">pcm</span><span class="p">,</span> <span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">snd_azf3328_capture_ops</span><span class="p">);</span>

	<span class="n">pcm</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">pcm</span><span class="o">-&gt;</span><span class="n">info_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">shortname</span><span class="p">);</span>
	<span class="cm">/* same pcm object for playback/capture (see snd_pcm_new() above) */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="p">[</span><span class="n">AZF_CODEC_PLAYBACK</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcm</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="p">[</span><span class="n">AZF_CODEC_CAPTURE</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcm</span><span class="p">;</span>

	<span class="n">snd_pcm_lib_preallocate_pages_for_all</span><span class="p">(</span><span class="n">pcm</span><span class="p">,</span> <span class="n">SNDRV_DMA_TYPE_DEV</span><span class="p">,</span>
						<span class="n">snd_dma_pci_data</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">),</span>
							<span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_pcm_new</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;AZF3328 I2S OUT&quot;</span><span class="p">,</span> <span class="n">AZF_PCMDEV_I2S_OUT</span><span class="p">,</span>
								<span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">snd_pcm_set_ops</span><span class="p">(</span><span class="n">pcm</span><span class="p">,</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">snd_azf3328_i2s_out_ops</span><span class="p">);</span>

	<span class="n">pcm</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">pcm</span><span class="o">-&gt;</span><span class="n">info_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">shortname</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="p">[</span><span class="n">AZF_CODEC_I2S_OUT</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcm</span><span class="p">;</span>

	<span class="n">snd_pcm_lib_preallocate_pages_for_all</span><span class="p">(</span><span class="n">pcm</span><span class="p">,</span> <span class="n">SNDRV_DMA_TYPE_DEV</span><span class="p">,</span>
						<span class="n">snd_dma_pci_data</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">),</span>
							<span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>

	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************/</span>

<span class="cm">/*** NOTE: the physical timer resolution actually is 1024000 ticks per second</span>
<span class="cm"> *** (probably derived from main crystal via a divider of 24),</span>
<span class="cm"> *** but announcing those attributes to user-space would make programs</span>
<span class="cm"> *** configure the timer to a 1 tick value, resulting in an absolutely fatal</span>
<span class="cm"> *** timer IRQ storm.</span>
<span class="cm"> *** Thus I chose to announce a down-scaled virtual timer to the outside and</span>
<span class="cm"> *** calculate real timer countdown values internally.</span>
<span class="cm"> *** (the scale factor can be set via module parameter &quot;seqtimer_scaling&quot;).</span>
<span class="cm"> ***/</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_timer_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">delay</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">snd_timer_chip</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">delay</span> <span class="o">=</span> <span class="p">((</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">sticks</span> <span class="o">*</span> <span class="n">seqtimer_scaling</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TIMER_VALUE_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delay</span> <span class="o">&lt;</span> <span class="mi">49</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* uhoh, that&#39;s not good, since user-space won&#39;t know about</span>
<span class="cm">		 * this timing tweak</span>
<span class="cm">		 * (we need to do it to avoid a lockup, though) */</span>

		<span class="n">snd_azf3328_dbgtimer</span><span class="p">(</span><span class="s">&quot;delay was too low (%d)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="mi">49</span><span class="p">;</span> <span class="cm">/* minimum time is 49 ticks */</span>
	<span class="p">}</span>
	<span class="n">snd_azf3328_dbgtimer</span><span class="p">(</span><span class="s">&quot;setting timer countdown value %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
	<span class="n">delay</span> <span class="o">|=</span> <span class="n">TIMER_COUNTDOWN_ENABLE</span> <span class="o">|</span> <span class="n">TIMER_IRQ_ENABLE</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">snd_azf3328_ctrl_outl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IDX_IO_TIMER_VALUE</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_timer_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">snd_timer_chip</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* disable timer countdown and interrupt */</span>
	<span class="cm">/* Hmm, should we write TIMER_IRQ_ACK here?</span>
<span class="cm">	   YES indeed, otherwise a rogue timer operation - which prompts</span>
<span class="cm">	   ALSA(?) to call repeated stop() in vain, but NOT start() -</span>
<span class="cm">	   will never end (value 0x03 is kept shown in control byte).</span>
<span class="cm">	   Simply manually poking 0x04 _once_ immediately successfully stops</span>
<span class="cm">	   the hardware/ALSA interrupt activity. */</span>
	<span class="n">snd_azf3328_ctrl_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IDX_IO_TIMER_VALUE</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_timer_precise_resolution</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">num</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">den</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="o">*</span><span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">den</span> <span class="o">=</span> <span class="mi">1024000</span> <span class="o">/</span> <span class="n">seqtimer_scaling</span><span class="p">;</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_timer_hardware</span> <span class="n">snd_azf3328_timer_hw</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">SNDRV_TIMER_HW_AUTO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="mi">977</span><span class="p">,</span> <span class="cm">/* 1000000/1024000 = 0.9765625us */</span>
	<span class="p">.</span><span class="n">ticks</span> <span class="o">=</span> <span class="mi">1024000</span><span class="p">,</span> <span class="cm">/* max tick count, defined by the value register; actually it&#39;s not 1024000, but 1048576, but we don&#39;t care */</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">snd_azf3328_timer_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">snd_azf3328_timer_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">precise_resolution</span> <span class="o">=</span> <span class="n">snd_azf3328_timer_precise_resolution</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">snd_azf3328_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_timer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_timer_id</span> <span class="n">tid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="n">tid</span><span class="p">.</span><span class="n">dev_class</span> <span class="o">=</span> <span class="n">SNDRV_TIMER_CLASS_CARD</span><span class="p">;</span>
	<span class="n">tid</span><span class="p">.</span><span class="n">dev_sclass</span> <span class="o">=</span> <span class="n">SNDRV_TIMER_SCLASS_NONE</span><span class="p">;</span>
	<span class="n">tid</span><span class="p">.</span><span class="n">card</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="n">tid</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">tid</span><span class="p">.</span><span class="n">subdevice</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">snd_azf3328_timer_hw</span><span class="p">.</span><span class="n">resolution</span> <span class="o">*=</span> <span class="n">seqtimer_scaling</span><span class="p">;</span>
	<span class="n">snd_azf3328_timer_hw</span><span class="p">.</span><span class="n">ticks</span> <span class="o">/=</span> <span class="n">seqtimer_scaling</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_timer_new</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;AZF3328&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;AZF3328 timer&quot;</span><span class="p">);</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">hw</span> <span class="o">=</span> <span class="n">snd_azf3328_timer_hw</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">timer</span> <span class="o">=</span> <span class="n">timer</span><span class="p">;</span>

	<span class="n">snd_azf3328_timer_stop</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************/</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">__end_hw</span><span class="p">;</span>

	<span class="n">snd_azf3328_mixer_reset</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="n">snd_azf3328_timer_stop</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">snd_azf3328_gameport_free</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="nl">__end_hw:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_dev_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">device_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snd_azf3328_free</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/* check whether a bit can be modified */</span>
<span class="c">static void</span>
<span class="c">snd_azf3328_test_bit(unsigned unsigned reg, int bit)</span>
<span class="c">{</span>
<span class="c">	unsigned char val, valoff, valon;</span>

<span class="c">	val = inb(reg);</span>

<span class="c">	outb(val &amp; ~(1 &lt;&lt; bit), reg);</span>
<span class="c">	valoff = inb(reg);</span>

<span class="c">	outb(val|(1 &lt;&lt; bit), reg);</span>
<span class="c">	valon = inb(reg);</span>

<span class="c">	outb(val, reg);</span>

<span class="c">	printk(KERN_DEBUG &quot;reg %04x bit %d: %02x %02x %02x\n&quot;,</span>
<span class="c">				reg, bit, val, valoff, valon</span>
<span class="c">	);</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_debug_show_ports</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if DEBUG_MISC</span>
	<span class="n">u16</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgmisc</span><span class="p">(</span>
		<span class="s">&quot;ctrl_io 0x%lx, game_io 0x%lx, mpu_io 0x%lx, &quot;</span>
		<span class="s">&quot;opl3_io 0x%lx, mixer_io 0x%lx, irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ctrl_io</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">game_io</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mpu_io</span><span class="p">,</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">opl3_io</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_io</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span>
	<span class="p">);</span>

	<span class="n">snd_azf3328_dbgmisc</span><span class="p">(</span><span class="s">&quot;game %02x %02x %02x %02x %02x %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">snd_azf3328_game_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">snd_azf3328_game_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">snd_azf3328_game_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
		<span class="n">snd_azf3328_game_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
		<span class="n">snd_azf3328_game_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">snd_azf3328_game_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
	<span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="mh">0x07</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">snd_azf3328_dbgmisc</span><span class="p">(</span><span class="s">&quot;mpu_io 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inb</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mpu_io</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">&lt;=</span> <span class="mh">0x07</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">snd_azf3328_dbgmisc</span><span class="p">(</span><span class="s">&quot;0x%02x: game200 0x%04x, game208 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tmp</span><span class="p">,</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0x200</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">),</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0x208</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">&lt;=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">snd_azf3328_dbgmisc</span><span class="p">(</span>
			<span class="s">&quot;0x%02x: mpu300 0x%04x, mpu310 0x%04x, mpu320 0x%04x, &quot;</span>
			<span class="s">&quot;mpu330 0x%04x opl388 0x%04x opl38c 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">tmp</span><span class="p">,</span>
				<span class="n">inb</span><span class="p">(</span><span class="mh">0x300</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">),</span>
				<span class="n">inb</span><span class="p">(</span><span class="mh">0x310</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">),</span>
				<span class="n">inb</span><span class="p">(</span><span class="mh">0x320</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">),</span>
				<span class="n">inb</span><span class="p">(</span><span class="mh">0x330</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">),</span>
				<span class="n">inb</span><span class="p">(</span><span class="mh">0x388</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">),</span>
				<span class="n">inb</span><span class="p">(</span><span class="mh">0x38c</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">)</span>
		<span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">AZF_IO_SIZE_CTRL</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">snd_azf3328_dbgmisc</span><span class="p">(</span><span class="s">&quot;ctrl 0x%02x: 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tmp</span><span class="p">,</span> <span class="n">snd_azf3328_ctrl_inw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
		<span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">AZF_IO_SIZE_MIXER</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">snd_azf3328_dbgmisc</span><span class="p">(</span><span class="s">&quot;mixer 0x%02x: 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tmp</span><span class="p">,</span> <span class="n">snd_azf3328_mixer_inw</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
		<span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG_MISC */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">snd_azf3328_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">device_type</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">**</span><span class="n">rchip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_device_ops</span> <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">dev_free</span> <span class="o">=</span>     <span class="n">snd_azf3328_dev_free</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="n">u8</span> <span class="n">dma_init</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">snd_azf3328_codec_type</span> <span class="n">codec_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec_setup</span><span class="p">;</span>

	<span class="o">*</span><span class="n">rchip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">chip</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chip</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span> <span class="o">=</span> <span class="n">card</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pci</span> <span class="o">=</span> <span class="n">pci</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* check if we can restrict PCI DMA transfers to 24 bits */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">24</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">24</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;architecture does not support &quot;</span>
					<span class="s">&quot;24bit PCI busmaster DMA</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="s">&quot;Aztech AZF3328&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ctrl_io</span>  <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">game_io</span>  <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">mpu_io</span>   <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">opl3_io</span>  <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_io</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">codec_setup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codecs</span><span class="p">[</span><span class="n">AZF_CODEC_PLAYBACK</span><span class="p">];</span>
	<span class="n">codec_setup</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ctrl_io</span> <span class="o">+</span> <span class="n">AZF_IO_OFFS_CODEC_PLAYBACK</span><span class="p">;</span>
	<span class="n">codec_setup</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">;</span>
	<span class="n">codec_setup</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">AZF_CODEC_PLAYBACK</span><span class="p">;</span>
	<span class="n">codec_setup</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;PLAYBACK&quot;</span><span class="p">;</span>

	<span class="n">codec_setup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codecs</span><span class="p">[</span><span class="n">AZF_CODEC_CAPTURE</span><span class="p">];</span>
	<span class="n">codec_setup</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ctrl_io</span> <span class="o">+</span> <span class="n">AZF_IO_OFFS_CODEC_CAPTURE</span><span class="p">;</span>
	<span class="n">codec_setup</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">;</span>
	<span class="n">codec_setup</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">AZF_CODEC_CAPTURE</span><span class="p">;</span>
	<span class="n">codec_setup</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;CAPTURE&quot;</span><span class="p">;</span>

	<span class="n">codec_setup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codecs</span><span class="p">[</span><span class="n">AZF_CODEC_I2S_OUT</span><span class="p">];</span>
	<span class="n">codec_setup</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ctrl_io</span> <span class="o">+</span> <span class="n">AZF_IO_OFFS_CODEC_I2S_OUT</span><span class="p">;</span>
	<span class="n">codec_setup</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">;</span>
	<span class="n">codec_setup</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">AZF_CODEC_I2S_OUT</span><span class="p">;</span>
	<span class="n">codec_setup</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;I2S_OUT&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">snd_azf3328_interrupt</span><span class="p">,</span>
			<span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">KBUILD_MODNAME</span><span class="p">,</span> <span class="n">chip</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;unable to grab IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pci</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">snd_azf3328_debug_show_ports</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_device_new</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">SNDRV_DEV_LOWLEVEL</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="cm">/* create mixer interface &amp; switches */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_azf3328_mixer_new</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="cm">/* standard codec init stuff */</span>
		<span class="cm">/* default DMA init value */</span>
	<span class="n">dma_init</span> <span class="o">=</span> <span class="n">DMA_RUN_SOMETHING2</span><span class="o">|</span><span class="n">DMA_EPILOGUE_SOMETHING</span><span class="o">|</span><span class="n">DMA_SOMETHING_ELSE</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">codec_type</span> <span class="o">=</span> <span class="n">AZF_CODEC_PLAYBACK</span><span class="p">;</span>
		<span class="n">codec_type</span> <span class="o">&lt;=</span> <span class="n">AZF_CODEC_I2S_OUT</span><span class="p">;</span> <span class="o">++</span><span class="n">codec_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">snd_azf3328_codec_data</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span>
			 <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">codecs</span><span class="p">[</span><span class="n">codec_type</span><span class="p">];</span>

		<span class="cm">/* shutdown codecs to reduce power / noise */</span>
			<span class="cm">/* have ...ctrl_codec_activity() act properly */</span>
		<span class="n">codec</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">snd_azf3328_ctrl_codec_activity</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">codec_type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">snd_azf3328_codec_outb</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">IDX_IO_CODEC_DMA_FLAGS</span><span class="p">,</span>
						 <span class="n">dma_init</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">snd_card_set_dev</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="o">*</span><span class="n">rchip</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="p">)</span>
		<span class="n">snd_azf3328_free</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">snd_azf3328_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">pci_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_opl3</span> <span class="o">*</span><span class="n">opl3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&gt;=</span> <span class="n">SNDRV_CARDS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable</span><span class="p">[</span><span class="n">dev</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">++</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_card_create</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">dev</span><span class="p">],</span> <span class="n">id</span><span class="p">[</span><span class="n">dev</span><span class="p">],</span> <span class="n">THIS_MODULE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">card</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="s">&quot;AZF3328&quot;</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">shortname</span><span class="p">,</span> <span class="s">&quot;Aztech AZF3328 (PCI168)&quot;</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_azf3328_create</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">pci</span><span class="p">,</span> <span class="n">pci_id</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">card</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>

	<span class="cm">/* chose to use MPU401_HW_AZT2320 ID instead of MPU401_HW_MPU401,</span>
<span class="cm">	   since our hardware ought to be similar, thus use same ID. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_mpu401_uart_new</span><span class="p">(</span>
		<span class="n">card</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">MPU401_HW_AZT2320</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mpu_io</span><span class="p">,</span>
		<span class="n">MPU401_INFO_INTEGRATED</span> <span class="o">|</span> <span class="n">MPU401_INFO_IRQ_HOOK</span><span class="p">,</span>
		<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rmidi</span>
	<span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;azf3328: no MPU-401 device at 0x%lx?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">mpu_io</span>
		<span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_azf3328_timer</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_azf3328_pcm</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_opl3_create</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">opl3_io</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">opl3_io</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span>
			    <span class="n">OPL3_HW_AUTO</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opl3</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;azf3328: no OPL3 device at 0x%lx-0x%lx?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">chip</span><span class="o">-&gt;</span><span class="n">opl3_io</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">opl3_io</span><span class="o">+</span><span class="mi">2</span>
		<span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* need to use IDs 1, 2 since ID 0 is snd_azf3328_timer above */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">snd_opl3_timer_new</span><span class="p">(</span><span class="n">opl3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">snd_opl3_hwdep_new</span><span class="p">(</span><span class="n">opl3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="n">opl3</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">longname</span><span class="p">,</span> <span class="s">&quot;%s at 0x%lx, irq %i&quot;</span><span class="p">,</span>
		<span class="n">card</span><span class="o">-&gt;</span><span class="n">shortname</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ctrl_io</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_card_register</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

<span class="cp">#ifdef MODULE</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
<span class="s">&quot;azt3328: Sound driver for Aztech AZF3328-based soundcards such as PCI168.</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;azt3328: Hardware was completely undocumented, unfortunately.</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;azt3328: Feel free to contact andi AT lisas.de for bug reports etc.!</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;azt3328: User-scalable sequencer timer set to %dHz (1024000Hz / %d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	<span class="mi">1024000</span> <span class="o">/</span> <span class="n">seqtimer_scaling</span><span class="p">,</span> <span class="n">seqtimer_scaling</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">snd_azf3328_gameport</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">card</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">++</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;azf3328: something failed, exiting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">snd_card_free</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span>
<span class="nf">snd_azf3328_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_azf3328_dbgcallenter</span><span class="p">();</span>
	<span class="n">snd_card_free</span><span class="p">(</span><span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">));</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">snd_azf3328_dbgcallleave</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_suspend_regs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">count</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">saved_regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">reg</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">saved_regs</span> <span class="o">=</span> <span class="n">inl</span><span class="p">(</span><span class="n">io_addr</span><span class="p">);</span>
		<span class="n">snd_azf3328_dbgpm</span><span class="p">(</span><span class="s">&quot;suspend: io 0x%04lx: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">io_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">saved_regs</span><span class="p">);</span>
		<span class="o">++</span><span class="n">saved_regs</span><span class="p">;</span>
		<span class="n">io_addr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">saved_regs</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_resume_regs</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">saved_regs</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">count</span>
<span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">reg</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outl</span><span class="p">(</span><span class="o">*</span><span class="n">saved_regs</span><span class="p">,</span> <span class="n">io_addr</span><span class="p">);</span>
		<span class="n">snd_azf3328_dbgpm</span><span class="p">(</span><span class="s">&quot;resume: io 0x%04lx: 0x%08x --&gt; 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">io_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">saved_regs</span><span class="p">,</span> <span class="n">inl</span><span class="p">(</span><span class="n">io_addr</span><span class="p">));</span>
		<span class="o">++</span><span class="n">saved_regs</span><span class="p">;</span>
		<span class="n">io_addr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">saved_regs</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_suspend_ac97</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef AZF_USE_AC97_LAYER</span>
	<span class="n">snd_ac97_suspend</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ac97</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">snd_azf3328_suspend_regs</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_io</span><span class="p">,</span>
		<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_mixer</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_mixer</span><span class="p">);</span>

	<span class="cm">/* make sure to disable master volume etc. to prevent looping sound */</span>
	<span class="n">snd_azf3328_mixer_mute_control_master</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">snd_azf3328_mixer_mute_control_pcm</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* AZF_USE_AC97_LAYER */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">snd_azf3328_resume_ac97</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef AZF_USE_AC97_LAYER</span>
	<span class="n">snd_ac97_resume</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ac97</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">snd_azf3328_resume_regs</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_mixer</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_io</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_mixer</span><span class="p">));</span>

	<span class="cm">/* unfortunately with 32bit transfers, IDX_MIXER_PLAY_MASTER (0x02)</span>
<span class="cm">	   and IDX_MIXER_RESET (offset 0x00) get touched at the same time,</span>
<span class="cm">	   resulting in a mixer reset condition persisting until _after_</span>
<span class="cm">	   master vol was restored. Thus master vol needs an extra restore. */</span>
	<span class="n">outw</span><span class="p">(((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_mixer</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_io</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* AZF_USE_AC97_LAYER */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">saved_regs_ctrl_u16</span><span class="p">;</span>

	<span class="n">snd_power_change_state</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">SNDRV_CTL_POWER_D3hot</span><span class="p">);</span>

	<span class="cm">/* same pcm object for playback/capture */</span>
	<span class="n">snd_pcm_suspend_all</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="p">[</span><span class="n">AZF_CODEC_PLAYBACK</span><span class="p">]);</span>
	<span class="n">snd_pcm_suspend_all</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="p">[</span><span class="n">AZF_CODEC_I2S_OUT</span><span class="p">]);</span>

	<span class="n">snd_azf3328_suspend_ac97</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="n">snd_azf3328_suspend_regs</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ctrl_io</span><span class="p">,</span>
		<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_ctrl</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_ctrl</span><span class="p">);</span>

	<span class="cm">/* manually store the one currently relevant write-only reg, too */</span>
	<span class="n">saved_regs_ctrl_u16</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_ctrl</span><span class="p">;</span>
	<span class="n">saved_regs_ctrl_u16</span><span class="p">[</span><span class="n">IDX_IO_6AH</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">shadow_reg_ctrl_6AH</span><span class="p">;</span>

	<span class="n">snd_azf3328_suspend_regs</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">game_io</span><span class="p">,</span>
		<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_game</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_game</span><span class="p">);</span>
	<span class="n">snd_azf3328_suspend_regs</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mpu_io</span><span class="p">,</span>
		<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_mpu</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_mpu</span><span class="p">);</span>
	<span class="n">snd_azf3328_suspend_regs</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">opl3_io</span><span class="p">,</span>
		<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_opl3</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_opl3</span><span class="p">);</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">snd_azf3328_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">snd_azf3328</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">card</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pci</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;azt3328: pci_enable_device failed, &quot;</span>
		       <span class="s">&quot;disabling device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">snd_card_disconnect</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pci</span><span class="p">);</span>

	<span class="n">snd_azf3328_resume_regs</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_game</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">game_io</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_game</span><span class="p">));</span>
	<span class="n">snd_azf3328_resume_regs</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_mpu</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mpu_io</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_mpu</span><span class="p">));</span>
	<span class="n">snd_azf3328_resume_regs</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_opl3</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">opl3_io</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_opl3</span><span class="p">));</span>

	<span class="n">snd_azf3328_resume_ac97</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="n">snd_azf3328_resume_regs</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_ctrl</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ctrl_io</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">saved_regs_ctrl</span><span class="p">));</span>

	<span class="n">snd_power_change_state</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">SNDRV_CTL_POWER_D0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">azf3328_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">KBUILD_MODNAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">snd_azf3328_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">snd_azf3328_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">snd_azf3328_remove</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">snd_azf3328_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">snd_azf3328_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="n">module_pci_driver</span><span class="p">(</span><span class="n">azf3328_driver</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
