<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › pci › mixart › mixart_core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mixart_core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Driver for Digigram miXart soundcards</span>
<span class="cm"> *</span>
<span class="cm"> * low level interface with interrupt handling and mail box implementation</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003 by Digigram &lt;alsa@digigram.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *   GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;sound/core.h&gt;</span>
<span class="cp">#include &quot;mixart.h&quot;</span>
<span class="cp">#include &quot;mixart_hwdep.h&quot;</span>
<span class="cp">#include &quot;mixart_core.h&quot;</span>


<span class="cp">#define MSG_TIMEOUT_JIFFIES         (400 * HZ) / 1000 </span><span class="cm">/* 400 ms */</span><span class="cp"></span>

<span class="cp">#define MSG_DESCRIPTOR_SIZE         0x24</span>
<span class="cp">#define MSG_HEADER_SIZE             (MSG_DESCRIPTOR_SIZE + 4)</span>

<span class="cp">#define MSG_DEFAULT_SIZE            512</span>

<span class="cp">#define MSG_TYPE_MASK               0x00000003    </span><span class="cm">/* mask for following types */</span><span class="cp"></span>
<span class="cp">#define MSG_TYPE_NOTIFY             0             </span><span class="cm">/* embedded -&gt; driver (only notification, do not get_msg() !) */</span><span class="cp"></span>
<span class="cp">#define MSG_TYPE_COMMAND            1             </span><span class="cm">/* driver &lt;-&gt; embedded (a command has no answer) */</span><span class="cp"></span>
<span class="cp">#define MSG_TYPE_REQUEST            2             </span><span class="cm">/* driver -&gt; embedded (request will get an answer back) */</span><span class="cp"></span>
<span class="cp">#define MSG_TYPE_ANSWER             3             </span><span class="cm">/* embedded -&gt; driver */</span><span class="cp"></span>
<span class="cp">#define MSG_CANCEL_NOTIFY_MASK      0x80000000    </span><span class="cm">/* this bit is set for a notification that has been canceled */</span><span class="cp"></span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">retrieve_msg_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">mixart_mgr</span> <span class="o">*</span><span class="n">mgr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">msg_frame</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* read the message frame fifo */</span>
	<span class="n">u32</span> <span class="n">headptr</span><span class="p">,</span> <span class="n">tailptr</span><span class="p">;</span>

	<span class="n">tailptr</span> <span class="o">=</span> <span class="n">readl_be</span><span class="p">(</span><span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MSG_OUTBOUND_POST_TAIL</span><span class="p">));</span>
	<span class="n">headptr</span> <span class="o">=</span> <span class="n">readl_be</span><span class="p">(</span><span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MSG_OUTBOUND_POST_HEAD</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tailptr</span> <span class="o">==</span> <span class="n">headptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* no message posted */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tailptr</span> <span class="o">&lt;</span> <span class="n">MSG_OUTBOUND_POST_STACK</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tailptr</span> <span class="o">&gt;=</span> <span class="n">MSG_OUTBOUND_POST_STACK</span> <span class="o">+</span> <span class="n">MSG_BOUND_STACK_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* error */</span>

	<span class="o">*</span><span class="n">msg_frame</span> <span class="o">=</span> <span class="n">readl_be</span><span class="p">(</span><span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">tailptr</span><span class="p">));</span>

	<span class="cm">/* increment the tail index */</span>
	<span class="n">tailptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">tailptr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">MSG_OUTBOUND_POST_STACK</span><span class="o">+</span><span class="n">MSG_BOUND_STACK_SIZE</span><span class="p">)</span> <span class="p">)</span>
		<span class="n">tailptr</span> <span class="o">=</span> <span class="n">MSG_OUTBOUND_POST_STACK</span><span class="p">;</span>
	<span class="n">writel_be</span><span class="p">(</span><span class="n">tailptr</span><span class="p">,</span> <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MSG_OUTBOUND_POST_TAIL</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">mixart_mgr</span> <span class="o">*</span><span class="n">mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mixart_msg</span> <span class="o">*</span><span class="n">resp</span><span class="p">,</span>
		   <span class="n">u32</span> <span class="n">msg_frame_address</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span>  <span class="n">headptr</span><span class="p">;</span>
	<span class="n">u32</span>  <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">err</span><span class="p">;</span>
<span class="cp">#ifndef __BIG_ENDIAN</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* copy message descriptor from miXart to driver */</span>
	<span class="n">size</span>                <span class="o">=</span>  <span class="n">readl_be</span><span class="p">(</span><span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span><span class="p">));</span>       <span class="cm">/* size of descriptor + response */</span>
	<span class="n">resp</span><span class="o">-&gt;</span><span class="n">message_id</span>    <span class="o">=</span>  <span class="n">readl_be</span><span class="p">(</span><span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>   <span class="cm">/* dwMessageID */</span>
	<span class="n">resp</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">object_id</span> <span class="o">=</span>  <span class="n">readl_be</span><span class="p">(</span><span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span> <span class="o">+</span> <span class="mi">8</span><span class="p">));</span>   <span class="cm">/* uidDest */</span>
	<span class="n">resp</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">desc</span>      <span class="o">=</span>  <span class="n">readl_be</span><span class="p">(</span><span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span> <span class="o">+</span> <span class="mi">12</span><span class="p">));</span>  <span class="cm">/* */</span>

	<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">MSG_DESCRIPTOR_SIZE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">resp</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">MSG_DESCRIPTOR_SIZE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;problem with response size = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">_clean_exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="n">MSG_DESCRIPTOR_SIZE</span><span class="p">;</span>

	<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">resp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span> <span class="o">+</span> <span class="n">MSG_HEADER_SIZE</span> <span class="p">),</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">resp</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* swap if necessary */</span>
<span class="cp">#ifndef __BIG_ENDIAN</span>
	<span class="n">size</span> <span class="o">/=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* u32 size */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">((</span><span class="n">u32</span><span class="o">*</span><span class="p">)</span><span class="n">resp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(((</span><span class="n">u32</span><span class="o">*</span><span class="p">)</span><span class="n">resp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * free message frame address</span>
<span class="cm">	 */</span>
	<span class="n">headptr</span> <span class="o">=</span> <span class="n">readl_be</span><span class="p">(</span><span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MSG_OUTBOUND_FREE_HEAD</span><span class="p">));</span>

	<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">headptr</span> <span class="o">&lt;</span> <span class="n">MSG_OUTBOUND_FREE_STACK</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span> <span class="n">headptr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">MSG_OUTBOUND_FREE_STACK</span><span class="o">+</span><span class="n">MSG_BOUND_STACK_SIZE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">_clean_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* give address back to outbound fifo */</span>
	<span class="n">writel_be</span><span class="p">(</span><span class="n">msg_frame_address</span><span class="p">,</span> <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">headptr</span><span class="p">));</span>

	<span class="cm">/* increment the outbound free head */</span>
	<span class="n">headptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">headptr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">MSG_OUTBOUND_FREE_STACK</span><span class="o">+</span><span class="n">MSG_BOUND_STACK_SIZE</span><span class="p">)</span> <span class="p">)</span>
		<span class="n">headptr</span> <span class="o">=</span> <span class="n">MSG_OUTBOUND_FREE_STACK</span><span class="p">;</span>

	<span class="n">writel_be</span><span class="p">(</span><span class="n">headptr</span><span class="p">,</span> <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MSG_OUTBOUND_FREE_HEAD</span><span class="p">));</span>

 <span class="nl">_clean_exit:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * send a message to miXart. return: the msg_frame used for this message</span>
<span class="cm"> */</span>
<span class="cm">/* call with mgr-&gt;msg_lock held! */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_msg</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mixart_mgr</span> <span class="o">*</span><span class="n">mgr</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">mixart_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">max_answersize</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">mark_pending</span><span class="p">,</span>
		     <span class="n">u32</span> <span class="o">*</span><span class="n">msg_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">headptr</span><span class="p">,</span> <span class="n">tailptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_frame_address</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">%</span> <span class="mi">4</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* get message frame address */</span>
	<span class="n">tailptr</span> <span class="o">=</span> <span class="n">readl_be</span><span class="p">(</span><span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MSG_INBOUND_FREE_TAIL</span><span class="p">));</span>
	<span class="n">headptr</span> <span class="o">=</span> <span class="n">readl_be</span><span class="p">(</span><span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MSG_INBOUND_FREE_HEAD</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tailptr</span> <span class="o">==</span> <span class="n">headptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;error: no message frame available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">tailptr</span> <span class="o">&lt;</span> <span class="n">MSG_INBOUND_FREE_STACK</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tailptr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">MSG_INBOUND_FREE_STACK</span><span class="o">+</span><span class="n">MSG_BOUND_STACK_SIZE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msg_frame_address</span> <span class="o">=</span> <span class="n">readl_be</span><span class="p">(</span><span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">tailptr</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">tailptr</span><span class="p">));</span> <span class="cm">/* set address to zero on this fifo position */</span>

	<span class="cm">/* increment the inbound free tail */</span>
	<span class="n">tailptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">tailptr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">MSG_INBOUND_FREE_STACK</span><span class="o">+</span><span class="n">MSG_BOUND_STACK_SIZE</span><span class="p">)</span> <span class="p">)</span>
		<span class="n">tailptr</span> <span class="o">=</span> <span class="n">MSG_INBOUND_FREE_STACK</span><span class="p">;</span>

	<span class="n">writel_be</span><span class="p">(</span><span class="n">tailptr</span><span class="p">,</span> <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MSG_INBOUND_FREE_TAIL</span><span class="p">));</span>

	<span class="cm">/* TODO : use memcpy_toio() with intermediate buffer to copy the message */</span>

	<span class="cm">/* copy message descriptor to card memory */</span>
	<span class="n">writel_be</span><span class="p">(</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+</span> <span class="n">MSG_DESCRIPTOR_SIZE</span><span class="p">,</span>      <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span><span class="p">)</span> <span class="p">);</span>      <span class="cm">/* size of descriptor + request */</span>
	<span class="n">writel_be</span><span class="p">(</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">message_id</span> <span class="p">,</span>                     <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="p">);</span>  <span class="cm">/* dwMessageID */</span>
	<span class="n">writel_be</span><span class="p">(</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">object_id</span><span class="p">,</span>                   <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="p">);</span>  <span class="cm">/* uidDest */</span>
	<span class="n">writel_be</span><span class="p">(</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span>                        <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span> <span class="o">+</span> <span class="mi">12</span><span class="p">)</span> <span class="p">);</span> <span class="cm">/* */</span>
	<span class="n">writel_be</span><span class="p">(</span> <span class="n">MSG_DESCRIPTOR_SIZE</span><span class="p">,</span>                  <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="p">);</span> <span class="cm">/* SizeHeader */</span>
	<span class="n">writel_be</span><span class="p">(</span> <span class="n">MSG_DESCRIPTOR_SIZE</span><span class="p">,</span>                  <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span> <span class="o">+</span> <span class="mi">20</span><span class="p">)</span> <span class="p">);</span> <span class="cm">/* OffsetDLL_T16 */</span>
	<span class="n">writel_be</span><span class="p">(</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>                            <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span> <span class="o">+</span> <span class="mi">24</span><span class="p">)</span> <span class="p">);</span> <span class="cm">/* SizeDLL_T16 */</span>
	<span class="n">writel_be</span><span class="p">(</span> <span class="n">MSG_DESCRIPTOR_SIZE</span><span class="p">,</span>                  <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span> <span class="o">+</span> <span class="mi">28</span><span class="p">)</span> <span class="p">);</span> <span class="cm">/* OffsetDLL_DRV */</span>
	<span class="n">writel_be</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span>                                    <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span> <span class="p">);</span> <span class="cm">/* SizeDLL_DRV */</span>
	<span class="n">writel_be</span><span class="p">(</span> <span class="n">MSG_DESCRIPTOR_SIZE</span> <span class="o">+</span> <span class="n">max_answersize</span><span class="p">,</span> <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">msg_frame_address</span> <span class="o">+</span> <span class="mi">36</span><span class="p">)</span> <span class="p">);</span> <span class="cm">/* dwExpectedAnswerSize */</span>

	<span class="cm">/* copy message data to card memory */</span>
	<span class="k">for</span><span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">4</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">writel_be</span><span class="p">(</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span> <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MSG_HEADER_SIZE</span> <span class="o">+</span> <span class="n">msg_frame_address</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>  <span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">mark_pending</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">msg_event</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* the pending event is the notification we wait for ! */</span>
			<span class="n">mgr</span><span class="o">-&gt;</span><span class="n">pending_event</span> <span class="o">=</span> <span class="o">*</span><span class="n">msg_event</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* the pending event is the answer we wait for (same address than the request)! */</span>
			<span class="n">mgr</span><span class="o">-&gt;</span><span class="n">pending_event</span> <span class="o">=</span> <span class="n">msg_frame_address</span><span class="p">;</span>

			<span class="cm">/* copy address back to caller */</span>
			<span class="o">*</span><span class="n">msg_event</span> <span class="o">=</span> <span class="n">msg_frame_address</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* mark the frame as a request (will have an answer) */</span>
	<span class="n">msg_frame_address</span> <span class="o">|=</span> <span class="n">MSG_TYPE_REQUEST</span><span class="p">;</span>

	<span class="cm">/* post the frame */</span>
	<span class="n">headptr</span> <span class="o">=</span> <span class="n">readl_be</span><span class="p">(</span><span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MSG_INBOUND_POST_HEAD</span><span class="p">));</span>

	<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">headptr</span> <span class="o">&lt;</span> <span class="n">MSG_INBOUND_POST_STACK</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">headptr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">MSG_INBOUND_POST_STACK</span><span class="o">+</span><span class="n">MSG_BOUND_STACK_SIZE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">writel_be</span><span class="p">(</span><span class="n">msg_frame_address</span><span class="p">,</span> <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">headptr</span><span class="p">));</span>

	<span class="cm">/* increment the inbound post head */</span>
	<span class="n">headptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">headptr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">MSG_INBOUND_POST_STACK</span><span class="o">+</span><span class="n">MSG_BOUND_STACK_SIZE</span><span class="p">)</span> <span class="p">)</span>
		<span class="n">headptr</span> <span class="o">=</span> <span class="n">MSG_INBOUND_POST_STACK</span><span class="p">;</span>

	<span class="n">writel_be</span><span class="p">(</span><span class="n">headptr</span><span class="p">,</span> <span class="n">MIXART_MEM</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MSG_INBOUND_POST_HEAD</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">snd_mixart_send_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">mixart_mgr</span> <span class="o">*</span><span class="n">mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mixart_msg</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_resp_size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">resp_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mixart_msg</span> <span class="n">resp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_frame</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* set to 0, so it&#39;s no notification to wait for, but the answer */</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_mutex</span><span class="p">);</span>

	<span class="n">init_waitqueue_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_lock</span><span class="p">);</span>
	<span class="cm">/* send the message */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">send_msg</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">max_resp_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_frame</span><span class="p">);</span>  <span class="cm">/* send and mark the answer pending */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_sleep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_lock</span><span class="p">);</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">MSG_TIMEOUT_JIFFIES</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_sleep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* error - no ack */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_mutex</span><span class="p">);</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;error: no response on msg %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg_frame</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* retrieve the answer into the same struct mixart_msg */</span>
	<span class="n">resp</span><span class="p">.</span><span class="n">message_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">resp</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mixart_uid</span><span class="p">){</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">resp</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">resp_data</span><span class="p">;</span>
	<span class="n">resp</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">max_resp_size</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">get_msg</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resp</span><span class="p">,</span> <span class="n">msg_frame</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">message_id</span> <span class="o">!=</span> <span class="n">resp</span><span class="p">.</span><span class="n">message_id</span> <span class="p">)</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;RESPONSE ERROR!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">snd_mixart_send_msg_wait_notif</span><span class="p">(</span><span class="k">struct</span> <span class="n">mixart_mgr</span> <span class="o">*</span><span class="n">mgr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">mixart_msg</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span> <span class="n">u32</span> <span class="n">notif_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">notif_event</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">((</span><span class="n">notif_event</span> <span class="o">&amp;</span> <span class="n">MSG_TYPE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MSG_TYPE_NOTIFY</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">notif_event</span> <span class="o">&amp;</span> <span class="n">MSG_CANCEL_NOTIFY_MASK</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_mutex</span><span class="p">);</span>

	<span class="n">init_waitqueue_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_lock</span><span class="p">);</span>
	<span class="cm">/* send the message */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">send_msg</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">MSG_DEFAULT_SIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">notif_event</span><span class="p">);</span>  <span class="cm">/* send and mark the notification event pending */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_sleep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_lock</span><span class="p">);</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">MSG_TIMEOUT_JIFFIES</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_sleep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* error - no ack */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_mutex</span><span class="p">);</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;error: notification %x not received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">notif_event</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">snd_mixart_send_msg_nonblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mixart_mgr</span> <span class="o">*</span><span class="n">mgr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mixart_msg</span> <span class="o">*</span><span class="n">request</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">message_frame</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* just send the message (do not mark it as a pending one) */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">send_msg</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">MSG_DEFAULT_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">message_frame</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* the answer will be handled by snd_struct mixart_msgasklet()  */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_processed</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* common buffer of tasklet and interrupt to send/receive messages */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">mixart_msg_data</span><span class="p">[</span><span class="n">MSG_DEFAULT_SIZE</span> <span class="o">/</span> <span class="mi">4</span><span class="p">];</span>


<span class="kt">void</span> <span class="nf">snd_mixart_msg_tasklet</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mixart_mgr</span> <span class="o">*</span><span class="n">mgr</span> <span class="o">=</span> <span class="p">(</span> <span class="k">struct</span> <span class="n">mixart_mgr</span><span class="o">*</span><span class="p">)(</span><span class="n">arg</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mixart_msg</span> <span class="n">resp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_fifo_readptr</span> <span class="o">!=</span> <span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_fifo_writeptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_fifo</span><span class="p">[</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_fifo_readptr</span><span class="p">];</span>
		<span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_fifo_readptr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_fifo_readptr</span> <span class="o">%=</span> <span class="n">MSG_FIFO_SIZE</span><span class="p">;</span>

		<span class="cm">/* process the message ... */</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MSG_TYPE_MASK</span><span class="p">;</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">&amp;</span> <span class="n">MSG_TYPE_MASK</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MSG_TYPE_ANSWER</span>:
			<span class="cm">/* answer to a message on that we did not wait for (send_msg_nonblock) */</span>
			<span class="n">resp</span><span class="p">.</span><span class="n">message_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">resp</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">mixart_msg_data</span><span class="p">;</span>
			<span class="n">resp</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mixart_msg_data</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">get_msg</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resp</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;tasklet: error(%d) reading mf %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">switch</span><span class="p">(</span><span class="n">resp</span><span class="p">.</span><span class="n">message_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">MSG_STREAM_START_INPUT_STAGE_PACKET</span>:
			<span class="k">case</span> <span class="n">MSG_STREAM_START_OUTPUT_STAGE_PACKET</span>:
			<span class="k">case</span> <span class="n">MSG_STREAM_STOP_INPUT_STAGE_PACKET</span>:
			<span class="k">case</span> <span class="n">MSG_STREAM_STOP_OUTPUT_STAGE_PACKET</span>:
				<span class="k">if</span><span class="p">(</span><span class="n">mixart_msg_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
					<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;tasklet : error MSG_STREAM_ST***_***PUT_STAGE_PACKET status=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mixart_msg_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;tasklet received mf(%x) : msg_id(%x) uid(%x, %x) size(%zd)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">msg</span><span class="p">,</span> <span class="n">resp</span><span class="p">.</span><span class="n">message_id</span><span class="p">,</span> <span class="n">resp</span><span class="p">.</span><span class="n">uid</span><span class="p">.</span><span class="n">object_id</span><span class="p">,</span> <span class="n">resp</span><span class="p">.</span><span class="n">uid</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span> <span class="n">resp</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
 		<span class="k">case</span> <span class="n">MSG_TYPE_NOTIFY</span>:
			<span class="cm">/* msg contains no address ! do not get_msg() ! */</span>
		<span class="k">case</span> <span class="n">MSG_TYPE_COMMAND</span>:
			<span class="cm">/* get_msg() necessary */</span>
		<span class="nl">default:</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;tasklet doesn&#39;t know what to do with message %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="p">}</span> <span class="cm">/* switch type */</span>

		<span class="cm">/* decrement counter */</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_processed</span><span class="p">);</span>

	<span class="p">}</span> <span class="cm">/* while there is a msg in fifo */</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">irqreturn_t</span> <span class="nf">snd_mixart_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mixart_mgr</span> <span class="o">*</span><span class="n">mgr</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mixart_msg</span> <span class="n">resp</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">msg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">it_reg</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">it_reg</span> <span class="o">=</span> <span class="n">readl_le</span><span class="p">(</span><span class="n">MIXART_REG</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MIXART_PCI_OMISR_OFFSET</span><span class="p">));</span>
	<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">it_reg</span> <span class="o">&amp;</span> <span class="n">MIXART_OIDI</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this device did not cause the interrupt */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* mask all interrupts */</span>
	<span class="n">writel_le</span><span class="p">(</span><span class="n">MIXART_HOST_ALL_INTERRUPT_MASKED</span><span class="p">,</span> <span class="n">MIXART_REG</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MIXART_PCI_OMIMR_OFFSET</span><span class="p">));</span>

	<span class="cm">/* outdoorbell register clear */</span>
	<span class="n">it_reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">MIXART_REG</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MIXART_PCI_ODBR_OFFSET</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">it_reg</span><span class="p">,</span> <span class="n">MIXART_REG</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MIXART_PCI_ODBR_OFFSET</span><span class="p">));</span>

	<span class="cm">/* clear interrupt */</span>
	<span class="n">writel_le</span><span class="p">(</span> <span class="n">MIXART_OIDI</span><span class="p">,</span> <span class="n">MIXART_REG</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MIXART_PCI_OMISR_OFFSET</span><span class="p">)</span> <span class="p">);</span>

	<span class="cm">/* process interrupt */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">retrieve_msg_frame</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">msg</span> <span class="o">&amp;</span> <span class="n">MSG_TYPE_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MSG_TYPE_COMMAND</span>:
			<span class="n">resp</span><span class="p">.</span><span class="n">message_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">resp</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">mixart_msg_data</span><span class="p">;</span>
			<span class="n">resp</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mixart_msg_data</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">get_msg</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resp</span><span class="p">,</span> <span class="n">msg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MSG_TYPE_MASK</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;interrupt: error(%d) reading mf %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span><span class="p">(</span><span class="n">resp</span><span class="p">.</span><span class="n">message_id</span> <span class="o">==</span> <span class="n">MSG_SERVICES_TIMER_NOTIFY</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">mixart_timer_notify</span> <span class="o">*</span><span class="n">notify</span><span class="p">;</span>
				<span class="n">notify</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mixart_timer_notify</span> <span class="o">*</span><span class="p">)</span><span class="n">mixart_msg_data</span><span class="p">;</span>

				<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">notify</span><span class="o">-&gt;</span><span class="n">stream_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

					<span class="n">u32</span> <span class="n">buffer_id</span> <span class="o">=</span> <span class="n">notify</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buffer_id</span><span class="p">;</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chip_number</span> <span class="o">=</span>  <span class="p">(</span><span class="n">buffer_id</span> <span class="o">&amp;</span> <span class="n">MIXART_NOTIFY_CARD_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">MIXART_NOTIFY_CARD_OFFSET</span><span class="p">;</span> <span class="cm">/* card0 to 3 */</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pcm_number</span>  <span class="o">=</span>  <span class="p">(</span><span class="n">buffer_id</span> <span class="o">&amp;</span> <span class="n">MIXART_NOTIFY_PCM_MASK</span> <span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">MIXART_NOTIFY_PCM_OFFSET</span><span class="p">;</span>  <span class="cm">/* pcm0 to 3  */</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sub_number</span>  <span class="o">=</span>   <span class="n">buffer_id</span> <span class="o">&amp;</span> <span class="n">MIXART_NOTIFY_SUBS_MASK</span><span class="p">;</span>             <span class="cm">/* 0 to MIXART_PLAYBACK_STREAMS */</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_capture</span>  <span class="o">=</span> <span class="p">((</span><span class="n">buffer_id</span> <span class="o">&amp;</span> <span class="n">MIXART_NOTIFY_CAPT_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>      <span class="cm">/* playback == 0 / capture == 1 */</span>

					<span class="k">struct</span> <span class="n">snd_mixart</span> <span class="o">*</span><span class="n">chip</span>  <span class="o">=</span> <span class="n">mgr</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">[</span><span class="n">chip_number</span><span class="p">];</span>
					<span class="k">struct</span> <span class="n">mixart_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">((</span><span class="n">chip_number</span> <span class="o">&gt;=</span> <span class="n">mgr</span><span class="o">-&gt;</span><span class="n">num_cards</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">pcm_number</span> <span class="o">&gt;=</span> <span class="n">MIXART_PCM_TOTAL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">sub_number</span> <span class="o">&gt;=</span> <span class="n">MIXART_PLAYBACK_STREAMS</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;error MSG_SERVICES_TIMER_NOTIFY buffer_id (%x) pos(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							   <span class="n">buffer_id</span><span class="p">,</span> <span class="n">notify</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sample_pos_low_part</span><span class="p">);</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">is_capture</span><span class="p">)</span>
						<span class="n">stream</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_stream</span><span class="p">[</span><span class="n">pcm_number</span><span class="p">];</span>
					<span class="k">else</span>
						<span class="n">stream</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_stream</span><span class="p">[</span><span class="n">pcm_number</span><span class="p">][</span><span class="n">sub_number</span><span class="p">];</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">substream</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">MIXART_STREAM_STATUS_RUNNING</span><span class="p">))</span> <span class="p">{</span>
						<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
						<span class="kt">int</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="n">u64</span> <span class="n">sample_count</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">notify</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sample_pos_high_part</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
						<span class="n">sample_count</span> <span class="o">|=</span> <span class="n">notify</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sample_pos_low_part</span><span class="p">;</span>

						<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">u64</span> <span class="n">new_elapse_pos</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">abs_period_elapsed</span> <span class="o">+</span>  <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">period_size</span><span class="p">;</span>

							<span class="k">if</span> <span class="p">(</span><span class="n">new_elapse_pos</span> <span class="o">&gt;</span> <span class="n">sample_count</span><span class="p">)</span> <span class="p">{</span>
								<span class="k">break</span><span class="p">;</span> <span class="cm">/* while */</span>
							<span class="p">}</span>
							<span class="k">else</span> <span class="p">{</span>
								<span class="n">elapsed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
								<span class="n">stream</span><span class="o">-&gt;</span><span class="n">buf_periods</span><span class="o">++</span><span class="p">;</span>
								<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">buf_periods</span> <span class="o">&gt;=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">periods</span><span class="p">)</span>
									<span class="n">stream</span><span class="o">-&gt;</span><span class="n">buf_periods</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

								<span class="n">stream</span><span class="o">-&gt;</span><span class="n">abs_period_elapsed</span> <span class="o">=</span> <span class="n">new_elapse_pos</span><span class="p">;</span>
							<span class="p">}</span>
						<span class="p">}</span>
						<span class="n">stream</span><span class="o">-&gt;</span><span class="n">buf_period_frag</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span> <span class="n">sample_count</span> <span class="o">-</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">abs_period_elapsed</span> <span class="p">);</span>

						<span class="k">if</span><span class="p">(</span><span class="n">elapsed</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
							<span class="n">snd_pcm_period_elapsed</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">);</span>
							<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span><span class="p">(</span><span class="n">resp</span><span class="p">.</span><span class="n">message_id</span> <span class="o">==</span> <span class="n">MSG_SERVICES_REPORT_TRACES</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">resp</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef __BIG_ENDIAN</span>
					<span class="cm">/* Traces are text: the swapped msg_data has to be swapped back ! */</span>
					<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
					<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">resp</span><span class="p">.</span><span class="n">size</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
						<span class="p">(</span><span class="n">mixart_msg_data</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">((</span><span class="n">mixart_msg_data</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span>
					<span class="p">}</span>
<span class="cp">#endif</span>
					<span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">mixart_msg_data</span><span class="p">)[</span><span class="n">resp</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;MIXART TRACE : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">mixart_msg_data</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;command %x not handled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">resp</span><span class="p">.</span><span class="n">message_id</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MSG_TYPE_NOTIFY</span>:
			<span class="k">if</span><span class="p">(</span><span class="n">msg</span> <span class="o">&amp;</span> <span class="n">MSG_CANCEL_NOTIFY_MASK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">msg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MSG_CANCEL_NOTIFY_MASK</span><span class="p">;</span>
				<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;canceled notification %x !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* no break, continue ! */</span>
		<span class="k">case</span> <span class="n">MSG_TYPE_ANSWER</span>:
			<span class="cm">/* answer or notification to a message we are waiting for*/</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_lock</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">msg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MSG_TYPE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">mgr</span><span class="o">-&gt;</span><span class="n">pending_event</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_sleep</span><span class="p">);</span>
				<span class="n">mgr</span><span class="o">-&gt;</span><span class="n">pending_event</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* answer to a message we did&#39;t want to wait for */</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_fifo</span><span class="p">[</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_fifo_writeptr</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
				<span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_fifo_writeptr</span><span class="o">++</span><span class="p">;</span>
				<span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_fifo_writeptr</span> <span class="o">%=</span> <span class="n">MSG_FIFO_SIZE</span><span class="p">;</span>
				<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_taskq</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">msg_lock</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MSG_TYPE_REQUEST</span>:
		<span class="nl">default:</span>
			<span class="n">snd_printdd</span><span class="p">(</span><span class="s">&quot;interrupt received request %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
			<span class="cm">/* TODO : are there things to do here ? */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="cm">/* switch on msg type */</span>
	<span class="p">}</span> <span class="cm">/* while there are msgs */</span>

	<span class="cm">/* allow interrupt again */</span>
	<span class="n">writel_le</span><span class="p">(</span> <span class="n">MIXART_ALLOW_OUTBOUND_DOORBELL</span><span class="p">,</span> <span class="n">MIXART_REG</span><span class="p">(</span> <span class="n">mgr</span><span class="p">,</span> <span class="n">MIXART_PCI_OMIMR_OFFSET</span><span class="p">));</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">snd_mixart_init_mailbox</span><span class="p">(</span><span class="k">struct</span> <span class="n">mixart_mgr</span> <span class="o">*</span><span class="n">mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MIXART_MEM</span><span class="p">(</span> <span class="n">mgr</span><span class="p">,</span> <span class="n">MSG_HOST_RSC_PROTECTION</span> <span class="p">)</span> <span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MIXART_MEM</span><span class="p">(</span> <span class="n">mgr</span><span class="p">,</span> <span class="n">MSG_AGENT_RSC_PROTECTION</span> <span class="p">)</span> <span class="p">);</span>

	<span class="cm">/* allow outbound messagebox to generate interrupts */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">mgr</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel_le</span><span class="p">(</span> <span class="n">MIXART_ALLOW_OUTBOUND_DOORBELL</span><span class="p">,</span> <span class="n">MIXART_REG</span><span class="p">(</span> <span class="n">mgr</span><span class="p">,</span> <span class="n">MIXART_PCI_OMIMR_OFFSET</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">snd_mixart_exit_mailbox</span><span class="p">(</span><span class="k">struct</span> <span class="n">mixart_mgr</span> <span class="o">*</span><span class="n">mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* no more interrupts on outbound messagebox */</span>
	<span class="n">writel_le</span><span class="p">(</span> <span class="n">MIXART_HOST_ALL_INTERRUPT_MASKED</span><span class="p">,</span> <span class="n">MIXART_REG</span><span class="p">(</span> <span class="n">mgr</span><span class="p">,</span> <span class="n">MIXART_PCI_OMIMR_OFFSET</span><span class="p">));</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">snd_mixart_reset_board</span><span class="p">(</span><span class="k">struct</span> <span class="n">mixart_mgr</span> <span class="o">*</span><span class="n">mgr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* reset miXart */</span>
	<span class="n">writel_be</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MIXART_REG</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">MIXART_BA1_BRUTAL_RESET_OFFSET</span><span class="p">)</span> <span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
