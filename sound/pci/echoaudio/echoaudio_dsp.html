<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › pci › echoaudio › echoaudio_dsp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>echoaudio_dsp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/****************************************************************************</span>

<span class="cm">   Copyright Echo Digital Audio Corporation (c) 1998 - 2004</span>
<span class="cm">   All rights reserved</span>
<span class="cm">   www.echoaudio.com</span>

<span class="cm">   This file is part of Echo Digital Audio&#39;s generic driver library.</span>

<span class="cm">   Echo Digital Audio&#39;s generic driver library is free software;</span>
<span class="cm">   you can redistribute it and/or modify it under the terms of</span>
<span class="cm">   the GNU General Public License as published by the Free Software</span>
<span class="cm">   Foundation.</span>

<span class="cm">   This program is distributed in the hope that it will be useful,</span>
<span class="cm">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">   GNU General Public License for more details.</span>

<span class="cm">   You should have received a copy of the GNU General Public License</span>
<span class="cm">   along with this program; if not, write to the Free Software</span>
<span class="cm">   Foundation, Inc., 59 Temple Place - Suite 330, Boston,</span>
<span class="cm">   MA  02111-1307, USA.</span>

<span class="cm">   *************************************************************************</span>

<span class="cm"> Translation from C++ and adaptation for use in ALSA-Driver</span>
<span class="cm"> were made by Giuliano Pochini &lt;pochini@shiny.it&gt;</span>

<span class="cm">****************************************************************************/</span>

<span class="cp">#if PAGE_SIZE &lt; 4096</span>
<span class="cp">#error PAGE_SIZE is &lt; 4k</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">restore_dsp_rettings</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>


<span class="cm">/* Some vector commands involve the DSP reading or writing data to and from the</span>
<span class="cm">comm page; if you send one of these commands to the DSP, it will complete the</span>
<span class="cm">command and then write a non-zero value to the Handshake field in the</span>
<span class="cm">comm page.  This function waits for the handshake to show up. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_handshake</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Wait up to 20ms for the handshake from the DSP */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HANDSHAKE_TIMEOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Look for the handshake value */</span>
		<span class="n">barrier</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">handshake</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;wait_handshake(): Timeout waiting for DSP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/* Much of the interaction between the DSP and the driver is done via vector</span>
<span class="cm">commands; send_vector writes a vector command to the DSP.  Typically, this</span>
<span class="cm">causes the DSP to read or write fields in the comm page.</span>
<span class="cm">PCI posting is not required thanks to the handshake logic. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">wmb</span><span class="p">();</span>	<span class="cm">/* Flush all pending writes before sending the command */</span>

	<span class="cm">/* Wait up to 100ms for the &quot;vector busy&quot; bit to be off */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">VECTOR_BUSY_TIMEOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">get_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_VECTOR_REG</span><span class="p">)</span> <span class="o">&amp;</span>
		      <span class="n">CHI32_VECTOR_BUSY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_VECTOR_REG</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>
			<span class="cm">/*if (i)  DE_ACT((&quot;send_vector time: %d\n&quot;, i));*/</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">DE_ACT</span><span class="p">((</span><span class="n">KERN_ERR</span> <span class="s">&quot;timeout on send_vector</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/* write_dsp writes a 32-bit value to the DSP; this is used almost</span>
<span class="cm">exclusively for loading the DSP. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_dsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* timeout = 10s */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">get_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_STATUS_REG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">CHI32_STATUS_HOST_WRITE_EMPTY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_DATA_REG</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="n">wmb</span><span class="p">();</span>			<span class="cm">/* write it immediately */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">bad_board</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>		<span class="cm">/* Set TRUE until DSP re-loaded */</span>
	<span class="n">DE_ACT</span><span class="p">((</span><span class="n">KERN_ERR</span> <span class="s">&quot;write_dsp: Set bad_board to TRUE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/* read_dsp reads a 32-bit value from the DSP; this is used almost</span>
<span class="cm">exclusively for loading the DSP and checking the status of the ASIC. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_dsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">READ_DSP_TIMEOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">get_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_STATUS_REG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">CHI32_STATUS_HOST_READ_FULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">get_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_DATA_REG</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">bad_board</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>		<span class="cm">/* Set TRUE until DSP re-loaded */</span>
	<span class="n">DE_INIT</span><span class="p">((</span><span class="n">KERN_ERR</span> <span class="s">&quot;read_dsp: Set bad_board to TRUE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/****************************************************************************</span>
<span class="cm">	Firmware loading functions</span>
<span class="cm"> ****************************************************************************/</span>

<span class="cm">/* This function is used to read back the serial number from the DSP;</span>
<span class="cm">this is triggered by the SET_COMMPAGE_ADDR command.</span>
<span class="cm">Only some early Echogals products have serial numbers in the ROM;</span>
<span class="cm">the serial number is not used, but you still need to do this as</span>
<span class="cm">part of the DSP load process. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_sn</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sn</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sn</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to read serial number</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;Read serial number %08x %08x %08x %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">sn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">sn</span><span class="p">[</span><span class="mi">4</span><span class="p">]));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cp">#ifndef ECHOCARD_HAS_ASIC</span>
<span class="cm">/* This card has no ASIC, just return ok */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_asic_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">asic_loaded</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !ECHOCARD_HAS_ASIC */</span><span class="cp"></span>



<span class="cp">#ifdef ECHOCARD_HAS_ASIC</span>

<span class="cm">/* Load ASIC code - done after the DSP is loaded */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_asic_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">short</span> <span class="n">asic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">code</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">get_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">asic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Firmware not found !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">code</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

	<span class="cm">/* Send the &quot;Here comes the ASIC&quot; command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">la_error</span><span class="p">;</span>

	<span class="cm">/* Write length of ASIC file in bytes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">la_error</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">write_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">code</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">la_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;ASIC loaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="n">free_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">la_error:</span>
	<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;failed on write_dsp</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="n">free_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ECHOCARD_HAS_ASIC */</span><span class="cp"></span>



<span class="cp">#ifdef DSP_56361</span>

<span class="cm">/* Install the resident loader for 56361 DSPs;  The resident loader is on</span>
<span class="cm">the EPROM on the board for 56301 DSP. The resident loader is a tiny little</span>
<span class="cm">program that is used to load the real DSP code. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">install_resident_loader</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">code</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>

	<span class="cm">/* 56361 cards only!  This check is required by the old 56301-based</span>
<span class="cm">	Mona and Gina24 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">device_id</span> <span class="o">!=</span> <span class="n">DEVICE_ID_56361</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Look to see if the resident loader is present.  If the resident</span>
<span class="cm">	loader is already installed, host flag 5 will be on. */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">get_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_STATUS_REG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">CHI32_STATUS_REG_HF5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;Resident loader already installed; status is 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">status</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">get_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">FW_361_LOADER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Firmware not found !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The DSP code is an array of 16 bit words.  The array is divided up</span>
<span class="cm">	into sections.  The first word of each section is the size in words,</span>
<span class="cm">	followed by the section type.</span>
<span class="cm">	Since DSP addresses and data are 24 bits wide, they each take up two</span>
<span class="cm">	16 bit words in the array.</span>
<span class="cm">	This is a lot like the other loader loop, but it&#39;s not a loop, you</span>
<span class="cm">	don&#39;t write the memory type, and you don&#39;t write a zero at the end. */</span>

	<span class="cm">/* Set DSP format bits for 24 bit mode */</span>
	<span class="n">set_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_CONTROL_REG</span><span class="p">,</span>
			 <span class="n">get_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_CONTROL_REG</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x900</span><span class="p">);</span>

	<span class="n">code</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Skip the header section; the first word in the array is the size</span>
<span class="cm">	of the first section, so the first real section of code is pointed</span>
<span class="cm">	to by Code[0]. */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">code</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* Skip the section size, LRS block type, and DSP memory type */</span>
	<span class="n">index</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* Get the number of DSP words to write */</span>
	<span class="n">words</span> <span class="o">=</span> <span class="n">code</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">];</span>

	<span class="cm">/* Get the DSP address for this block; 24 bits, so build from two words */</span>
	<span class="n">address</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">code</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">code</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">index</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Write the count to the DSP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">words</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;install_resident_loader: Failed to write word count!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">irl_error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Write the DSP address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;install_resident_loader: Failed to write DSP address!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">irl_error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Write out this block of code to the DSP */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>

		<span class="n">data</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">code</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">code</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">write_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;install_resident_loader: Failed to write DSP code</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">irl_error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">index</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wait for flag 5 to come up */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Timeout is 50us * 200 = 10ms */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">get_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_STATUS_REG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">CHI32_STATUS_REG_HF5</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;Resident loader failed to set HF5</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">irl_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;Resident loader successfully installed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="n">free_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">irl_error:</span>
	<span class="n">free_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* DSP_56361 */</span><span class="cp"></span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_dsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">address</span><span class="p">,</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">dsp_code</span> <span class="o">==</span> <span class="n">code</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;DSP is already loaded!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">bad_board</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>		<span class="cm">/* Set TRUE until DSP loaded */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dsp_code</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>		<span class="cm">/* Current DSP code not loaded */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">asic_loaded</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>	<span class="cm">/* Loading the DSP code will reset the ASIC */</span>

	<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;load_dsp: Set bad_board to TRUE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="cm">/* If this board requires a resident loader, install it. */</span>
<span class="cp">#ifdef DSP_56361</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">install_resident_loader</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Send software reset command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">send_vector</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DSP_VC_RESET</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;LoadDsp: send_vector DSP_VC_RESET failed, Critical Failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Delay 10us */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="cm">/* Wait 10ms for HF3 to indicate that software reset is complete */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Timeout is 10us * 1000 = 10ms */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span>
		    <span class="n">CHI32_STATUS_REG_HF3</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;load_dsp: Timeout waiting for CHI32_STATUS_REG_HF3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set DSP format bits for 24 bit mode now that soft reset is done */</span>
	<span class="n">set_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_CONTROL_REG</span><span class="p">,</span>
			 <span class="n">get_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_CONTROL_REG</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x900</span><span class="p">);</span>

	<span class="cm">/* Main loader loop */</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">code</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">block_type</span><span class="p">,</span> <span class="n">mem_type</span><span class="p">;</span>

		<span class="cm">/* Total Block Size */</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Block Type */</span>
		<span class="n">block_type</span> <span class="o">=</span> <span class="n">code</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_type</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>	<span class="cm">/* We&#39;re finished */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">index</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Memory Type  P=0,X=1,Y=2 */</span>
		<span class="n">mem_type</span> <span class="o">=</span> <span class="n">code</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">];</span>

		<span class="cm">/* Block Code Size */</span>
		<span class="n">words</span> <span class="o">=</span> <span class="n">code</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">words</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>		<span class="cm">/* We&#39;re finished */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Start Address */</span>
		<span class="n">address</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">code</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">code</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">index</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">write_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">words</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;load_dsp: failed to write number of DSP words</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">write_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;load_dsp: failed to write DSP address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">write_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">mem_type</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;load_dsp: failed to write DSP memory type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Code */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">index</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">code</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">code</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">write_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;load_dsp: failed to write DSP data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* We&#39;re done!!! */</span>
		<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;load_dsp: Failed to write final zero</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Timeout is 100us * 5000 = 500ms */</span>
		<span class="cm">/* Wait for flag 4 - indicates that the DSP loaded OK */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span>
		    <span class="n">CHI32_STATUS_REG_HF4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_CONTROL_REG</span><span class="p">,</span>
					 <span class="n">get_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_CONTROL_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x1b00</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">write_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DSP_FNC_SET_COMMPAGE_ADDR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;load_dsp: Failed to write DSP_FNC_SET_COMMPAGE_ADDR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">write_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page_phys</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;load_dsp: Failed to write comm page address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Get the serial number via slave mode.</span>
<span class="cm">			This is triggered by the SET_COMMPAGE_ADDR command.</span>
<span class="cm">			We don&#39;t actually use the serial number but we have to</span>
<span class="cm">			get it as part of the DSP init voodoo. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">read_sn</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;load_dsp: Failed to read serial number</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dsp_code</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>		<span class="cm">/* Show which DSP code loaded */</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">bad_board</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>	<span class="cm">/* DSP OK */</span>
			<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;load_dsp: OK!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;load_dsp: DSP load timed out waiting for HF4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/* load_firmware takes care of loading the DSP and any ASIC code. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">box_type</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* See if the ASIC is present and working - only if the DSP is already loaded */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">dsp_code</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">box_type</span> <span class="o">=</span> <span class="n">check_asic_status</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">box_type</span><span class="p">;</span>
		<span class="cm">/* ASIC check failed; force the DSP to reload */</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dsp_code</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">get_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">dsp_code_to_load</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">load_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">free_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">box_type</span> <span class="o">=</span> <span class="n">load_asic</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">box_type</span><span class="p">;</span>	<span class="cm">/* error */</span>

	<span class="k">return</span> <span class="n">box_type</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/****************************************************************************</span>
<span class="cm">	Mixer functions</span>
<span class="cm"> ****************************************************************************/</span>

<span class="cp">#if defined(ECHOCARD_HAS_INPUT_NOMINAL_LEVEL) || \</span>
<span class="cp">	defined(ECHOCARD_HAS_OUTPUT_NOMINAL_LEVEL)</span>

<span class="cm">/* Set the nominal level for an input or output bus (true = -10dBV, false = +4dBu) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_nominal_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u16</span> <span class="n">index</span><span class="p">,</span> <span class="kt">char</span> <span class="n">consumer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">num_busses_out</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_busses_in</span><span class="p">(</span><span class="n">chip</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Wait for the handshake (OK even if ASIC is not loaded) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">nominal_level</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">consumer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">consumer</span><span class="p">)</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">nominal_level_mask</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">nominal_level_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* ECHOCARD_HAS_*_NOMINAL_LEVEL */</span><span class="cp"></span>



<span class="cm">/* Set the gain for a single physical output channel (dB). */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_output_gain</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u16</span> <span class="n">channel</span><span class="p">,</span> <span class="n">s8</span> <span class="n">gain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">channel</span> <span class="o">&gt;=</span> <span class="n">num_busses_out</span><span class="p">(</span><span class="n">chip</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* Save the new value */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">output_gain</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">gain</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">line_out_level</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">gain</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cp">#ifdef ECHOCARD_HAS_MONITOR</span>
<span class="cm">/* Set the monitor level from an input bus to an output bus. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_monitor_gain</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u16</span> <span class="n">output</span><span class="p">,</span> <span class="n">u16</span> <span class="n">input</span><span class="p">,</span>
			    <span class="n">s8</span> <span class="n">gain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">output</span> <span class="o">&gt;=</span> <span class="n">num_busses_out</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">input</span> <span class="o">&gt;=</span> <span class="n">num_busses_in</span><span class="p">(</span><span class="n">chip</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">monitor_gain</span><span class="p">[</span><span class="n">output</span><span class="p">][</span><span class="n">input</span><span class="p">]</span> <span class="o">=</span> <span class="n">gain</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">monitors</span><span class="p">[</span><span class="n">monitor_index</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">input</span><span class="p">)]</span> <span class="o">=</span> <span class="n">gain</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* ECHOCARD_HAS_MONITOR */</span><span class="cp"></span>


<span class="cm">/* Tell the DSP to read and update output, nominal &amp; monitor levels in comm page. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_output_line_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">clear_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">send_vector</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DSP_VC_UPDATE_OUTVOL</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/* Tell the DSP to read and update input levels in comm page */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_input_line_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">clear_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">send_vector</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DSP_VC_UPDATE_INGAIN</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/* set_meters_on turns the meters on or off.  If meters are turned on, the DSP</span>
<span class="cm">will write the meter and clock detect values to the comm page at about 30Hz */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_meters_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">char</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">meters_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">send_vector</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DSP_VC_METERS_ON</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">meters_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">on</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">meters_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">send_vector</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DSP_VC_METERS_OFF</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">meters_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">((</span><span class="n">s8</span> <span class="o">*</span><span class="p">)</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">vu_meter</span><span class="p">,</span> <span class="n">ECHOGAIN_MUTED</span><span class="p">,</span>
		       <span class="n">DSP_MAXPIPES</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">((</span><span class="n">s8</span> <span class="o">*</span><span class="p">)</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">peak_meter</span><span class="p">,</span> <span class="n">ECHOGAIN_MUTED</span><span class="p">,</span>
		       <span class="n">DSP_MAXPIPES</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>



<span class="cm">/* Fill out an the given array using the current values in the comm page.</span>
<span class="cm">Meters are written in the comm page by the DSP in this order:</span>
<span class="cm"> Output busses</span>
<span class="cm"> Input busses</span>
<span class="cm"> Output pipes (vmixer cards only)</span>

<span class="cm">This function assumes there are no more than 16 in/out busses or pipes</span>
<span class="cm">Meters is an array [3][16][2] of long. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_audio_meters</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">meters</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_busses_out</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">meters</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">vu_meter</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
		<span class="n">meters</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">peak_meter</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
		<span class="n">meters</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef ECHOCARD_ECHO3G</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">E3G_MAX_OUTPUTS</span><span class="p">;</span>	<span class="cm">/* Skip unused meters */</span>
<span class="cp">#endif</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_busses_in</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">meters</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">vu_meter</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
		<span class="n">meters</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">peak_meter</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
		<span class="n">meters</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef ECHOCARD_HAS_VMIXER</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pipes_out</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">meters</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">vu_meter</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
		<span class="n">meters</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">peak_meter</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">96</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
		<span class="n">meters</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">int</span> <span class="nf">restore_dsp_rettings</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;restore_dsp_settings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">check_asic_status</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Gina20/Darla20 only. Should be harmless for other cards. */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">gd_clock_state</span> <span class="o">=</span> <span class="n">GD_CLOCK_UNDEF</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">gd_spdif_status</span> <span class="o">=</span> <span class="n">GD_SPDIF_STATUS_UNDEF</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">handshake</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>

	<span class="cm">/* Restore output busses */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_busses_out</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">set_output_gain</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">output_gain</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef ECHOCARD_HAS_VMIXER</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pipes_out</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">o</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">o</span> <span class="o">&lt;</span> <span class="n">num_busses_out</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span> <span class="n">o</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">set_vmixer_gain</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
						<span class="n">chip</span><span class="o">-&gt;</span><span class="n">vmixer_gain</span><span class="p">[</span><span class="n">o</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">update_vmixer_level</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* ECHOCARD_HAS_VMIXER */</span><span class="cp"></span>

<span class="cp">#ifdef ECHOCARD_HAS_MONITOR</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">o</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">o</span> <span class="o">&lt;</span> <span class="n">num_busses_out</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span> <span class="n">o</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_busses_in</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">set_monitor_gain</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
						<span class="n">chip</span><span class="o">-&gt;</span><span class="n">monitor_gain</span><span class="p">[</span><span class="n">o</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* ECHOCARD_HAS_MONITOR */</span><span class="cp"></span>

<span class="cp">#ifdef ECHOCARD_HAS_INPUT_GAIN</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_busses_in</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">set_input_gain</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_gain</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* ECHOCARD_HAS_INPUT_GAIN */</span><span class="cp"></span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">update_output_line_level</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">update_input_line_level</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">set_sample_rate</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">meters_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">send_vector</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DSP_VC_METERS_ON</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef ECHOCARD_HAS_DIGITAL_MODE_SWITCH</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set_digital_mode</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">digital_mode</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef ECHOCARD_HAS_DIGITAL_IO</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set_professional_spdif</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">professional_spdif</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef ECHOCARD_HAS_PHANTOM_POWER</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set_phantom_power</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">phantom_power</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef ECHOCARD_HAS_EXTERNAL_CLOCK</span>
	<span class="cm">/* set_input_clock() also restores automute setting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set_input_clock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_clock</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef ECHOCARD_HAS_OUTPUT_CLOCK_SWITCH</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set_output_clock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">output_clock</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">clear_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">send_vector</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DSP_VC_UPDATE_FLAGS</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;restore_dsp_rettings done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/****************************************************************************</span>
<span class="cm">	Transport functions</span>
<span class="cm"> ****************************************************************************/</span>

<span class="cm">/* set_audio_format() sets the format of the audio data in host memory for</span>
<span class="cm">this pipe.  Note that _MS_ (mono-to-stereo) playback modes are not used by ALSA</span>
<span class="cm">but they are here because they are just mono while capturing */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_audio_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u16</span> <span class="n">pipe_index</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">format</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">dsp_format</span><span class="p">;</span>

	<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_SS_16LE</span><span class="p">;</span>

	<span class="cm">/* Look for super-interleave (no big-endian and 8 bits) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">interleave</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">bits_per_sample</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">16</span>:
			<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_SUPER_INTERLEAVE_16LE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">24</span>:
			<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_SUPER_INTERLEAVE_24LE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">32</span>:
			<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_SUPER_INTERLEAVE_32LE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dsp_format</span> <span class="o">|=</span> <span class="n">format</span><span class="o">-&gt;</span><span class="n">interleave</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">data_are_bigendian</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* For big-endian data, only 32 bit samples are supported */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">interleave</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_MM_32BE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef ECHOCARD_HAS_STEREO_BIG_ENDIAN32</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_SS_32BE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">interleave</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
		   <span class="n">format</span><span class="o">-&gt;</span><span class="n">bits_per_sample</span> <span class="o">==</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">mono_to_stereo</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 32 bit little-endian mono-&gt;mono case */</span>
		<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_MM_32LE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Handle the other little-endian formats */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">bits_per_sample</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">8</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">interleave</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_SS_8</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_MS_8</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
		<span class="k">case</span> <span class="mi">16</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">interleave</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_SS_16LE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_MS_16LE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">24</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">interleave</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_SS_24LE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_MS_24LE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">32</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">interleave</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_SS_32LE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">dsp_format</span> <span class="o">=</span> <span class="n">DSP_AUDIOFORM_MS_32LE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">DE_ACT</span><span class="p">((</span><span class="s">&quot;set_audio_format[%d] = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pipe_index</span><span class="p">,</span> <span class="n">dsp_format</span><span class="p">));</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">audio_format</span><span class="p">[</span><span class="n">pipe_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">dsp_format</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/* start_transport starts transport for a set of pipes.</span>
<span class="cm">The bits 1 in channel_mask specify what pipes to start. Only the bit of the</span>
<span class="cm">first channel must be set, regardless its interleave.</span>
<span class="cm">Same thing for pause_ and stop_ -trasport below. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">start_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">channel_mask</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="n">cyclic_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DE_ACT</span><span class="p">((</span><span class="s">&quot;start_transport %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel_mask</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">cmd_start</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">channel_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">cmd_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="n">send_vector</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DSP_VC_START_TRANSFER</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="cm">/* Keep track of which pipes are transporting */</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">active_mask</span> <span class="o">|=</span> <span class="n">channel_mask</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">cmd_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DE_ACT</span><span class="p">((</span><span class="s">&quot;start_transport: No pipes to start!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">int</span> <span class="nf">pause_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">channel_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DE_ACT</span><span class="p">((</span><span class="s">&quot;pause_transport %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel_mask</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">cmd_stop</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">channel_mask</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">cmd_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">cmd_stop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="n">send_vector</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DSP_VC_STOP_TRANSFER</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="cm">/* Keep track of which pipes are transporting */</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">active_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">channel_mask</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">cmd_stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">cmd_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DE_ACT</span><span class="p">((</span><span class="s">&quot;pause_transport: No pipes to stop!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">int</span> <span class="nf">stop_transport</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u32</span> <span class="n">channel_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DE_ACT</span><span class="p">((</span><span class="s">&quot;stop_transport %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">channel_mask</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">cmd_stop</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">channel_mask</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">cmd_reset</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">channel_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">cmd_reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="n">send_vector</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DSP_VC_STOP_TRANSFER</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_handshake</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="cm">/* Keep track of which pipes are transporting */</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">active_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">channel_mask</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">cmd_stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">cmd_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DE_ACT</span><span class="p">((</span><span class="s">&quot;stop_transport: No pipes to stop!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_pipe_allocated</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">u16</span> <span class="n">pipe_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pipe_alloc_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pipe_index</span><span class="p">));</span>
<span class="p">}</span>



<span class="cm">/* Stops everything and turns off the DSP. All pipes should be already</span>
<span class="cm">stopped and unallocated. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rest_in_peace</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DE_ACT</span><span class="p">((</span><span class="s">&quot;rest_in_peace() open=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">pipe_alloc_mask</span><span class="p">));</span>

	<span class="cm">/* Stops all active pipes (just to be sure) */</span>
	<span class="n">stop_transport</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">active_mask</span><span class="p">);</span>

	<span class="n">set_meters_on</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>

<span class="cp">#ifdef ECHOCARD_HAS_MIDI</span>
	<span class="n">enable_midi_input</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Go to sleep */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">dsp_code</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make load_firmware do a complete reload */</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dsp_code</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* Put the DSP to sleep */</span>
		<span class="k">return</span> <span class="n">send_vector</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DSP_VC_GO_COMATOSE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/* Fills the comm page with default values */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_dsp_comm_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Check if the compiler added extra padding inside the structure */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">comm_page</span><span class="p">,</span> <span class="n">midi_output</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xbe0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;init_dsp_comm_page() - Invalid struct comm_page structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Init all the basic stuff */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">card_name</span> <span class="o">=</span> <span class="n">ECHOCARD_NAME</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">bad_board</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>	<span class="cm">/* Set TRUE until DSP loaded */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dsp_code</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* Current DSP code not loaded */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">asic_loaded</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">comm_page</span><span class="p">));</span>

	<span class="cm">/* Init the comm page */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">comm_size</span> <span class="o">=</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">comm_page</span><span class="p">));</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">handshake</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">midi_out_free_count</span> <span class="o">=</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DSP_MIDI_OUT_FIFO_SIZE</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">44100</span><span class="p">);</span>

	<span class="cm">/* Set line levels so we don&#39;t blast any inputs on startup */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">monitors</span><span class="p">,</span> <span class="n">ECHOGAIN_MUTED</span><span class="p">,</span> <span class="n">MONITOR_ARRAY_SIZE</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">vmixer</span><span class="p">,</span> <span class="n">ECHOGAIN_MUTED</span><span class="p">,</span> <span class="n">VMIXER_ARRAY_SIZE</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/* This function initializes the chip structure with default values, ie. all</span>
<span class="cm"> * muted and internal clock source. Then it copies the settings to the DSP.</span>
<span class="cm"> * This MUST be called after the DSP is up and running !</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_line_levels</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DE_INIT</span><span class="p">((</span><span class="s">&quot;init_line_levels</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">output_gain</span><span class="p">,</span> <span class="n">ECHOGAIN_MUTED</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">output_gain</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_gain</span><span class="p">,</span> <span class="n">ECHOGAIN_MUTED</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_gain</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">monitor_gain</span><span class="p">,</span> <span class="n">ECHOGAIN_MUTED</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">monitor_gain</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">vmixer_gain</span><span class="p">,</span> <span class="n">ECHOGAIN_MUTED</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">vmixer_gain</span><span class="p">));</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">input_clock</span> <span class="o">=</span> <span class="n">ECHO_CLOCK_INTERNAL</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">output_clock</span> <span class="o">=</span> <span class="n">ECHO_CLOCK_WORD</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="mi">44100</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">restore_dsp_rettings</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/* This is low level part of the interrupt handler.</span>
<span class="cm">It returns -1 if the IRQ is not ours, or N&gt;=0 if it is, where N is the number</span>
<span class="cm">of midi data in the input queue. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">service_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">st</span><span class="p">;</span>

	<span class="cm">/* Read the DSP status register and see if this DSP generated this interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_dsp_register</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CHI32_STATUS_REG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CHI32_STATUS_IRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">st</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef ECHOCARD_HAS_MIDI</span>
		<span class="cm">/* Get and parse midi data if present */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">midi_input</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>	<span class="cm">/* The count is at index 0 */</span>
			<span class="n">st</span> <span class="o">=</span> <span class="n">midi_service_irq</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>	<span class="cm">/* Returns how many midi bytes we received */</span>
<span class="cp">#endif</span>
		<span class="cm">/* Clear the hardware interrupt */</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">midi_input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">send_vector</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">DSP_VC_ACK_INT</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">st</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>




<span class="cm">/******************************************************************************</span>
<span class="cm">	Functions for opening and closing pipes</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/* allocate_pipes is used to reserve audio pipes for your exclusive use.</span>
<span class="cm">The call will fail if some pipes are already allocated. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">allocate_pipes</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audiopipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">pipe_index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">interleave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">channel_mask</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">is_cyclic</span><span class="p">;</span>

	<span class="n">DE_ACT</span><span class="p">((</span><span class="s">&quot;allocate_pipes: ch=%d int=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pipe_index</span><span class="p">,</span> <span class="n">interleave</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bad_board</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">is_cyclic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* This driver uses cyclic buffers only */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">channel_mask</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">interleave</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">channel_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">pipe_index</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pipe_alloc_mask</span> <span class="o">&amp;</span> <span class="n">channel_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DE_ACT</span><span class="p">((</span><span class="s">&quot;allocate_pipes: channel already open</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">position</span><span class="p">[</span><span class="n">pipe_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pipe_alloc_mask</span> <span class="o">|=</span> <span class="n">channel_mask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_cyclic</span><span class="p">)</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pipe_cyclic_mask</span> <span class="o">|=</span> <span class="n">channel_mask</span><span class="p">;</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">pipe_index</span><span class="p">;</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">interleave</span> <span class="o">=</span> <span class="n">interleave</span><span class="p">;</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PIPE_STATE_STOPPED</span><span class="p">;</span>

	<span class="cm">/* The counter register is where the DSP writes the 32 bit DMA</span>
<span class="cm">	position for a pipe.  The DSP is constantly updating this value as</span>
<span class="cm">	it moves data. The DMA counter is in units of bytes, not samples. */</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">dma_counter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">position</span><span class="p">[</span><span class="n">pipe_index</span><span class="p">];</span>
	<span class="o">*</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">dma_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DE_ACT</span><span class="p">((</span><span class="s">&quot;allocate_pipes: ok</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">pipe_index</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">int</span> <span class="nf">free_pipes</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audiopipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">channel_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">DE_ACT</span><span class="p">((</span><span class="s">&quot;free_pipes: Pipe %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_pipe_allocated</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">PIPE_STATE_STOPPED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">channel_mask</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">interleave</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">channel_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pipe_alloc_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">channel_mask</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pipe_cyclic_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">channel_mask</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/******************************************************************************</span>
<span class="cm">	Functions for managing the scatter-gather list</span>
<span class="cm">******************************************************************************/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sglist_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audiopipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">sglist_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">sgpage</span><span class="p">.</span><span class="n">area</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">comm_page</span><span class="o">-&gt;</span><span class="n">sglist_addr</span><span class="p">[</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">sgpage</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">int</span> <span class="nf">sglist_add_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audiopipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
				<span class="n">dma_addr_t</span> <span class="n">address</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">head</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">sglist_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_entry</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sg_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">sgpage</span><span class="p">.</span><span class="n">area</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">&lt;</span> <span class="n">MAX_SGLIST_ENTRIES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list</span><span class="p">[</span><span class="n">head</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
		<span class="n">list</span><span class="p">[</span><span class="n">head</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">sglist_head</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DE_ACT</span><span class="p">((</span><span class="s">&quot;SGlist: too many fragments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sglist_add_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audiopipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sglist_add_mapping</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sglist_wrap</span><span class="p">(</span><span class="k">struct</span> <span class="n">echoaudio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audiopipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sglist_add_mapping</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">sgpage</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
