<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › drivers › serial-u16550.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>serial-u16550.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   serial.c</span>
<span class="cm"> *   Copyright (c) by Jaroslav Kysela &lt;perex@perex.cz&gt;,</span>
<span class="cm"> *                    Isaku Yamahata &lt;yamahata@private.email.ne.jp&gt;,</span>
<span class="cm"> *		      George Hansper &lt;ghansper@apana.org.au&gt;,</span>
<span class="cm"> *		      Hannu Savolainen</span>
<span class="cm"> *</span>
<span class="cm"> *   This code is based on the code from ALSA 0.5.9, but heavily rewritten.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *   GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Sat Mar 31 17:27:57 PST 2001 tim.mann@compaq.com </span>
<span class="cm"> *      Added support for the Midiator MS-124T and for the MS-124W in</span>
<span class="cm"> *      Single Addressed (S/A) or Multiple Burst (M/B) mode, with</span>
<span class="cm"> *      power derived either parasitically from the serial port or</span>
<span class="cm"> *      from a separate power supply.</span>
<span class="cm"> *</span>
<span class="cm"> *      More documentation can be found in serial-u16550.txt.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;sound/core.h&gt;</span>
<span class="cp">#include &lt;sound/rawmidi.h&gt;</span>
<span class="cp">#include &lt;sound/initval.h&gt;</span>

<span class="cp">#include &lt;linux/serial_reg.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;MIDI serial u16550&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_SUPPORTED_DEVICE</span><span class="p">(</span><span class="s">&quot;{{ALSA, MIDI serial u16550}}&quot;</span><span class="p">);</span>

<span class="cp">#define SNDRV_SERIAL_SOUNDCANVAS 0 </span><span class="cm">/* Roland Soundcanvas; F5 NN selects part */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SERIAL_MS124T 1      </span><span class="cm">/* Midiator MS-124T */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SERIAL_MS124W_SA 2   </span><span class="cm">/* Midiator MS-124W in S/A mode */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SERIAL_MS124W_MB 3   </span><span class="cm">/* Midiator MS-124W in M/B mode */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SERIAL_GENERIC 4     </span><span class="cm">/* Generic Interface */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SERIAL_MAX_ADAPTOR SNDRV_SERIAL_GENERIC</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">adaptor_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;Soundcanvas&quot;</span><span class="p">,</span>
        <span class="s">&quot;MS-124T&quot;</span><span class="p">,</span>
	<span class="s">&quot;MS-124W S/A&quot;</span><span class="p">,</span>
	<span class="s">&quot;MS-124W M/B&quot;</span><span class="p">,</span>
	<span class="s">&quot;Generic&quot;</span>
<span class="p">};</span>

<span class="cp">#define SNDRV_SERIAL_NORMALBUFF 0 </span><span class="cm">/* Normal blocking buffer operation */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SERIAL_DROPBUFF   1 </span><span class="cm">/* Non-blocking discard operation */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">index</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="n">SNDRV_DEFAULT_IDX</span><span class="p">;</span>	<span class="cm">/* Index 0-MAX */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="n">SNDRV_DEFAULT_STR</span><span class="p">;</span>	<span class="cm">/* ID for this card */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="n">SNDRV_DEFAULT_ENABLE</span><span class="p">;</span> <span class="cm">/* Enable this card */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">port</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="n">SNDRV_DEFAULT_PORT</span><span class="p">;</span> <span class="cm">/* 0x3f8,0x2f8,0x3e8,0x2e8 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="n">SNDRV_DEFAULT_IRQ</span><span class="p">;</span> 	<span class="cm">/* 3,4,5,7,9,10,11,14,15 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">speed</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">0</span> <span class="p">...</span> <span class="p">(</span><span class="n">SNDRV_CARDS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">38400</span><span class="p">};</span> <span class="cm">/* 9600,19200,38400,57600,115200 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">base</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">0</span> <span class="p">...</span> <span class="p">(</span><span class="n">SNDRV_CARDS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">115200</span><span class="p">};</span> <span class="cm">/* baud base */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">outs</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">0</span> <span class="p">...</span> <span class="p">(</span><span class="n">SNDRV_CARDS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">};</span>	 <span class="cm">/* 1 to 16 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ins</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">0</span> <span class="p">...</span> <span class="p">(</span><span class="n">SNDRV_CARDS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">};</span>	<span class="cm">/* 1 to 16 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">adaptor</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">0</span> <span class="p">...</span> <span class="p">(</span><span class="n">SNDRV_CARDS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">SNDRV_SERIAL_SOUNDCANVAS</span><span class="p">};</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">droponfull</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">0</span> <span class="p">...</span> <span class="p">(</span><span class="n">SNDRV_CARDS</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">SNDRV_SERIAL_NORMALBUFF</span> <span class="p">};</span>

<span class="n">module_param_array</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s">&quot;Index value for Serial MIDI.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="s">&quot;ID string for Serial MIDI.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">enable</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">enable</span><span class="p">,</span> <span class="s">&quot;Enable UART16550A chip.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="s">&quot;Port # for UART16550A chip.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="s">&quot;IRQ # for UART16550A chip.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">speed</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">speed</span><span class="p">,</span> <span class="s">&quot;Speed in bauds.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s">&quot;Base for divisor in bauds.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="s">&quot;Number of MIDI outputs.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="s">&quot;Number of MIDI inputs.&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">droponfull</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">droponfull</span><span class="p">,</span> <span class="s">&quot;Flag to enable drop-on-full buffer mode&quot;</span><span class="p">);</span>

<span class="n">module_param_array</span><span class="p">(</span><span class="n">adaptor</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">adaptor</span><span class="p">,</span> <span class="s">&quot;Type of adaptor.&quot;</span><span class="p">);</span>

<span class="cm">/*#define SNDRV_SERIAL_MS124W_MB_NOCOMBO 1*/</span>  <span class="cm">/* Address outs as 0-3 instead of bitmap */</span>

<span class="cp">#define SNDRV_SERIAL_MAX_OUTS	16		</span><span class="cm">/* max 64, min 16 */</span><span class="cp"></span>
<span class="cp">#define SNDRV_SERIAL_MAX_INS	16		</span><span class="cm">/* max 64, min 16 */</span><span class="cp"></span>

<span class="cp">#define TX_BUFF_SIZE		(1&lt;&lt;15)		</span><span class="cm">/* Must be 2^n */</span><span class="cp"></span>
<span class="cp">#define TX_BUFF_MASK		(TX_BUFF_SIZE - 1)</span>

<span class="cp">#define SERIAL_MODE_NOT_OPENED 		(0)</span>
<span class="cp">#define SERIAL_MODE_INPUT_OPEN		(1 &lt;&lt; 0)</span>
<span class="cp">#define SERIAL_MODE_OUTPUT_OPEN		(1 &lt;&lt; 1)</span>
<span class="cp">#define SERIAL_MODE_INPUT_TRIGGERED	(1 &lt;&lt; 2)</span>
<span class="cp">#define SERIAL_MODE_OUTPUT_TRIGGERED	(1 &lt;&lt; 3)</span>

<span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_rawmidi</span> <span class="o">*</span><span class="n">rmidi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_rawmidi_substream</span> <span class="o">*</span><span class="n">midi_output</span><span class="p">[</span><span class="n">SNDRV_SERIAL_MAX_OUTS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">snd_rawmidi_substream</span> <span class="o">*</span><span class="n">midi_input</span><span class="p">[</span><span class="n">SNDRV_SERIAL_MAX_INS</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">filemode</span><span class="p">;</span>		<span class="cm">/* open status of file */</span>

	<span class="n">spinlock_t</span> <span class="n">open_lock</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res_base</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">speed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">speed_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">divisor</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">old_divisor_lsb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">old_divisor_msb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">old_line_ctrl_reg</span><span class="p">;</span>

	<span class="cm">/* parameter for using of write loop */</span>
	<span class="kt">short</span> <span class="kt">int</span> <span class="n">fifo_limit</span><span class="p">;</span>	<span class="cm">/* used in uart16550 */</span>
        <span class="kt">short</span> <span class="kt">int</span> <span class="n">fifo_count</span><span class="p">;</span>	<span class="cm">/* used in uart16550 */</span>

	<span class="cm">/* type of adaptor */</span>
	<span class="kt">int</span> <span class="n">adaptor</span><span class="p">;</span>

	<span class="cm">/* inputs */</span>
	<span class="kt">int</span> <span class="n">prev_in</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">rstatus</span><span class="p">;</span>

	<span class="cm">/* outputs */</span>
	<span class="kt">int</span> <span class="n">prev_out</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">prev_status</span><span class="p">[</span><span class="n">SNDRV_SERIAL_MAX_OUTS</span><span class="p">];</span>

	<span class="cm">/* write buffer and its writing/reading position */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tx_buff</span><span class="p">[</span><span class="n">TX_BUFF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">buff_in_count</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">buff_in</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">buff_out</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">drop_on_full</span><span class="p">;</span>

	<span class="cm">/* wait timer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer_running</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">buffer_timer</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">devices</span><span class="p">[</span><span class="n">SNDRV_CARDS</span><span class="p">];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">snd_uart16550_add_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">timer_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* timer 38600bps * 10bit * 16byte */</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">buffer_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span><span class="o">+</span><span class="mi">255</span><span class="p">)</span><span class="o">/</span><span class="mi">256</span><span class="p">;</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">timer_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">buffer_timer</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">snd_uart16550_del_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">timer_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">buffer_timer</span><span class="p">);</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">timer_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This macro is only used in snd_uart16550_io_loop */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">snd_uart16550_buffer_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">buff_out</span> <span class="o">=</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_in_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">[</span><span class="n">buff_out</span><span class="p">],</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_TX</span><span class="p">);</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">fifo_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">buff_out</span><span class="o">++</span><span class="p">;</span>
		<span class="n">buff_out</span> <span class="o">&amp;=</span> <span class="n">TX_BUFF_MASK</span><span class="p">;</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_out</span> <span class="o">=</span> <span class="n">buff_out</span><span class="p">;</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_in_count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This loop should be called with interrupts disabled</span>
<span class="cm"> * We don&#39;t want to interrupt this, </span>
<span class="cm"> * as we&#39;re already handling an interrupt </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snd_uart16550_io_loop</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span> <span class="n">uart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">substream</span><span class="p">;</span>

	<span class="cm">/* recall previous stream */</span>
	<span class="n">substream</span> <span class="o">=</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">prev_in</span><span class="p">;</span>

	<span class="cm">/* Read Loop */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">status</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_LSR</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">UART_LSR_DR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* while receive data ready */</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_RX</span><span class="p">);</span>

		<span class="cm">/* keep track of last status byte */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span>
			<span class="n">uart</span><span class="o">-&gt;</span><span class="n">rstatus</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

		<span class="cm">/* handle stream switch */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span> <span class="o">==</span> <span class="n">SNDRV_SERIAL_GENERIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">rstatus</span> <span class="o">==</span> <span class="mh">0xf5</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;=</span> <span class="n">SNDRV_SERIAL_MAX_INS</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">substream</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="mh">0xf5</span><span class="p">)</span>
					<span class="cm">/* prevent future bytes from being</span>
<span class="cm">					   interpreted as streams */</span>
					<span class="n">uart</span><span class="o">-&gt;</span><span class="n">rstatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">&amp;</span> <span class="n">SERIAL_MODE_INPUT_OPEN</span><span class="p">)</span>
				   <span class="o">&amp;&amp;</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">midi_input</span><span class="p">[</span><span class="n">substream</span><span class="p">])</span>
				<span class="n">snd_rawmidi_receive</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">midi_input</span><span class="p">[</span><span class="n">substream</span><span class="p">],</span>
						    <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">&amp;</span> <span class="n">SERIAL_MODE_INPUT_OPEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="n">uart</span><span class="o">-&gt;</span><span class="n">midi_input</span><span class="p">[</span><span class="n">substream</span><span class="p">])</span>
			<span class="n">snd_rawmidi_receive</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">midi_input</span><span class="p">[</span><span class="n">substream</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">UART_LSR_OE</span><span class="p">)</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				   <span class="s">&quot;%s: Overrun on device at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">uart</span><span class="o">-&gt;</span><span class="n">rmidi</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* remember the last stream */</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">prev_in</span> <span class="o">=</span> <span class="n">substream</span><span class="p">;</span>

	<span class="cm">/* no need of check SERIAL_MODE_OUTPUT_OPEN because if not,</span>
<span class="cm">	   buffer is never filled. */</span>
	<span class="cm">/* Check write status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">UART_LSR_THRE</span><span class="p">)</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">fifo_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span> <span class="o">==</span> <span class="n">SNDRV_SERIAL_MS124W_SA</span>
	   <span class="o">||</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span> <span class="o">==</span> <span class="n">SNDRV_SERIAL_GENERIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Can&#39;t use FIFO, must send only when CTS is true */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_MSR</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">fifo_count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">UART_MSR_CTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_in_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		       <span class="n">snd_uart16550_buffer_output</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
		       <span class="n">status</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_MSR</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Write loop */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">fifo_count</span> <span class="o">&lt;</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">fifo_limit</span> <span class="cm">/* Can we write ? */</span>
		       <span class="o">&amp;&amp;</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_in_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* Do we want to? */</span>
			<span class="n">snd_uart16550_buffer_output</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_in_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">snd_uart16550_add_timer</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* NOTES ON SERVICING INTERUPTS</span>
<span class="cm"> * ---------------------------</span>
<span class="cm"> * After receiving a interrupt, it is important to indicate to the UART that</span>
<span class="cm"> * this has been done. </span>
<span class="cm"> * For a Rx interrupt, this is done by reading the received byte.</span>
<span class="cm"> * For a Tx interrupt this is done by either:</span>
<span class="cm"> * a) Writing a byte</span>
<span class="cm"> * b) Reading the IIR</span>
<span class="cm"> * It is particularly important to read the IIR if a Tx interrupt is received</span>
<span class="cm"> * when there is no data in tx_buff[], as in this case there no other</span>
<span class="cm"> * indication that the interrupt has been serviced, and it remains outstanding</span>
<span class="cm"> * indefinitely. This has the curious side effect that and no further interrupts</span>
<span class="cm"> * will be generated from this device AT ALL!!.</span>
<span class="cm"> * It is also desirable to clear outstanding interrupts when the device is</span>
<span class="cm"> * opened/closed.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Note that some devices need OUT2 to be set before they will generate</span>
<span class="cm"> * interrupts at all. (Possibly tied to an internal pull-up on CTS?)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">snd_uart16550_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span><span class="p">;</span>

	<span class="n">uart</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">==</span> <span class="n">SERIAL_MODE_NOT_OPENED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* indicate to the UART that the interrupt has been serviced */</span>
	<span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_IIR</span><span class="p">);</span>
	<span class="n">snd_uart16550_io_loop</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* When the polling mode, this function calls snd_uart16550_io_loop. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snd_uart16550_buffer_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span><span class="p">;</span>

	<span class="n">uart</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">snd_uart16550_del_timer</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
	<span class="n">snd_uart16550_io_loop</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  this method probes, if an uart sits on given port</span>
<span class="cm"> *  return 0 if found</span>
<span class="cm"> *  return negative error if not found</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">snd_uart16550_detect</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_base</span> <span class="o">=</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ok</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

	<span class="cm">/* Do some vague tests for the presence of the uart */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">io_base</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">io_base</span> <span class="o">==</span> <span class="n">SNDRV_AUTO_PORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>	<span class="cm">/* Not configured */</span>
	<span class="p">}</span>

	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">res_base</span> <span class="o">=</span> <span class="n">request_region</span><span class="p">(</span><span class="n">io_base</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&quot;Serial MIDI&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">res_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;u16550: can&#39;t grab port 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">io_base</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* uart detected unless one of the following tests should fail */</span>
	<span class="n">ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* 8 data-bits, 1 stop-bit, parity off, DLAB = 0 */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">UART_LCR_WLEN8</span><span class="p">,</span> <span class="n">io_base</span> <span class="o">+</span> <span class="n">UART_LCR</span><span class="p">);</span> <span class="cm">/* Line Control Register */</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">UART_IER</span><span class="p">);</span>
	<span class="cm">/* The top four bits of the IER should always == 0 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* failed */</span>

	<span class="n">outb</span><span class="p">(</span><span class="mh">0xaa</span><span class="p">,</span> <span class="n">io_base</span> <span class="o">+</span> <span class="n">UART_SCR</span><span class="p">);</span>
	<span class="cm">/* Write arbitrary data into the scratch reg */</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">UART_SCR</span><span class="p">);</span>
	<span class="cm">/* If it comes back, it&#39;s OK */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="mh">0xaa</span><span class="p">)</span>
		<span class="n">ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* failed */</span>

	<span class="n">outb</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">io_base</span> <span class="o">+</span> <span class="n">UART_SCR</span><span class="p">);</span>
	<span class="cm">/* Write arbitrary data into the scratch reg */</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">UART_SCR</span><span class="p">);</span>
	<span class="cm">/* If it comes back, it&#39;s OK */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="mh">0x55</span><span class="p">)</span>
		<span class="n">ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* failed */</span>

	<span class="k">return</span> <span class="n">ok</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">snd_uart16550_do_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span> <span class="n">uart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">byte</span><span class="p">;</span>

	<span class="cm">/* Initialize basic variables */</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_in_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">fifo_limit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">fifo_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">timer_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">UART_FCR_ENABLE_FIFO</span>	<span class="cm">/* Enable FIFO&#39;s (if available) */</span>
	     <span class="o">|</span> <span class="n">UART_FCR_CLEAR_RCVR</span>	<span class="cm">/* Clear receiver FIFO */</span>
	     <span class="o">|</span> <span class="n">UART_FCR_CLEAR_XMIT</span>	<span class="cm">/* Clear transmitter FIFO */</span>
	     <span class="o">|</span> <span class="n">UART_FCR_TRIGGER_4</span>	<span class="cm">/* Set FIFO trigger at 4-bytes */</span>
	<span class="cm">/* NOTE: interrupt generated after T=(time)4-bytes</span>
<span class="cm">	 * if less than UART_FCR_TRIGGER bytes received</span>
<span class="cm">	 */</span>
	     <span class="p">,</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_FCR</span><span class="p">);</span>	<span class="cm">/* FIFO Control Register */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_IIR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xc0</span><span class="p">)</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">fifo_limit</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">divisor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">old_line_ctrl_reg</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_LCR</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">UART_LCR_DLAB</span>	<span class="cm">/* Divisor latch access bit */</span>
		     <span class="p">,</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_LCR</span><span class="p">);</span>	<span class="cm">/* Line Control Register */</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">old_divisor_lsb</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_DLL</span><span class="p">);</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">old_divisor_msb</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_DLM</span><span class="p">);</span>

		<span class="n">outb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">divisor</span>
		     <span class="p">,</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_DLL</span><span class="p">);</span>	<span class="cm">/* Divisor Latch Low */</span>
		<span class="n">outb</span><span class="p">(</span><span class="mi">0</span>
		     <span class="p">,</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_DLM</span><span class="p">);</span>	<span class="cm">/* Divisor Latch High */</span>
		<span class="cm">/* DLAB is reset to 0 in next outb() */</span>
	<span class="p">}</span>
	<span class="cm">/* Set serial parameters (parity off, etc) */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">UART_LCR_WLEN8</span>	<span class="cm">/* 8 data-bits */</span>
	     <span class="o">|</span> <span class="mi">0</span>		<span class="cm">/* 1 stop-bit */</span>
	     <span class="o">|</span> <span class="mi">0</span>		<span class="cm">/* parity off */</span>
	     <span class="o">|</span> <span class="mi">0</span>		<span class="cm">/* DLAB = 0 */</span>
	     <span class="p">,</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_LCR</span><span class="p">);</span>	<span class="cm">/* Line Control Register */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">UART_MCR_RTS</span>	<span class="cm">/* Set Request-To-Send line active */</span>
		     <span class="o">|</span> <span class="n">UART_MCR_DTR</span>	<span class="cm">/* Set Data-Terminal-Ready line active */</span>
		     <span class="o">|</span> <span class="n">UART_MCR_OUT2</span>	<span class="cm">/* Set OUT2 - not always required, but when</span>
<span class="cm">					 * it is, it is ESSENTIAL for enabling interrupts</span>
<span class="cm">				 */</span>
		     <span class="p">,</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_MCR</span><span class="p">);</span>	<span class="cm">/* Modem Control Register */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_SERIAL_MS124W_SA</span>:
	<span class="k">case</span> <span class="n">SNDRV_SERIAL_MS124W_MB</span>:
		<span class="cm">/* MS-124W can draw power from RTS and DTR if they</span>
<span class="cm">		   are in opposite states. */</span> 
		<span class="n">outb</span><span class="p">(</span><span class="n">UART_MCR_RTS</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span><span class="o">&amp;</span><span class="n">UART_MCR_DTR</span><span class="p">)</span> <span class="o">|</span> <span class="n">UART_MCR_OUT2</span><span class="p">,</span>
		     <span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_MCR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_SERIAL_MS124T</span>:
		<span class="cm">/* MS-124T can draw power from RTS and/or DTR (preferably</span>
<span class="cm">		   both) if they are both asserted. */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">UART_MCR_RTS</span> <span class="o">|</span> <span class="n">UART_MCR_DTR</span> <span class="o">|</span> <span class="n">UART_MCR_OUT2</span><span class="p">,</span>
		     <span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_MCR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">byte</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&amp;</span> <span class="n">UART_IER_RDI</span><span class="p">)</span>	<span class="cm">/* Disable Receiver data interrupt */</span>
		    <span class="o">|</span><span class="p">(</span><span class="mi">0</span> <span class="o">&amp;</span> <span class="n">UART_IER_THRI</span><span class="p">)</span>	<span class="cm">/* Disable Transmitter holding register empty interrupt */</span>
		    <span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span> <span class="o">==</span> <span class="n">SNDRV_SERIAL_MS124W_SA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">byte</span> <span class="o">=</span> <span class="n">UART_IER_RDI</span>	<span class="cm">/* Enable Receiver data interrupt */</span>
		    <span class="o">|</span> <span class="n">UART_IER_MSI</span>	<span class="cm">/* Enable Modem status interrupt */</span>
		    <span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span> <span class="o">==</span> <span class="n">SNDRV_SERIAL_GENERIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">byte</span> <span class="o">=</span> <span class="n">UART_IER_RDI</span>	<span class="cm">/* Enable Receiver data interrupt */</span>
		    <span class="o">|</span> <span class="n">UART_IER_MSI</span>	<span class="cm">/* Enable Modem status interrupt */</span>
		    <span class="o">|</span> <span class="n">UART_IER_THRI</span>	<span class="cm">/* Enable Transmitter holding register empty interrupt */</span>
		    <span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">byte</span> <span class="o">=</span> <span class="n">UART_IER_RDI</span>	<span class="cm">/* Enable Receiver data interrupt */</span>
		    <span class="o">|</span> <span class="n">UART_IER_THRI</span>	<span class="cm">/* Enable Transmitter holding register empty interrupt */</span>
		    <span class="p">;</span>
	<span class="p">}</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_IER</span><span class="p">);</span>	<span class="cm">/* Interrupt enable Register */</span>

	<span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_LSR</span><span class="p">);</span>	<span class="cm">/* Clear any pre-existing overrun indication */</span>
	<span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_IIR</span><span class="p">);</span>	<span class="cm">/* Clear any pre-existing transmit interrupt */</span>
	<span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_RX</span><span class="p">);</span>	<span class="cm">/* Clear any pre-existing receive interrupt */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">snd_uart16550_do_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span> <span class="n">uart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">snd_uart16550_del_timer</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>

	<span class="cm">/* NOTE: may need to disable interrupts before de-registering out handler.</span>
<span class="cm">	 * For now, the consequences are harmless.</span>
<span class="cm">	 */</span>

	<span class="n">outb</span><span class="p">((</span><span class="mi">0</span> <span class="o">&amp;</span> <span class="n">UART_IER_RDI</span><span class="p">)</span>		<span class="cm">/* Disable Receiver data interrupt */</span>
	     <span class="o">|</span><span class="p">(</span><span class="mi">0</span> <span class="o">&amp;</span> <span class="n">UART_IER_THRI</span><span class="p">)</span>	<span class="cm">/* Disable Transmitter holding register empty interrupt */</span>
	     <span class="p">,</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_IER</span><span class="p">);</span>	<span class="cm">/* Interrupt enable Register */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">outb</span><span class="p">((</span><span class="mi">0</span> <span class="o">&amp;</span> <span class="n">UART_MCR_RTS</span><span class="p">)</span>		<span class="cm">/* Deactivate Request-To-Send line  */</span>
		     <span class="o">|</span><span class="p">(</span><span class="mi">0</span> <span class="o">&amp;</span> <span class="n">UART_MCR_DTR</span><span class="p">)</span>	<span class="cm">/* Deactivate Data-Terminal-Ready line */</span>
		     <span class="o">|</span><span class="p">(</span><span class="mi">0</span> <span class="o">&amp;</span> <span class="n">UART_MCR_OUT2</span><span class="p">)</span>	<span class="cm">/* Deactivate OUT2 */</span>
		     <span class="p">,</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_MCR</span><span class="p">);</span>	<span class="cm">/* Modem Control Register */</span>
	  <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_SERIAL_MS124W_SA</span>:
	<span class="k">case</span> <span class="n">SNDRV_SERIAL_MS124W_MB</span>:
		<span class="cm">/* MS-124W can draw power from RTS and DTR if they</span>
<span class="cm">		   are in opposite states; leave it powered. */</span> 
		<span class="n">outb</span><span class="p">(</span><span class="n">UART_MCR_RTS</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span><span class="o">&amp;</span><span class="n">UART_MCR_DTR</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span><span class="o">&amp;</span><span class="n">UART_MCR_OUT2</span><span class="p">),</span>
		     <span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_MCR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_SERIAL_MS124T</span>:
		<span class="cm">/* MS-124T can draw power from RTS and/or DTR (preferably</span>
<span class="cm">		   both) if they are both asserted; leave it powered. */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">UART_MCR_RTS</span> <span class="o">|</span> <span class="n">UART_MCR_DTR</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span><span class="o">&amp;</span><span class="n">UART_MCR_OUT2</span><span class="p">),</span>
		     <span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_MCR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_IIR</span><span class="p">);</span>	<span class="cm">/* Clear any outstanding interrupts */</span>

	<span class="cm">/* Restore old divisor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">divisor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">UART_LCR_DLAB</span>		<span class="cm">/* Divisor latch access bit */</span>
		     <span class="p">,</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_LCR</span><span class="p">);</span>	<span class="cm">/* Line Control Register */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">old_divisor_lsb</span>
		     <span class="p">,</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_DLL</span><span class="p">);</span>	<span class="cm">/* Divisor Latch Low */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">old_divisor_msb</span>
		     <span class="p">,</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_DLM</span><span class="p">);</span>	<span class="cm">/* Divisor Latch High */</span>
		<span class="cm">/* Restore old LCR (data bits, stop bits, parity, DLAB) */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">old_line_ctrl_reg</span>
		     <span class="p">,</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_LCR</span><span class="p">);</span>	<span class="cm">/* Line Control Register */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_uart16550_input_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_rawmidi_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">rmidi</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">==</span> <span class="n">SERIAL_MODE_NOT_OPENED</span><span class="p">)</span>
		<span class="n">snd_uart16550_do_open</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">|=</span> <span class="n">SERIAL_MODE_INPUT_OPEN</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">midi_input</span><span class="p">[</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="n">substream</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_uart16550_input_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_rawmidi_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">rmidi</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SERIAL_MODE_INPUT_OPEN</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">midi_input</span><span class="p">[</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">==</span> <span class="n">SERIAL_MODE_NOT_OPENED</span><span class="p">)</span>
		<span class="n">snd_uart16550_do_close</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">snd_uart16550_input_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_rawmidi_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">up</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">rmidi</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">up</span><span class="p">)</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">|=</span> <span class="n">SERIAL_MODE_INPUT_TRIGGERED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SERIAL_MODE_INPUT_TRIGGERED</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_uart16550_output_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_rawmidi_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">rmidi</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">==</span> <span class="n">SERIAL_MODE_NOT_OPENED</span><span class="p">)</span>
		<span class="n">snd_uart16550_do_open</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">|=</span> <span class="n">SERIAL_MODE_OUTPUT_OPEN</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">midi_output</span><span class="p">[</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="n">substream</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_uart16550_output_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_rawmidi_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">rmidi</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SERIAL_MODE_OUTPUT_OPEN</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">midi_output</span><span class="p">[</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">==</span> <span class="n">SERIAL_MODE_NOT_OPENED</span><span class="p">)</span>
		<span class="n">snd_uart16550_do_close</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">snd_uart16550_buffer_can_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span><span class="p">,</span>
						 <span class="kt">int</span> <span class="n">Num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_in_count</span> <span class="o">+</span> <span class="n">Num</span> <span class="o">&lt;</span> <span class="n">TX_BUFF_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">snd_uart16550_write_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">byte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">buff_in</span> <span class="o">=</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_in</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_in_count</span> <span class="o">&lt;</span> <span class="n">TX_BUFF_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">[</span><span class="n">buff_in</span><span class="p">]</span> <span class="o">=</span> <span class="n">byte</span><span class="p">;</span>
		<span class="n">buff_in</span><span class="o">++</span><span class="p">;</span>
		<span class="n">buff_in</span> <span class="o">&amp;=</span> <span class="n">TX_BUFF_MASK</span><span class="p">;</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_in</span> <span class="o">=</span> <span class="n">buff_in</span><span class="p">;</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_in_count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* polling mode */</span>
			<span class="n">snd_uart16550_add_timer</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_uart16550_output_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">snd_rawmidi_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">midi_byte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_in_count</span> <span class="o">==</span> <span class="mi">0</span>                    <span class="cm">/* Buffer empty? */</span>
	    <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span> <span class="o">!=</span> <span class="n">SNDRV_SERIAL_MS124W_SA</span> <span class="o">&amp;&amp;</span>
	    <span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span> <span class="o">!=</span> <span class="n">SNDRV_SERIAL_GENERIC</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">fifo_count</span> <span class="o">==</span> <span class="mi">0</span>                  <span class="cm">/* FIFO empty? */</span>
		 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_MSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UART_MSR_CTS</span><span class="p">))))</span> <span class="p">{</span> <span class="cm">/* CTS? */</span>

	        <span class="cm">/* Tx Buffer Empty - try to write immediately */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_LSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UART_LSR_THRE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		        <span class="cm">/* Transmitter holding register (and Tx FIFO) empty */</span>
		        <span class="n">uart</span><span class="o">-&gt;</span><span class="n">fifo_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">midi_byte</span><span class="p">,</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_TX</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		        <span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">fifo_count</span> <span class="o">&lt;</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">fifo_limit</span><span class="p">)</span> <span class="p">{</span>
			        <span class="n">uart</span><span class="o">-&gt;</span><span class="n">fifo_count</span><span class="o">++</span><span class="p">;</span>
				<span class="n">outb</span><span class="p">(</span><span class="n">midi_byte</span><span class="p">,</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_TX</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			        <span class="cm">/* Cannot write (buffer empty) -</span>
<span class="cm">				 * put char in buffer */</span>
				<span class="n">snd_uart16550_write_buffer</span><span class="p">(</span><span class="n">uart</span><span class="p">,</span> <span class="n">midi_byte</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">snd_uart16550_write_buffer</span><span class="p">(</span><span class="n">uart</span><span class="p">,</span> <span class="n">midi_byte</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				   <span class="s">&quot;%s: Buffer overrun on device at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">uart</span><span class="o">-&gt;</span><span class="n">rmidi</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">snd_uart16550_output_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_rawmidi_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">midi_byte</span><span class="p">,</span> <span class="n">addr_byte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">rmidi</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">first</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lasttime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="cm">/* Interrupts are disabled during the updating of the tx_buff,</span>
<span class="cm">	 * since it is &#39;bad&#39; to have two processes updating the same</span>
<span class="cm">	 * variables (ie buff_in &amp; buff_out)</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* polling */</span>
		<span class="n">snd_uart16550_io_loop</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span> <span class="o">==</span> <span class="n">SNDRV_SERIAL_MS124W_MB</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* buffer full? */</span>
			<span class="cm">/* in this mode we need two bytes of space */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">buff_in_count</span> <span class="o">&gt;</span> <span class="n">TX_BUFF_SIZE</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">snd_rawmidi_transmit</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">midi_byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef SNDRV_SERIAL_MS124W_MB_NOCOMBO</span>
			<span class="cm">/* select exactly one of the four ports */</span>
			<span class="n">addr_byte</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span> <span class="o">|</span> <span class="mh">0x08</span><span class="p">;</span>
<span class="cp">#else</span>
			<span class="cm">/* select any combination of the four ports */</span>
			<span class="n">addr_byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x08</span><span class="p">;</span>
			<span class="cm">/* ...except none */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addr_byte</span> <span class="o">==</span> <span class="mh">0x08</span><span class="p">)</span>
				<span class="n">addr_byte</span> <span class="o">=</span> <span class="mh">0xf8</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="n">snd_uart16550_output_byte</span><span class="p">(</span><span class="n">uart</span><span class="p">,</span> <span class="n">substream</span><span class="p">,</span> <span class="n">addr_byte</span><span class="p">);</span>
			<span class="cm">/* send midi byte */</span>
			<span class="n">snd_uart16550_output_byte</span><span class="p">(</span><span class="n">uart</span><span class="p">,</span> <span class="n">substream</span><span class="p">,</span> <span class="n">midi_byte</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">snd_rawmidi_transmit_peek</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">midi_byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Also send F5 after 3 seconds with no data</span>
<span class="cm">			 * to handle device disconnect */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span> <span class="o">==</span> <span class="n">SNDRV_SERIAL_SOUNDCANVAS</span> <span class="o">||</span>
			     <span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span> <span class="o">==</span> <span class="n">SNDRV_SERIAL_GENERIC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">prev_out</span> <span class="o">!=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">||</span>
			     <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">lasttime</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">HZ</span><span class="p">)))</span> <span class="p">{</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">snd_uart16550_buffer_can_write</span><span class="p">(</span><span class="n">uart</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* Roland Soundcanvas part selection */</span>
					<span class="cm">/* If this substream of the data is</span>
<span class="cm">					 * different previous substream</span>
<span class="cm">					 * in this uart, send the change part</span>
<span class="cm">					 * event</span>
<span class="cm">					 */</span>
					<span class="n">uart</span><span class="o">-&gt;</span><span class="n">prev_out</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
					<span class="cm">/* change part */</span>
					<span class="n">snd_uart16550_output_byte</span><span class="p">(</span><span class="n">uart</span><span class="p">,</span> <span class="n">substream</span><span class="p">,</span>
								  <span class="mh">0xf5</span><span class="p">);</span>
					<span class="cm">/* data */</span>
					<span class="n">snd_uart16550_output_byte</span><span class="p">(</span><span class="n">uart</span><span class="p">,</span> <span class="n">substream</span><span class="p">,</span>
								  <span class="n">uart</span><span class="o">-&gt;</span><span class="n">prev_out</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
					<span class="cm">/* If midi_byte is a data byte,</span>
<span class="cm">					 * send the previous status byte */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">midi_byte</span> <span class="o">&lt;</span> <span class="mh">0x80</span> <span class="o">&amp;&amp;</span>
					    <span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span> <span class="o">==</span> <span class="n">SNDRV_SERIAL_SOUNDCANVAS</span><span class="p">)</span>
						<span class="n">snd_uart16550_output_byte</span><span class="p">(</span><span class="n">uart</span><span class="p">,</span> <span class="n">substream</span><span class="p">,</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">prev_status</span><span class="p">[</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">prev_out</span><span class="p">]);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">drop_on_full</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>

			<span class="p">}</span>

			<span class="cm">/* send midi byte */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">snd_uart16550_output_byte</span><span class="p">(</span><span class="n">uart</span><span class="p">,</span> <span class="n">substream</span><span class="p">,</span> <span class="n">midi_byte</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">drop_on_full</span> <span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">midi_byte</span> <span class="o">&gt;=</span> <span class="mh">0x80</span> <span class="o">&amp;&amp;</span> <span class="n">midi_byte</span> <span class="o">&lt;</span> <span class="mh">0xf0</span><span class="p">)</span>
				<span class="n">uart</span><span class="o">-&gt;</span><span class="n">prev_status</span><span class="p">[</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">prev_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">midi_byte</span><span class="p">;</span>
			<span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">snd_rawmidi_transmit_ack</span><span class="p">(</span> <span class="n">substream</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lasttime</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">snd_uart16550_output_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_rawmidi_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">up</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">rmidi</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">up</span><span class="p">)</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">|=</span> <span class="n">SERIAL_MODE_OUTPUT_TRIGGERED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">filemode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SERIAL_MODE_OUTPUT_TRIGGERED</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">up</span><span class="p">)</span>
		<span class="n">snd_uart16550_output_write</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_rawmidi_ops</span> <span class="n">snd_uart16550_output</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">snd_uart16550_output_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span>	<span class="n">snd_uart16550_output_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span>	<span class="n">snd_uart16550_output_trigger</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_rawmidi_ops</span> <span class="n">snd_uart16550_input</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">snd_uart16550_input_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span>	<span class="n">snd_uart16550_input_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span>	<span class="n">snd_uart16550_input_trigger</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_uart16550_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">uart</span><span class="p">);</span>
	<span class="n">release_and_free_resource</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">res_base</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_uart16550_dev_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">device_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snd_uart16550_free</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">snd_uart16550_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iobase</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">speed</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">adaptor</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">droponfull</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">**</span><span class="n">ruart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_device_ops</span> <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">dev_free</span> <span class="o">=</span>	<span class="n">snd_uart16550_dev_free</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">((</span><span class="n">uart</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uart</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span> <span class="o">=</span> <span class="n">adaptor</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">card</span> <span class="o">=</span> <span class="n">card</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">open_lock</span><span class="p">);</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">drop_on_full</span> <span class="o">=</span> <span class="n">droponfull</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_uart16550_detect</span><span class="p">(</span><span class="n">uart</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;no UART detected at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>
		<span class="n">snd_uart16550_free</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">irq</span> <span class="o">!=</span> <span class="n">SNDRV_AUTO_IRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">snd_uart16550_interrupt</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Serial MIDI&quot;</span><span class="p">,</span> <span class="n">uart</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				   <span class="s">&quot;irq %d busy. Using Polling.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uart</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">divisor</span> <span class="o">=</span> <span class="n">base</span> <span class="o">/</span> <span class="n">speed</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">base</span> <span class="o">/</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">divisor</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">speed_base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">prev_out</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">prev_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">rstatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">prev_status</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="n">SNDRV_SERIAL_MAX_OUTS</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">buffer_timer</span><span class="p">);</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">buffer_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">snd_uart16550_buffer_timer</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">buffer_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">uart</span><span class="p">;</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">timer_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Register device */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_device_new</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">SNDRV_DEV_LOWLEVEL</span><span class="p">,</span> <span class="n">uart</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_uart16550_free</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_SERIAL_MS124W_SA</span>:
	<span class="k">case</span> <span class="n">SNDRV_SERIAL_MS124W_MB</span>:
		<span class="cm">/* MS-124W can draw power from RTS and DTR if they</span>
<span class="cm">		   are in opposite states. */</span> 
		<span class="n">outb</span><span class="p">(</span><span class="n">UART_MCR_RTS</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span><span class="o">&amp;</span><span class="n">UART_MCR_DTR</span><span class="p">),</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_MCR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_SERIAL_MS124T</span>:
		<span class="cm">/* MS-124T can draw power from RTS and/or DTR (preferably</span>
<span class="cm">		   both) if they are asserted. */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">UART_MCR_RTS</span> <span class="o">|</span> <span class="n">UART_MCR_DTR</span><span class="p">,</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">UART_MCR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ruart</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ruart</span> <span class="o">=</span> <span class="n">uart</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">snd_uart16550_substreams</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_rawmidi_str</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_rawmidi_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">substreams</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;Serial MIDI %d&quot;</span><span class="p">,</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">snd_uart16550_rmidi</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span><span class="p">,</span> <span class="kt">int</span> <span class="n">device</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">outs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ins</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">snd_rawmidi</span> <span class="o">**</span><span class="n">rmidi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_rawmidi</span> <span class="o">*</span><span class="n">rrawmidi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_rawmidi_new</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;UART Serial MIDI&quot;</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span>
			      <span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rrawmidi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">snd_rawmidi_set_ops</span><span class="p">(</span><span class="n">rrawmidi</span><span class="p">,</span> <span class="n">SNDRV_RAWMIDI_STREAM_INPUT</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">snd_uart16550_input</span><span class="p">);</span>
	<span class="n">snd_rawmidi_set_ops</span><span class="p">(</span><span class="n">rrawmidi</span><span class="p">,</span> <span class="n">SNDRV_RAWMIDI_STREAM_OUTPUT</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">snd_uart16550_output</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">rrawmidi</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;Serial MIDI&quot;</span><span class="p">);</span>
	<span class="n">snd_uart16550_substreams</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rrawmidi</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_RAWMIDI_STREAM_OUTPUT</span><span class="p">]);</span>
	<span class="n">snd_uart16550_substreams</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rrawmidi</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">SNDRV_RAWMIDI_STREAM_INPUT</span><span class="p">]);</span>
	<span class="n">rrawmidi</span><span class="o">-&gt;</span><span class="n">info_flags</span> <span class="o">=</span> <span class="n">SNDRV_RAWMIDI_INFO_OUTPUT</span> <span class="o">|</span>
			       <span class="n">SNDRV_RAWMIDI_INFO_INPUT</span> <span class="o">|</span>
			       <span class="n">SNDRV_RAWMIDI_INFO_DUPLEX</span><span class="p">;</span>
	<span class="n">rrawmidi</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">uart</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rmidi</span><span class="p">)</span>
		<span class="o">*</span><span class="n">rmidi</span> <span class="o">=</span> <span class="n">rrawmidi</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">snd_serial_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">devptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_uart16550</span> <span class="o">*</span><span class="n">uart</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">devptr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">adaptor</span><span class="p">[</span><span class="n">dev</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_SERIAL_SOUNDCANVAS</span>:
		<span class="n">ins</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_SERIAL_MS124T</span>:
	<span class="k">case</span> <span class="n">SNDRV_SERIAL_MS124W_SA</span>:
		<span class="n">outs</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ins</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_SERIAL_MS124W_MB</span>:
		<span class="n">outs</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">ins</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_SERIAL_GENERIC</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			   <span class="s">&quot;Adaptor type is out of range 0-%d (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">SNDRV_SERIAL_MAX_ADAPTOR</span><span class="p">,</span> <span class="n">adaptor</span><span class="p">[</span><span class="n">dev</span><span class="p">]);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">outs</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">outs</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">SNDRV_SERIAL_MAX_OUTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			   <span class="s">&quot;Count of outputs is out of range 1-%d (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">SNDRV_SERIAL_MAX_OUTS</span><span class="p">,</span> <span class="n">outs</span><span class="p">[</span><span class="n">dev</span><span class="p">]);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">ins</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">SNDRV_SERIAL_MAX_INS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			   <span class="s">&quot;Count of inputs is out of range 1-%d (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">SNDRV_SERIAL_MAX_INS</span><span class="p">,</span> <span class="n">ins</span><span class="p">[</span><span class="n">dev</span><span class="p">]);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span>  <span class="o">=</span> <span class="n">snd_card_create</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">dev</span><span class="p">],</span> <span class="n">id</span><span class="p">[</span><span class="n">dev</span><span class="p">],</span> <span class="n">THIS_MODULE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">card</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="s">&quot;Serial&quot;</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">shortname</span><span class="p">,</span> <span class="s">&quot;Serial MIDI (UART16550A)&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_uart16550_create</span><span class="p">(</span><span class="n">card</span><span class="p">,</span>
					<span class="n">port</span><span class="p">[</span><span class="n">dev</span><span class="p">],</span>
					<span class="n">irq</span><span class="p">[</span><span class="n">dev</span><span class="p">],</span>
					<span class="n">speed</span><span class="p">[</span><span class="n">dev</span><span class="p">],</span>
					<span class="n">base</span><span class="p">[</span><span class="n">dev</span><span class="p">],</span>
					<span class="n">adaptor</span><span class="p">[</span><span class="n">dev</span><span class="p">],</span>
					<span class="n">droponfull</span><span class="p">[</span><span class="n">dev</span><span class="p">],</span>
					<span class="o">&amp;</span><span class="n">uart</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">_err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_uart16550_rmidi</span><span class="p">(</span><span class="n">uart</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">outs</span><span class="p">[</span><span class="n">dev</span><span class="p">],</span> <span class="n">ins</span><span class="p">[</span><span class="n">dev</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">rmidi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">_err</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">longname</span><span class="p">,</span> <span class="s">&quot;%s [%s] at %#lx, irq %d&quot;</span><span class="p">,</span>
		<span class="n">card</span><span class="o">-&gt;</span><span class="n">shortname</span><span class="p">,</span>
		<span class="n">adaptor_names</span><span class="p">[</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">adaptor</span><span class="p">],</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
		<span class="n">uart</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">snd_card_set_dev</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devptr</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_card_register</span><span class="p">(</span><span class="n">card</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">_err</span><span class="p">;</span>

	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">devptr</span><span class="p">,</span> <span class="n">card</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">_err:</span>
	<span class="n">snd_card_free</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">snd_serial_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">devptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_card_free</span><span class="p">(</span><span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">devptr</span><span class="p">));</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">devptr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define SND_SERIAL_DRIVER	&quot;snd_serial_u16550&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">snd_serial_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">snd_serial_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span> <span class="n">snd_serial_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="n">SND_SERIAL_DRIVER</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">snd_serial_unregister_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">devices</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">platform_device_unregister</span><span class="p">(</span><span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snd_serial_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">alsa_card_serial_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cards</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snd_serial_driver</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">cards</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SNDRV_CARDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">enable</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">device</span> <span class="o">=</span> <span class="n">platform_device_register_simple</span><span class="p">(</span><span class="n">SND_SERIAL_DRIVER</span><span class="p">,</span>
							 <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">device</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">platform_device_unregister</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">devices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
		<span class="n">cards</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">cards</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef MODULE</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;serial midi soundcard not found or device busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">snd_serial_unregister_all</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">alsa_card_serial_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_serial_unregister_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">alsa_card_serial_init</span><span class="p">)</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">alsa_card_serial_exit</span><span class="p">)</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
